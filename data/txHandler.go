// Copyright (C) 2019-2022 Algorand, Inc.
// This file is part of go-algorand
//
// go-algorand is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// go-algorand is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with go-algorand.  If not, see <https://www.gnu.org/licenses/>.

package data

import (
	"bytes"
	"container/heap"
	"context"
	"fmt"
	"io"
	"sync"
	"sync/atomic"
	"time"

	"github.com/algorand/go-algorand/config"
	"github.com/algorand/go-algorand/crypto"
	"github.com/algorand/go-algorand/data/bookkeeping"
	"github.com/algorand/go-algorand/data/pools"
	"github.com/algorand/go-algorand/data/transactions"
	"github.com/algorand/go-algorand/data/transactions/verify"
	"github.com/algorand/go-algorand/ledger"
	"github.com/algorand/go-algorand/ledger/ledgercore"
	"github.com/algorand/go-algorand/logging"
	"github.com/algorand/go-algorand/network"
	"github.com/algorand/go-algorand/protocol"
	"github.com/algorand/go-algorand/util/execpool"
	"github.com/algorand/go-algorand/util/metrics"
	"github.com/algorand/go-deadlock"
)

// The size txBacklogSize used to determine the size of the backlog that is used to store incoming transaction messages before starting dropping them.
// It should be configured to be higher then the number of CPU cores, so that the execution pool get saturated, but not too high to avoid lockout of the
// execution pool for a long duration of time.
// Set backlog at 'approximately one block' by dividing block size by a typical transaction size.
var txBacklogSize = config.Consensus[protocol.ConsensusCurrentVersion].MaxTxnBytesPerBlock / 200

var transactionMessagesHandled = metrics.MakeCounter(metrics.TransactionMessagesHandled)
var transactionMessagesDroppedFromBacklog = metrics.MakeCounter(metrics.TransactionMessagesDroppedFromBacklog)
var transactionMessagesDroppedFromPool = metrics.MakeCounter(metrics.TransactionMessagesDroppedFromPool)

// The txBacklogMsg structure used to track a single incoming transaction from the gossip network,
type txBacklogMsg struct {
	rawmsg            *network.IncomingMessage // the raw message from the network
	unverifiedTxGroup []transactions.SignedTxn // the unverified ( and signed ) transaction group
	verificationErr   error                    // The verification error generated by the verification function, if any.
}

// TxHandler handles transaction messages
type TxHandler struct {
	txPool                *pools.TransactionPool
	ledger                *Ledger
	log                   logging.Logger
	genesisID             string
	genesisHash           crypto.Digest
	txVerificationPool    execpool.BacklogPool
	backlogQueue          chan *txBacklogMsg
	postVerificationQueue chan *txBacklogMsg
	backlogWg             sync.WaitGroup
	net                   network.GossipNode
	ctx                   context.Context
	ctxCancel             context.CancelFunc

	relayMessages bool

	prevRound uint64

	//txRequests   map[transactions.Txid]*requestedTxn
	txRequests   requestedTxnSet
	txRequestsMu deadlock.Mutex
	// TODO: age-out txRequests, remove txids that have been committed more than N (probably 2) rounds ago, remove txns no longer valid range
	// TODO: keep a prio-heap of open requests sorted by expiration

	// prevTxns is map[transactions.Txid]SignedTxn
	prevTxns atomic.Value
}

// We need to store txns we have seen:
// * Until one round after they have committed, other nodes could still be fetching them to validate what we see as the 'previous' round.
// * Until they expire by LastValid. (txPool does this)
// * Fetch them by txid when requested by a peer
//
// data.Ledger.LookupTxid() is horribly expensive, inflating the entire block's Txns, calculating Txid one by one, and then throwing away the set when done.

// We need to keep track of Txn requests
// * Until we get the txn data
// * Or N rounds then give up?

type requestedTxn struct {
	txid          transactions.Txid
	requestedFrom []network.Peer
	advertisedBy  []network.Peer
	requestedAt   time.Time
	heapPos       int
}

type requestedTxnSet struct {
	// ar contains a heap ordered by .requestedAt
	ar     []*requestedTxn
	byTxid map[transactions.Txid]*requestedTxn
}

// Len is part of sort.Interface and container/heap.Interface
func (rts *requestedTxnSet) Len() int {
	return len(rts.ar)
}

// Less is part of sort.Interface and container/heap.Interface
func (rts *requestedTxnSet) Less(i, j int) bool {
	return rts.ar[i].requestedAt.Before(rts.ar[j].requestedAt)
}

// Swap is part of sort.Interface and container/heap.Interface
func (rts *requestedTxnSet) Swap(i, j int) {
	t := rts.ar[i]
	rts.ar[i] = rts.ar[j]
	rts.ar[j] = t
	rts.ar[i].heapPos = i
	rts.ar[j].heapPos = j
}

// Push is part of container/heap.Interface
func (rts *requestedTxnSet) Push(x interface{}) {
	req := x.(*requestedTxn)
	last := len(rts.ar)
	req.heapPos = last
	rts.ar = append(rts.ar, req)
}

// Pop is part of container/heap.Interface
func (rts *requestedTxnSet) Pop() interface{} {
	last := len(rts.ar) - 1
	out := rts.ar[last]
	out.heapPos = -1
	rts.ar = rts.ar[:last]
	return out
}

func (rts *requestedTxnSet) add(x *requestedTxn) {
	if rts.byTxid == nil {
		rts.byTxid = make(map[transactions.Txid]*requestedTxn)
	}
	rts.byTxid[x.txid] = x
	heap.Push(rts, x)
}

func (rts *requestedTxnSet) getByTxid(txid transactions.Txid) (x *requestedTxn, ok bool) {
	x, ok = rts.byTxid[txid]
	return x, ok
}

func (rts *requestedTxnSet) popByTxid(txid transactions.Txid) (x *requestedTxn, ok bool) {
	x, ok = rts.byTxid[txid]
	if ok {
		delete(rts.byTxid, txid)
		heap.Remove(rts, x.heapPos)
	}
	return x, ok
}

// MakeTxHandler makes a new handler for transaction messages
func MakeTxHandler(txPool *pools.TransactionPool, dledger *Ledger, net network.GossipNode, genesisID string, genesisHash crypto.Digest, executionPool execpool.BacklogPool, cfg *config.Local) *TxHandler {

	if txPool == nil {
		dledger.log.Fatal("MakeTxHandler: txPool is nil on initialization")
		return nil
	}

	if dledger == nil {
		dledger.log.Fatal("MakeTxHandler: ledger is nil on initialization")
		return nil
	}

	handler := &TxHandler{
		txPool:                txPool,
		genesisID:             genesisID,
		genesisHash:           genesisHash,
		ledger:                dledger,
		log:                   dledger.log,
		txVerificationPool:    executionPool,
		backlogQueue:          make(chan *txBacklogMsg, txBacklogSize),
		postVerificationQueue: make(chan *txBacklogMsg, txBacklogSize),
		net:                   net,
		relayMessages:         cfg.NetAddress != "" || cfg.ForceRelayMessages,
	}

	handler.ctx, handler.ctxCancel = context.WithCancel(context.Background())

	handler.ledger.Ledger.RegisterBlockListeners([]ledger.BlockListener{handler})
	return handler
}

// OnNewBlock is part of ledger.BlockListener interface
func (handler *TxHandler) OnNewBlock(block bookkeeping.Block, delta ledgercore.StateDelta) {
	stxns, err := block.DecodePaysetFlat()
	if err != nil {
		handler.log.Errorf("txHandler OnNewBlock DecodePaysetFlat: %v", err)
		return
	}
	txidList := make([]transactions.Txid, len(stxns))
	prevTxns := make(map[transactions.Txid]transactions.SignedTxn, len(stxns))
	for i, stxn := range stxns {
		txid := stxn.ID()
		prevTxns[txid] = stxn.SignedTxn
		txidList[i] = txid
	}
	handler.txRequestsMu.Lock()
	for _, txid := range txidList {
		handler.txRequests.popByTxid(txid)
	}
	handler.prevTxns.Store(prevTxns)
	atomic.StoreUint64(&handler.prevRound, uint64(block.BlockHeader.Round))
	handler.txRequestsMu.Unlock()
}

// Start enables the processing of incoming messages at the transaction handler
func (handler *TxHandler) Start() {
	handler.net.RegisterHandlers([]network.TaggedMessageHandler{
		{
			Tag:            protocol.TxnTag,
			MessageHandler: network.HandlerFunc(handler.processIncomingTxn),
		},
		{
			Tag:            protocol.TxnAdvertiseTag,
			MessageHandler: network.HandlerFunc(handler.processIncomingTxnAdvertise),
		},
		{
			Tag:            protocol.TxnRequestTag,
			MessageHandler: network.HandlerFunc(handler.processIncomingTxnRequest),
		},
	})
	handler.log.Info("txHandler Start")
	handler.backlogWg.Add(2)
	go handler.backlogWorker()
	go handler.retryHandler()
}

// Stop suspends the processing of incoming messages at the transaction handler
func (handler *TxHandler) Stop() {
	handler.ctxCancel()
	handler.backlogWg.Wait()
}

func reencode(stxns []transactions.SignedTxn) []byte {
	var result [][]byte
	for _, stxn := range stxns {
		result = append(result, protocol.Encode(&stxn))
	}
	return bytes.Join(result, nil)
}

// backlogWorker is the worker go routine that process the incoming messages from the postVerificationQueue and backlogQueue channels
// and dispatches them further.
func (handler *TxHandler) backlogWorker() {
	defer handler.backlogWg.Done()
	for {
		// prioritize the postVerificationQueue
		select {
		case wi, ok := <-handler.postVerificationQueue:
			if !ok {
				return
			}
			handler.postprocessCheckedTxn(wi)

			// restart the loop so that we could empty out the post verification queue.
			continue
		default:
		}

		// we have no more post verification items. wait for either backlog queue item or post verification item.
		select {
		case wi, ok := <-handler.backlogQueue:
			if !ok {
				return
			}
			if handler.checkAlreadyCommitted(wi) {
				continue
			}

			// enqueue the task to the verification pool.
			handler.txVerificationPool.EnqueueBacklog(handler.ctx, handler.asyncVerifySignature, wi, nil)

		case wi, ok := <-handler.postVerificationQueue:
			if !ok {
				return
			}
			handler.postprocessCheckedTxn(wi)

		case <-handler.ctx.Done():
			return
		}
	}
}

func (handler *TxHandler) postprocessCheckedTxn(wi *txBacklogMsg) {
	if wi.verificationErr != nil {
		// disconnect from peer.
		handler.log.Warnf("Received a malformed tx group %v: %v", wi.unverifiedTxGroup, wi.verificationErr)
		handler.net.Disconnect(wi.rawmsg.Sender)
		return
	}

	// we've processed this message, so increase the counter.
	transactionMessagesHandled.Inc(nil)

	// at this point, we've verified the transaction, so we can safely treat the transaction as a verified transaction.
	verifiedTxGroup := wi.unverifiedTxGroup

	// save the transaction, if it has high enough fee and not already in the cache
	err := handler.txPool.Remember(verifiedTxGroup)
	if err != nil {
		handler.log.Debugf("could not remember tx: %v", err)
		return
	}

	// if we remembered without any error ( i.e. txpool wasn't full ), then we should pin these transactions.
	err = handler.ledger.VerifiedTransactionCache().Pin(verifiedTxGroup)
	if err != nil {
		handler.log.Infof("unable to pin transaction: %v", err)
	}

	// TODO: at this point we need to either send TX data or Ta txid advertisement depending on what protocol the peer is
	// We reencode here instead of using rawmsg.Data to avoid broadcasting non-canonical encodings
	// handler.net.Relay(handler.ctx, protocol.TxnTag, reencode(verifiedTxGroup), false, wi.rawmsg.Sender)
	if handler.relayMessages {
		err = TxnBroadcast(handler.ctx, handler.net, verifiedTxGroup, wi.rawmsg.Sender)
		if err != nil {
			handler.log.Infof("unable to pin transaction: %v", err)
		}
	}
}

const peerTxn2Key = "tx3"

type tx3Data struct {
	enabled bool
}

func tx3Check(net network.GossipNode, npeer network.Peer) (out *tx3Data) {
	txpd := net.GetPeerData(npeer, peerTxn2Key)
	if txpd != nil {
		out, ok := txpd.(*tx3Data)
		if ok {
			return out
		}
	}
	peer, ok := npeer.(network.UnicastPeer)
	if ok {
		version := peer.Version()
		if version == "3" {
			// TODO: this logic needs to change before network.ProtocolVersion advances beyond "3"
			out = &tx3Data{enabled: true}
			net.SetPeerData(npeer, peerTxn2Key, out)
			logging.Base().Infof("peer %p is version 3!", peer)
			return out
		} else {
			logging.Base().Infof("peer %p is version %s", peer, version)
		}
	} else {
		logging.Base().Infof("peer %p is not UnicastPeer", peer)
	}
	out = &tx3Data{enabled: false}
	net.SetPeerData(npeer, peerTxn2Key, out)
	return out
}

func (handler *TxHandler) smarterTxnBroadcast(wi *txBacklogMsg) {
	verifiedTxGroup := wi.unverifiedTxGroup
	net := wi.rawmsg.Net
	sender := wi.rawmsg.Sender
	TxnBroadcast(handler.ctx, net, verifiedTxGroup, sender)
}

func TxnBroadcast(ctx context.Context, net network.GossipNode, verifiedTxGroup []transactions.SignedTxn, sender network.Peer) (err error) {
	peers := net.GetPeers(network.PeersConnectedOut, network.PeersConnectedIn)
	logging.Base().Infof("txHandler TxnBroadcast, sender=%p, %d peeers", sender, len(peers))
	var blob []byte
	var txid []byte
	for _, npeer := range peers {
		if npeer == sender {
			continue
		}
		peer, ok := npeer.(network.UnicastPeer)
		if !ok {
			logging.Base().Info("peer is not UnicastPeer")
			continue
		}
		txpd := tx3Check(net, npeer)
		if txpd.enabled {
			// tx3 protocol
			if txid == nil {
				for i := range verifiedTxGroup {
					id := verifiedTxGroup[i].ID()
					logging.Base().Infof("send Ta %s", id.String())
					txid = append(txid, (id[:])...)
				}
			}
			err = peer.Unicast(ctx, txid, protocol.TxnAdvertiseTag)
		} else {
			// not a tx3 protocol client, broadcast txn
			if blob == nil {
				blob = reencode(verifiedTxGroup)
			}
			err = peer.Unicast(ctx, blob, protocol.TxnTag)
			logging.Base().Info("sent TX")
		}
	}
	return nil
}

// asyncVerifySignature verifies that the given transaction group is valid, and update the txBacklogMsg data structure accordingly.
func (handler *TxHandler) asyncVerifySignature(arg interface{}) interface{} {
	tx := arg.(*txBacklogMsg)

	// build the transaction verification context
	latest := handler.ledger.Latest()
	latestHdr, err := handler.ledger.BlockHdr(latest)
	if err != nil {
		tx.verificationErr = fmt.Errorf("Could not get header for previous block %d: %w", latest, err)
		handler.log.Warnf("Could not get header for previous block %d: %v", latest, err)
	} else {
		// we can't use PaysetGroups here since it's using a execpool like this go-routine and we don't want to deadlock.
		_, tx.verificationErr = verify.TxnGroup(tx.unverifiedTxGroup, latestHdr, handler.ledger.VerifiedTransactionCache(), handler.ledger)
	}

	select {
	case handler.postVerificationQueue <- tx:
	default:
		// we failed to write to the output queue, since the queue was full.
		// adding the metric here allows us to monitor how frequently it happens.
		transactionMessagesDroppedFromPool.Inc(nil)
	}
	return nil
}

// processIncomingTxn is the handler for protocol.TxnTag "TX"
func (handler *TxHandler) processIncomingTxn(rawmsg network.IncomingMessage) network.OutgoingMessage {
	dec := protocol.NewMsgpDecoderBytes(rawmsg.Data)
	ntx := 0
	unverifiedTxGroup := make([]transactions.SignedTxn, 1)
	for {
		if len(unverifiedTxGroup) == ntx {
			n := make([]transactions.SignedTxn, len(unverifiedTxGroup)*2)
			copy(n, unverifiedTxGroup)
			unverifiedTxGroup = n
		}

		err := dec.Decode(&unverifiedTxGroup[ntx])
		if err == io.EOF {
			break
		}
		if err != nil {
			handler.log.Warnf("Received a non-decodable txn: %v", err)
			return network.OutgoingMessage{Action: network.Disconnect}
		}
		ntx++
	}
	if ntx == 0 {
		handler.log.Warnf("Received empty tx group")
		return network.OutgoingMessage{Action: network.Disconnect}
	}
	unverifiedTxGroup = unverifiedTxGroup[:ntx]

	select {
	case handler.backlogQueue <- &txBacklogMsg{
		rawmsg:            &rawmsg,
		unverifiedTxGroup: unverifiedTxGroup,
	}:
		handler.txRequestsMu.Lock()
		for _, stxn := range unverifiedTxGroup {
			handler.txRequests.popByTxid(stxn.ID())
		}
		handler.txRequestsMu.Unlock()
	default:
		// if we failed here we want to increase the corresponding metric. It might suggest that we
		// want to increase the queue size.
		transactionMessagesDroppedFromBacklog.Inc(nil)
	}

	return network.OutgoingMessage{Action: network.Ignore}
}

// we can be lazy responding to advertise offers
const requestExpiration = time.Millisecond * 900

// processIncomingTxnAdvertise is the handler for protocol.TxnAdvertiseTag "Ta"
func (handler *TxHandler) processIncomingTxnAdvertise(rawmsg network.IncomingMessage) network.OutgoingMessage {
	var request []byte
	var txid transactions.Txid
	peer, ok := rawmsg.Sender.(network.UnicastPeer)
	if !ok {
		handler.log.Errorf("Ta Sender not UnicastPeer")
		return network.OutgoingMessage{}
	}
	numids := len(rawmsg.Data) / len(txid)
	if numids*len(txid) != len(rawmsg.Data) {
		handler.log.Warnf("got txid advertisement len %d", len(rawmsg.Data))
		return network.OutgoingMessage{Action: network.Disconnect}
	}
	handler.txRequestsMu.Lock()
	now := time.Now()
	for i := 0; i < numids; i++ {
		copy(txid[:], rawmsg.Data[len(txid)*i:])
		_, _, found := handler.txPool.Lookup(txid)
		if found {
			// we already have it, nothing to do
			handler.log.Infof("Ta already have %s", txid.String())
			continue
		}
		req, ok := handler.txRequests.getByTxid(txid)
		if !ok {
			req = new(requestedTxn)
			req.txid = txid
			req.requestedAt = now
			//req.LastValid = basics.Round(handler.prevRound + 1000)
			handler.txRequests.add(req)
			req.advertisedBy = append(req.advertisedBy, rawmsg.Sender)
		} else {
			req.advertisedBy = append(req.advertisedBy, rawmsg.Sender)
			if now.Sub(req.requestedAt) < requestExpiration {
				// no new request
				handler.log.Infof("Ta already req %s", txid.String())
				continue
			}
			req.requestedAt = now
			heap.Fix(&handler.txRequests, req.heapPos)
		}
		handler.log.Infof("Ta req %s", txid.String())
		req.requestedFrom = append(req.requestedFrom, rawmsg.Sender)
		request = append(request, (txid[:])...)
	}
	handler.txRequestsMu.Unlock()
	if len(request) != 0 {
		err := peer.Unicast(handler.ctx, request, protocol.TxnRequestTag)
		if err != nil {
			handler.log.Errorf("Ta req err, %v", err)
		}
	}
	return network.OutgoingMessage{}
}

func (handler *TxHandler) retryHandler() {
	ticker := time.NewTicker(200 * time.Millisecond)
	defer handler.backlogWg.Done()
	defer ticker.Stop()
	for {
		select {
		case <-handler.ctx.Done():
			return
		case now := <-ticker.C:
			handler.retryHandlerTick(now)
		}
	}
}
func (handler *TxHandler) retryHandlerTick(now time.Time) {
	toRequest := handler.retryHandlerTickRequestList(now)
	if len(toRequest) == 0 {
		return
	}
	for npeer, request := range toRequest {
		peer, ok := npeer.(network.UnicastPeer)
		if !ok {
			handler.log.Errorf("Ta Sender not UnicastPeer")
			continue
		}
		err := peer.Unicast(handler.ctx, request, protocol.TxnRequestTag)
		if err != nil {
			handler.log.Errorf("Ta req err, %v", err)
		}
	}
}
func (handler *TxHandler) retryHandlerTickRequestList(now time.Time) (toRequest map[network.Peer][]byte) {
	handler.txRequestsMu.Lock()
	defer handler.txRequestsMu.Unlock()
	if len(handler.txRequests.ar) == 0 {
		return
	}
	timeout := now.Add(-1 * requestExpiration)
	req := handler.txRequests.ar[0]
	for req.requestedAt.Before(timeout) {
		var nextSource network.Peer
		// find a peer that has advertised it who we haven't asked yet
		for _, source := range req.advertisedBy {
			found := false
			for _, prevReq := range req.requestedFrom {
				if prevReq == source {
					found = true
					break
				}
			}
			if !found {
				nextSource = source
				break
			}
		}
		if nextSource != nil {
			if toRequest == nil {
				toRequest = make(map[network.Peer][]byte)
			}
			toRequest[nextSource] = append(toRequest[nextSource], (req.txid[:])...)
			req.requestedAt = now
			req.requestedFrom = append(req.requestedFrom, nextSource)
			heap.Fix(&handler.txRequests, 0)
		} else {
			heap.Pop(&handler.txRequests)
		}
		if len(handler.txRequests.ar) == 0 {
			break
		}
		req = handler.txRequests.ar[0]
	}
	return
}

// getByTxid looks up a transaction first in the pool, then in the previous block
func (handler *TxHandler) getByTxid(txid transactions.Txid) (tx transactions.SignedTxn, found bool) {
	tx, _, found = handler.txPool.Lookup(txid)
	if found {
		handler.log.Infof("Tr p %s", txid.String())
		return tx, found
	}
	ptany := handler.prevTxns.Load()
	if ptany == nil {
		handler.log.Infof("Tr np MISSING %s", txid.String())
	}
	prevTxns := ptany.(map[transactions.Txid]transactions.SignedTxn)
	tx, found = prevTxns[txid]
	if !found {
		handler.log.Infof("Tr MISSING %s", txid.String())
	}
	return tx, found
}

// processIncomingTxnRequest is the handler for protocol.TxnRequestTag "Tr"
func (handler *TxHandler) processIncomingTxnRequest(rawmsg network.IncomingMessage) network.OutgoingMessage {
	peer, ok := rawmsg.Sender.(network.UnicastPeer)
	if !ok {
		handler.log.Errorf("Tr Sender not UnicastPeer")
		return network.OutgoingMessage{}
	}
	var txid transactions.Txid
	numids := len(rawmsg.Data) / len(txid)
	if numids*len(txid) != len(rawmsg.Data) {
		handler.log.Warnf("got txid advertisement len %d", len(rawmsg.Data))
		return network.OutgoingMessage{Action: network.Disconnect}
	}
	response := make([]transactions.SignedTxn, numids)
	numFound := 0
	for i := 0; i < numids; i++ {
		copy(txid[:], rawmsg.Data[len(txid)*i:])
		tx, found := handler.getByTxid(txid)
		if found {
			response[i] = tx
			numFound++
		}
	}
	if numFound != 0 {
		err := peer.Unicast(handler.ctx, reencode(response), protocol.TxnTag)
		if err != nil {
			handler.log.Errorf("Tr res err, %v", err)
		}
	}
	// TODO: add NACK message to protocol so they can ask another node?
	// But really, this should never happen. We advertised it. We should have it. (Unless it just got committed to a block?) ((TODO: search most recent block for txn by txid?))
	//handler.log.Error("request for txid we don't have: %s", txid.String())
	return network.OutgoingMessage{}
}

// checkAlreadyCommitted test to see if the given transaction ( in the txBacklogMsg ) was already committed, and
// whether it would qualify as a candidate for the transaction pool.
//
// Note that this also checks the consistency of the transaction's group hash,
// which is required for safe transaction signature caching behavior.
func (handler *TxHandler) checkAlreadyCommitted(tx *txBacklogMsg) (processingDone bool) {
	if handler.log.IsLevelEnabled(logging.Debug) {
		txids := make([]transactions.Txid, len(tx.unverifiedTxGroup))
		for i := range tx.unverifiedTxGroup {
			txids[i] = tx.unverifiedTxGroup[i].ID()
		}
		handler.log.Debugf("got a tx group with IDs %v", txids)
	}

	// do a quick test to check that this transaction could potentially be committed, to reject dup pending transactions
	err := handler.txPool.Test(tx.unverifiedTxGroup)
	if err != nil {
		handler.log.Debugf("txPool rejected transaction: %v", err)
		return true
	}
	return false
}

func (handler *TxHandler) processDecoded(unverifiedTxGroup []transactions.SignedTxn) (outmsg network.OutgoingMessage, processingDone bool) {
	tx := &txBacklogMsg{
		unverifiedTxGroup: unverifiedTxGroup,
	}
	if handler.checkAlreadyCommitted(tx) {
		return network.OutgoingMessage{}, true
	}

	// build the transaction verification context
	latest := handler.ledger.Latest()
	latestHdr, err := handler.ledger.BlockHdr(latest)
	if err != nil {
		handler.log.Warnf("Could not get header for previous block %v: %v", latest, err)
		return network.OutgoingMessage{}, true
	}

	unverifiedTxnGroups := bookkeeping.SignedTxnsToGroups(unverifiedTxGroup)
	err = verify.PaysetGroups(context.Background(), unverifiedTxnGroups, latestHdr, handler.txVerificationPool, handler.ledger.VerifiedTransactionCache(), handler.ledger)
	if err != nil {
		// transaction is invalid
		handler.log.Warnf("One or more transactions were malformed: %v", err)
		return network.OutgoingMessage{Action: network.Disconnect}, true
	}

	// at this point, we've verified the transaction group,
	// so we can safely treat the transaction as a verified transaction.
	verifiedTxGroup := unverifiedTxGroup

	// save the transaction, if it has high enough fee and not already in the cache
	err = handler.txPool.Remember(verifiedTxGroup)
	if err != nil {
		handler.log.Debugf("could not remember tx: %v", err)
		return network.OutgoingMessage{}, true
	}

	// if we remembered without any error ( i.e. txpool wasn't full ), then we should pin these transactions.
	err = handler.ledger.VerifiedTransactionCache().Pin(verifiedTxGroup)
	if err != nil {
		handler.log.Warnf("unable to pin transaction: %v", err)
	}

	return network.OutgoingMessage{}, false
}

// SolicitedTxHandler handles messages received through channels other than the gossip network.
// It therefore circumvents the notion of incoming/outgoing messages
type SolicitedTxHandler interface {
	Handle(txgroup []transactions.SignedTxn) error
}

// SolicitedTxHandler converts a transaction handler to a SolicitedTxHandler
func (handler *TxHandler) SolicitedTxHandler() SolicitedTxHandler {
	return &solicitedTxHandler{txHandler: handler}
}

type solicitedTxHandler struct {
	txHandler *TxHandler
}

func (handler *solicitedTxHandler) Handle(txgroup []transactions.SignedTxn) error {
	outmsg, _ := handler.txHandler.processDecoded(txgroup)
	if outmsg.Action == network.Disconnect {
		return fmt.Errorf("invalid transaction")
	}
	return nil
}
