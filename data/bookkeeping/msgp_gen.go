package bookkeeping

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	"sort"

	"github.com/algorand/go-algorand/crypto"
	"github.com/algorand/go-algorand/protocol"
	"github.com/algorand/msgp/msgp"
)

// MarshalMsg implements msgp.Marshaler
func (z *Block) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(24)
	var zb0003Mask uint32 /* 27 bits */
	if len((*z).BlockHeader.CompactCert) == 0 {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).BlockHeader.RewardsState.RewardsLevel == 0 {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if (*z).BlockHeader.RewardsState.FeeSink.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if (*z).BlockHeader.RewardsState.RewardsResidue == 0 {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	if (*z).BlockHeader.GenesisID == "" {
		zb0003Len--
		zb0003Mask |= 0x80
	}
	if (*z).BlockHeader.GenesisHash.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x100
	}
	if (*z).BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x200
	}
	if (*z).BlockHeader.UpgradeState.NextProtocol.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x400
	}
	if (*z).BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x800
	}
	if (*z).BlockHeader.UpgradeState.NextProtocolApprovals == 0 {
		zb0003Len--
		zb0003Mask |= 0x1000
	}
	if (*z).BlockHeader.Branch.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x2000
	}
	if (*z).BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x4000
	}
	if (*z).BlockHeader.RewardsState.RewardsRate == 0 {
		zb0003Len--
		zb0003Mask |= 0x8000
	}
	if (*z).BlockHeader.Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10000
	}
	if (*z).BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x20000
	}
	if (*z).BlockHeader.RewardsState.RewardsPool.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x40000
	}
	if (*z).BlockHeader.Seed.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x80000
	}
	if (*z).BlockHeader.TxnCounter == 0 {
		zb0003Len--
		zb0003Mask |= 0x100000
	}
	if (*z).BlockHeader.TimeStamp == 0 {
		zb0003Len--
		zb0003Mask |= 0x200000
	}
	if (*z).BlockHeader.TxnRoot.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x400000
	}
	if (*z).Payset.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x800000
	}
	if (*z).BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x1000000
	}
	if (*z).BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x2000000
	}
	if (*z).BlockHeader.UpgradeVote.UpgradeApprove == false {
		zb0003Len--
		zb0003Mask |= 0x4000000
	}
	// variable map header, size zb0003Len
	o = msgp.AppendMapHeader(o, zb0003Len)
	if zb0003Len != 0 {
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "cc"
			o = append(o, 0xa2, 0x63, 0x63)
			if (*z).BlockHeader.CompactCert == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).BlockHeader.CompactCert)))
			}
			zb0001_keys := make([]protocol.CompactCertType, 0, len((*z).BlockHeader.CompactCert))
			for zb0001 := range (*z).BlockHeader.CompactCert {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort(protocol.SortCompactCertType(zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).BlockHeader.CompactCert[zb0001]
				_ = zb0002
				o = zb0001.MarshalMsg(o)
				o = zb0002.MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "earn"
			o = append(o, 0xa4, 0x65, 0x61, 0x72, 0x6e)
			o = msgp.AppendUint64(o, (*z).BlockHeader.RewardsState.RewardsLevel)
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o = (*z).BlockHeader.RewardsState.FeeSink.MarshalMsg(o)
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "frac"
			o = append(o, 0xa4, 0x66, 0x72, 0x61, 0x63)
			o = msgp.AppendUint64(o, (*z).BlockHeader.RewardsState.RewardsResidue)
		}
		if (zb0003Mask & 0x80) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).BlockHeader.GenesisID)
		}
		if (zb0003Mask & 0x100) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o = (*z).BlockHeader.GenesisHash.MarshalMsg(o)
		}
		if (zb0003Mask & 0x200) == 0 { // if not empty
			// string "nextbefore"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
			o = (*z).BlockHeader.UpgradeState.NextProtocolVoteBefore.MarshalMsg(o)
		}
		if (zb0003Mask & 0x400) == 0 { // if not empty
			// string "nextproto"
			o = append(o, 0xa9, 0x6e, 0x65, 0x78, 0x74, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).BlockHeader.UpgradeState.NextProtocol.MarshalMsg(o)
		}
		if (zb0003Mask & 0x800) == 0 { // if not empty
			// string "nextswitch"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68)
			o = (*z).BlockHeader.UpgradeState.NextProtocolSwitchOn.MarshalMsg(o)
		}
		if (zb0003Mask & 0x1000) == 0 { // if not empty
			// string "nextyes"
			o = append(o, 0xa7, 0x6e, 0x65, 0x78, 0x74, 0x79, 0x65, 0x73)
			o = msgp.AppendUint64(o, (*z).BlockHeader.UpgradeState.NextProtocolApprovals)
		}
		if (zb0003Mask & 0x2000) == 0 { // if not empty
			// string "prev"
			o = append(o, 0xa4, 0x70, 0x72, 0x65, 0x76)
			o = (*z).BlockHeader.Branch.MarshalMsg(o)
		}
		if (zb0003Mask & 0x4000) == 0 { // if not empty
			// string "proto"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).BlockHeader.UpgradeState.CurrentProtocol.MarshalMsg(o)
		}
		if (zb0003Mask & 0x8000) == 0 { // if not empty
			// string "rate"
			o = append(o, 0xa4, 0x72, 0x61, 0x74, 0x65)
			o = msgp.AppendUint64(o, (*z).BlockHeader.RewardsState.RewardsRate)
		}
		if (zb0003Mask & 0x10000) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).BlockHeader.Round.MarshalMsg(o)
		}
		if (zb0003Mask & 0x20000) == 0 { // if not empty
			// string "rwcalr"
			o = append(o, 0xa6, 0x72, 0x77, 0x63, 0x61, 0x6c, 0x72)
			o = (*z).BlockHeader.RewardsState.RewardsRecalculationRound.MarshalMsg(o)
		}
		if (zb0003Mask & 0x40000) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o = (*z).BlockHeader.RewardsState.RewardsPool.MarshalMsg(o)
		}
		if (zb0003Mask & 0x80000) == 0 { // if not empty
			// string "seed"
			o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
			o = (*z).BlockHeader.Seed.MarshalMsg(o)
		}
		if (zb0003Mask & 0x100000) == 0 { // if not empty
			// string "tc"
			o = append(o, 0xa2, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).BlockHeader.TxnCounter)
		}
		if (zb0003Mask & 0x200000) == 0 { // if not empty
			// string "ts"
			o = append(o, 0xa2, 0x74, 0x73)
			o = msgp.AppendInt64(o, (*z).BlockHeader.TimeStamp)
		}
		if (zb0003Mask & 0x400000) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o = (*z).BlockHeader.TxnRoot.MarshalMsg(o)
		}
		if (zb0003Mask & 0x800000) == 0 { // if not empty
			// string "txns"
			o = append(o, 0xa4, 0x74, 0x78, 0x6e, 0x73)
			o = (*z).Payset.MarshalMsg(o)
		}
		if (zb0003Mask & 0x1000000) == 0 { // if not empty
			// string "upgradedelay"
			o = append(o, 0xac, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x64, 0x65, 0x6c, 0x61, 0x79)
			o = (*z).BlockHeader.UpgradeVote.UpgradeDelay.MarshalMsg(o)
		}
		if (zb0003Mask & 0x2000000) == 0 { // if not empty
			// string "upgradeprop"
			o = append(o, 0xab, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).BlockHeader.UpgradeVote.UpgradePropose.MarshalMsg(o)
		}
		if (zb0003Mask & 0x4000000) == 0 { // if not empty
			// string "upgradeyes"
			o = append(o, 0xaa, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x65, 0x73)
			o = msgp.AppendBool(o, (*z).BlockHeader.UpgradeVote.UpgradeApprove)
		}
	}
	return
}

func (_ *Block) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Block)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Block) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.Branch.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Branch")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.TxnRoot.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnRoot")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TimeStamp")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRate")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsResidue")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRecalculationRound")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CurrentProtocol")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocol")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolApprovals")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolVoteBefore")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolSwitchOn")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradePropose")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeDelay")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeApprove")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnCounter")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CompactCert")
				return
			}
			if zb0005 > protocol.NumCompactCertTypes {
				err = msgp.ErrOverflow(uint64(zb0005), uint64(protocol.NumCompactCertTypes))
				err = msgp.WrapError(err, "struct-from-array", "CompactCert")
				return
			}
			if zb0006 {
				(*z).BlockHeader.CompactCert = nil
			} else if (*z).BlockHeader.CompactCert == nil {
				(*z).BlockHeader.CompactCert = make(map[protocol.CompactCertType]CompactCertState, zb0005)
			}
			for zb0005 > 0 {
				var zb0001 protocol.CompactCertType
				var zb0002 CompactCertState
				zb0005--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CompactCert")
					return
				}
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CompactCert", zb0001)
					return
				}
				(*z).BlockHeader.CompactCert[zb0001] = zb0002
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Payset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Payset")
				return
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = Block{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				bts, err = (*z).BlockHeader.Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "prev":
				bts, err = (*z).BlockHeader.Branch.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Branch")
					return
				}
			case "seed":
				bts, err = (*z).BlockHeader.Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
			case "txn":
				bts, err = (*z).BlockHeader.TxnRoot.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnRoot")
					return
				}
			case "ts":
				(*z).BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimeStamp")
					return
				}
			case "gen":
				(*z).BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "gh":
				bts, err = (*z).BlockHeader.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "fees":
				bts, err = (*z).BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
			case "rwd":
				bts, err = (*z).BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
			case "earn":
				(*z).BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
			case "rate":
				(*z).BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRate")
					return
				}
			case "frac":
				(*z).BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsResidue")
					return
				}
			case "rwcalr":
				bts, err = (*z).BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRecalculationRound")
					return
				}
			case "proto":
				bts, err = (*z).BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CurrentProtocol")
					return
				}
			case "nextproto":
				bts, err = (*z).BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocol")
					return
				}
			case "nextyes":
				(*z).BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolApprovals")
					return
				}
			case "nextbefore":
				bts, err = (*z).BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolVoteBefore")
					return
				}
			case "nextswitch":
				bts, err = (*z).BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolSwitchOn")
					return
				}
			case "upgradeprop":
				bts, err = (*z).BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradePropose")
					return
				}
			case "upgradedelay":
				bts, err = (*z).BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeDelay")
					return
				}
			case "upgradeyes":
				(*z).BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeApprove")
					return
				}
			case "tc":
				(*z).BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnCounter")
					return
				}
			case "cc":
				var zb0007 int
				var zb0008 bool
				zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CompactCert")
					return
				}
				if zb0007 > protocol.NumCompactCertTypes {
					err = msgp.ErrOverflow(uint64(zb0007), uint64(protocol.NumCompactCertTypes))
					err = msgp.WrapError(err, "CompactCert")
					return
				}
				if zb0008 {
					(*z).BlockHeader.CompactCert = nil
				} else if (*z).BlockHeader.CompactCert == nil {
					(*z).BlockHeader.CompactCert = make(map[protocol.CompactCertType]CompactCertState, zb0007)
				}
				for zb0007 > 0 {
					var zb0001 protocol.CompactCertType
					var zb0002 CompactCertState
					zb0007--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CompactCert")
						return
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CompactCert", zb0001)
						return
					}
					(*z).BlockHeader.CompactCert[zb0001] = zb0002
				}
			case "txns":
				bts, err = (*z).Payset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Payset")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *Block) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Block)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Block) Msgsize() (s int) {
	s = 3 + 4 + (*z).BlockHeader.Round.Msgsize() + 5 + (*z).BlockHeader.Branch.Msgsize() + 5 + (*z).BlockHeader.Seed.Msgsize() + 4 + (*z).BlockHeader.TxnRoot.Msgsize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len((*z).BlockHeader.GenesisID) + 3 + (*z).BlockHeader.GenesisHash.Msgsize() + 5 + (*z).BlockHeader.RewardsState.FeeSink.Msgsize() + 4 + (*z).BlockHeader.RewardsState.RewardsPool.Msgsize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + (*z).BlockHeader.RewardsState.RewardsRecalculationRound.Msgsize() + 6 + (*z).BlockHeader.UpgradeState.CurrentProtocol.Msgsize() + 10 + (*z).BlockHeader.UpgradeState.NextProtocol.Msgsize() + 8 + msgp.Uint64Size + 11 + (*z).BlockHeader.UpgradeState.NextProtocolVoteBefore.Msgsize() + 11 + (*z).BlockHeader.UpgradeState.NextProtocolSwitchOn.Msgsize() + 12 + (*z).BlockHeader.UpgradeVote.UpgradePropose.Msgsize() + 13 + (*z).BlockHeader.UpgradeVote.UpgradeDelay.Msgsize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 3 + msgp.MapHeaderSize
	if (*z).BlockHeader.CompactCert != nil {
		for zb0001, zb0002 := range (*z).BlockHeader.CompactCert {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	s += 5 + (*z).Payset.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Block) MsgIsZero() bool {
	return ((*z).BlockHeader.Round.MsgIsZero()) && ((*z).BlockHeader.Branch.MsgIsZero()) && ((*z).BlockHeader.Seed.MsgIsZero()) && ((*z).BlockHeader.TxnRoot.MsgIsZero()) && ((*z).BlockHeader.TimeStamp == 0) && ((*z).BlockHeader.GenesisID == "") && ((*z).BlockHeader.GenesisHash.MsgIsZero()) && ((*z).BlockHeader.RewardsState.FeeSink.MsgIsZero()) && ((*z).BlockHeader.RewardsState.RewardsPool.MsgIsZero()) && ((*z).BlockHeader.RewardsState.RewardsLevel == 0) && ((*z).BlockHeader.RewardsState.RewardsRate == 0) && ((*z).BlockHeader.RewardsState.RewardsResidue == 0) && ((*z).BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero()) && ((*z).BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero()) && ((*z).BlockHeader.UpgradeState.NextProtocol.MsgIsZero()) && ((*z).BlockHeader.UpgradeState.NextProtocolApprovals == 0) && ((*z).BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero()) && ((*z).BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero()) && ((*z).BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero()) && ((*z).BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero()) && ((*z).BlockHeader.UpgradeVote.UpgradeApprove == false) && ((*z).BlockHeader.TxnCounter == 0) && (len((*z).BlockHeader.CompactCert) == 0) && ((*z).Payset.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *BlockHash) MarshalMsg(b []byte) []byte {
	return ((*(crypto.Digest))(z)).MarshalMsg(b)
}
func (_ *BlockHash) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*BlockHash)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BlockHash) UnmarshalMsg(bts []byte) ([]byte, error) {
	return ((*(crypto.Digest))(z)).UnmarshalMsg(bts)
}
func (_ *BlockHash) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*BlockHash)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BlockHash) Msgsize() int {
	return ((*(crypto.Digest))(z)).Msgsize()
}

// MsgIsZero returns whether this is a zero value
func (z *BlockHash) MsgIsZero() bool {
	return ((*(crypto.Digest))(z)).MsgIsZero()
}

// MarshalMsg implements msgp.Marshaler
func (z *BlockHeader) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(23)
	var zb0003Mask uint32 /* 26 bits */
	if len((*z).CompactCert) == 0 {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).RewardsState.RewardsLevel == 0 {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if (*z).RewardsState.FeeSink.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if (*z).RewardsState.RewardsResidue == 0 {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	if (*z).GenesisID == "" {
		zb0003Len--
		zb0003Mask |= 0x80
	}
	if (*z).GenesisHash.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x100
	}
	if (*z).UpgradeState.NextProtocolVoteBefore.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x200
	}
	if (*z).UpgradeState.NextProtocol.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x400
	}
	if (*z).UpgradeState.NextProtocolSwitchOn.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x800
	}
	if (*z).UpgradeState.NextProtocolApprovals == 0 {
		zb0003Len--
		zb0003Mask |= 0x1000
	}
	if (*z).Branch.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x2000
	}
	if (*z).UpgradeState.CurrentProtocol.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x4000
	}
	if (*z).RewardsState.RewardsRate == 0 {
		zb0003Len--
		zb0003Mask |= 0x8000
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10000
	}
	if (*z).RewardsState.RewardsRecalculationRound.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x20000
	}
	if (*z).RewardsState.RewardsPool.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x40000
	}
	if (*z).Seed.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x80000
	}
	if (*z).TxnCounter == 0 {
		zb0003Len--
		zb0003Mask |= 0x100000
	}
	if (*z).TimeStamp == 0 {
		zb0003Len--
		zb0003Mask |= 0x200000
	}
	if (*z).TxnRoot.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x400000
	}
	if (*z).UpgradeVote.UpgradeDelay.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x800000
	}
	if (*z).UpgradeVote.UpgradePropose.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x1000000
	}
	if (*z).UpgradeVote.UpgradeApprove == false {
		zb0003Len--
		zb0003Mask |= 0x2000000
	}
	// variable map header, size zb0003Len
	o = msgp.AppendMapHeader(o, zb0003Len)
	if zb0003Len != 0 {
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "cc"
			o = append(o, 0xa2, 0x63, 0x63)
			if (*z).CompactCert == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).CompactCert)))
			}
			zb0001_keys := make([]protocol.CompactCertType, 0, len((*z).CompactCert))
			for zb0001 := range (*z).CompactCert {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort(protocol.SortCompactCertType(zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).CompactCert[zb0001]
				_ = zb0002
				o = zb0001.MarshalMsg(o)
				o = zb0002.MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "earn"
			o = append(o, 0xa4, 0x65, 0x61, 0x72, 0x6e)
			o = msgp.AppendUint64(o, (*z).RewardsState.RewardsLevel)
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o = (*z).RewardsState.FeeSink.MarshalMsg(o)
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "frac"
			o = append(o, 0xa4, 0x66, 0x72, 0x61, 0x63)
			o = msgp.AppendUint64(o, (*z).RewardsState.RewardsResidue)
		}
		if (zb0003Mask & 0x80) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).GenesisID)
		}
		if (zb0003Mask & 0x100) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o = (*z).GenesisHash.MarshalMsg(o)
		}
		if (zb0003Mask & 0x200) == 0 { // if not empty
			// string "nextbefore"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
			o = (*z).UpgradeState.NextProtocolVoteBefore.MarshalMsg(o)
		}
		if (zb0003Mask & 0x400) == 0 { // if not empty
			// string "nextproto"
			o = append(o, 0xa9, 0x6e, 0x65, 0x78, 0x74, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).UpgradeState.NextProtocol.MarshalMsg(o)
		}
		if (zb0003Mask & 0x800) == 0 { // if not empty
			// string "nextswitch"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68)
			o = (*z).UpgradeState.NextProtocolSwitchOn.MarshalMsg(o)
		}
		if (zb0003Mask & 0x1000) == 0 { // if not empty
			// string "nextyes"
			o = append(o, 0xa7, 0x6e, 0x65, 0x78, 0x74, 0x79, 0x65, 0x73)
			o = msgp.AppendUint64(o, (*z).UpgradeState.NextProtocolApprovals)
		}
		if (zb0003Mask & 0x2000) == 0 { // if not empty
			// string "prev"
			o = append(o, 0xa4, 0x70, 0x72, 0x65, 0x76)
			o = (*z).Branch.MarshalMsg(o)
		}
		if (zb0003Mask & 0x4000) == 0 { // if not empty
			// string "proto"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).UpgradeState.CurrentProtocol.MarshalMsg(o)
		}
		if (zb0003Mask & 0x8000) == 0 { // if not empty
			// string "rate"
			o = append(o, 0xa4, 0x72, 0x61, 0x74, 0x65)
			o = msgp.AppendUint64(o, (*z).RewardsState.RewardsRate)
		}
		if (zb0003Mask & 0x10000) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0003Mask & 0x20000) == 0 { // if not empty
			// string "rwcalr"
			o = append(o, 0xa6, 0x72, 0x77, 0x63, 0x61, 0x6c, 0x72)
			o = (*z).RewardsState.RewardsRecalculationRound.MarshalMsg(o)
		}
		if (zb0003Mask & 0x40000) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o = (*z).RewardsState.RewardsPool.MarshalMsg(o)
		}
		if (zb0003Mask & 0x80000) == 0 { // if not empty
			// string "seed"
			o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
			o = (*z).Seed.MarshalMsg(o)
		}
		if (zb0003Mask & 0x100000) == 0 { // if not empty
			// string "tc"
			o = append(o, 0xa2, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).TxnCounter)
		}
		if (zb0003Mask & 0x200000) == 0 { // if not empty
			// string "ts"
			o = append(o, 0xa2, 0x74, 0x73)
			o = msgp.AppendInt64(o, (*z).TimeStamp)
		}
		if (zb0003Mask & 0x400000) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o = (*z).TxnRoot.MarshalMsg(o)
		}
		if (zb0003Mask & 0x800000) == 0 { // if not empty
			// string "upgradedelay"
			o = append(o, 0xac, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x64, 0x65, 0x6c, 0x61, 0x79)
			o = (*z).UpgradeVote.UpgradeDelay.MarshalMsg(o)
		}
		if (zb0003Mask & 0x1000000) == 0 { // if not empty
			// string "upgradeprop"
			o = append(o, 0xab, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).UpgradeVote.UpgradePropose.MarshalMsg(o)
		}
		if (zb0003Mask & 0x2000000) == 0 { // if not empty
			// string "upgradeyes"
			o = append(o, 0xaa, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x65, 0x73)
			o = msgp.AppendBool(o, (*z).UpgradeVote.UpgradeApprove)
		}
	}
	return
}

func (_ *BlockHeader) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*BlockHeader)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BlockHeader) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Branch.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Branch")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).TxnRoot.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnRoot")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TimeStamp")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).RewardsState.FeeSink.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).RewardsState.RewardsPool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRate")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsResidue")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRecalculationRound")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CurrentProtocol")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).UpgradeState.NextProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocol")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolApprovals")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolVoteBefore")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolSwitchOn")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradePropose")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeDelay")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeApprove")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnCounter")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CompactCert")
				return
			}
			if zb0005 > protocol.NumCompactCertTypes {
				err = msgp.ErrOverflow(uint64(zb0005), uint64(protocol.NumCompactCertTypes))
				err = msgp.WrapError(err, "struct-from-array", "CompactCert")
				return
			}
			if zb0006 {
				(*z).CompactCert = nil
			} else if (*z).CompactCert == nil {
				(*z).CompactCert = make(map[protocol.CompactCertType]CompactCertState, zb0005)
			}
			for zb0005 > 0 {
				var zb0001 protocol.CompactCertType
				var zb0002 CompactCertState
				zb0005--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CompactCert")
					return
				}
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CompactCert", zb0001)
					return
				}
				(*z).CompactCert[zb0001] = zb0002
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = BlockHeader{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "prev":
				bts, err = (*z).Branch.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Branch")
					return
				}
			case "seed":
				bts, err = (*z).Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
			case "txn":
				bts, err = (*z).TxnRoot.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnRoot")
					return
				}
			case "ts":
				(*z).TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimeStamp")
					return
				}
			case "gen":
				(*z).GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "gh":
				bts, err = (*z).GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "fees":
				bts, err = (*z).RewardsState.FeeSink.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
			case "rwd":
				bts, err = (*z).RewardsState.RewardsPool.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
			case "earn":
				(*z).RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
			case "rate":
				(*z).RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRate")
					return
				}
			case "frac":
				(*z).RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsResidue")
					return
				}
			case "rwcalr":
				bts, err = (*z).RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRecalculationRound")
					return
				}
			case "proto":
				bts, err = (*z).UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CurrentProtocol")
					return
				}
			case "nextproto":
				bts, err = (*z).UpgradeState.NextProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocol")
					return
				}
			case "nextyes":
				(*z).UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolApprovals")
					return
				}
			case "nextbefore":
				bts, err = (*z).UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolVoteBefore")
					return
				}
			case "nextswitch":
				bts, err = (*z).UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolSwitchOn")
					return
				}
			case "upgradeprop":
				bts, err = (*z).UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradePropose")
					return
				}
			case "upgradedelay":
				bts, err = (*z).UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeDelay")
					return
				}
			case "upgradeyes":
				(*z).UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeApprove")
					return
				}
			case "tc":
				(*z).TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnCounter")
					return
				}
			case "cc":
				var zb0007 int
				var zb0008 bool
				zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CompactCert")
					return
				}
				if zb0007 > protocol.NumCompactCertTypes {
					err = msgp.ErrOverflow(uint64(zb0007), uint64(protocol.NumCompactCertTypes))
					err = msgp.WrapError(err, "CompactCert")
					return
				}
				if zb0008 {
					(*z).CompactCert = nil
				} else if (*z).CompactCert == nil {
					(*z).CompactCert = make(map[protocol.CompactCertType]CompactCertState, zb0007)
				}
				for zb0007 > 0 {
					var zb0001 protocol.CompactCertType
					var zb0002 CompactCertState
					zb0007--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CompactCert")
						return
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CompactCert", zb0001)
						return
					}
					(*z).CompactCert[zb0001] = zb0002
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *BlockHeader) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*BlockHeader)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BlockHeader) Msgsize() (s int) {
	s = 3 + 4 + (*z).Round.Msgsize() + 5 + (*z).Branch.Msgsize() + 5 + (*z).Seed.Msgsize() + 4 + (*z).TxnRoot.Msgsize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len((*z).GenesisID) + 3 + (*z).GenesisHash.Msgsize() + 5 + (*z).RewardsState.FeeSink.Msgsize() + 4 + (*z).RewardsState.RewardsPool.Msgsize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + (*z).RewardsState.RewardsRecalculationRound.Msgsize() + 6 + (*z).UpgradeState.CurrentProtocol.Msgsize() + 10 + (*z).UpgradeState.NextProtocol.Msgsize() + 8 + msgp.Uint64Size + 11 + (*z).UpgradeState.NextProtocolVoteBefore.Msgsize() + 11 + (*z).UpgradeState.NextProtocolSwitchOn.Msgsize() + 12 + (*z).UpgradeVote.UpgradePropose.Msgsize() + 13 + (*z).UpgradeVote.UpgradeDelay.Msgsize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 3 + msgp.MapHeaderSize
	if (*z).CompactCert != nil {
		for zb0001, zb0002 := range (*z).CompactCert {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *BlockHeader) MsgIsZero() bool {
	return ((*z).Round.MsgIsZero()) && ((*z).Branch.MsgIsZero()) && ((*z).Seed.MsgIsZero()) && ((*z).TxnRoot.MsgIsZero()) && ((*z).TimeStamp == 0) && ((*z).GenesisID == "") && ((*z).GenesisHash.MsgIsZero()) && ((*z).RewardsState.FeeSink.MsgIsZero()) && ((*z).RewardsState.RewardsPool.MsgIsZero()) && ((*z).RewardsState.RewardsLevel == 0) && ((*z).RewardsState.RewardsRate == 0) && ((*z).RewardsState.RewardsResidue == 0) && ((*z).RewardsState.RewardsRecalculationRound.MsgIsZero()) && ((*z).UpgradeState.CurrentProtocol.MsgIsZero()) && ((*z).UpgradeState.NextProtocol.MsgIsZero()) && ((*z).UpgradeState.NextProtocolApprovals == 0) && ((*z).UpgradeState.NextProtocolVoteBefore.MsgIsZero()) && ((*z).UpgradeState.NextProtocolSwitchOn.MsgIsZero()) && ((*z).UpgradeVote.UpgradePropose.MsgIsZero()) && ((*z).UpgradeVote.UpgradeDelay.MsgIsZero()) && ((*z).UpgradeVote.UpgradeApprove == false) && ((*z).TxnCounter == 0) && (len((*z).CompactCert) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *CompactCertState) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).CompactCertNextRound.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).CompactCertVotersTotal.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).CompactCertVoters.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "n"
			o = append(o, 0xa1, 0x6e)
			o = (*z).CompactCertNextRound.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			o = (*z).CompactCertVotersTotal.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "v"
			o = append(o, 0xa1, 0x76)
			o = (*z).CompactCertVoters.MarshalMsg(o)
		}
	}
	return
}

func (_ *CompactCertState) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*CompactCertState)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CompactCertState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).CompactCertVoters.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CompactCertVoters")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).CompactCertVotersTotal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CompactCertVotersTotal")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).CompactCertNextRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CompactCertNextRound")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = CompactCertState{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "v":
				bts, err = (*z).CompactCertVoters.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CompactCertVoters")
					return
				}
			case "t":
				bts, err = (*z).CompactCertVotersTotal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CompactCertVotersTotal")
					return
				}
			case "n":
				bts, err = (*z).CompactCertNextRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CompactCertNextRound")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *CompactCertState) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*CompactCertState)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CompactCertState) Msgsize() (s int) {
	s = 1 + 2 + (*z).CompactCertVoters.Msgsize() + 2 + (*z).CompactCertVotersTotal.Msgsize() + 2 + (*z).CompactCertNextRound.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *CompactCertState) MsgIsZero() bool {
	return ((*z).CompactCertVoters.MsgIsZero()) && ((*z).CompactCertVotersTotal.MsgIsZero()) && ((*z).CompactCertNextRound.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *Genesis) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(8)
	var zb0002Mask uint16 /* 9 bits */
	if len((*z).Allocation) == 0 {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	if (*z).Comment == "" {
		zb0002Len--
		zb0002Mask |= 0x4
	}
	if (*z).FeeSink == "" {
		zb0002Len--
		zb0002Mask |= 0x8
	}
	if (*z).SchemaID == "" {
		zb0002Len--
		zb0002Mask |= 0x10
	}
	if (*z).Network.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x20
	}
	if (*z).Proto.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x40
	}
	if (*z).RewardsPool == "" {
		zb0002Len--
		zb0002Mask |= 0x80
	}
	if (*z).Timestamp == 0 {
		zb0002Len--
		zb0002Mask |= 0x100
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "alloc"
			o = append(o, 0xa5, 0x61, 0x6c, 0x6c, 0x6f, 0x63)
			if (*z).Allocation == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Allocation)))
			}
			for zb0001 := range (*z).Allocation {
				o = (*z).Allocation[zb0001].MarshalMsg(o)
			}
		}
		if (zb0002Mask & 0x4) == 0 { // if not empty
			// string "comment"
			o = append(o, 0xa7, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74)
			o = msgp.AppendString(o, (*z).Comment)
		}
		if (zb0002Mask & 0x8) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o = msgp.AppendString(o, (*z).FeeSink)
		}
		if (zb0002Mask & 0x10) == 0 { // if not empty
			// string "id"
			o = append(o, 0xa2, 0x69, 0x64)
			o = msgp.AppendString(o, (*z).SchemaID)
		}
		if (zb0002Mask & 0x20) == 0 { // if not empty
			// string "network"
			o = append(o, 0xa7, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b)
			o = (*z).Network.MarshalMsg(o)
		}
		if (zb0002Mask & 0x40) == 0 { // if not empty
			// string "proto"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).Proto.MarshalMsg(o)
		}
		if (zb0002Mask & 0x80) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o = msgp.AppendString(o, (*z).RewardsPool)
		}
		if (zb0002Mask & 0x100) == 0 { // if not empty
			// string "timestamp"
			o = append(o, 0xa9, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
			o = msgp.AppendInt64(o, (*z).Timestamp)
		}
	}
	return
}

func (_ *Genesis) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Genesis)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Genesis) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			(*z).SchemaID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SchemaID")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Network.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Network")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Proto.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proto")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Allocation")
				return
			}
			if zb0004 > MaxInitialGenesisAllocationSize {
				err = msgp.ErrOverflow(uint64(zb0004), uint64(MaxInitialGenesisAllocationSize))
				err = msgp.WrapError(err, "struct-from-array", "Allocation")
				return
			}
			if zb0005 {
				(*z).Allocation = nil
			} else if (*z).Allocation != nil && cap((*z).Allocation) >= zb0004 {
				(*z).Allocation = ((*z).Allocation)[:zb0004]
			} else {
				(*z).Allocation = make([]GenesisAllocation, zb0004)
			}
			for zb0001 := range (*z).Allocation {
				bts, err = (*z).Allocation[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Allocation", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).RewardsPool, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).FeeSink, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Timestamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Timestamp")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Comment, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Comment")
				return
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = Genesis{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "id":
				(*z).SchemaID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SchemaID")
					return
				}
			case "network":
				bts, err = (*z).Network.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Network")
					return
				}
			case "proto":
				bts, err = (*z).Proto.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proto")
					return
				}
			case "alloc":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Allocation")
					return
				}
				if zb0006 > MaxInitialGenesisAllocationSize {
					err = msgp.ErrOverflow(uint64(zb0006), uint64(MaxInitialGenesisAllocationSize))
					err = msgp.WrapError(err, "Allocation")
					return
				}
				if zb0007 {
					(*z).Allocation = nil
				} else if (*z).Allocation != nil && cap((*z).Allocation) >= zb0006 {
					(*z).Allocation = ((*z).Allocation)[:zb0006]
				} else {
					(*z).Allocation = make([]GenesisAllocation, zb0006)
				}
				for zb0001 := range (*z).Allocation {
					bts, err = (*z).Allocation[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Allocation", zb0001)
						return
					}
				}
			case "rwd":
				(*z).RewardsPool, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
			case "fees":
				(*z).FeeSink, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
			case "timestamp":
				(*z).Timestamp, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Timestamp")
					return
				}
			case "comment":
				(*z).Comment, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Comment")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *Genesis) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Genesis)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Genesis) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len((*z).SchemaID) + 8 + (*z).Network.Msgsize() + 6 + (*z).Proto.Msgsize() + 6 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Allocation {
		s += (*z).Allocation[zb0001].Msgsize()
	}
	s += 4 + msgp.StringPrefixSize + len((*z).RewardsPool) + 5 + msgp.StringPrefixSize + len((*z).FeeSink) + 10 + msgp.Int64Size + 8 + msgp.StringPrefixSize + len((*z).Comment)
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Genesis) MsgIsZero() bool {
	return ((*z).SchemaID == "") && ((*z).Network.MsgIsZero()) && ((*z).Proto.MsgIsZero()) && (len((*z).Allocation) == 0) && ((*z).RewardsPool == "") && ((*z).FeeSink == "") && ((*z).Timestamp == 0) && ((*z).Comment == "")
}

// MarshalMsg implements msgp.Marshaler
func (z *GenesisAllocation) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "addr"
	o = append(o, 0x83, 0xa4, 0x61, 0x64, 0x64, 0x72)
	o = msgp.AppendString(o, (*z).Address)
	// string "comment"
	o = append(o, 0xa7, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74)
	o = msgp.AppendString(o, (*z).Comment)
	// string "state"
	o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
	o = (*z).State.MarshalMsg(o)
	return
}

func (_ *GenesisAllocation) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*GenesisAllocation)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GenesisAllocation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Address, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Address")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Comment, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Comment")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).State.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "State")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = GenesisAllocation{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "addr":
				(*z).Address, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Address")
					return
				}
			case "comment":
				(*z).Comment, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Comment")
					return
				}
			case "state":
				bts, err = (*z).State.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "State")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *GenesisAllocation) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*GenesisAllocation)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GenesisAllocation) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len((*z).Address) + 8 + msgp.StringPrefixSize + len((*z).Comment) + 6 + (*z).State.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *GenesisAllocation) MsgIsZero() bool {
	return ((*z).Address == "") && ((*z).Comment == "") && ((*z).State.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *RewardsState) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 7 bits */
	if (*z).RewardsLevel == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).FeeSink.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).RewardsResidue == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).RewardsRate == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).RewardsRecalculationRound.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).RewardsPool.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "earn"
			o = append(o, 0xa4, 0x65, 0x61, 0x72, 0x6e)
			o = msgp.AppendUint64(o, (*z).RewardsLevel)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o = (*z).FeeSink.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "frac"
			o = append(o, 0xa4, 0x66, 0x72, 0x61, 0x63)
			o = msgp.AppendUint64(o, (*z).RewardsResidue)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "rate"
			o = append(o, 0xa4, 0x72, 0x61, 0x74, 0x65)
			o = msgp.AppendUint64(o, (*z).RewardsRate)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "rwcalr"
			o = append(o, 0xa6, 0x72, 0x77, 0x63, 0x61, 0x6c, 0x72)
			o = (*z).RewardsRecalculationRound.MarshalMsg(o)
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o = (*z).RewardsPool.MarshalMsg(o)
		}
	}
	return
}

func (_ *RewardsState) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*RewardsState)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RewardsState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).FeeSink.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).RewardsPool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRate")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsResidue")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).RewardsRecalculationRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRecalculationRound")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = RewardsState{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "fees":
				bts, err = (*z).FeeSink.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
			case "rwd":
				bts, err = (*z).RewardsPool.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
			case "earn":
				(*z).RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
			case "rate":
				(*z).RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRate")
					return
				}
			case "frac":
				(*z).RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsResidue")
					return
				}
			case "rwcalr":
				bts, err = (*z).RewardsRecalculationRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRecalculationRound")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *RewardsState) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*RewardsState)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RewardsState) Msgsize() (s int) {
	s = 1 + 5 + (*z).FeeSink.Msgsize() + 4 + (*z).RewardsPool.Msgsize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + (*z).RewardsRecalculationRound.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *RewardsState) MsgIsZero() bool {
	return ((*z).FeeSink.MsgIsZero()) && ((*z).RewardsPool.MsgIsZero()) && ((*z).RewardsLevel == 0) && ((*z).RewardsRate == 0) && ((*z).RewardsResidue == 0) && ((*z).RewardsRecalculationRound.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *UpgradeVote) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).UpgradeDelay.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).UpgradePropose.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).UpgradeApprove == false {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "upgradedelay"
			o = append(o, 0xac, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x64, 0x65, 0x6c, 0x61, 0x79)
			o = (*z).UpgradeDelay.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "upgradeprop"
			o = append(o, 0xab, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).UpgradePropose.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "upgradeyes"
			o = append(o, 0xaa, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x65, 0x73)
			o = msgp.AppendBool(o, (*z).UpgradeApprove)
		}
	}
	return
}

func (_ *UpgradeVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*UpgradeVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UpgradeVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).UpgradePropose.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradePropose")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).UpgradeDelay.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeDelay")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeApprove")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = UpgradeVote{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "upgradeprop":
				bts, err = (*z).UpgradePropose.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradePropose")
					return
				}
			case "upgradedelay":
				bts, err = (*z).UpgradeDelay.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeDelay")
					return
				}
			case "upgradeyes":
				(*z).UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeApprove")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *UpgradeVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*UpgradeVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *UpgradeVote) Msgsize() (s int) {
	s = 1 + 12 + (*z).UpgradePropose.Msgsize() + 13 + (*z).UpgradeDelay.Msgsize() + 11 + msgp.BoolSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *UpgradeVote) MsgIsZero() bool {
	return ((*z).UpgradePropose.MsgIsZero()) && ((*z).UpgradeDelay.MsgIsZero()) && ((*z).UpgradeApprove == false)
}
