package transactions

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	"github.com/algorand/go-algorand/crypto"
	"github.com/algorand/msgp/msgp"
)

// MarshalMsg implements msgp.Marshaler
func (z *ApplyData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 5 bits */
	if (*z).ClosingAmount.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).CloseRewards.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).ReceiverRewards.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).SenderRewards.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "ca"
			o = append(o, 0xa2, 0x63, 0x61)
			o, err = (*z).ClosingAmount.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "ClosingAmount")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "rc"
			o = append(o, 0xa2, 0x72, 0x63)
			o, err = (*z).CloseRewards.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "CloseRewards")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "rr"
			o = append(o, 0xa2, 0x72, 0x72)
			o, err = (*z).ReceiverRewards.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "ReceiverRewards")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "rs"
			o = append(o, 0xa2, 0x72, 0x73)
			o, err = (*z).SenderRewards.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "SenderRewards")
				return
			}
		}
	}
	return
}

func (_ *ApplyData) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*ApplyData)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ApplyData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).ClosingAmount.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ClosingAmount")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SenderRewards.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SenderRewards")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).ReceiverRewards.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ReceiverRewards")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).CloseRewards.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRewards")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = ApplyData{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "ca":
				bts, err = (*z).ClosingAmount.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ClosingAmount")
					return
				}
			case "rs":
				bts, err = (*z).SenderRewards.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SenderRewards")
					return
				}
			case "rr":
				bts, err = (*z).ReceiverRewards.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ReceiverRewards")
					return
				}
			case "rc":
				bts, err = (*z).CloseRewards.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRewards")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *ApplyData) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*ApplyData)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ApplyData) Msgsize() (s int) {
	s = 1 + 3 + (*z).ClosingAmount.Msgsize() + 3 + (*z).SenderRewards.Msgsize() + 3 + (*z).ReceiverRewards.Msgsize() + 3 + (*z).CloseRewards.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *ApplyData) MsgIsZero() bool {
	return ((*z).ClosingAmount.MsgIsZero()) && ((*z).SenderRewards.MsgIsZero()) && ((*z).ReceiverRewards.MsgIsZero()) && ((*z).CloseRewards.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *AssetConfigTxnFields) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 3 bits */
	if (*z).AssetParams.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).ConfigAsset.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "apar"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x72)
			o, err = (*z).AssetParams.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "AssetParams")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "caid"
			o = append(o, 0xa4, 0x63, 0x61, 0x69, 0x64)
			o, err = (*z).ConfigAsset.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "ConfigAsset")
				return
			}
		}
	}
	return
}

func (_ *AssetConfigTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*AssetConfigTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AssetConfigTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).ConfigAsset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ConfigAsset")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).AssetParams.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetParams")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = AssetConfigTxnFields{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "caid":
				bts, err = (*z).ConfigAsset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ConfigAsset")
					return
				}
			case "apar":
				bts, err = (*z).AssetParams.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetParams")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *AssetConfigTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*AssetConfigTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AssetConfigTxnFields) Msgsize() (s int) {
	s = 1 + 5 + (*z).ConfigAsset.Msgsize() + 5 + (*z).AssetParams.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *AssetConfigTxnFields) MsgIsZero() bool {
	return ((*z).ConfigAsset.MsgIsZero()) && ((*z).AssetParams.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *AssetFreezeTxnFields) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).AssetFrozen == false {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).FreezeAccount.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).FreezeAsset.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "afrz"
			o = append(o, 0xa4, 0x61, 0x66, 0x72, 0x7a)
			o = msgp.AppendBool(o, (*z).AssetFrozen)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "fadd"
			o = append(o, 0xa4, 0x66, 0x61, 0x64, 0x64)
			o, err = (*z).FreezeAccount.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "FreezeAccount")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "faid"
			o = append(o, 0xa4, 0x66, 0x61, 0x69, 0x64)
			o, err = (*z).FreezeAsset.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "FreezeAsset")
				return
			}
		}
	}
	return
}

func (_ *AssetFreezeTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*AssetFreezeTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AssetFreezeTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).FreezeAccount.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAccount")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).FreezeAsset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAsset")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).AssetFrozen, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetFrozen")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = AssetFreezeTxnFields{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "fadd":
				bts, err = (*z).FreezeAccount.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAccount")
					return
				}
			case "faid":
				bts, err = (*z).FreezeAsset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAsset")
					return
				}
			case "afrz":
				(*z).AssetFrozen, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetFrozen")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *AssetFreezeTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*AssetFreezeTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AssetFreezeTxnFields) Msgsize() (s int) {
	s = 1 + 5 + (*z).FreezeAccount.Msgsize() + 5 + (*z).FreezeAsset.Msgsize() + 5 + msgp.BoolSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *AssetFreezeTxnFields) MsgIsZero() bool {
	return ((*z).FreezeAccount.MsgIsZero()) && ((*z).FreezeAsset.MsgIsZero()) && ((*z).AssetFrozen == false)
}

// MarshalMsg implements msgp.Marshaler
func (z *AssetTransferTxnFields) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 6 bits */
	if (*z).AssetAmount == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).AssetCloseTo.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).AssetReceiver.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).AssetSender.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).XferAsset.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "aamt"
			o = append(o, 0xa4, 0x61, 0x61, 0x6d, 0x74)
			o = msgp.AppendUint64(o, (*z).AssetAmount)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "aclose"
			o = append(o, 0xa6, 0x61, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			o, err = (*z).AssetCloseTo.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "AssetCloseTo")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "arcv"
			o = append(o, 0xa4, 0x61, 0x72, 0x63, 0x76)
			o, err = (*z).AssetReceiver.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "AssetReceiver")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "asnd"
			o = append(o, 0xa4, 0x61, 0x73, 0x6e, 0x64)
			o, err = (*z).AssetSender.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "AssetSender")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "xaid"
			o = append(o, 0xa4, 0x78, 0x61, 0x69, 0x64)
			o, err = (*z).XferAsset.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "XferAsset")
				return
			}
		}
	}
	return
}

func (_ *AssetTransferTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*AssetTransferTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AssetTransferTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).XferAsset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "XferAsset")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).AssetAmount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetAmount")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).AssetSender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetSender")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).AssetReceiver.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetReceiver")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).AssetCloseTo.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetCloseTo")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = AssetTransferTxnFields{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "xaid":
				bts, err = (*z).XferAsset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "XferAsset")
					return
				}
			case "aamt":
				(*z).AssetAmount, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetAmount")
					return
				}
			case "asnd":
				bts, err = (*z).AssetSender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetSender")
					return
				}
			case "arcv":
				bts, err = (*z).AssetReceiver.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetReceiver")
					return
				}
			case "aclose":
				bts, err = (*z).AssetCloseTo.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetCloseTo")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *AssetTransferTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*AssetTransferTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AssetTransferTxnFields) Msgsize() (s int) {
	s = 1 + 5 + (*z).XferAsset.Msgsize() + 5 + msgp.Uint64Size + 5 + (*z).AssetSender.Msgsize() + 5 + (*z).AssetReceiver.Msgsize() + 7 + (*z).AssetCloseTo.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *AssetTransferTxnFields) MsgIsZero() bool {
	return ((*z).XferAsset.MsgIsZero()) && ((*z).AssetAmount == 0) && ((*z).AssetSender.MsgIsZero()) && ((*z).AssetReceiver.MsgIsZero()) && ((*z).AssetCloseTo.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *Header) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(10)
	var zb0002Mask uint16 /* 11 bits */
	if (*z).Fee.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	if (*z).FirstValid.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x4
	}
	if (*z).GenesisID == "" {
		zb0002Len--
		zb0002Mask |= 0x8
	}
	if (*z).GenesisHash.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x10
	}
	if (*z).Group.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x20
	}
	if (*z).LastValid.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x40
	}
	if (*z).Lease == ([32]byte{}) {
		zb0002Len--
		zb0002Mask |= 0x80
	}
	if len((*z).Note) == 0 {
		zb0002Len--
		zb0002Mask |= 0x100
	}
	if (*z).RekeyTo.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x200
	}
	if (*z).Sender.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x400
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "fee"
			o = append(o, 0xa3, 0x66, 0x65, 0x65)
			o, err = (*z).Fee.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Fee")
				return
			}
		}
		if (zb0002Mask & 0x4) == 0 { // if not empty
			// string "fv"
			o = append(o, 0xa2, 0x66, 0x76)
			o, err = (*z).FirstValid.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "FirstValid")
				return
			}
		}
		if (zb0002Mask & 0x8) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).GenesisID)
		}
		if (zb0002Mask & 0x10) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o, err = (*z).GenesisHash.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "GenesisHash")
				return
			}
		}
		if (zb0002Mask & 0x20) == 0 { // if not empty
			// string "grp"
			o = append(o, 0xa3, 0x67, 0x72, 0x70)
			o, err = (*z).Group.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		}
		if (zb0002Mask & 0x40) == 0 { // if not empty
			// string "lv"
			o = append(o, 0xa2, 0x6c, 0x76)
			o, err = (*z).LastValid.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "LastValid")
				return
			}
		}
		if (zb0002Mask & 0x80) == 0 { // if not empty
			// string "lx"
			o = append(o, 0xa2, 0x6c, 0x78)
			o = msgp.AppendBytes(o, ((*z).Lease)[:])
		}
		if (zb0002Mask & 0x100) == 0 { // if not empty
			// string "note"
			o = append(o, 0xa4, 0x6e, 0x6f, 0x74, 0x65)
			o = msgp.AppendBytes(o, (*z).Note)
		}
		if (zb0002Mask & 0x200) == 0 { // if not empty
			// string "rekey"
			o = append(o, 0xa5, 0x72, 0x65, 0x6b, 0x65, 0x79)
			o, err = (*z).RekeyTo.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "RekeyTo")
				return
			}
		}
		if (zb0002Mask & 0x400) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o, err = (*z).Sender.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		}
	}
	return
}

func (_ *Header) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Header)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Header) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Fee.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).FirstValid.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).LastValid.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Note, bts, err = msgp.ReadBytesBytes(bts, (*z).Note)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Group.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Group")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = msgp.ReadExactBytes(bts, ((*z).Lease)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).RekeyTo.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = Header{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "fee":
				bts, err = (*z).Fee.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Fee")
					return
				}
			case "fv":
				bts, err = (*z).FirstValid.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstValid")
					return
				}
			case "lv":
				bts, err = (*z).LastValid.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastValid")
					return
				}
			case "note":
				(*z).Note, bts, err = msgp.ReadBytesBytes(bts, (*z).Note)
				if err != nil {
					err = msgp.WrapError(err, "Note")
					return
				}
			case "gen":
				(*z).GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "gh":
				bts, err = (*z).GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "grp":
				bts, err = (*z).Group.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Group")
					return
				}
			case "lx":
				bts, err = msgp.ReadExactBytes(bts, ((*z).Lease)[:])
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
			case "rekey":
				bts, err = (*z).RekeyTo.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *Header) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Header)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Header) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 4 + (*z).Fee.Msgsize() + 3 + (*z).FirstValid.Msgsize() + 3 + (*z).LastValid.Msgsize() + 5 + msgp.BytesPrefixSize + len((*z).Note) + 4 + msgp.StringPrefixSize + len((*z).GenesisID) + 3 + (*z).GenesisHash.Msgsize() + 4 + (*z).Group.Msgsize() + 3 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 6 + (*z).RekeyTo.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Header) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Fee.MsgIsZero()) && ((*z).FirstValid.MsgIsZero()) && ((*z).LastValid.MsgIsZero()) && (len((*z).Note) == 0) && ((*z).GenesisID == "") && ((*z).GenesisHash.MsgIsZero()) && ((*z).Group.MsgIsZero()) && ((*z).Lease == ([32]byte{})) && ((*z).RekeyTo.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *KeyregTxnFields) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 7 bits */
	if (*z).Nonparticipation == false {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).SelectionPK.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).VoteFirst.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).VoteKeyDilution == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).VotePK.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).VoteLast.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "nonpart"
			o = append(o, 0xa7, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74)
			o = msgp.AppendBool(o, (*z).Nonparticipation)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "selkey"
			o = append(o, 0xa6, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79)
			o, err = (*z).SelectionPK.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "SelectionPK")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "votefst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74)
			o, err = (*z).VoteFirst.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "VoteFirst")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "votekd"
			o = append(o, 0xa6, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64)
			o = msgp.AppendUint64(o, (*z).VoteKeyDilution)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "votekey"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79)
			o, err = (*z).VotePK.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "VotePK")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "votelst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74)
			o, err = (*z).VoteLast.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "VoteLast")
				return
			}
		}
	}
	return
}

func (_ *KeyregTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*KeyregTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *KeyregTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).VotePK.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SelectionPK.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).VoteFirst.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).VoteLast.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).VoteKeyDilution, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Nonparticipation, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Nonparticipation")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = KeyregTxnFields{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "votekey":
				bts, err = (*z).VotePK.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
			case "selkey":
				bts, err = (*z).SelectionPK.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
			case "votefst":
				bts, err = (*z).VoteFirst.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
			case "votelst":
				bts, err = (*z).VoteLast.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteLast")
					return
				}
			case "votekd":
				(*z).VoteKeyDilution, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
			case "nonpart":
				(*z).Nonparticipation, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Nonparticipation")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *KeyregTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*KeyregTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *KeyregTxnFields) Msgsize() (s int) {
	s = 1 + 8 + (*z).VotePK.Msgsize() + 7 + (*z).SelectionPK.Msgsize() + 8 + (*z).VoteFirst.Msgsize() + 8 + (*z).VoteLast.Msgsize() + 7 + msgp.Uint64Size + 8 + msgp.BoolSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *KeyregTxnFields) MsgIsZero() bool {
	return ((*z).VotePK.MsgIsZero()) && ((*z).SelectionPK.MsgIsZero()) && ((*z).VoteFirst.MsgIsZero()) && ((*z).VoteLast.MsgIsZero()) && ((*z).VoteKeyDilution == 0) && ((*z).Nonparticipation == false)
}

// MarshalMsg implements msgp.Marshaler
func (z *LogicSig) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(4)
	var zb0002Mask uint8 /* 5 bits */
	if len((*z).Args) == 0 {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	if len((*z).Logic) == 0 {
		zb0002Len--
		zb0002Mask |= 0x4
	}
	if (*z).Msig.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x8
	}
	if (*z).Sig.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x10
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "arg"
			o = append(o, 0xa3, 0x61, 0x72, 0x67)
			if (*z).Args == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Args)))
			}
			for zb0001 := range (*z).Args {
				o = msgp.AppendBytes(o, (*z).Args[zb0001])
			}
		}
		if (zb0002Mask & 0x4) == 0 { // if not empty
			// string "l"
			o = append(o, 0xa1, 0x6c)
			o = msgp.AppendBytes(o, (*z).Logic)
		}
		if (zb0002Mask & 0x8) == 0 { // if not empty
			// string "msig"
			o = append(o, 0xa4, 0x6d, 0x73, 0x69, 0x67)
			o, err = (*z).Msig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Msig")
				return
			}
		}
		if (zb0002Mask & 0x10) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o, err = (*z).Sig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sig")
				return
			}
		}
	}
	return
}

func (_ *LogicSig) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*LogicSig)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LogicSig) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Logic, bts, err = msgp.ReadBytesBytes(bts, (*z).Logic)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Logic")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Msig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Msig")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Args")
				return
			}
			if zb0004 > EvalMaxArgs {
				err = msgp.ErrOverflow(uint64(zb0004), uint64(EvalMaxArgs))
				err = msgp.WrapError(err, "struct-from-array", "Args")
				return
			}
			if zb0005 {
				(*z).Args = nil
			} else if (*z).Args != nil && cap((*z).Args) >= zb0004 {
				(*z).Args = ((*z).Args)[:zb0004]
			} else {
				(*z).Args = make([][]byte, zb0004)
			}
			for zb0001 := range (*z).Args {
				(*z).Args[zb0001], bts, err = msgp.ReadBytesBytes(bts, (*z).Args[zb0001])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Args", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = LogicSig{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "l":
				(*z).Logic, bts, err = msgp.ReadBytesBytes(bts, (*z).Logic)
				if err != nil {
					err = msgp.WrapError(err, "Logic")
					return
				}
			case "sig":
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			case "msig":
				bts, err = (*z).Msig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Msig")
					return
				}
			case "arg":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Args")
					return
				}
				if zb0006 > EvalMaxArgs {
					err = msgp.ErrOverflow(uint64(zb0006), uint64(EvalMaxArgs))
					err = msgp.WrapError(err, "Args")
					return
				}
				if zb0007 {
					(*z).Args = nil
				} else if (*z).Args != nil && cap((*z).Args) >= zb0006 {
					(*z).Args = ((*z).Args)[:zb0006]
				} else {
					(*z).Args = make([][]byte, zb0006)
				}
				for zb0001 := range (*z).Args {
					(*z).Args[zb0001], bts, err = msgp.ReadBytesBytes(bts, (*z).Args[zb0001])
					if err != nil {
						err = msgp.WrapError(err, "Args", zb0001)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *LogicSig) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*LogicSig)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *LogicSig) Msgsize() (s int) {
	s = 1 + 2 + msgp.BytesPrefixSize + len((*z).Logic) + 4 + (*z).Sig.Msgsize() + 5 + (*z).Msig.Msgsize() + 4 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Args {
		s += msgp.BytesPrefixSize + len((*z).Args[zb0001])
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *LogicSig) MsgIsZero() bool {
	return (len((*z).Logic) == 0) && ((*z).Sig.MsgIsZero()) && ((*z).Msig.MsgIsZero()) && (len((*z).Args) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z MinFeeError) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

func (_ MinFeeError) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(MinFeeError)
	if !ok {
		_, ok = (z).(*MinFeeError)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MinFeeError) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MinFeeError(zb0001)
	}
	o = bts
	return
}

func (_ *MinFeeError) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*MinFeeError)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MinFeeError) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MsgIsZero returns whether this is a zero value
func (z MinFeeError) MsgIsZero() bool {
	return z == ""
}

// MarshalMsg implements msgp.Marshaler
func (z *PaymentTxnFields) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).Amount.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).CloseRemainderTo.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Receiver.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "amt"
			o = append(o, 0xa3, 0x61, 0x6d, 0x74)
			o, err = (*z).Amount.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Amount")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "close"
			o = append(o, 0xa5, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			o, err = (*z).CloseRemainderTo.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "CloseRemainderTo")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "rcv"
			o = append(o, 0xa3, 0x72, 0x63, 0x76)
			o, err = (*z).Receiver.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Receiver")
				return
			}
		}
	}
	return
}

func (_ *PaymentTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*PaymentTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PaymentTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Receiver.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Amount.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).CloseRemainderTo.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = PaymentTxnFields{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rcv":
				bts, err = (*z).Receiver.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
			case "amt":
				bts, err = (*z).Amount.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Amount")
					return
				}
			case "close":
				bts, err = (*z).CloseRemainderTo.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *PaymentTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*PaymentTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PaymentTxnFields) Msgsize() (s int) {
	s = 1 + 4 + (*z).Receiver.Msgsize() + 4 + (*z).Amount.Msgsize() + 6 + (*z).CloseRemainderTo.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *PaymentTxnFields) MsgIsZero() bool {
	return ((*z).Receiver.MsgIsZero()) && ((*z).Amount.MsgIsZero()) && ((*z).CloseRemainderTo.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z Payset) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	if z == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(z)))
	}
	for za0001 := range z {
		o, err = z[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, za0001)
			return
		}
	}
	return
}

func (_ Payset) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(Payset)
	if !ok {
		_, ok = (z).(*Payset)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Payset) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0002 > 100000 {
		err = msgp.ErrOverflow(uint64(zb0002), uint64(100000))
		err = msgp.WrapError(err)
		return
	}
	if zb0003 {
		(*z) = nil
	} else if (*z) != nil && cap((*z)) >= zb0002 {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(Payset, zb0002)
	}
	for zb0001 := range *z {
		bts, err = (*z)[zb0001].UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

func (_ *Payset) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Payset)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Payset) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for za0001 := range z {
		s += z[za0001].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z Payset) MsgIsZero() bool {
	return len(z) == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *SignedTxn) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 6 bits */
	if (*z).Lsig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Msig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).AuthAddr.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).Txn.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "lsig"
			o = append(o, 0xa4, 0x6c, 0x73, 0x69, 0x67)
			o, err = (*z).Lsig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Lsig")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "msig"
			o = append(o, 0xa4, 0x6d, 0x73, 0x69, 0x67)
			o, err = (*z).Msig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Msig")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "sgnr"
			o = append(o, 0xa4, 0x73, 0x67, 0x6e, 0x72)
			o, err = (*z).AuthAddr.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "AuthAddr")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o, err = (*z).Sig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sig")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o, err = (*z).Txn.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Txn")
				return
			}
		}
	}
	return
}

func (_ *SignedTxn) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedTxn)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SignedTxn) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Msig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Msig")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Lsig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lsig")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Txn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Txn")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).AuthAddr.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = SignedTxn{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "sig":
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			case "msig":
				bts, err = (*z).Msig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Msig")
					return
				}
			case "lsig":
				bts, err = (*z).Lsig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lsig")
					return
				}
			case "txn":
				bts, err = (*z).Txn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Txn")
					return
				}
			case "sgnr":
				bts, err = (*z).AuthAddr.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *SignedTxn) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedTxn)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedTxn) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sig.Msgsize() + 5 + (*z).Msig.Msgsize() + 5 + (*z).Lsig.Msgsize() + 4 + (*z).Txn.Msgsize() + 5 + (*z).AuthAddr.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *SignedTxn) MsgIsZero() bool {
	return ((*z).Sig.MsgIsZero()) && ((*z).Msig.MsgIsZero()) && ((*z).Lsig.MsgIsZero()) && ((*z).Txn.MsgIsZero()) && ((*z).AuthAddr.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *SignedTxnInBlock) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 15 bits */
	if (*z).SignedTxnWithAD.ApplyData.ClosingAmount.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).HasGenesisHash == false {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).HasGenesisID == false {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if (*z).SignedTxnWithAD.SignedTxn.Lsig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if (*z).SignedTxnWithAD.SignedTxn.Msig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if (*z).SignedTxnWithAD.ApplyData.CloseRewards.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if (*z).SignedTxnWithAD.ApplyData.ReceiverRewards.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if (*z).SignedTxnWithAD.ApplyData.SenderRewards.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if (*z).SignedTxnWithAD.SignedTxn.AuthAddr.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if (*z).SignedTxnWithAD.SignedTxn.Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if (*z).SignedTxnWithAD.SignedTxn.Txn.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "ca"
			o = append(o, 0xa2, 0x63, 0x61)
			o, err = (*z).SignedTxnWithAD.ApplyData.ClosingAmount.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "ClosingAmount")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "hgh"
			o = append(o, 0xa3, 0x68, 0x67, 0x68)
			o = msgp.AppendBool(o, (*z).HasGenesisHash)
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "hgi"
			o = append(o, 0xa3, 0x68, 0x67, 0x69)
			o = msgp.AppendBool(o, (*z).HasGenesisID)
		}
		if (zb0001Mask & 0x80) == 0 { // if not empty
			// string "lsig"
			o = append(o, 0xa4, 0x6c, 0x73, 0x69, 0x67)
			o, err = (*z).SignedTxnWithAD.SignedTxn.Lsig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Lsig")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not empty
			// string "msig"
			o = append(o, 0xa4, 0x6d, 0x73, 0x69, 0x67)
			o, err = (*z).SignedTxnWithAD.SignedTxn.Msig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Msig")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not empty
			// string "rc"
			o = append(o, 0xa2, 0x72, 0x63)
			o, err = (*z).SignedTxnWithAD.ApplyData.CloseRewards.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "CloseRewards")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not empty
			// string "rr"
			o = append(o, 0xa2, 0x72, 0x72)
			o, err = (*z).SignedTxnWithAD.ApplyData.ReceiverRewards.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "ReceiverRewards")
				return
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not empty
			// string "rs"
			o = append(o, 0xa2, 0x72, 0x73)
			o, err = (*z).SignedTxnWithAD.ApplyData.SenderRewards.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "SenderRewards")
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not empty
			// string "sgnr"
			o = append(o, 0xa4, 0x73, 0x67, 0x6e, 0x72)
			o, err = (*z).SignedTxnWithAD.SignedTxn.AuthAddr.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "AuthAddr")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o, err = (*z).SignedTxnWithAD.SignedTxn.Sig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sig")
				return
			}
		}
		if (zb0001Mask & 0x4000) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o, err = (*z).SignedTxnWithAD.SignedTxn.Txn.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Txn")
				return
			}
		}
	}
	return
}

func (_ *SignedTxnInBlock) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedTxnInBlock)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SignedTxnInBlock) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxnWithAD.SignedTxn.Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxnWithAD.SignedTxn.Msig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Msig")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxnWithAD.SignedTxn.Lsig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lsig")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxnWithAD.SignedTxn.Txn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Txn")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxnWithAD.SignedTxn.AuthAddr.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxnWithAD.ApplyData.ClosingAmount.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ClosingAmount")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxnWithAD.ApplyData.SenderRewards.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SenderRewards")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxnWithAD.ApplyData.ReceiverRewards.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ReceiverRewards")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxnWithAD.ApplyData.CloseRewards.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRewards")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).HasGenesisID, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "HasGenesisID")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).HasGenesisHash, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "HasGenesisHash")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = SignedTxnInBlock{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "sig":
				bts, err = (*z).SignedTxnWithAD.SignedTxn.Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			case "msig":
				bts, err = (*z).SignedTxnWithAD.SignedTxn.Msig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Msig")
					return
				}
			case "lsig":
				bts, err = (*z).SignedTxnWithAD.SignedTxn.Lsig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lsig")
					return
				}
			case "txn":
				bts, err = (*z).SignedTxnWithAD.SignedTxn.Txn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Txn")
					return
				}
			case "sgnr":
				bts, err = (*z).SignedTxnWithAD.SignedTxn.AuthAddr.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
			case "ca":
				bts, err = (*z).SignedTxnWithAD.ApplyData.ClosingAmount.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ClosingAmount")
					return
				}
			case "rs":
				bts, err = (*z).SignedTxnWithAD.ApplyData.SenderRewards.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SenderRewards")
					return
				}
			case "rr":
				bts, err = (*z).SignedTxnWithAD.ApplyData.ReceiverRewards.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ReceiverRewards")
					return
				}
			case "rc":
				bts, err = (*z).SignedTxnWithAD.ApplyData.CloseRewards.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRewards")
					return
				}
			case "hgi":
				(*z).HasGenesisID, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HasGenesisID")
					return
				}
			case "hgh":
				(*z).HasGenesisHash, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HasGenesisHash")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *SignedTxnInBlock) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedTxnInBlock)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedTxnInBlock) Msgsize() (s int) {
	s = 1 + 4 + (*z).SignedTxnWithAD.SignedTxn.Sig.Msgsize() + 5 + (*z).SignedTxnWithAD.SignedTxn.Msig.Msgsize() + 5 + (*z).SignedTxnWithAD.SignedTxn.Lsig.Msgsize() + 4 + (*z).SignedTxnWithAD.SignedTxn.Txn.Msgsize() + 5 + (*z).SignedTxnWithAD.SignedTxn.AuthAddr.Msgsize() + 3 + (*z).SignedTxnWithAD.ApplyData.ClosingAmount.Msgsize() + 3 + (*z).SignedTxnWithAD.ApplyData.SenderRewards.Msgsize() + 3 + (*z).SignedTxnWithAD.ApplyData.ReceiverRewards.Msgsize() + 3 + (*z).SignedTxnWithAD.ApplyData.CloseRewards.Msgsize() + 4 + msgp.BoolSize + 4 + msgp.BoolSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *SignedTxnInBlock) MsgIsZero() bool {
	return ((*z).SignedTxnWithAD.SignedTxn.Sig.MsgIsZero()) && ((*z).SignedTxnWithAD.SignedTxn.Msig.MsgIsZero()) && ((*z).SignedTxnWithAD.SignedTxn.Lsig.MsgIsZero()) && ((*z).SignedTxnWithAD.SignedTxn.Txn.MsgIsZero()) && ((*z).SignedTxnWithAD.SignedTxn.AuthAddr.MsgIsZero()) && ((*z).SignedTxnWithAD.ApplyData.ClosingAmount.MsgIsZero()) && ((*z).SignedTxnWithAD.ApplyData.SenderRewards.MsgIsZero()) && ((*z).SignedTxnWithAD.ApplyData.ReceiverRewards.MsgIsZero()) && ((*z).SignedTxnWithAD.ApplyData.CloseRewards.MsgIsZero()) && ((*z).HasGenesisID == false) && ((*z).HasGenesisHash == false)
}

// MarshalMsg implements msgp.Marshaler
func (z *SignedTxnWithAD) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(9)
	var zb0001Mask uint16 /* 12 bits */
	if (*z).ApplyData.ClosingAmount.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).SignedTxn.Lsig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).SignedTxn.Msig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).ApplyData.CloseRewards.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if (*z).ApplyData.ReceiverRewards.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if (*z).ApplyData.SenderRewards.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if (*z).SignedTxn.AuthAddr.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if (*z).SignedTxn.Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if (*z).SignedTxn.Txn.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "ca"
			o = append(o, 0xa2, 0x63, 0x61)
			o, err = (*z).ApplyData.ClosingAmount.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "ClosingAmount")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "lsig"
			o = append(o, 0xa4, 0x6c, 0x73, 0x69, 0x67)
			o, err = (*z).SignedTxn.Lsig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Lsig")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "msig"
			o = append(o, 0xa4, 0x6d, 0x73, 0x69, 0x67)
			o, err = (*z).SignedTxn.Msig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Msig")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "rc"
			o = append(o, 0xa2, 0x72, 0x63)
			o, err = (*z).ApplyData.CloseRewards.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "CloseRewards")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not empty
			// string "rr"
			o = append(o, 0xa2, 0x72, 0x72)
			o, err = (*z).ApplyData.ReceiverRewards.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "ReceiverRewards")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not empty
			// string "rs"
			o = append(o, 0xa2, 0x72, 0x73)
			o, err = (*z).ApplyData.SenderRewards.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "SenderRewards")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not empty
			// string "sgnr"
			o = append(o, 0xa4, 0x73, 0x67, 0x6e, 0x72)
			o, err = (*z).SignedTxn.AuthAddr.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "AuthAddr")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o, err = (*z).SignedTxn.Sig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sig")
				return
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o, err = (*z).SignedTxn.Txn.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Txn")
				return
			}
		}
	}
	return
}

func (_ *SignedTxnWithAD) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedTxnWithAD)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SignedTxnWithAD) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxn.Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxn.Msig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Msig")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxn.Lsig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lsig")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxn.Txn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Txn")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).SignedTxn.AuthAddr.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).ApplyData.ClosingAmount.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ClosingAmount")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).ApplyData.SenderRewards.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SenderRewards")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).ApplyData.ReceiverRewards.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ReceiverRewards")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).ApplyData.CloseRewards.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRewards")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = SignedTxnWithAD{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "sig":
				bts, err = (*z).SignedTxn.Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			case "msig":
				bts, err = (*z).SignedTxn.Msig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Msig")
					return
				}
			case "lsig":
				bts, err = (*z).SignedTxn.Lsig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lsig")
					return
				}
			case "txn":
				bts, err = (*z).SignedTxn.Txn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Txn")
					return
				}
			case "sgnr":
				bts, err = (*z).SignedTxn.AuthAddr.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
			case "ca":
				bts, err = (*z).ApplyData.ClosingAmount.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ClosingAmount")
					return
				}
			case "rs":
				bts, err = (*z).ApplyData.SenderRewards.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SenderRewards")
					return
				}
			case "rr":
				bts, err = (*z).ApplyData.ReceiverRewards.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ReceiverRewards")
					return
				}
			case "rc":
				bts, err = (*z).ApplyData.CloseRewards.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRewards")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *SignedTxnWithAD) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedTxnWithAD)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedTxnWithAD) Msgsize() (s int) {
	s = 1 + 4 + (*z).SignedTxn.Sig.Msgsize() + 5 + (*z).SignedTxn.Msig.Msgsize() + 5 + (*z).SignedTxn.Lsig.Msgsize() + 4 + (*z).SignedTxn.Txn.Msgsize() + 5 + (*z).SignedTxn.AuthAddr.Msgsize() + 3 + (*z).ApplyData.ClosingAmount.Msgsize() + 3 + (*z).ApplyData.SenderRewards.Msgsize() + 3 + (*z).ApplyData.ReceiverRewards.Msgsize() + 3 + (*z).ApplyData.CloseRewards.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *SignedTxnWithAD) MsgIsZero() bool {
	return ((*z).SignedTxn.Sig.MsgIsZero()) && ((*z).SignedTxn.Msig.MsgIsZero()) && ((*z).SignedTxn.Lsig.MsgIsZero()) && ((*z).SignedTxn.Txn.MsgIsZero()) && ((*z).SignedTxn.AuthAddr.MsgIsZero()) && ((*z).ApplyData.ClosingAmount.MsgIsZero()) && ((*z).ApplyData.SenderRewards.MsgIsZero()) && ((*z).ApplyData.ReceiverRewards.MsgIsZero()) && ((*z).ApplyData.CloseRewards.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *Transaction) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(30)
	var zb0002Mask uint64 /* 37 bits */
	if (*z).AssetTransferTxnFields.AssetAmount == 0 {
		zb0002Len--
		zb0002Mask |= 0x80
	}
	if (*z).AssetTransferTxnFields.AssetCloseTo.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x100
	}
	if (*z).AssetFreezeTxnFields.AssetFrozen == false {
		zb0002Len--
		zb0002Mask |= 0x200
	}
	if (*z).PaymentTxnFields.Amount.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x400
	}
	if (*z).AssetConfigTxnFields.AssetParams.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x800
	}
	if (*z).AssetTransferTxnFields.AssetReceiver.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x1000
	}
	if (*z).AssetTransferTxnFields.AssetSender.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x2000
	}
	if (*z).AssetConfigTxnFields.ConfigAsset.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x4000
	}
	if (*z).PaymentTxnFields.CloseRemainderTo.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x8000
	}
	if (*z).AssetFreezeTxnFields.FreezeAccount.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x10000
	}
	if (*z).AssetFreezeTxnFields.FreezeAsset.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x20000
	}
	if (*z).Header.Fee.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x40000
	}
	if (*z).Header.FirstValid.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x80000
	}
	if (*z).Header.GenesisID == "" {
		zb0002Len--
		zb0002Mask |= 0x100000
	}
	if (*z).Header.GenesisHash.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x200000
	}
	if (*z).Header.Group.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x400000
	}
	if (*z).Header.LastValid.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x800000
	}
	if (*z).Header.Lease == ([32]byte{}) {
		zb0002Len--
		zb0002Mask |= 0x1000000
	}
	if (*z).KeyregTxnFields.Nonparticipation == false {
		zb0002Len--
		zb0002Mask |= 0x2000000
	}
	if len((*z).Header.Note) == 0 {
		zb0002Len--
		zb0002Mask |= 0x4000000
	}
	if (*z).PaymentTxnFields.Receiver.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x8000000
	}
	if (*z).Header.RekeyTo.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x10000000
	}
	if (*z).KeyregTxnFields.SelectionPK.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x20000000
	}
	if (*z).Header.Sender.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x40000000
	}
	if (*z).Type.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x80000000
	}
	if (*z).KeyregTxnFields.VoteFirst.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x100000000
	}
	if (*z).KeyregTxnFields.VoteKeyDilution == 0 {
		zb0002Len--
		zb0002Mask |= 0x200000000
	}
	if (*z).KeyregTxnFields.VotePK.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x400000000
	}
	if (*z).KeyregTxnFields.VoteLast.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x800000000
	}
	if (*z).AssetTransferTxnFields.XferAsset.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x1000000000
	}
	// variable map header, size zb0002Len
	o = msgp.AppendMapHeader(o, zb0002Len)
	if zb0002Len != 0 {
		if (zb0002Mask & 0x80) == 0 { // if not empty
			// string "aamt"
			o = append(o, 0xa4, 0x61, 0x61, 0x6d, 0x74)
			o = msgp.AppendUint64(o, (*z).AssetTransferTxnFields.AssetAmount)
		}
		if (zb0002Mask & 0x100) == 0 { // if not empty
			// string "aclose"
			o = append(o, 0xa6, 0x61, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			o, err = (*z).AssetTransferTxnFields.AssetCloseTo.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "AssetCloseTo")
				return
			}
		}
		if (zb0002Mask & 0x200) == 0 { // if not empty
			// string "afrz"
			o = append(o, 0xa4, 0x61, 0x66, 0x72, 0x7a)
			o = msgp.AppendBool(o, (*z).AssetFreezeTxnFields.AssetFrozen)
		}
		if (zb0002Mask & 0x400) == 0 { // if not empty
			// string "amt"
			o = append(o, 0xa3, 0x61, 0x6d, 0x74)
			o, err = (*z).PaymentTxnFields.Amount.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Amount")
				return
			}
		}
		if (zb0002Mask & 0x800) == 0 { // if not empty
			// string "apar"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x72)
			o, err = (*z).AssetConfigTxnFields.AssetParams.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "AssetParams")
				return
			}
		}
		if (zb0002Mask & 0x1000) == 0 { // if not empty
			// string "arcv"
			o = append(o, 0xa4, 0x61, 0x72, 0x63, 0x76)
			o, err = (*z).AssetTransferTxnFields.AssetReceiver.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "AssetReceiver")
				return
			}
		}
		if (zb0002Mask & 0x2000) == 0 { // if not empty
			// string "asnd"
			o = append(o, 0xa4, 0x61, 0x73, 0x6e, 0x64)
			o, err = (*z).AssetTransferTxnFields.AssetSender.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "AssetSender")
				return
			}
		}
		if (zb0002Mask & 0x4000) == 0 { // if not empty
			// string "caid"
			o = append(o, 0xa4, 0x63, 0x61, 0x69, 0x64)
			o, err = (*z).AssetConfigTxnFields.ConfigAsset.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "ConfigAsset")
				return
			}
		}
		if (zb0002Mask & 0x8000) == 0 { // if not empty
			// string "close"
			o = append(o, 0xa5, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			o, err = (*z).PaymentTxnFields.CloseRemainderTo.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "CloseRemainderTo")
				return
			}
		}
		if (zb0002Mask & 0x10000) == 0 { // if not empty
			// string "fadd"
			o = append(o, 0xa4, 0x66, 0x61, 0x64, 0x64)
			o, err = (*z).AssetFreezeTxnFields.FreezeAccount.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "FreezeAccount")
				return
			}
		}
		if (zb0002Mask & 0x20000) == 0 { // if not empty
			// string "faid"
			o = append(o, 0xa4, 0x66, 0x61, 0x69, 0x64)
			o, err = (*z).AssetFreezeTxnFields.FreezeAsset.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "FreezeAsset")
				return
			}
		}
		if (zb0002Mask & 0x40000) == 0 { // if not empty
			// string "fee"
			o = append(o, 0xa3, 0x66, 0x65, 0x65)
			o, err = (*z).Header.Fee.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Fee")
				return
			}
		}
		if (zb0002Mask & 0x80000) == 0 { // if not empty
			// string "fv"
			o = append(o, 0xa2, 0x66, 0x76)
			o, err = (*z).Header.FirstValid.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "FirstValid")
				return
			}
		}
		if (zb0002Mask & 0x100000) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).Header.GenesisID)
		}
		if (zb0002Mask & 0x200000) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o, err = (*z).Header.GenesisHash.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "GenesisHash")
				return
			}
		}
		if (zb0002Mask & 0x400000) == 0 { // if not empty
			// string "grp"
			o = append(o, 0xa3, 0x67, 0x72, 0x70)
			o, err = (*z).Header.Group.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		}
		if (zb0002Mask & 0x800000) == 0 { // if not empty
			// string "lv"
			o = append(o, 0xa2, 0x6c, 0x76)
			o, err = (*z).Header.LastValid.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "LastValid")
				return
			}
		}
		if (zb0002Mask & 0x1000000) == 0 { // if not empty
			// string "lx"
			o = append(o, 0xa2, 0x6c, 0x78)
			o = msgp.AppendBytes(o, ((*z).Header.Lease)[:])
		}
		if (zb0002Mask & 0x2000000) == 0 { // if not empty
			// string "nonpart"
			o = append(o, 0xa7, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74)
			o = msgp.AppendBool(o, (*z).KeyregTxnFields.Nonparticipation)
		}
		if (zb0002Mask & 0x4000000) == 0 { // if not empty
			// string "note"
			o = append(o, 0xa4, 0x6e, 0x6f, 0x74, 0x65)
			o = msgp.AppendBytes(o, (*z).Header.Note)
		}
		if (zb0002Mask & 0x8000000) == 0 { // if not empty
			// string "rcv"
			o = append(o, 0xa3, 0x72, 0x63, 0x76)
			o, err = (*z).PaymentTxnFields.Receiver.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Receiver")
				return
			}
		}
		if (zb0002Mask & 0x10000000) == 0 { // if not empty
			// string "rekey"
			o = append(o, 0xa5, 0x72, 0x65, 0x6b, 0x65, 0x79)
			o, err = (*z).Header.RekeyTo.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "RekeyTo")
				return
			}
		}
		if (zb0002Mask & 0x20000000) == 0 { // if not empty
			// string "selkey"
			o = append(o, 0xa6, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79)
			o, err = (*z).KeyregTxnFields.SelectionPK.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "SelectionPK")
				return
			}
		}
		if (zb0002Mask & 0x40000000) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o, err = (*z).Header.Sender.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		}
		if (zb0002Mask & 0x80000000) == 0 { // if not empty
			// string "type"
			o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
			o, err = (*z).Type.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		}
		if (zb0002Mask & 0x100000000) == 0 { // if not empty
			// string "votefst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74)
			o, err = (*z).KeyregTxnFields.VoteFirst.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "VoteFirst")
				return
			}
		}
		if (zb0002Mask & 0x200000000) == 0 { // if not empty
			// string "votekd"
			o = append(o, 0xa6, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64)
			o = msgp.AppendUint64(o, (*z).KeyregTxnFields.VoteKeyDilution)
		}
		if (zb0002Mask & 0x400000000) == 0 { // if not empty
			// string "votekey"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79)
			o, err = (*z).KeyregTxnFields.VotePK.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "VotePK")
				return
			}
		}
		if (zb0002Mask & 0x800000000) == 0 { // if not empty
			// string "votelst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74)
			o, err = (*z).KeyregTxnFields.VoteLast.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "VoteLast")
				return
			}
		}
		if (zb0002Mask & 0x1000000000) == 0 { // if not empty
			// string "xaid"
			o = append(o, 0xa4, 0x78, 0x61, 0x69, 0x64)
			o, err = (*z).AssetTransferTxnFields.XferAsset.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "XferAsset")
				return
			}
		}
	}
	return
}

func (_ *Transaction) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Transaction)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Transaction) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Type.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Type")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Header.Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Header.Fee.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Header.FirstValid.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Header.LastValid.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Header.Note, bts, err = msgp.ReadBytesBytes(bts, (*z).Header.Note)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Header.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Header.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Header.Group.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Group")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = msgp.ReadExactBytes(bts, ((*z).Header.Lease)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Header.RekeyTo.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).KeyregTxnFields.VotePK.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).KeyregTxnFields.SelectionPK.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).KeyregTxnFields.VoteFirst.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).KeyregTxnFields.VoteLast.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).KeyregTxnFields.VoteKeyDilution, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).KeyregTxnFields.Nonparticipation, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Nonparticipation")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).PaymentTxnFields.Receiver.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).PaymentTxnFields.Amount.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).PaymentTxnFields.CloseRemainderTo.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).AssetConfigTxnFields.ConfigAsset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ConfigAsset")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).AssetConfigTxnFields.AssetParams.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetParams")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).AssetTransferTxnFields.XferAsset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "XferAsset")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).AssetTransferTxnFields.AssetAmount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetAmount")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).AssetTransferTxnFields.AssetSender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetSender")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).AssetTransferTxnFields.AssetReceiver.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetReceiver")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).AssetTransferTxnFields.AssetCloseTo.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetCloseTo")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).AssetFreezeTxnFields.FreezeAccount.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAccount")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).AssetFreezeTxnFields.FreezeAsset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAsset")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).AssetFreezeTxnFields.AssetFrozen, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetFrozen")
				return
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = Transaction{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "type":
				bts, err = (*z).Type.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
			case "snd":
				bts, err = (*z).Header.Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "fee":
				bts, err = (*z).Header.Fee.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Fee")
					return
				}
			case "fv":
				bts, err = (*z).Header.FirstValid.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstValid")
					return
				}
			case "lv":
				bts, err = (*z).Header.LastValid.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastValid")
					return
				}
			case "note":
				(*z).Header.Note, bts, err = msgp.ReadBytesBytes(bts, (*z).Header.Note)
				if err != nil {
					err = msgp.WrapError(err, "Note")
					return
				}
			case "gen":
				(*z).Header.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "gh":
				bts, err = (*z).Header.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "grp":
				bts, err = (*z).Header.Group.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Group")
					return
				}
			case "lx":
				bts, err = msgp.ReadExactBytes(bts, ((*z).Header.Lease)[:])
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
			case "rekey":
				bts, err = (*z).Header.RekeyTo.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
			case "votekey":
				bts, err = (*z).KeyregTxnFields.VotePK.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
			case "selkey":
				bts, err = (*z).KeyregTxnFields.SelectionPK.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
			case "votefst":
				bts, err = (*z).KeyregTxnFields.VoteFirst.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
			case "votelst":
				bts, err = (*z).KeyregTxnFields.VoteLast.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteLast")
					return
				}
			case "votekd":
				(*z).KeyregTxnFields.VoteKeyDilution, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
			case "nonpart":
				(*z).KeyregTxnFields.Nonparticipation, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Nonparticipation")
					return
				}
			case "rcv":
				bts, err = (*z).PaymentTxnFields.Receiver.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
			case "amt":
				bts, err = (*z).PaymentTxnFields.Amount.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Amount")
					return
				}
			case "close":
				bts, err = (*z).PaymentTxnFields.CloseRemainderTo.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
			case "caid":
				bts, err = (*z).AssetConfigTxnFields.ConfigAsset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ConfigAsset")
					return
				}
			case "apar":
				bts, err = (*z).AssetConfigTxnFields.AssetParams.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetParams")
					return
				}
			case "xaid":
				bts, err = (*z).AssetTransferTxnFields.XferAsset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "XferAsset")
					return
				}
			case "aamt":
				(*z).AssetTransferTxnFields.AssetAmount, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetAmount")
					return
				}
			case "asnd":
				bts, err = (*z).AssetTransferTxnFields.AssetSender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetSender")
					return
				}
			case "arcv":
				bts, err = (*z).AssetTransferTxnFields.AssetReceiver.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetReceiver")
					return
				}
			case "aclose":
				bts, err = (*z).AssetTransferTxnFields.AssetCloseTo.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetCloseTo")
					return
				}
			case "fadd":
				bts, err = (*z).AssetFreezeTxnFields.FreezeAccount.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAccount")
					return
				}
			case "faid":
				bts, err = (*z).AssetFreezeTxnFields.FreezeAsset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAsset")
					return
				}
			case "afrz":
				(*z).AssetFreezeTxnFields.AssetFrozen, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetFrozen")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *Transaction) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Transaction)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Transaction) Msgsize() (s int) {
	s = 3 + 5 + (*z).Type.Msgsize() + 4 + (*z).Header.Sender.Msgsize() + 4 + (*z).Header.Fee.Msgsize() + 3 + (*z).Header.FirstValid.Msgsize() + 3 + (*z).Header.LastValid.Msgsize() + 5 + msgp.BytesPrefixSize + len((*z).Header.Note) + 4 + msgp.StringPrefixSize + len((*z).Header.GenesisID) + 3 + (*z).Header.GenesisHash.Msgsize() + 4 + (*z).Header.Group.Msgsize() + 3 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 6 + (*z).Header.RekeyTo.Msgsize() + 8 + (*z).KeyregTxnFields.VotePK.Msgsize() + 7 + (*z).KeyregTxnFields.SelectionPK.Msgsize() + 8 + (*z).KeyregTxnFields.VoteFirst.Msgsize() + 8 + (*z).KeyregTxnFields.VoteLast.Msgsize() + 7 + msgp.Uint64Size + 8 + msgp.BoolSize + 4 + (*z).PaymentTxnFields.Receiver.Msgsize() + 4 + (*z).PaymentTxnFields.Amount.Msgsize() + 6 + (*z).PaymentTxnFields.CloseRemainderTo.Msgsize() + 5 + (*z).AssetConfigTxnFields.ConfigAsset.Msgsize() + 5 + (*z).AssetConfigTxnFields.AssetParams.Msgsize() + 5 + (*z).AssetTransferTxnFields.XferAsset.Msgsize() + 5 + msgp.Uint64Size + 5 + (*z).AssetTransferTxnFields.AssetSender.Msgsize() + 5 + (*z).AssetTransferTxnFields.AssetReceiver.Msgsize() + 7 + (*z).AssetTransferTxnFields.AssetCloseTo.Msgsize() + 5 + (*z).AssetFreezeTxnFields.FreezeAccount.Msgsize() + 5 + (*z).AssetFreezeTxnFields.FreezeAsset.Msgsize() + 5 + msgp.BoolSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Transaction) MsgIsZero() bool {
	return ((*z).Type.MsgIsZero()) && ((*z).Header.Sender.MsgIsZero()) && ((*z).Header.Fee.MsgIsZero()) && ((*z).Header.FirstValid.MsgIsZero()) && ((*z).Header.LastValid.MsgIsZero()) && (len((*z).Header.Note) == 0) && ((*z).Header.GenesisID == "") && ((*z).Header.GenesisHash.MsgIsZero()) && ((*z).Header.Group.MsgIsZero()) && ((*z).Header.Lease == ([32]byte{})) && ((*z).Header.RekeyTo.MsgIsZero()) && ((*z).KeyregTxnFields.VotePK.MsgIsZero()) && ((*z).KeyregTxnFields.SelectionPK.MsgIsZero()) && ((*z).KeyregTxnFields.VoteFirst.MsgIsZero()) && ((*z).KeyregTxnFields.VoteLast.MsgIsZero()) && ((*z).KeyregTxnFields.VoteKeyDilution == 0) && ((*z).KeyregTxnFields.Nonparticipation == false) && ((*z).PaymentTxnFields.Receiver.MsgIsZero()) && ((*z).PaymentTxnFields.Amount.MsgIsZero()) && ((*z).PaymentTxnFields.CloseRemainderTo.MsgIsZero()) && ((*z).AssetConfigTxnFields.ConfigAsset.MsgIsZero()) && ((*z).AssetConfigTxnFields.AssetParams.MsgIsZero()) && ((*z).AssetTransferTxnFields.XferAsset.MsgIsZero()) && ((*z).AssetTransferTxnFields.AssetAmount == 0) && ((*z).AssetTransferTxnFields.AssetSender.MsgIsZero()) && ((*z).AssetTransferTxnFields.AssetReceiver.MsgIsZero()) && ((*z).AssetTransferTxnFields.AssetCloseTo.MsgIsZero()) && ((*z).AssetFreezeTxnFields.FreezeAccount.MsgIsZero()) && ((*z).AssetFreezeTxnFields.FreezeAsset.MsgIsZero()) && ((*z).AssetFreezeTxnFields.AssetFrozen == false)
}

// MarshalMsg implements msgp.Marshaler
func (z *TxGroup) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(1)
	var zb0002Mask uint8 /* 2 bits */
	if len((*z).TxGroupHashes) == 0 {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "txlist"
			o = append(o, 0xa6, 0x74, 0x78, 0x6c, 0x69, 0x73, 0x74)
			if (*z).TxGroupHashes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).TxGroupHashes)))
			}
			for zb0001 := range (*z).TxGroupHashes {
				o, err = (*z).TxGroupHashes[zb0001].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "TxGroupHashes", zb0001)
					return
				}
			}
		}
	}
	return
}

func (_ *TxGroup) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*TxGroup)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TxGroup) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxGroupHashes")
				return
			}
			if zb0005 {
				(*z).TxGroupHashes = nil
			} else if (*z).TxGroupHashes != nil && cap((*z).TxGroupHashes) >= zb0004 {
				(*z).TxGroupHashes = ((*z).TxGroupHashes)[:zb0004]
			} else {
				(*z).TxGroupHashes = make([]crypto.Digest, zb0004)
			}
			for zb0001 := range (*z).TxGroupHashes {
				bts, err = (*z).TxGroupHashes[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "TxGroupHashes", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = TxGroup{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "txlist":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxGroupHashes")
					return
				}
				if zb0007 {
					(*z).TxGroupHashes = nil
				} else if (*z).TxGroupHashes != nil && cap((*z).TxGroupHashes) >= zb0006 {
					(*z).TxGroupHashes = ((*z).TxGroupHashes)[:zb0006]
				} else {
					(*z).TxGroupHashes = make([]crypto.Digest, zb0006)
				}
				for zb0001 := range (*z).TxGroupHashes {
					bts, err = (*z).TxGroupHashes[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "TxGroupHashes", zb0001)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *TxGroup) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*TxGroup)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TxGroup) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).TxGroupHashes {
		s += (*z).TxGroupHashes[zb0001].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *TxGroup) MsgIsZero() bool {
	return (len((*z).TxGroupHashes) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *Txid) MarshalMsg(b []byte) ([]byte, error) {
	return ((*(crypto.Digest))(z)).MarshalMsg(b)
}
func (_ *Txid) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Txid)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Txid) UnmarshalMsg(bts []byte) ([]byte, error) {
	return ((*(crypto.Digest))(z)).UnmarshalMsg(bts)
}
func (_ *Txid) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Txid)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Txid) Msgsize() int {
	return ((*(crypto.Digest))(z)).Msgsize()
}

// MsgIsZero returns whether this is a zero value
func (z *Txid) MsgIsZero() bool {
	return ((*(crypto.Digest))(z)).MsgIsZero()
}
