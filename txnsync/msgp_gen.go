package txnsync

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	"sort"

	"github.com/algorand/go-algorand/config"
	"github.com/algorand/go-algorand/crypto"
	"github.com/algorand/go-algorand/crypto/compactcert"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/algorand/go-algorand/data/pooldata"
	"github.com/algorand/go-algorand/data/transactions"
	"github.com/algorand/go-algorand/protocol"
	"github.com/algorand/msgp/msgp"
)

// The following msgp objects are implemented in this file:
// addresses
//     |-----> MarshalMsg
//     |-----> CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> Msgsize
//     |-----> MsgIsZero
//
// appIndices
//      |-----> MarshalMsg
//      |-----> CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> Msgsize
//      |-----> MsgIsZero
//
// applicationArgs
//        |-----> MarshalMsg
//        |-----> CanMarshalMsg
//        |-----> (*) UnmarshalMsg
//        |-----> (*) CanUnmarshalMsg
//        |-----> Msgsize
//        |-----> MsgIsZero
//
// assetIndices
//       |-----> MarshalMsg
//       |-----> CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> Msgsize
//       |-----> MsgIsZero
//
// bitmask
//    |-----> MarshalMsg
//    |-----> CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> Msgsize
//    |-----> MsgIsZero
//
// certProofs
//      |-----> MarshalMsg
//      |-----> CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> Msgsize
//      |-----> MsgIsZero
//
// encodedApplicationCallTxnFields
//                |-----> (*) MarshalMsg
//                |-----> (*) CanMarshalMsg
//                |-----> (*) UnmarshalMsg
//                |-----> (*) CanUnmarshalMsg
//                |-----> (*) Msgsize
//                |-----> (*) MsgIsZero
//
// encodedAssetConfigTxnFields
//              |-----> (*) MarshalMsg
//              |-----> (*) CanMarshalMsg
//              |-----> (*) UnmarshalMsg
//              |-----> (*) CanUnmarshalMsg
//              |-----> (*) Msgsize
//              |-----> (*) MsgIsZero
//
// encodedAssetFreezeTxnFields
//              |-----> (*) MarshalMsg
//              |-----> (*) CanMarshalMsg
//              |-----> (*) UnmarshalMsg
//              |-----> (*) CanUnmarshalMsg
//              |-----> (*) Msgsize
//              |-----> (*) MsgIsZero
//
// encodedAssetParams
//          |-----> (*) MarshalMsg
//          |-----> (*) CanMarshalMsg
//          |-----> (*) UnmarshalMsg
//          |-----> (*) CanUnmarshalMsg
//          |-----> (*) Msgsize
//          |-----> (*) MsgIsZero
//
// encodedAssetTransferTxnFields
//               |-----> (*) MarshalMsg
//               |-----> (*) CanMarshalMsg
//               |-----> (*) UnmarshalMsg
//               |-----> (*) CanUnmarshalMsg
//               |-----> (*) Msgsize
//               |-----> (*) MsgIsZero
//
// encodedBloomFilter
//          |-----> (*) MarshalMsg
//          |-----> (*) CanMarshalMsg
//          |-----> (*) UnmarshalMsg
//          |-----> (*) CanUnmarshalMsg
//          |-----> (*) Msgsize
//          |-----> (*) MsgIsZero
//
// encodedCert
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//
// encodedCompactCertTxnFields
//              |-----> (*) MarshalMsg
//              |-----> (*) CanMarshalMsg
//              |-----> (*) UnmarshalMsg
//              |-----> (*) CanUnmarshalMsg
//              |-----> (*) Msgsize
//              |-----> (*) MsgIsZero
//
// encodedKeyregTxnFields
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// encodedLsigs
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// encodedMsigs
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// encodedPaymentTxnFields
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// encodedSignedTxns
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//
// encodedTxnHeaders
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//
// encodedTxns
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//
// packedTransactionGroups
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// program
//    |-----> MarshalMsg
//    |-----> CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> Msgsize
//    |-----> MsgIsZero
//
// relayedProposal
//        |-----> (*) MarshalMsg
//        |-----> (*) CanMarshalMsg
//        |-----> (*) UnmarshalMsg
//        |-----> (*) CanUnmarshalMsg
//        |-----> (*) Msgsize
//        |-----> (*) MsgIsZero
//
// requestParams
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// revealMap
//     |-----> MarshalMsg
//     |-----> CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> Msgsize
//     |-----> MsgIsZero
//
// timingParams
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// transactionBlockMessage
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// txGroupsEncodingStub
//           |-----> (*) MarshalMsg
//           |-----> (*) CanMarshalMsg
//           |-----> (*) UnmarshalMsg
//           |-----> (*) CanUnmarshalMsg
//           |-----> (*) Msgsize
//           |-----> (*) MsgIsZero
//
// txGroupsEncodingStubOld
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// txnGroups
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//

// MarshalMsg implements msgp.Marshaler
func (z addresses) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	if z == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(z)))
	}
	for za0005 := range z {
		o = z[za0005].MarshalMsg(o)
	}
	return
}

func (_ addresses) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(addresses)
	if !ok {
		_, ok = (z).(*addresses)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *addresses) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0002 > transactions.EncodedMaxAccounts {
		err = msgp.ErrOverflow(uint64(zb0002), uint64(transactions.EncodedMaxAccounts))
		err = msgp.WrapError(err)
		return
	}
	if zb0003 {
		(*z) = nil
	} else if (*z) != nil && cap((*z)) >= zb0002 {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(addresses, zb0002)
	}
	for zb0001 := range *z {
		bts, err = (*z)[zb0001].UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

func (_ *addresses) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*addresses)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z addresses) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for za0005 := range z {
		s += z[za0005].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z addresses) MsgIsZero() bool {
	return len(z) == 0
}

// MarshalMsg implements msgp.Marshaler
func (z appIndices) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	if z == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(z)))
	}
	for za0001 := range z {
		o = z[za0001].MarshalMsg(o)
	}
	return
}

func (_ appIndices) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(appIndices)
	if !ok {
		_, ok = (z).(*appIndices)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *appIndices) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0002 > transactions.EncodedMaxForeignApps {
		err = msgp.ErrOverflow(uint64(zb0002), uint64(transactions.EncodedMaxForeignApps))
		err = msgp.WrapError(err)
		return
	}
	if zb0003 {
		(*z) = nil
	} else if (*z) != nil && cap((*z)) >= zb0002 {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(appIndices, zb0002)
	}
	for zb0001 := range *z {
		bts, err = (*z)[zb0001].UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

func (_ *appIndices) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*appIndices)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z appIndices) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for za0001 := range z {
		s += z[za0001].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z appIndices) MsgIsZero() bool {
	return len(z) == 0
}

// MarshalMsg implements msgp.Marshaler
func (z applicationArgs) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	if z == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(z)))
	}
	for za0001 := range z {
		o = msgp.AppendBytes(o, z[za0001])
	}
	return
}

func (_ applicationArgs) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(applicationArgs)
	if !ok {
		_, ok = (z).(*applicationArgs)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *applicationArgs) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0002 > transactions.EncodedMaxApplicationArgs {
		err = msgp.ErrOverflow(uint64(zb0002), uint64(transactions.EncodedMaxApplicationArgs))
		err = msgp.WrapError(err)
		return
	}
	if zb0003 {
		(*z) = nil
	} else if (*z) != nil && cap((*z)) >= zb0002 {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(applicationArgs, zb0002)
	}
	for zb0001 := range *z {
		(*z)[zb0001], bts, err = msgp.ReadBytesBytes(bts, (*z)[zb0001])
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

func (_ *applicationArgs) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*applicationArgs)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z applicationArgs) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for za0001 := range z {
		s += msgp.BytesPrefixSize + len(z[za0001])
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z applicationArgs) MsgIsZero() bool {
	return len(z) == 0
}

// MarshalMsg implements msgp.Marshaler
func (z assetIndices) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	if z == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(z)))
	}
	for za0001 := range z {
		o = z[za0001].MarshalMsg(o)
	}
	return
}

func (_ assetIndices) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(assetIndices)
	if !ok {
		_, ok = (z).(*assetIndices)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *assetIndices) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0002 > transactions.EncodedMaxForeignAssets {
		err = msgp.ErrOverflow(uint64(zb0002), uint64(transactions.EncodedMaxForeignAssets))
		err = msgp.WrapError(err)
		return
	}
	if zb0003 {
		(*z) = nil
	} else if (*z) != nil && cap((*z)) >= zb0002 {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(assetIndices, zb0002)
	}
	for zb0001 := range *z {
		bts, err = (*z)[zb0001].UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

func (_ *assetIndices) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*assetIndices)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z assetIndices) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for za0001 := range z {
		s += z[za0001].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z assetIndices) MsgIsZero() bool {
	return len(z) == 0
}

// MarshalMsg implements msgp.Marshaler
func (z bitmask) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, []byte(z))
	return
}

func (_ bitmask) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(bitmask)
	if !ok {
		_, ok = (z).(*bitmask)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *bitmask) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 []byte
		var zb0002 int
		zb0002, err = msgp.ReadBytesBytesHeader(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > maxBitmaskSize {
			err = msgp.ErrOverflow(uint64(zb0002), uint64(maxBitmaskSize))
			return
		}
		zb0001, bts, err = msgp.ReadBytesBytes(bts, []byte((*z)))
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = bitmask(zb0001)
	}
	o = bts
	return
}

func (_ *bitmask) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*bitmask)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z bitmask) Msgsize() (s int) {
	s = msgp.BytesPrefixSize + len([]byte(z))
	return
}

// MsgIsZero returns whether this is a zero value
func (z bitmask) MsgIsZero() bool {
	return len(z) == 0
}

// MarshalMsg implements msgp.Marshaler
func (z certProofs) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	if z == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(z)))
	}
	for za0001 := range z {
		o = z[za0001].MarshalMsg(o)
	}
	return
}

func (_ certProofs) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(certProofs)
	if !ok {
		_, ok = (z).(*certProofs)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *certProofs) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0002 > compactcert.MaxProofDigests {
		err = msgp.ErrOverflow(uint64(zb0002), uint64(compactcert.MaxProofDigests))
		err = msgp.WrapError(err)
		return
	}
	if zb0003 {
		(*z) = nil
	} else if (*z) != nil && cap((*z)) >= zb0002 {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(certProofs, zb0002)
	}
	for zb0001 := range *z {
		bts, err = (*z)[zb0001].UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

func (_ *certProofs) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*certProofs)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z certProofs) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for za0001 := range z {
		s += z[za0001].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z certProofs) MsgIsZero() bool {
	return len(z) == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedApplicationCallTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0017Len := uint32(26)
	var zb0017Mask uint32 /* 27 bits */
	if len((*z).ApplicationArgs) == 0 {
		zb0017Len--
		zb0017Mask |= 0x2
	}
	if len((*z).BitmaskApplicationArgs) == 0 {
		zb0017Len--
		zb0017Mask |= 0x4
	}
	if len((*z).OnCompletion) == 0 {
		zb0017Len--
		zb0017Mask |= 0x8
	}
	if len((*z).BitmaskOnCompletion) == 0 {
		zb0017Len--
		zb0017Mask |= 0x10
	}
	if len((*z).ApprovalProgram) == 0 {
		zb0017Len--
		zb0017Mask |= 0x20
	}
	if len((*z).BitmaskApprovalProgram) == 0 {
		zb0017Len--
		zb0017Mask |= 0x40
	}
	if len((*z).ForeignAssets) == 0 {
		zb0017Len--
		zb0017Mask |= 0x80
	}
	if len((*z).BitmaskForeignAssets) == 0 {
		zb0017Len--
		zb0017Mask |= 0x100
	}
	if len((*z).Accounts) == 0 {
		zb0017Len--
		zb0017Mask |= 0x200
	}
	if len((*z).BitmaskAccounts) == 0 {
		zb0017Len--
		zb0017Mask |= 0x400
	}
	if len((*z).ExtraProgramPages) == 0 {
		zb0017Len--
		zb0017Mask |= 0x800
	}
	if len((*z).BitmaskExtraProgramPages) == 0 {
		zb0017Len--
		zb0017Mask |= 0x1000
	}
	if len((*z).ForeignApps) == 0 {
		zb0017Len--
		zb0017Mask |= 0x2000
	}
	if len((*z).BitmaskForeignApps) == 0 {
		zb0017Len--
		zb0017Mask |= 0x4000
	}
	if len((*z).ApplicationID) == 0 {
		zb0017Len--
		zb0017Mask |= 0x8000
	}
	if len((*z).BitmaskApplicationID) == 0 {
		zb0017Len--
		zb0017Mask |= 0x10000
	}
	if len((*z).ClearStateProgram) == 0 {
		zb0017Len--
		zb0017Mask |= 0x20000
	}
	if len((*z).BitmaskClearStateProgram) == 0 {
		zb0017Len--
		zb0017Mask |= 0x40000
	}
	if len((*z).GlobalNumByteSlice) == 0 {
		zb0017Len--
		zb0017Mask |= 0x80000
	}
	if len((*z).BitmaskGlobalNumByteSlice) == 0 {
		zb0017Len--
		zb0017Mask |= 0x100000
	}
	if len((*z).GlobalNumUint) == 0 {
		zb0017Len--
		zb0017Mask |= 0x200000
	}
	if len((*z).BitmaskGlobalNumUint) == 0 {
		zb0017Len--
		zb0017Mask |= 0x400000
	}
	if len((*z).LocalNumByteSlice) == 0 {
		zb0017Len--
		zb0017Mask |= 0x800000
	}
	if len((*z).BitmaskLocalNumByteSlice) == 0 {
		zb0017Len--
		zb0017Mask |= 0x1000000
	}
	if len((*z).LocalNumUint) == 0 {
		zb0017Len--
		zb0017Mask |= 0x2000000
	}
	if len((*z).BitmaskLocalNumUint) == 0 {
		zb0017Len--
		zb0017Mask |= 0x4000000
	}
	// variable map header, size zb0017Len
	o = msgp.AppendMapHeader(o, zb0017Len)
	if zb0017Len != 0 {
		if (zb0017Mask & 0x2) == 0 { // if not empty
			// string "apaa"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x61)
			if (*z).ApplicationArgs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).ApplicationArgs)))
			}
			for zb0002 := range (*z).ApplicationArgs {
				if (*z).ApplicationArgs[zb0002] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).ApplicationArgs[zb0002])))
				}
				for zb0003 := range (*z).ApplicationArgs[zb0002] {
					o = msgp.AppendBytes(o, (*z).ApplicationArgs[zb0002][zb0003])
				}
			}
		}
		if (zb0017Mask & 0x4) == 0 { // if not empty
			// string "apaabm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x61, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskApplicationArgs))
		}
		if (zb0017Mask & 0x8) == 0 { // if not empty
			// string "apan"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x6e)
			o = msgp.AppendBytes(o, (*z).OnCompletion)
		}
		if (zb0017Mask & 0x10) == 0 { // if not empty
			// string "apanbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskOnCompletion))
		}
		if (zb0017Mask & 0x20) == 0 { // if not empty
			// string "apap"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x70)
			if (*z).ApprovalProgram == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).ApprovalProgram)))
			}
			for zb0014 := range (*z).ApprovalProgram {
				o = msgp.AppendBytes(o, []byte((*z).ApprovalProgram[zb0014]))
			}
		}
		if (zb0017Mask & 0x40) == 0 { // if not empty
			// string "apapbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x70, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskApprovalProgram))
		}
		if (zb0017Mask & 0x80) == 0 { // if not empty
			// string "apas"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x73)
			if (*z).ForeignAssets == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).ForeignAssets)))
			}
			for zb0008 := range (*z).ForeignAssets {
				if (*z).ForeignAssets[zb0008] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).ForeignAssets[zb0008])))
				}
				for zb0009 := range (*z).ForeignAssets[zb0008] {
					o = (*z).ForeignAssets[zb0008][zb0009].MarshalMsg(o)
				}
			}
		}
		if (zb0017Mask & 0x100) == 0 { // if not empty
			// string "apasbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskForeignAssets))
		}
		if (zb0017Mask & 0x200) == 0 { // if not empty
			// string "apat"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x74)
			if (*z).Accounts == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Accounts)))
			}
			for zb0004 := range (*z).Accounts {
				if (*z).Accounts[zb0004] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).Accounts[zb0004])))
				}
				for zb0005 := range (*z).Accounts[zb0004] {
					o = (*z).Accounts[zb0004][zb0005].MarshalMsg(o)
				}
			}
		}
		if (zb0017Mask & 0x400) == 0 { // if not empty
			// string "apatbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskAccounts))
		}
		if (zb0017Mask & 0x800) == 0 { // if not empty
			// string "apep"
			o = append(o, 0xa4, 0x61, 0x70, 0x65, 0x70)
			if (*z).ExtraProgramPages == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).ExtraProgramPages)))
			}
			for zb0016 := range (*z).ExtraProgramPages {
				o = msgp.AppendUint32(o, (*z).ExtraProgramPages[zb0016])
			}
		}
		if (zb0017Mask & 0x1000) == 0 { // if not empty
			// string "apepbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x65, 0x70, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskExtraProgramPages))
		}
		if (zb0017Mask & 0x2000) == 0 { // if not empty
			// string "apfa"
			o = append(o, 0xa4, 0x61, 0x70, 0x66, 0x61)
			if (*z).ForeignApps == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).ForeignApps)))
			}
			for zb0006 := range (*z).ForeignApps {
				if (*z).ForeignApps[zb0006] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).ForeignApps[zb0006])))
				}
				for zb0007 := range (*z).ForeignApps[zb0006] {
					o = (*z).ForeignApps[zb0006][zb0007].MarshalMsg(o)
				}
			}
		}
		if (zb0017Mask & 0x4000) == 0 { // if not empty
			// string "apfabm"
			o = append(o, 0xa6, 0x61, 0x70, 0x66, 0x61, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskForeignApps))
		}
		if (zb0017Mask & 0x8000) == 0 { // if not empty
			// string "apid"
			o = append(o, 0xa4, 0x61, 0x70, 0x69, 0x64)
			if (*z).ApplicationID == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).ApplicationID)))
			}
			for zb0001 := range (*z).ApplicationID {
				o = (*z).ApplicationID[zb0001].MarshalMsg(o)
			}
		}
		if (zb0017Mask & 0x10000) == 0 { // if not empty
			// string "apidbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskApplicationID))
		}
		if (zb0017Mask & 0x20000) == 0 { // if not empty
			// string "apsu"
			o = append(o, 0xa4, 0x61, 0x70, 0x73, 0x75)
			if (*z).ClearStateProgram == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).ClearStateProgram)))
			}
			for zb0015 := range (*z).ClearStateProgram {
				o = msgp.AppendBytes(o, []byte((*z).ClearStateProgram[zb0015]))
			}
		}
		if (zb0017Mask & 0x40000) == 0 { // if not empty
			// string "apsubm"
			o = append(o, 0xa6, 0x61, 0x70, 0x73, 0x75, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskClearStateProgram))
		}
		if (zb0017Mask & 0x80000) == 0 { // if not empty
			// string "gnbs"
			o = append(o, 0xa4, 0x67, 0x6e, 0x62, 0x73)
			if (*z).GlobalNumByteSlice == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).GlobalNumByteSlice)))
			}
			for zb0013 := range (*z).GlobalNumByteSlice {
				o = msgp.AppendUint64(o, (*z).GlobalNumByteSlice[zb0013])
			}
		}
		if (zb0017Mask & 0x100000) == 0 { // if not empty
			// string "gnbsbm"
			o = append(o, 0xa6, 0x67, 0x6e, 0x62, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskGlobalNumByteSlice))
		}
		if (zb0017Mask & 0x200000) == 0 { // if not empty
			// string "gnui"
			o = append(o, 0xa4, 0x67, 0x6e, 0x75, 0x69)
			if (*z).GlobalNumUint == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).GlobalNumUint)))
			}
			for zb0012 := range (*z).GlobalNumUint {
				o = msgp.AppendUint64(o, (*z).GlobalNumUint[zb0012])
			}
		}
		if (zb0017Mask & 0x400000) == 0 { // if not empty
			// string "gnuibm"
			o = append(o, 0xa6, 0x67, 0x6e, 0x75, 0x69, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskGlobalNumUint))
		}
		if (zb0017Mask & 0x800000) == 0 { // if not empty
			// string "lnbs"
			o = append(o, 0xa4, 0x6c, 0x6e, 0x62, 0x73)
			if (*z).LocalNumByteSlice == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).LocalNumByteSlice)))
			}
			for zb0011 := range (*z).LocalNumByteSlice {
				o = msgp.AppendUint64(o, (*z).LocalNumByteSlice[zb0011])
			}
		}
		if (zb0017Mask & 0x1000000) == 0 { // if not empty
			// string "lnbsbm"
			o = append(o, 0xa6, 0x6c, 0x6e, 0x62, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskLocalNumByteSlice))
		}
		if (zb0017Mask & 0x2000000) == 0 { // if not empty
			// string "lnui"
			o = append(o, 0xa4, 0x6c, 0x6e, 0x75, 0x69)
			if (*z).LocalNumUint == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).LocalNumUint)))
			}
			for zb0010 := range (*z).LocalNumUint {
				o = msgp.AppendUint64(o, (*z).LocalNumUint[zb0010])
			}
		}
		if (zb0017Mask & 0x4000000) == 0 { // if not empty
			// string "lnuibm"
			o = append(o, 0xa6, 0x6c, 0x6e, 0x75, 0x69, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskLocalNumUint))
		}
	}
	return
}

func (_ *encodedApplicationCallTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedApplicationCallTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedApplicationCallTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0017 int
	var zb0018 bool
	zb0017, zb0018, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0017, zb0018, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0017 > 0 {
			zb0017--
			var zb0019 int
			var zb0020 bool
			zb0019, zb0020, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ApplicationID")
				return
			}
			if zb0019 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0019), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ApplicationID")
				return
			}
			if zb0020 {
				(*z).ApplicationID = nil
			} else if (*z).ApplicationID != nil && cap((*z).ApplicationID) >= zb0019 {
				(*z).ApplicationID = ((*z).ApplicationID)[:zb0019]
			} else {
				(*z).ApplicationID = make([]basics.AppIndex, zb0019)
			}
			for zb0001 := range (*z).ApplicationID {
				bts, err = (*z).ApplicationID[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ApplicationID", zb0001)
					return
				}
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0021 []byte
				var zb0022 int
				zb0022, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationID")
					return
				}
				if zb0022 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0022), uint64(maxBitmaskSize))
					return
				}
				zb0021, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskApplicationID))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationID")
					return
				}
				(*z).BitmaskApplicationID = bitmask(zb0021)
			}
		}
		if zb0017 > 0 {
			zb0017--
			var zb0023 int
			zb0023, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OnCompletion")
				return
			}
			if zb0023 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0023), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).OnCompletion, bts, err = msgp.ReadBytesBytes(bts, (*z).OnCompletion)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OnCompletion")
				return
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0024 []byte
				var zb0025 int
				zb0025, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskOnCompletion")
					return
				}
				if zb0025 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0025), uint64(maxBitmaskSize))
					return
				}
				zb0024, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskOnCompletion))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskOnCompletion")
					return
				}
				(*z).BitmaskOnCompletion = bitmask(zb0024)
			}
		}
		if zb0017 > 0 {
			zb0017--
			var zb0026 int
			var zb0027 bool
			zb0026, zb0027, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs")
				return
			}
			if zb0026 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0026), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs")
				return
			}
			if zb0027 {
				(*z).ApplicationArgs = nil
			} else if (*z).ApplicationArgs != nil && cap((*z).ApplicationArgs) >= zb0026 {
				(*z).ApplicationArgs = ((*z).ApplicationArgs)[:zb0026]
			} else {
				(*z).ApplicationArgs = make([]applicationArgs, zb0026)
			}
			for zb0002 := range (*z).ApplicationArgs {
				var zb0028 int
				var zb0029 bool
				zb0028, zb0029, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs", zb0002)
					return
				}
				if zb0028 > transactions.EncodedMaxApplicationArgs {
					err = msgp.ErrOverflow(uint64(zb0028), uint64(transactions.EncodedMaxApplicationArgs))
					err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs", zb0002)
					return
				}
				if zb0029 {
					(*z).ApplicationArgs[zb0002] = nil
				} else if (*z).ApplicationArgs[zb0002] != nil && cap((*z).ApplicationArgs[zb0002]) >= zb0028 {
					(*z).ApplicationArgs[zb0002] = ((*z).ApplicationArgs[zb0002])[:zb0028]
				} else {
					(*z).ApplicationArgs[zb0002] = make(applicationArgs, zb0028)
				}
				for zb0003 := range (*z).ApplicationArgs[zb0002] {
					(*z).ApplicationArgs[zb0002][zb0003], bts, err = msgp.ReadBytesBytes(bts, (*z).ApplicationArgs[zb0002][zb0003])
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs", zb0002, zb0003)
						return
					}
				}
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0030 []byte
				var zb0031 int
				zb0031, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationArgs")
					return
				}
				if zb0031 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0031), uint64(maxBitmaskSize))
					return
				}
				zb0030, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskApplicationArgs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationArgs")
					return
				}
				(*z).BitmaskApplicationArgs = bitmask(zb0030)
			}
		}
		if zb0017 > 0 {
			zb0017--
			var zb0032 int
			var zb0033 bool
			zb0032, zb0033, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Accounts")
				return
			}
			if zb0032 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0032), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Accounts")
				return
			}
			if zb0033 {
				(*z).Accounts = nil
			} else if (*z).Accounts != nil && cap((*z).Accounts) >= zb0032 {
				(*z).Accounts = ((*z).Accounts)[:zb0032]
			} else {
				(*z).Accounts = make([]addresses, zb0032)
			}
			for zb0004 := range (*z).Accounts {
				var zb0034 int
				var zb0035 bool
				zb0034, zb0035, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Accounts", zb0004)
					return
				}
				if zb0034 > transactions.EncodedMaxAccounts {
					err = msgp.ErrOverflow(uint64(zb0034), uint64(transactions.EncodedMaxAccounts))
					err = msgp.WrapError(err, "struct-from-array", "Accounts", zb0004)
					return
				}
				if zb0035 {
					(*z).Accounts[zb0004] = nil
				} else if (*z).Accounts[zb0004] != nil && cap((*z).Accounts[zb0004]) >= zb0034 {
					(*z).Accounts[zb0004] = ((*z).Accounts[zb0004])[:zb0034]
				} else {
					(*z).Accounts[zb0004] = make(addresses, zb0034)
				}
				for zb0005 := range (*z).Accounts[zb0004] {
					bts, err = (*z).Accounts[zb0004][zb0005].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Accounts", zb0004, zb0005)
						return
					}
				}
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0036 []byte
				var zb0037 int
				zb0037, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAccounts")
					return
				}
				if zb0037 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0037), uint64(maxBitmaskSize))
					return
				}
				zb0036, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAccounts))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAccounts")
					return
				}
				(*z).BitmaskAccounts = bitmask(zb0036)
			}
		}
		if zb0017 > 0 {
			zb0017--
			var zb0038 int
			var zb0039 bool
			zb0038, zb0039, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ForeignApps")
				return
			}
			if zb0038 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0038), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ForeignApps")
				return
			}
			if zb0039 {
				(*z).ForeignApps = nil
			} else if (*z).ForeignApps != nil && cap((*z).ForeignApps) >= zb0038 {
				(*z).ForeignApps = ((*z).ForeignApps)[:zb0038]
			} else {
				(*z).ForeignApps = make([]appIndices, zb0038)
			}
			for zb0006 := range (*z).ForeignApps {
				var zb0040 int
				var zb0041 bool
				zb0040, zb0041, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ForeignApps", zb0006)
					return
				}
				if zb0040 > transactions.EncodedMaxForeignApps {
					err = msgp.ErrOverflow(uint64(zb0040), uint64(transactions.EncodedMaxForeignApps))
					err = msgp.WrapError(err, "struct-from-array", "ForeignApps", zb0006)
					return
				}
				if zb0041 {
					(*z).ForeignApps[zb0006] = nil
				} else if (*z).ForeignApps[zb0006] != nil && cap((*z).ForeignApps[zb0006]) >= zb0040 {
					(*z).ForeignApps[zb0006] = ((*z).ForeignApps[zb0006])[:zb0040]
				} else {
					(*z).ForeignApps[zb0006] = make(appIndices, zb0040)
				}
				for zb0007 := range (*z).ForeignApps[zb0006] {
					bts, err = (*z).ForeignApps[zb0006][zb0007].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ForeignApps", zb0006, zb0007)
						return
					}
				}
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0042 []byte
				var zb0043 int
				zb0043, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignApps")
					return
				}
				if zb0043 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0043), uint64(maxBitmaskSize))
					return
				}
				zb0042, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskForeignApps))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignApps")
					return
				}
				(*z).BitmaskForeignApps = bitmask(zb0042)
			}
		}
		if zb0017 > 0 {
			zb0017--
			var zb0044 int
			var zb0045 bool
			zb0044, zb0045, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ForeignAssets")
				return
			}
			if zb0044 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0044), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ForeignAssets")
				return
			}
			if zb0045 {
				(*z).ForeignAssets = nil
			} else if (*z).ForeignAssets != nil && cap((*z).ForeignAssets) >= zb0044 {
				(*z).ForeignAssets = ((*z).ForeignAssets)[:zb0044]
			} else {
				(*z).ForeignAssets = make([]assetIndices, zb0044)
			}
			for zb0008 := range (*z).ForeignAssets {
				var zb0046 int
				var zb0047 bool
				zb0046, zb0047, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ForeignAssets", zb0008)
					return
				}
				if zb0046 > transactions.EncodedMaxForeignAssets {
					err = msgp.ErrOverflow(uint64(zb0046), uint64(transactions.EncodedMaxForeignAssets))
					err = msgp.WrapError(err, "struct-from-array", "ForeignAssets", zb0008)
					return
				}
				if zb0047 {
					(*z).ForeignAssets[zb0008] = nil
				} else if (*z).ForeignAssets[zb0008] != nil && cap((*z).ForeignAssets[zb0008]) >= zb0046 {
					(*z).ForeignAssets[zb0008] = ((*z).ForeignAssets[zb0008])[:zb0046]
				} else {
					(*z).ForeignAssets[zb0008] = make(assetIndices, zb0046)
				}
				for zb0009 := range (*z).ForeignAssets[zb0008] {
					bts, err = (*z).ForeignAssets[zb0008][zb0009].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ForeignAssets", zb0008, zb0009)
						return
					}
				}
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0048 []byte
				var zb0049 int
				zb0049, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignAssets")
					return
				}
				if zb0049 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0049), uint64(maxBitmaskSize))
					return
				}
				zb0048, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskForeignAssets))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignAssets")
					return
				}
				(*z).BitmaskForeignAssets = bitmask(zb0048)
			}
		}
		if zb0017 > 0 {
			zb0017--
			var zb0050 int
			var zb0051 bool
			zb0050, zb0051, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LocalNumUint")
				return
			}
			if zb0050 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0050), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LocalNumUint")
				return
			}
			if zb0051 {
				(*z).LocalNumUint = nil
			} else if (*z).LocalNumUint != nil && cap((*z).LocalNumUint) >= zb0050 {
				(*z).LocalNumUint = ((*z).LocalNumUint)[:zb0050]
			} else {
				(*z).LocalNumUint = make([]uint64, zb0050)
			}
			for zb0010 := range (*z).LocalNumUint {
				(*z).LocalNumUint[zb0010], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LocalNumUint", zb0010)
					return
				}
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0052 []byte
				var zb0053 int
				zb0053, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumUint")
					return
				}
				if zb0053 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0053), uint64(maxBitmaskSize))
					return
				}
				zb0052, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLocalNumUint))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumUint")
					return
				}
				(*z).BitmaskLocalNumUint = bitmask(zb0052)
			}
		}
		if zb0017 > 0 {
			zb0017--
			var zb0054 int
			var zb0055 bool
			zb0054, zb0055, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LocalNumByteSlice")
				return
			}
			if zb0054 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0054), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LocalNumByteSlice")
				return
			}
			if zb0055 {
				(*z).LocalNumByteSlice = nil
			} else if (*z).LocalNumByteSlice != nil && cap((*z).LocalNumByteSlice) >= zb0054 {
				(*z).LocalNumByteSlice = ((*z).LocalNumByteSlice)[:zb0054]
			} else {
				(*z).LocalNumByteSlice = make([]uint64, zb0054)
			}
			for zb0011 := range (*z).LocalNumByteSlice {
				(*z).LocalNumByteSlice[zb0011], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LocalNumByteSlice", zb0011)
					return
				}
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0056 []byte
				var zb0057 int
				zb0057, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumByteSlice")
					return
				}
				if zb0057 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0057), uint64(maxBitmaskSize))
					return
				}
				zb0056, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLocalNumByteSlice))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumByteSlice")
					return
				}
				(*z).BitmaskLocalNumByteSlice = bitmask(zb0056)
			}
		}
		if zb0017 > 0 {
			zb0017--
			var zb0058 int
			var zb0059 bool
			zb0058, zb0059, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumUint")
				return
			}
			if zb0058 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0058), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumUint")
				return
			}
			if zb0059 {
				(*z).GlobalNumUint = nil
			} else if (*z).GlobalNumUint != nil && cap((*z).GlobalNumUint) >= zb0058 {
				(*z).GlobalNumUint = ((*z).GlobalNumUint)[:zb0058]
			} else {
				(*z).GlobalNumUint = make([]uint64, zb0058)
			}
			for zb0012 := range (*z).GlobalNumUint {
				(*z).GlobalNumUint[zb0012], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "GlobalNumUint", zb0012)
					return
				}
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0060 []byte
				var zb0061 int
				zb0061, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumUint")
					return
				}
				if zb0061 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0061), uint64(maxBitmaskSize))
					return
				}
				zb0060, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskGlobalNumUint))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumUint")
					return
				}
				(*z).BitmaskGlobalNumUint = bitmask(zb0060)
			}
		}
		if zb0017 > 0 {
			zb0017--
			var zb0062 int
			var zb0063 bool
			zb0062, zb0063, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumByteSlice")
				return
			}
			if zb0062 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0062), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumByteSlice")
				return
			}
			if zb0063 {
				(*z).GlobalNumByteSlice = nil
			} else if (*z).GlobalNumByteSlice != nil && cap((*z).GlobalNumByteSlice) >= zb0062 {
				(*z).GlobalNumByteSlice = ((*z).GlobalNumByteSlice)[:zb0062]
			} else {
				(*z).GlobalNumByteSlice = make([]uint64, zb0062)
			}
			for zb0013 := range (*z).GlobalNumByteSlice {
				(*z).GlobalNumByteSlice[zb0013], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "GlobalNumByteSlice", zb0013)
					return
				}
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0064 []byte
				var zb0065 int
				zb0065, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumByteSlice")
					return
				}
				if zb0065 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0065), uint64(maxBitmaskSize))
					return
				}
				zb0064, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskGlobalNumByteSlice))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumByteSlice")
					return
				}
				(*z).BitmaskGlobalNumByteSlice = bitmask(zb0064)
			}
		}
		if zb0017 > 0 {
			zb0017--
			var zb0066 int
			var zb0067 bool
			zb0066, zb0067, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram")
				return
			}
			if zb0066 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0066), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram")
				return
			}
			if zb0067 {
				(*z).ApprovalProgram = nil
			} else if (*z).ApprovalProgram != nil && cap((*z).ApprovalProgram) >= zb0066 {
				(*z).ApprovalProgram = ((*z).ApprovalProgram)[:zb0066]
			} else {
				(*z).ApprovalProgram = make([]program, zb0066)
			}
			for zb0014 := range (*z).ApprovalProgram {
				{
					var zb0068 []byte
					var zb0069 int
					zb0069, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram", zb0014)
						return
					}
					if zb0069 > config.MaxAvailableAppProgramLen {
						err = msgp.ErrOverflow(uint64(zb0069), uint64(config.MaxAvailableAppProgramLen))
						return
					}
					zb0068, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).ApprovalProgram[zb0014]))
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram", zb0014)
						return
					}
					(*z).ApprovalProgram[zb0014] = program(zb0068)
				}
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0070 []byte
				var zb0071 int
				zb0071, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApprovalProgram")
					return
				}
				if zb0071 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0071), uint64(maxBitmaskSize))
					return
				}
				zb0070, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskApprovalProgram))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApprovalProgram")
					return
				}
				(*z).BitmaskApprovalProgram = bitmask(zb0070)
			}
		}
		if zb0017 > 0 {
			zb0017--
			var zb0072 int
			var zb0073 bool
			zb0072, zb0073, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram")
				return
			}
			if zb0072 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0072), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram")
				return
			}
			if zb0073 {
				(*z).ClearStateProgram = nil
			} else if (*z).ClearStateProgram != nil && cap((*z).ClearStateProgram) >= zb0072 {
				(*z).ClearStateProgram = ((*z).ClearStateProgram)[:zb0072]
			} else {
				(*z).ClearStateProgram = make([]program, zb0072)
			}
			for zb0015 := range (*z).ClearStateProgram {
				{
					var zb0074 []byte
					var zb0075 int
					zb0075, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram", zb0015)
						return
					}
					if zb0075 > config.MaxAvailableAppProgramLen {
						err = msgp.ErrOverflow(uint64(zb0075), uint64(config.MaxAvailableAppProgramLen))
						return
					}
					zb0074, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).ClearStateProgram[zb0015]))
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram", zb0015)
						return
					}
					(*z).ClearStateProgram[zb0015] = program(zb0074)
				}
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0076 []byte
				var zb0077 int
				zb0077, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClearStateProgram")
					return
				}
				if zb0077 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0077), uint64(maxBitmaskSize))
					return
				}
				zb0076, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskClearStateProgram))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClearStateProgram")
					return
				}
				(*z).BitmaskClearStateProgram = bitmask(zb0076)
			}
		}
		if zb0017 > 0 {
			zb0017--
			var zb0078 int
			var zb0079 bool
			zb0078, zb0079, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ExtraProgramPages")
				return
			}
			if zb0078 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0078), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ExtraProgramPages")
				return
			}
			if zb0079 {
				(*z).ExtraProgramPages = nil
			} else if (*z).ExtraProgramPages != nil && cap((*z).ExtraProgramPages) >= zb0078 {
				(*z).ExtraProgramPages = ((*z).ExtraProgramPages)[:zb0078]
			} else {
				(*z).ExtraProgramPages = make([]uint32, zb0078)
			}
			for zb0016 := range (*z).ExtraProgramPages {
				(*z).ExtraProgramPages[zb0016], bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ExtraProgramPages", zb0016)
					return
				}
			}
		}
		if zb0017 > 0 {
			zb0017--
			{
				var zb0080 []byte
				var zb0081 int
				zb0081, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskExtraProgramPages")
					return
				}
				if zb0081 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0081), uint64(maxBitmaskSize))
					return
				}
				zb0080, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskExtraProgramPages))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskExtraProgramPages")
					return
				}
				(*z).BitmaskExtraProgramPages = bitmask(zb0080)
			}
		}
		if zb0017 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0017)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0018 {
			(*z) = encodedApplicationCallTxnFields{}
		}
		for zb0017 > 0 {
			zb0017--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "apid":
				var zb0082 int
				var zb0083 bool
				zb0082, zb0083, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ApplicationID")
					return
				}
				if zb0082 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0082), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ApplicationID")
					return
				}
				if zb0083 {
					(*z).ApplicationID = nil
				} else if (*z).ApplicationID != nil && cap((*z).ApplicationID) >= zb0082 {
					(*z).ApplicationID = ((*z).ApplicationID)[:zb0082]
				} else {
					(*z).ApplicationID = make([]basics.AppIndex, zb0082)
				}
				for zb0001 := range (*z).ApplicationID {
					bts, err = (*z).ApplicationID[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ApplicationID", zb0001)
						return
					}
				}
			case "apidbm":
				{
					var zb0084 []byte
					var zb0085 int
					zb0085, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationID")
						return
					}
					if zb0085 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0085), uint64(maxBitmaskSize))
						return
					}
					zb0084, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskApplicationID))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationID")
						return
					}
					(*z).BitmaskApplicationID = bitmask(zb0084)
				}
			case "apan":
				var zb0086 int
				zb0086, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "OnCompletion")
					return
				}
				if zb0086 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0086), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).OnCompletion, bts, err = msgp.ReadBytesBytes(bts, (*z).OnCompletion)
				if err != nil {
					err = msgp.WrapError(err, "OnCompletion")
					return
				}
			case "apanbm":
				{
					var zb0087 []byte
					var zb0088 int
					zb0088, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskOnCompletion")
						return
					}
					if zb0088 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0088), uint64(maxBitmaskSize))
						return
					}
					zb0087, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskOnCompletion))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskOnCompletion")
						return
					}
					(*z).BitmaskOnCompletion = bitmask(zb0087)
				}
			case "apaa":
				var zb0089 int
				var zb0090 bool
				zb0089, zb0090, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ApplicationArgs")
					return
				}
				if zb0089 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0089), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ApplicationArgs")
					return
				}
				if zb0090 {
					(*z).ApplicationArgs = nil
				} else if (*z).ApplicationArgs != nil && cap((*z).ApplicationArgs) >= zb0089 {
					(*z).ApplicationArgs = ((*z).ApplicationArgs)[:zb0089]
				} else {
					(*z).ApplicationArgs = make([]applicationArgs, zb0089)
				}
				for zb0002 := range (*z).ApplicationArgs {
					var zb0091 int
					var zb0092 bool
					zb0091, zb0092, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ApplicationArgs", zb0002)
						return
					}
					if zb0091 > transactions.EncodedMaxApplicationArgs {
						err = msgp.ErrOverflow(uint64(zb0091), uint64(transactions.EncodedMaxApplicationArgs))
						err = msgp.WrapError(err, "ApplicationArgs", zb0002)
						return
					}
					if zb0092 {
						(*z).ApplicationArgs[zb0002] = nil
					} else if (*z).ApplicationArgs[zb0002] != nil && cap((*z).ApplicationArgs[zb0002]) >= zb0091 {
						(*z).ApplicationArgs[zb0002] = ((*z).ApplicationArgs[zb0002])[:zb0091]
					} else {
						(*z).ApplicationArgs[zb0002] = make(applicationArgs, zb0091)
					}
					for zb0003 := range (*z).ApplicationArgs[zb0002] {
						(*z).ApplicationArgs[zb0002][zb0003], bts, err = msgp.ReadBytesBytes(bts, (*z).ApplicationArgs[zb0002][zb0003])
						if err != nil {
							err = msgp.WrapError(err, "ApplicationArgs", zb0002, zb0003)
							return
						}
					}
				}
			case "apaabm":
				{
					var zb0093 []byte
					var zb0094 int
					zb0094, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationArgs")
						return
					}
					if zb0094 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0094), uint64(maxBitmaskSize))
						return
					}
					zb0093, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskApplicationArgs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationArgs")
						return
					}
					(*z).BitmaskApplicationArgs = bitmask(zb0093)
				}
			case "apat":
				var zb0095 int
				var zb0096 bool
				zb0095, zb0096, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Accounts")
					return
				}
				if zb0095 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0095), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Accounts")
					return
				}
				if zb0096 {
					(*z).Accounts = nil
				} else if (*z).Accounts != nil && cap((*z).Accounts) >= zb0095 {
					(*z).Accounts = ((*z).Accounts)[:zb0095]
				} else {
					(*z).Accounts = make([]addresses, zb0095)
				}
				for zb0004 := range (*z).Accounts {
					var zb0097 int
					var zb0098 bool
					zb0097, zb0098, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Accounts", zb0004)
						return
					}
					if zb0097 > transactions.EncodedMaxAccounts {
						err = msgp.ErrOverflow(uint64(zb0097), uint64(transactions.EncodedMaxAccounts))
						err = msgp.WrapError(err, "Accounts", zb0004)
						return
					}
					if zb0098 {
						(*z).Accounts[zb0004] = nil
					} else if (*z).Accounts[zb0004] != nil && cap((*z).Accounts[zb0004]) >= zb0097 {
						(*z).Accounts[zb0004] = ((*z).Accounts[zb0004])[:zb0097]
					} else {
						(*z).Accounts[zb0004] = make(addresses, zb0097)
					}
					for zb0005 := range (*z).Accounts[zb0004] {
						bts, err = (*z).Accounts[zb0004][zb0005].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Accounts", zb0004, zb0005)
							return
						}
					}
				}
			case "apatbm":
				{
					var zb0099 []byte
					var zb0100 int
					zb0100, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAccounts")
						return
					}
					if zb0100 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0100), uint64(maxBitmaskSize))
						return
					}
					zb0099, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAccounts))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAccounts")
						return
					}
					(*z).BitmaskAccounts = bitmask(zb0099)
				}
			case "apfa":
				var zb0101 int
				var zb0102 bool
				zb0101, zb0102, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ForeignApps")
					return
				}
				if zb0101 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0101), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ForeignApps")
					return
				}
				if zb0102 {
					(*z).ForeignApps = nil
				} else if (*z).ForeignApps != nil && cap((*z).ForeignApps) >= zb0101 {
					(*z).ForeignApps = ((*z).ForeignApps)[:zb0101]
				} else {
					(*z).ForeignApps = make([]appIndices, zb0101)
				}
				for zb0006 := range (*z).ForeignApps {
					var zb0103 int
					var zb0104 bool
					zb0103, zb0104, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ForeignApps", zb0006)
						return
					}
					if zb0103 > transactions.EncodedMaxForeignApps {
						err = msgp.ErrOverflow(uint64(zb0103), uint64(transactions.EncodedMaxForeignApps))
						err = msgp.WrapError(err, "ForeignApps", zb0006)
						return
					}
					if zb0104 {
						(*z).ForeignApps[zb0006] = nil
					} else if (*z).ForeignApps[zb0006] != nil && cap((*z).ForeignApps[zb0006]) >= zb0103 {
						(*z).ForeignApps[zb0006] = ((*z).ForeignApps[zb0006])[:zb0103]
					} else {
						(*z).ForeignApps[zb0006] = make(appIndices, zb0103)
					}
					for zb0007 := range (*z).ForeignApps[zb0006] {
						bts, err = (*z).ForeignApps[zb0006][zb0007].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "ForeignApps", zb0006, zb0007)
							return
						}
					}
				}
			case "apfabm":
				{
					var zb0105 []byte
					var zb0106 int
					zb0106, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignApps")
						return
					}
					if zb0106 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0106), uint64(maxBitmaskSize))
						return
					}
					zb0105, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskForeignApps))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignApps")
						return
					}
					(*z).BitmaskForeignApps = bitmask(zb0105)
				}
			case "apas":
				var zb0107 int
				var zb0108 bool
				zb0107, zb0108, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ForeignAssets")
					return
				}
				if zb0107 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0107), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ForeignAssets")
					return
				}
				if zb0108 {
					(*z).ForeignAssets = nil
				} else if (*z).ForeignAssets != nil && cap((*z).ForeignAssets) >= zb0107 {
					(*z).ForeignAssets = ((*z).ForeignAssets)[:zb0107]
				} else {
					(*z).ForeignAssets = make([]assetIndices, zb0107)
				}
				for zb0008 := range (*z).ForeignAssets {
					var zb0109 int
					var zb0110 bool
					zb0109, zb0110, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ForeignAssets", zb0008)
						return
					}
					if zb0109 > transactions.EncodedMaxForeignAssets {
						err = msgp.ErrOverflow(uint64(zb0109), uint64(transactions.EncodedMaxForeignAssets))
						err = msgp.WrapError(err, "ForeignAssets", zb0008)
						return
					}
					if zb0110 {
						(*z).ForeignAssets[zb0008] = nil
					} else if (*z).ForeignAssets[zb0008] != nil && cap((*z).ForeignAssets[zb0008]) >= zb0109 {
						(*z).ForeignAssets[zb0008] = ((*z).ForeignAssets[zb0008])[:zb0109]
					} else {
						(*z).ForeignAssets[zb0008] = make(assetIndices, zb0109)
					}
					for zb0009 := range (*z).ForeignAssets[zb0008] {
						bts, err = (*z).ForeignAssets[zb0008][zb0009].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "ForeignAssets", zb0008, zb0009)
							return
						}
					}
				}
			case "apasbm":
				{
					var zb0111 []byte
					var zb0112 int
					zb0112, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignAssets")
						return
					}
					if zb0112 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0112), uint64(maxBitmaskSize))
						return
					}
					zb0111, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskForeignAssets))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignAssets")
						return
					}
					(*z).BitmaskForeignAssets = bitmask(zb0111)
				}
			case "lnui":
				var zb0113 int
				var zb0114 bool
				zb0113, zb0114, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LocalNumUint")
					return
				}
				if zb0113 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0113), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LocalNumUint")
					return
				}
				if zb0114 {
					(*z).LocalNumUint = nil
				} else if (*z).LocalNumUint != nil && cap((*z).LocalNumUint) >= zb0113 {
					(*z).LocalNumUint = ((*z).LocalNumUint)[:zb0113]
				} else {
					(*z).LocalNumUint = make([]uint64, zb0113)
				}
				for zb0010 := range (*z).LocalNumUint {
					(*z).LocalNumUint[zb0010], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LocalNumUint", zb0010)
						return
					}
				}
			case "lnuibm":
				{
					var zb0115 []byte
					var zb0116 int
					zb0116, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumUint")
						return
					}
					if zb0116 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0116), uint64(maxBitmaskSize))
						return
					}
					zb0115, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLocalNumUint))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumUint")
						return
					}
					(*z).BitmaskLocalNumUint = bitmask(zb0115)
				}
			case "lnbs":
				var zb0117 int
				var zb0118 bool
				zb0117, zb0118, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LocalNumByteSlice")
					return
				}
				if zb0117 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0117), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LocalNumByteSlice")
					return
				}
				if zb0118 {
					(*z).LocalNumByteSlice = nil
				} else if (*z).LocalNumByteSlice != nil && cap((*z).LocalNumByteSlice) >= zb0117 {
					(*z).LocalNumByteSlice = ((*z).LocalNumByteSlice)[:zb0117]
				} else {
					(*z).LocalNumByteSlice = make([]uint64, zb0117)
				}
				for zb0011 := range (*z).LocalNumByteSlice {
					(*z).LocalNumByteSlice[zb0011], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LocalNumByteSlice", zb0011)
						return
					}
				}
			case "lnbsbm":
				{
					var zb0119 []byte
					var zb0120 int
					zb0120, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumByteSlice")
						return
					}
					if zb0120 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0120), uint64(maxBitmaskSize))
						return
					}
					zb0119, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLocalNumByteSlice))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumByteSlice")
						return
					}
					(*z).BitmaskLocalNumByteSlice = bitmask(zb0119)
				}
			case "gnui":
				var zb0121 int
				var zb0122 bool
				zb0121, zb0122, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GlobalNumUint")
					return
				}
				if zb0121 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0121), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "GlobalNumUint")
					return
				}
				if zb0122 {
					(*z).GlobalNumUint = nil
				} else if (*z).GlobalNumUint != nil && cap((*z).GlobalNumUint) >= zb0121 {
					(*z).GlobalNumUint = ((*z).GlobalNumUint)[:zb0121]
				} else {
					(*z).GlobalNumUint = make([]uint64, zb0121)
				}
				for zb0012 := range (*z).GlobalNumUint {
					(*z).GlobalNumUint[zb0012], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "GlobalNumUint", zb0012)
						return
					}
				}
			case "gnuibm":
				{
					var zb0123 []byte
					var zb0124 int
					zb0124, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumUint")
						return
					}
					if zb0124 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0124), uint64(maxBitmaskSize))
						return
					}
					zb0123, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskGlobalNumUint))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumUint")
						return
					}
					(*z).BitmaskGlobalNumUint = bitmask(zb0123)
				}
			case "gnbs":
				var zb0125 int
				var zb0126 bool
				zb0125, zb0126, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GlobalNumByteSlice")
					return
				}
				if zb0125 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0125), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "GlobalNumByteSlice")
					return
				}
				if zb0126 {
					(*z).GlobalNumByteSlice = nil
				} else if (*z).GlobalNumByteSlice != nil && cap((*z).GlobalNumByteSlice) >= zb0125 {
					(*z).GlobalNumByteSlice = ((*z).GlobalNumByteSlice)[:zb0125]
				} else {
					(*z).GlobalNumByteSlice = make([]uint64, zb0125)
				}
				for zb0013 := range (*z).GlobalNumByteSlice {
					(*z).GlobalNumByteSlice[zb0013], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "GlobalNumByteSlice", zb0013)
						return
					}
				}
			case "gnbsbm":
				{
					var zb0127 []byte
					var zb0128 int
					zb0128, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumByteSlice")
						return
					}
					if zb0128 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0128), uint64(maxBitmaskSize))
						return
					}
					zb0127, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskGlobalNumByteSlice))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumByteSlice")
						return
					}
					(*z).BitmaskGlobalNumByteSlice = bitmask(zb0127)
				}
			case "apap":
				var zb0129 int
				var zb0130 bool
				zb0129, zb0130, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ApprovalProgram")
					return
				}
				if zb0129 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0129), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ApprovalProgram")
					return
				}
				if zb0130 {
					(*z).ApprovalProgram = nil
				} else if (*z).ApprovalProgram != nil && cap((*z).ApprovalProgram) >= zb0129 {
					(*z).ApprovalProgram = ((*z).ApprovalProgram)[:zb0129]
				} else {
					(*z).ApprovalProgram = make([]program, zb0129)
				}
				for zb0014 := range (*z).ApprovalProgram {
					{
						var zb0131 []byte
						var zb0132 int
						zb0132, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "ApprovalProgram", zb0014)
							return
						}
						if zb0132 > config.MaxAvailableAppProgramLen {
							err = msgp.ErrOverflow(uint64(zb0132), uint64(config.MaxAvailableAppProgramLen))
							return
						}
						zb0131, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).ApprovalProgram[zb0014]))
						if err != nil {
							err = msgp.WrapError(err, "ApprovalProgram", zb0014)
							return
						}
						(*z).ApprovalProgram[zb0014] = program(zb0131)
					}
				}
			case "apapbm":
				{
					var zb0133 []byte
					var zb0134 int
					zb0134, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApprovalProgram")
						return
					}
					if zb0134 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0134), uint64(maxBitmaskSize))
						return
					}
					zb0133, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskApprovalProgram))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApprovalProgram")
						return
					}
					(*z).BitmaskApprovalProgram = bitmask(zb0133)
				}
			case "apsu":
				var zb0135 int
				var zb0136 bool
				zb0135, zb0136, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ClearStateProgram")
					return
				}
				if zb0135 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0135), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ClearStateProgram")
					return
				}
				if zb0136 {
					(*z).ClearStateProgram = nil
				} else if (*z).ClearStateProgram != nil && cap((*z).ClearStateProgram) >= zb0135 {
					(*z).ClearStateProgram = ((*z).ClearStateProgram)[:zb0135]
				} else {
					(*z).ClearStateProgram = make([]program, zb0135)
				}
				for zb0015 := range (*z).ClearStateProgram {
					{
						var zb0137 []byte
						var zb0138 int
						zb0138, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "ClearStateProgram", zb0015)
							return
						}
						if zb0138 > config.MaxAvailableAppProgramLen {
							err = msgp.ErrOverflow(uint64(zb0138), uint64(config.MaxAvailableAppProgramLen))
							return
						}
						zb0137, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).ClearStateProgram[zb0015]))
						if err != nil {
							err = msgp.WrapError(err, "ClearStateProgram", zb0015)
							return
						}
						(*z).ClearStateProgram[zb0015] = program(zb0137)
					}
				}
			case "apsubm":
				{
					var zb0139 []byte
					var zb0140 int
					zb0140, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClearStateProgram")
						return
					}
					if zb0140 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0140), uint64(maxBitmaskSize))
						return
					}
					zb0139, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskClearStateProgram))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClearStateProgram")
						return
					}
					(*z).BitmaskClearStateProgram = bitmask(zb0139)
				}
			case "apep":
				var zb0141 int
				var zb0142 bool
				zb0141, zb0142, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExtraProgramPages")
					return
				}
				if zb0141 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0141), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ExtraProgramPages")
					return
				}
				if zb0142 {
					(*z).ExtraProgramPages = nil
				} else if (*z).ExtraProgramPages != nil && cap((*z).ExtraProgramPages) >= zb0141 {
					(*z).ExtraProgramPages = ((*z).ExtraProgramPages)[:zb0141]
				} else {
					(*z).ExtraProgramPages = make([]uint32, zb0141)
				}
				for zb0016 := range (*z).ExtraProgramPages {
					(*z).ExtraProgramPages[zb0016], bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ExtraProgramPages", zb0016)
						return
					}
				}
			case "apepbm":
				{
					var zb0143 []byte
					var zb0144 int
					zb0144, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskExtraProgramPages")
						return
					}
					if zb0144 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0144), uint64(maxBitmaskSize))
						return
					}
					zb0143, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskExtraProgramPages))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskExtraProgramPages")
						return
					}
					(*z).BitmaskExtraProgramPages = bitmask(zb0143)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedApplicationCallTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedApplicationCallTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedApplicationCallTxnFields) Msgsize() (s int) {
	s = 3 + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).ApplicationID {
		s += (*z).ApplicationID[zb0001].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskApplicationID)) + 5 + msgp.BytesPrefixSize + len((*z).OnCompletion) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskOnCompletion)) + 5 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).ApplicationArgs {
		s += msgp.ArrayHeaderSize
		for zb0003 := range (*z).ApplicationArgs[zb0002] {
			s += msgp.BytesPrefixSize + len((*z).ApplicationArgs[zb0002][zb0003])
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskApplicationArgs)) + 5 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).Accounts {
		s += msgp.ArrayHeaderSize
		for zb0005 := range (*z).Accounts[zb0004] {
			s += (*z).Accounts[zb0004][zb0005].Msgsize()
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskAccounts)) + 5 + msgp.ArrayHeaderSize
	for zb0006 := range (*z).ForeignApps {
		s += msgp.ArrayHeaderSize
		for zb0007 := range (*z).ForeignApps[zb0006] {
			s += (*z).ForeignApps[zb0006][zb0007].Msgsize()
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskForeignApps)) + 5 + msgp.ArrayHeaderSize
	for zb0008 := range (*z).ForeignAssets {
		s += msgp.ArrayHeaderSize
		for zb0009 := range (*z).ForeignAssets[zb0008] {
			s += (*z).ForeignAssets[zb0008][zb0009].Msgsize()
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskForeignAssets)) + 5 + msgp.ArrayHeaderSize + (len((*z).LocalNumUint) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskLocalNumUint)) + 5 + msgp.ArrayHeaderSize + (len((*z).LocalNumByteSlice) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskLocalNumByteSlice)) + 5 + msgp.ArrayHeaderSize + (len((*z).GlobalNumUint) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskGlobalNumUint)) + 5 + msgp.ArrayHeaderSize + (len((*z).GlobalNumByteSlice) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskGlobalNumByteSlice)) + 5 + msgp.ArrayHeaderSize
	for zb0014 := range (*z).ApprovalProgram {
		s += msgp.BytesPrefixSize + len([]byte((*z).ApprovalProgram[zb0014]))
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskApprovalProgram)) + 5 + msgp.ArrayHeaderSize
	for zb0015 := range (*z).ClearStateProgram {
		s += msgp.BytesPrefixSize + len([]byte((*z).ClearStateProgram[zb0015]))
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskClearStateProgram)) + 5 + msgp.ArrayHeaderSize + (len((*z).ExtraProgramPages) * (msgp.Uint32Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskExtraProgramPages))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedApplicationCallTxnFields) MsgIsZero() bool {
	return (len((*z).ApplicationID) == 0) && (len((*z).BitmaskApplicationID) == 0) && (len((*z).OnCompletion) == 0) && (len((*z).BitmaskOnCompletion) == 0) && (len((*z).ApplicationArgs) == 0) && (len((*z).BitmaskApplicationArgs) == 0) && (len((*z).Accounts) == 0) && (len((*z).BitmaskAccounts) == 0) && (len((*z).ForeignApps) == 0) && (len((*z).BitmaskForeignApps) == 0) && (len((*z).ForeignAssets) == 0) && (len((*z).BitmaskForeignAssets) == 0) && (len((*z).LocalNumUint) == 0) && (len((*z).BitmaskLocalNumUint) == 0) && (len((*z).LocalNumByteSlice) == 0) && (len((*z).BitmaskLocalNumByteSlice) == 0) && (len((*z).GlobalNumUint) == 0) && (len((*z).BitmaskGlobalNumUint) == 0) && (len((*z).GlobalNumByteSlice) == 0) && (len((*z).BitmaskGlobalNumByteSlice) == 0) && (len((*z).ApprovalProgram) == 0) && (len((*z).BitmaskApprovalProgram) == 0) && (len((*z).ClearStateProgram) == 0) && (len((*z).BitmaskClearStateProgram) == 0) && (len((*z).ExtraProgramPages) == 0) && (len((*z).BitmaskExtraProgramPages) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedAssetConfigTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0007Len := uint32(23)
	var zb0007Mask uint32 /* 25 bits */
	if len((*z).encodedAssetParams.MetadataHash) == 0 {
		zb0007Len--
		zb0007Mask |= 0x4
	}
	if len((*z).encodedAssetParams.BitmaskMetadataHash) == 0 {
		zb0007Len--
		zb0007Mask |= 0x8
	}
	if len((*z).encodedAssetParams.AssetName) == 0 {
		zb0007Len--
		zb0007Mask |= 0x10
	}
	if len((*z).encodedAssetParams.BitmaskAssetName) == 0 {
		zb0007Len--
		zb0007Mask |= 0x20
	}
	if len((*z).encodedAssetParams.URL) == 0 {
		zb0007Len--
		zb0007Mask |= 0x40
	}
	if len((*z).encodedAssetParams.BitmaskURL) == 0 {
		zb0007Len--
		zb0007Mask |= 0x80
	}
	if len((*z).encodedAssetParams.Clawback) == 0 {
		zb0007Len--
		zb0007Mask |= 0x100
	}
	if len((*z).ConfigAsset) == 0 {
		zb0007Len--
		zb0007Mask |= 0x200
	}
	if len((*z).BitmaskConfigAsset) == 0 {
		zb0007Len--
		zb0007Mask |= 0x400
	}
	if len((*z).encodedAssetParams.BitmaskClawback) == 0 {
		zb0007Len--
		zb0007Mask |= 0x800
	}
	if len((*z).encodedAssetParams.Decimals) == 0 {
		zb0007Len--
		zb0007Mask |= 0x1000
	}
	if len((*z).encodedAssetParams.BitmaskDecimals) == 0 {
		zb0007Len--
		zb0007Mask |= 0x2000
	}
	if len((*z).encodedAssetParams.BitmaskDefaultFrozen) == 0 {
		zb0007Len--
		zb0007Mask |= 0x4000
	}
	if len((*z).encodedAssetParams.Freeze) == 0 {
		zb0007Len--
		zb0007Mask |= 0x8000
	}
	if len((*z).encodedAssetParams.BitmaskFreeze) == 0 {
		zb0007Len--
		zb0007Mask |= 0x10000
	}
	if len((*z).encodedAssetParams.Manager) == 0 {
		zb0007Len--
		zb0007Mask |= 0x20000
	}
	if len((*z).encodedAssetParams.BitmaskManager) == 0 {
		zb0007Len--
		zb0007Mask |= 0x40000
	}
	if len((*z).encodedAssetParams.Reserve) == 0 {
		zb0007Len--
		zb0007Mask |= 0x80000
	}
	if len((*z).encodedAssetParams.BitmaskReserve) == 0 {
		zb0007Len--
		zb0007Mask |= 0x100000
	}
	if len((*z).encodedAssetParams.Total) == 0 {
		zb0007Len--
		zb0007Mask |= 0x200000
	}
	if len((*z).encodedAssetParams.BitmaskTotal) == 0 {
		zb0007Len--
		zb0007Mask |= 0x400000
	}
	if len((*z).encodedAssetParams.UnitName) == 0 {
		zb0007Len--
		zb0007Mask |= 0x800000
	}
	if len((*z).encodedAssetParams.BitmaskUnitName) == 0 {
		zb0007Len--
		zb0007Mask |= 0x1000000
	}
	// variable map header, size zb0007Len
	o = msgp.AppendMapHeader(o, zb0007Len)
	if zb0007Len != 0 {
		if (zb0007Mask & 0x4) == 0 { // if not empty
			// string "am"
			o = append(o, 0xa2, 0x61, 0x6d)
			o = msgp.AppendBytes(o, (*z).encodedAssetParams.MetadataHash)
		}
		if (zb0007Mask & 0x8) == 0 { // if not empty
			// string "ambm"
			o = append(o, 0xa4, 0x61, 0x6d, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetParams.BitmaskMetadataHash))
		}
		if (zb0007Mask & 0x10) == 0 { // if not empty
			// string "an"
			o = append(o, 0xa2, 0x61, 0x6e)
			if (*z).encodedAssetParams.AssetName == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetParams.AssetName)))
			}
			for zb0005 := range (*z).encodedAssetParams.AssetName {
				o = msgp.AppendString(o, (*z).encodedAssetParams.AssetName[zb0005])
			}
		}
		if (zb0007Mask & 0x20) == 0 { // if not empty
			// string "anbm"
			o = append(o, 0xa4, 0x61, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetParams.BitmaskAssetName))
		}
		if (zb0007Mask & 0x40) == 0 { // if not empty
			// string "au"
			o = append(o, 0xa2, 0x61, 0x75)
			if (*z).encodedAssetParams.URL == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetParams.URL)))
			}
			for zb0006 := range (*z).encodedAssetParams.URL {
				o = msgp.AppendString(o, (*z).encodedAssetParams.URL[zb0006])
			}
		}
		if (zb0007Mask & 0x80) == 0 { // if not empty
			// string "aubm"
			o = append(o, 0xa4, 0x61, 0x75, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetParams.BitmaskURL))
		}
		if (zb0007Mask & 0x100) == 0 { // if not empty
			// string "c"
			o = append(o, 0xa1, 0x63)
			o = msgp.AppendBytes(o, (*z).encodedAssetParams.Clawback)
		}
		if (zb0007Mask & 0x200) == 0 { // if not empty
			// string "caid"
			o = append(o, 0xa4, 0x63, 0x61, 0x69, 0x64)
			if (*z).ConfigAsset == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).ConfigAsset)))
			}
			for zb0001 := range (*z).ConfigAsset {
				o = (*z).ConfigAsset[zb0001].MarshalMsg(o)
			}
		}
		if (zb0007Mask & 0x400) == 0 { // if not empty
			// string "caidbm"
			o = append(o, 0xa6, 0x63, 0x61, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskConfigAsset))
		}
		if (zb0007Mask & 0x800) == 0 { // if not empty
			// string "cbm"
			o = append(o, 0xa3, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetParams.BitmaskClawback))
		}
		if (zb0007Mask & 0x1000) == 0 { // if not empty
			// string "dc"
			o = append(o, 0xa2, 0x64, 0x63)
			if (*z).encodedAssetParams.Decimals == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetParams.Decimals)))
			}
			for zb0003 := range (*z).encodedAssetParams.Decimals {
				o = msgp.AppendUint32(o, (*z).encodedAssetParams.Decimals[zb0003])
			}
		}
		if (zb0007Mask & 0x2000) == 0 { // if not empty
			// string "dcbm"
			o = append(o, 0xa4, 0x64, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetParams.BitmaskDecimals))
		}
		if (zb0007Mask & 0x4000) == 0 { // if not empty
			// string "dfbm"
			o = append(o, 0xa4, 0x64, 0x66, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetParams.BitmaskDefaultFrozen))
		}
		if (zb0007Mask & 0x8000) == 0 { // if not empty
			// string "f"
			o = append(o, 0xa1, 0x66)
			o = msgp.AppendBytes(o, (*z).encodedAssetParams.Freeze)
		}
		if (zb0007Mask & 0x10000) == 0 { // if not empty
			// string "fbm"
			o = append(o, 0xa3, 0x66, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetParams.BitmaskFreeze))
		}
		if (zb0007Mask & 0x20000) == 0 { // if not empty
			// string "m"
			o = append(o, 0xa1, 0x6d)
			o = msgp.AppendBytes(o, (*z).encodedAssetParams.Manager)
		}
		if (zb0007Mask & 0x40000) == 0 { // if not empty
			// string "mbm"
			o = append(o, 0xa3, 0x6d, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetParams.BitmaskManager))
		}
		if (zb0007Mask & 0x80000) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = msgp.AppendBytes(o, (*z).encodedAssetParams.Reserve)
		}
		if (zb0007Mask & 0x100000) == 0 { // if not empty
			// string "rbm"
			o = append(o, 0xa3, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetParams.BitmaskReserve))
		}
		if (zb0007Mask & 0x200000) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			if (*z).encodedAssetParams.Total == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetParams.Total)))
			}
			for zb0002 := range (*z).encodedAssetParams.Total {
				o = msgp.AppendUint64(o, (*z).encodedAssetParams.Total[zb0002])
			}
		}
		if (zb0007Mask & 0x400000) == 0 { // if not empty
			// string "tbm"
			o = append(o, 0xa3, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetParams.BitmaskTotal))
		}
		if (zb0007Mask & 0x800000) == 0 { // if not empty
			// string "un"
			o = append(o, 0xa2, 0x75, 0x6e)
			if (*z).encodedAssetParams.UnitName == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetParams.UnitName)))
			}
			for zb0004 := range (*z).encodedAssetParams.UnitName {
				o = msgp.AppendString(o, (*z).encodedAssetParams.UnitName[zb0004])
			}
		}
		if (zb0007Mask & 0x1000000) == 0 { // if not empty
			// string "unbm"
			o = append(o, 0xa4, 0x75, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetParams.BitmaskUnitName))
		}
	}
	return
}

func (_ *encodedAssetConfigTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetConfigTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedAssetConfigTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0007 int
	var zb0008 bool
	zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0007 > 0 {
			zb0007--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ConfigAsset")
				return
			}
			if zb0009 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ConfigAsset")
				return
			}
			if zb0010 {
				(*z).ConfigAsset = nil
			} else if (*z).ConfigAsset != nil && cap((*z).ConfigAsset) >= zb0009 {
				(*z).ConfigAsset = ((*z).ConfigAsset)[:zb0009]
			} else {
				(*z).ConfigAsset = make([]basics.AssetIndex, zb0009)
			}
			for zb0001 := range (*z).ConfigAsset {
				bts, err = (*z).ConfigAsset[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ConfigAsset", zb0001)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0011 []byte
				var zb0012 int
				zb0012, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskConfigAsset")
					return
				}
				if zb0012 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0012), uint64(maxBitmaskSize))
					return
				}
				zb0011, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskConfigAsset))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskConfigAsset")
					return
				}
				(*z).BitmaskConfigAsset = bitmask(zb0011)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0013 int
			var zb0014 bool
			zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Total")
				return
			}
			if zb0013 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0013), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Total")
				return
			}
			if zb0014 {
				(*z).encodedAssetParams.Total = nil
			} else if (*z).encodedAssetParams.Total != nil && cap((*z).encodedAssetParams.Total) >= zb0013 {
				(*z).encodedAssetParams.Total = ((*z).encodedAssetParams.Total)[:zb0013]
			} else {
				(*z).encodedAssetParams.Total = make([]uint64, zb0013)
			}
			for zb0002 := range (*z).encodedAssetParams.Total {
				(*z).encodedAssetParams.Total[zb0002], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Total", zb0002)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0015 []byte
				var zb0016 int
				zb0016, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTotal")
					return
				}
				if zb0016 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0016), uint64(maxBitmaskSize))
					return
				}
				zb0015, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskTotal))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTotal")
					return
				}
				(*z).encodedAssetParams.BitmaskTotal = bitmask(zb0015)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0017 int
			var zb0018 bool
			zb0017, zb0018, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Decimals")
				return
			}
			if zb0017 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0017), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Decimals")
				return
			}
			if zb0018 {
				(*z).encodedAssetParams.Decimals = nil
			} else if (*z).encodedAssetParams.Decimals != nil && cap((*z).encodedAssetParams.Decimals) >= zb0017 {
				(*z).encodedAssetParams.Decimals = ((*z).encodedAssetParams.Decimals)[:zb0017]
			} else {
				(*z).encodedAssetParams.Decimals = make([]uint32, zb0017)
			}
			for zb0003 := range (*z).encodedAssetParams.Decimals {
				(*z).encodedAssetParams.Decimals[zb0003], bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Decimals", zb0003)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0019 []byte
				var zb0020 int
				zb0020, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDecimals")
					return
				}
				if zb0020 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0020), uint64(maxBitmaskSize))
					return
				}
				zb0019, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskDecimals))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDecimals")
					return
				}
				(*z).encodedAssetParams.BitmaskDecimals = bitmask(zb0019)
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0021 []byte
				var zb0022 int
				zb0022, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDefaultFrozen")
					return
				}
				if zb0022 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0022), uint64(maxBitmaskSize))
					return
				}
				zb0021, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskDefaultFrozen))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDefaultFrozen")
					return
				}
				(*z).encodedAssetParams.BitmaskDefaultFrozen = bitmask(zb0021)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0023 int
			var zb0024 bool
			zb0023, zb0024, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UnitName")
				return
			}
			if zb0023 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0023), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "UnitName")
				return
			}
			if zb0024 {
				(*z).encodedAssetParams.UnitName = nil
			} else if (*z).encodedAssetParams.UnitName != nil && cap((*z).encodedAssetParams.UnitName) >= zb0023 {
				(*z).encodedAssetParams.UnitName = ((*z).encodedAssetParams.UnitName)[:zb0023]
			} else {
				(*z).encodedAssetParams.UnitName = make([]string, zb0023)
			}
			for zb0004 := range (*z).encodedAssetParams.UnitName {
				(*z).encodedAssetParams.UnitName[zb0004], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "UnitName", zb0004)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0025 []byte
				var zb0026 int
				zb0026, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskUnitName")
					return
				}
				if zb0026 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0026), uint64(maxBitmaskSize))
					return
				}
				zb0025, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskUnitName))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskUnitName")
					return
				}
				(*z).encodedAssetParams.BitmaskUnitName = bitmask(zb0025)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0027 int
			var zb0028 bool
			zb0027, zb0028, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetName")
				return
			}
			if zb0027 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0027), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "AssetName")
				return
			}
			if zb0028 {
				(*z).encodedAssetParams.AssetName = nil
			} else if (*z).encodedAssetParams.AssetName != nil && cap((*z).encodedAssetParams.AssetName) >= zb0027 {
				(*z).encodedAssetParams.AssetName = ((*z).encodedAssetParams.AssetName)[:zb0027]
			} else {
				(*z).encodedAssetParams.AssetName = make([]string, zb0027)
			}
			for zb0005 := range (*z).encodedAssetParams.AssetName {
				(*z).encodedAssetParams.AssetName[zb0005], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AssetName", zb0005)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0029 []byte
				var zb0030 int
				zb0030, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetName")
					return
				}
				if zb0030 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0030), uint64(maxBitmaskSize))
					return
				}
				zb0029, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskAssetName))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetName")
					return
				}
				(*z).encodedAssetParams.BitmaskAssetName = bitmask(zb0029)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0031 int
			var zb0032 bool
			zb0031, zb0032, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "URL")
				return
			}
			if zb0031 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0031), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "URL")
				return
			}
			if zb0032 {
				(*z).encodedAssetParams.URL = nil
			} else if (*z).encodedAssetParams.URL != nil && cap((*z).encodedAssetParams.URL) >= zb0031 {
				(*z).encodedAssetParams.URL = ((*z).encodedAssetParams.URL)[:zb0031]
			} else {
				(*z).encodedAssetParams.URL = make([]string, zb0031)
			}
			for zb0006 := range (*z).encodedAssetParams.URL {
				(*z).encodedAssetParams.URL[zb0006], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "URL", zb0006)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0033 []byte
				var zb0034 int
				zb0034, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskURL")
					return
				}
				if zb0034 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0034), uint64(maxBitmaskSize))
					return
				}
				zb0033, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskURL))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskURL")
					return
				}
				(*z).encodedAssetParams.BitmaskURL = bitmask(zb0033)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0035 int
			zb0035, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MetadataHash")
				return
			}
			if zb0035 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0035), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetParams.MetadataHash, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetParams.MetadataHash)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MetadataHash")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0036 []byte
				var zb0037 int
				zb0037, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMetadataHash")
					return
				}
				if zb0037 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0037), uint64(maxBitmaskSize))
					return
				}
				zb0036, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskMetadataHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMetadataHash")
					return
				}
				(*z).encodedAssetParams.BitmaskMetadataHash = bitmask(zb0036)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0038 int
			zb0038, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Manager")
				return
			}
			if zb0038 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0038), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetParams.Manager, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetParams.Manager)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Manager")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0039 []byte
				var zb0040 int
				zb0040, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskManager")
					return
				}
				if zb0040 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0040), uint64(maxBitmaskSize))
					return
				}
				zb0039, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskManager))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskManager")
					return
				}
				(*z).encodedAssetParams.BitmaskManager = bitmask(zb0039)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0041 int
			zb0041, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reserve")
				return
			}
			if zb0041 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0041), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetParams.Reserve, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetParams.Reserve)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reserve")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0042 []byte
				var zb0043 int
				zb0043, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReserve")
					return
				}
				if zb0043 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0043), uint64(maxBitmaskSize))
					return
				}
				zb0042, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskReserve))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReserve")
					return
				}
				(*z).encodedAssetParams.BitmaskReserve = bitmask(zb0042)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0044 int
			zb0044, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Freeze")
				return
			}
			if zb0044 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0044), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetParams.Freeze, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetParams.Freeze)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Freeze")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0045 []byte
				var zb0046 int
				zb0046, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreeze")
					return
				}
				if zb0046 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0046), uint64(maxBitmaskSize))
					return
				}
				zb0045, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskFreeze))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreeze")
					return
				}
				(*z).encodedAssetParams.BitmaskFreeze = bitmask(zb0045)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0047 int
			zb0047, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Clawback")
				return
			}
			if zb0047 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0047), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetParams.Clawback, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetParams.Clawback)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Clawback")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0048 []byte
				var zb0049 int
				zb0049, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClawback")
					return
				}
				if zb0049 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0049), uint64(maxBitmaskSize))
					return
				}
				zb0048, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskClawback))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClawback")
					return
				}
				(*z).encodedAssetParams.BitmaskClawback = bitmask(zb0048)
			}
		}
		if zb0007 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0007)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0008 {
			(*z) = encodedAssetConfigTxnFields{}
		}
		for zb0007 > 0 {
			zb0007--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "caid":
				var zb0050 int
				var zb0051 bool
				zb0050, zb0051, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ConfigAsset")
					return
				}
				if zb0050 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0050), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ConfigAsset")
					return
				}
				if zb0051 {
					(*z).ConfigAsset = nil
				} else if (*z).ConfigAsset != nil && cap((*z).ConfigAsset) >= zb0050 {
					(*z).ConfigAsset = ((*z).ConfigAsset)[:zb0050]
				} else {
					(*z).ConfigAsset = make([]basics.AssetIndex, zb0050)
				}
				for zb0001 := range (*z).ConfigAsset {
					bts, err = (*z).ConfigAsset[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ConfigAsset", zb0001)
						return
					}
				}
			case "caidbm":
				{
					var zb0052 []byte
					var zb0053 int
					zb0053, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskConfigAsset")
						return
					}
					if zb0053 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0053), uint64(maxBitmaskSize))
						return
					}
					zb0052, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskConfigAsset))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskConfigAsset")
						return
					}
					(*z).BitmaskConfigAsset = bitmask(zb0052)
				}
			case "t":
				var zb0054 int
				var zb0055 bool
				zb0054, zb0055, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Total")
					return
				}
				if zb0054 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0054), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Total")
					return
				}
				if zb0055 {
					(*z).encodedAssetParams.Total = nil
				} else if (*z).encodedAssetParams.Total != nil && cap((*z).encodedAssetParams.Total) >= zb0054 {
					(*z).encodedAssetParams.Total = ((*z).encodedAssetParams.Total)[:zb0054]
				} else {
					(*z).encodedAssetParams.Total = make([]uint64, zb0054)
				}
				for zb0002 := range (*z).encodedAssetParams.Total {
					(*z).encodedAssetParams.Total[zb0002], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Total", zb0002)
						return
					}
				}
			case "tbm":
				{
					var zb0056 []byte
					var zb0057 int
					zb0057, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTotal")
						return
					}
					if zb0057 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0057), uint64(maxBitmaskSize))
						return
					}
					zb0056, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskTotal))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTotal")
						return
					}
					(*z).encodedAssetParams.BitmaskTotal = bitmask(zb0056)
				}
			case "dc":
				var zb0058 int
				var zb0059 bool
				zb0058, zb0059, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Decimals")
					return
				}
				if zb0058 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0058), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Decimals")
					return
				}
				if zb0059 {
					(*z).encodedAssetParams.Decimals = nil
				} else if (*z).encodedAssetParams.Decimals != nil && cap((*z).encodedAssetParams.Decimals) >= zb0058 {
					(*z).encodedAssetParams.Decimals = ((*z).encodedAssetParams.Decimals)[:zb0058]
				} else {
					(*z).encodedAssetParams.Decimals = make([]uint32, zb0058)
				}
				for zb0003 := range (*z).encodedAssetParams.Decimals {
					(*z).encodedAssetParams.Decimals[zb0003], bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Decimals", zb0003)
						return
					}
				}
			case "dcbm":
				{
					var zb0060 []byte
					var zb0061 int
					zb0061, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDecimals")
						return
					}
					if zb0061 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0061), uint64(maxBitmaskSize))
						return
					}
					zb0060, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskDecimals))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDecimals")
						return
					}
					(*z).encodedAssetParams.BitmaskDecimals = bitmask(zb0060)
				}
			case "dfbm":
				{
					var zb0062 []byte
					var zb0063 int
					zb0063, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDefaultFrozen")
						return
					}
					if zb0063 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0063), uint64(maxBitmaskSize))
						return
					}
					zb0062, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskDefaultFrozen))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDefaultFrozen")
						return
					}
					(*z).encodedAssetParams.BitmaskDefaultFrozen = bitmask(zb0062)
				}
			case "un":
				var zb0064 int
				var zb0065 bool
				zb0064, zb0065, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UnitName")
					return
				}
				if zb0064 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0064), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "UnitName")
					return
				}
				if zb0065 {
					(*z).encodedAssetParams.UnitName = nil
				} else if (*z).encodedAssetParams.UnitName != nil && cap((*z).encodedAssetParams.UnitName) >= zb0064 {
					(*z).encodedAssetParams.UnitName = ((*z).encodedAssetParams.UnitName)[:zb0064]
				} else {
					(*z).encodedAssetParams.UnitName = make([]string, zb0064)
				}
				for zb0004 := range (*z).encodedAssetParams.UnitName {
					(*z).encodedAssetParams.UnitName[zb0004], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "UnitName", zb0004)
						return
					}
				}
			case "unbm":
				{
					var zb0066 []byte
					var zb0067 int
					zb0067, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskUnitName")
						return
					}
					if zb0067 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0067), uint64(maxBitmaskSize))
						return
					}
					zb0066, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskUnitName))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskUnitName")
						return
					}
					(*z).encodedAssetParams.BitmaskUnitName = bitmask(zb0066)
				}
			case "an":
				var zb0068 int
				var zb0069 bool
				zb0068, zb0069, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetName")
					return
				}
				if zb0068 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0068), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "AssetName")
					return
				}
				if zb0069 {
					(*z).encodedAssetParams.AssetName = nil
				} else if (*z).encodedAssetParams.AssetName != nil && cap((*z).encodedAssetParams.AssetName) >= zb0068 {
					(*z).encodedAssetParams.AssetName = ((*z).encodedAssetParams.AssetName)[:zb0068]
				} else {
					(*z).encodedAssetParams.AssetName = make([]string, zb0068)
				}
				for zb0005 := range (*z).encodedAssetParams.AssetName {
					(*z).encodedAssetParams.AssetName[zb0005], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AssetName", zb0005)
						return
					}
				}
			case "anbm":
				{
					var zb0070 []byte
					var zb0071 int
					zb0071, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetName")
						return
					}
					if zb0071 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0071), uint64(maxBitmaskSize))
						return
					}
					zb0070, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskAssetName))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetName")
						return
					}
					(*z).encodedAssetParams.BitmaskAssetName = bitmask(zb0070)
				}
			case "au":
				var zb0072 int
				var zb0073 bool
				zb0072, zb0073, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "URL")
					return
				}
				if zb0072 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0072), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "URL")
					return
				}
				if zb0073 {
					(*z).encodedAssetParams.URL = nil
				} else if (*z).encodedAssetParams.URL != nil && cap((*z).encodedAssetParams.URL) >= zb0072 {
					(*z).encodedAssetParams.URL = ((*z).encodedAssetParams.URL)[:zb0072]
				} else {
					(*z).encodedAssetParams.URL = make([]string, zb0072)
				}
				for zb0006 := range (*z).encodedAssetParams.URL {
					(*z).encodedAssetParams.URL[zb0006], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "URL", zb0006)
						return
					}
				}
			case "aubm":
				{
					var zb0074 []byte
					var zb0075 int
					zb0075, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskURL")
						return
					}
					if zb0075 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0075), uint64(maxBitmaskSize))
						return
					}
					zb0074, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskURL))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskURL")
						return
					}
					(*z).encodedAssetParams.BitmaskURL = bitmask(zb0074)
				}
			case "am":
				var zb0076 int
				zb0076, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "MetadataHash")
					return
				}
				if zb0076 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0076), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetParams.MetadataHash, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetParams.MetadataHash)
				if err != nil {
					err = msgp.WrapError(err, "MetadataHash")
					return
				}
			case "ambm":
				{
					var zb0077 []byte
					var zb0078 int
					zb0078, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMetadataHash")
						return
					}
					if zb0078 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0078), uint64(maxBitmaskSize))
						return
					}
					zb0077, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskMetadataHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMetadataHash")
						return
					}
					(*z).encodedAssetParams.BitmaskMetadataHash = bitmask(zb0077)
				}
			case "m":
				var zb0079 int
				zb0079, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Manager")
					return
				}
				if zb0079 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0079), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetParams.Manager, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetParams.Manager)
				if err != nil {
					err = msgp.WrapError(err, "Manager")
					return
				}
			case "mbm":
				{
					var zb0080 []byte
					var zb0081 int
					zb0081, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskManager")
						return
					}
					if zb0081 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0081), uint64(maxBitmaskSize))
						return
					}
					zb0080, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskManager))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskManager")
						return
					}
					(*z).encodedAssetParams.BitmaskManager = bitmask(zb0080)
				}
			case "r":
				var zb0082 int
				zb0082, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reserve")
					return
				}
				if zb0082 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0082), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetParams.Reserve, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetParams.Reserve)
				if err != nil {
					err = msgp.WrapError(err, "Reserve")
					return
				}
			case "rbm":
				{
					var zb0083 []byte
					var zb0084 int
					zb0084, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReserve")
						return
					}
					if zb0084 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0084), uint64(maxBitmaskSize))
						return
					}
					zb0083, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskReserve))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReserve")
						return
					}
					(*z).encodedAssetParams.BitmaskReserve = bitmask(zb0083)
				}
			case "f":
				var zb0085 int
				zb0085, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Freeze")
					return
				}
				if zb0085 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0085), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetParams.Freeze, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetParams.Freeze)
				if err != nil {
					err = msgp.WrapError(err, "Freeze")
					return
				}
			case "fbm":
				{
					var zb0086 []byte
					var zb0087 int
					zb0087, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreeze")
						return
					}
					if zb0087 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0087), uint64(maxBitmaskSize))
						return
					}
					zb0086, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskFreeze))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreeze")
						return
					}
					(*z).encodedAssetParams.BitmaskFreeze = bitmask(zb0086)
				}
			case "c":
				var zb0088 int
				zb0088, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Clawback")
					return
				}
				if zb0088 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0088), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetParams.Clawback, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetParams.Clawback)
				if err != nil {
					err = msgp.WrapError(err, "Clawback")
					return
				}
			case "cbm":
				{
					var zb0089 []byte
					var zb0090 int
					zb0090, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClawback")
						return
					}
					if zb0090 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0090), uint64(maxBitmaskSize))
						return
					}
					zb0089, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetParams.BitmaskClawback))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClawback")
						return
					}
					(*z).encodedAssetParams.BitmaskClawback = bitmask(zb0089)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedAssetConfigTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetConfigTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedAssetConfigTxnFields) Msgsize() (s int) {
	s = 3 + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).ConfigAsset {
		s += (*z).ConfigAsset[zb0001].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskConfigAsset)) + 2 + msgp.ArrayHeaderSize + (len((*z).encodedAssetParams.Total) * (msgp.Uint64Size)) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetParams.BitmaskTotal)) + 3 + msgp.ArrayHeaderSize + (len((*z).encodedAssetParams.Decimals) * (msgp.Uint32Size)) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetParams.BitmaskDecimals)) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetParams.BitmaskDefaultFrozen)) + 3 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).encodedAssetParams.UnitName {
		s += msgp.StringPrefixSize + len((*z).encodedAssetParams.UnitName[zb0004])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetParams.BitmaskUnitName)) + 3 + msgp.ArrayHeaderSize
	for zb0005 := range (*z).encodedAssetParams.AssetName {
		s += msgp.StringPrefixSize + len((*z).encodedAssetParams.AssetName[zb0005])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetParams.BitmaskAssetName)) + 3 + msgp.ArrayHeaderSize
	for zb0006 := range (*z).encodedAssetParams.URL {
		s += msgp.StringPrefixSize + len((*z).encodedAssetParams.URL[zb0006])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetParams.BitmaskURL)) + 3 + msgp.BytesPrefixSize + len((*z).encodedAssetParams.MetadataHash) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetParams.BitmaskMetadataHash)) + 2 + msgp.BytesPrefixSize + len((*z).encodedAssetParams.Manager) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetParams.BitmaskManager)) + 2 + msgp.BytesPrefixSize + len((*z).encodedAssetParams.Reserve) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetParams.BitmaskReserve)) + 2 + msgp.BytesPrefixSize + len((*z).encodedAssetParams.Freeze) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetParams.BitmaskFreeze)) + 2 + msgp.BytesPrefixSize + len((*z).encodedAssetParams.Clawback) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetParams.BitmaskClawback))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedAssetConfigTxnFields) MsgIsZero() bool {
	return (len((*z).ConfigAsset) == 0) && (len((*z).BitmaskConfigAsset) == 0) && (len((*z).encodedAssetParams.Total) == 0) && (len((*z).encodedAssetParams.BitmaskTotal) == 0) && (len((*z).encodedAssetParams.Decimals) == 0) && (len((*z).encodedAssetParams.BitmaskDecimals) == 0) && (len((*z).encodedAssetParams.BitmaskDefaultFrozen) == 0) && (len((*z).encodedAssetParams.UnitName) == 0) && (len((*z).encodedAssetParams.BitmaskUnitName) == 0) && (len((*z).encodedAssetParams.AssetName) == 0) && (len((*z).encodedAssetParams.BitmaskAssetName) == 0) && (len((*z).encodedAssetParams.URL) == 0) && (len((*z).encodedAssetParams.BitmaskURL) == 0) && (len((*z).encodedAssetParams.MetadataHash) == 0) && (len((*z).encodedAssetParams.BitmaskMetadataHash) == 0) && (len((*z).encodedAssetParams.Manager) == 0) && (len((*z).encodedAssetParams.BitmaskManager) == 0) && (len((*z).encodedAssetParams.Reserve) == 0) && (len((*z).encodedAssetParams.BitmaskReserve) == 0) && (len((*z).encodedAssetParams.Freeze) == 0) && (len((*z).encodedAssetParams.BitmaskFreeze) == 0) && (len((*z).encodedAssetParams.Clawback) == 0) && (len((*z).encodedAssetParams.BitmaskClawback) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedAssetFreezeTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(5)
	var zb0002Mask uint8 /* 6 bits */
	if len((*z).BitmaskAssetFrozen) == 0 {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	if len((*z).FreezeAccount) == 0 {
		zb0002Len--
		zb0002Mask |= 0x4
	}
	if len((*z).BitmaskFreezeAccount) == 0 {
		zb0002Len--
		zb0002Mask |= 0x8
	}
	if len((*z).FreezeAsset) == 0 {
		zb0002Len--
		zb0002Mask |= 0x10
	}
	if len((*z).BitmaskFreezeAsset) == 0 {
		zb0002Len--
		zb0002Mask |= 0x20
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "afrzbm"
			o = append(o, 0xa6, 0x61, 0x66, 0x72, 0x7a, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskAssetFrozen))
		}
		if (zb0002Mask & 0x4) == 0 { // if not empty
			// string "fadd"
			o = append(o, 0xa4, 0x66, 0x61, 0x64, 0x64)
			o = msgp.AppendBytes(o, (*z).FreezeAccount)
		}
		if (zb0002Mask & 0x8) == 0 { // if not empty
			// string "faddbm"
			o = append(o, 0xa6, 0x66, 0x61, 0x64, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskFreezeAccount))
		}
		if (zb0002Mask & 0x10) == 0 { // if not empty
			// string "faid"
			o = append(o, 0xa4, 0x66, 0x61, 0x69, 0x64)
			if (*z).FreezeAsset == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).FreezeAsset)))
			}
			for zb0001 := range (*z).FreezeAsset {
				o = (*z).FreezeAsset[zb0001].MarshalMsg(o)
			}
		}
		if (zb0002Mask & 0x20) == 0 { // if not empty
			// string "faidbm"
			o = append(o, 0xa6, 0x66, 0x61, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskFreezeAsset))
		}
	}
	return
}

func (_ *encodedAssetFreezeTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetFreezeTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedAssetFreezeTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			var zb0004 int
			zb0004, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAccount")
				return
			}
			if zb0004 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0004), uint64(maxAddressBytes))
				return
			}
			(*z).FreezeAccount, bts, err = msgp.ReadBytesBytes(bts, (*z).FreezeAccount)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAccount")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			{
				var zb0005 []byte
				var zb0006 int
				zb0006, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAccount")
					return
				}
				if zb0006 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0006), uint64(maxBitmaskSize))
					return
				}
				zb0005, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFreezeAccount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAccount")
					return
				}
				(*z).BitmaskFreezeAccount = bitmask(zb0005)
			}
		}
		if zb0002 > 0 {
			zb0002--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAsset")
				return
			}
			if zb0007 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0007), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "FreezeAsset")
				return
			}
			if zb0008 {
				(*z).FreezeAsset = nil
			} else if (*z).FreezeAsset != nil && cap((*z).FreezeAsset) >= zb0007 {
				(*z).FreezeAsset = ((*z).FreezeAsset)[:zb0007]
			} else {
				(*z).FreezeAsset = make([]basics.AssetIndex, zb0007)
			}
			for zb0001 := range (*z).FreezeAsset {
				bts, err = (*z).FreezeAsset[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "FreezeAsset", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			zb0002--
			{
				var zb0009 []byte
				var zb0010 int
				zb0010, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAsset")
					return
				}
				if zb0010 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0010), uint64(maxBitmaskSize))
					return
				}
				zb0009, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFreezeAsset))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAsset")
					return
				}
				(*z).BitmaskFreezeAsset = bitmask(zb0009)
			}
		}
		if zb0002 > 0 {
			zb0002--
			{
				var zb0011 []byte
				var zb0012 int
				zb0012, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetFrozen")
					return
				}
				if zb0012 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0012), uint64(maxBitmaskSize))
					return
				}
				zb0011, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAssetFrozen))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetFrozen")
					return
				}
				(*z).BitmaskAssetFrozen = bitmask(zb0011)
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = encodedAssetFreezeTxnFields{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "fadd":
				var zb0013 int
				zb0013, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAccount")
					return
				}
				if zb0013 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(maxAddressBytes))
					return
				}
				(*z).FreezeAccount, bts, err = msgp.ReadBytesBytes(bts, (*z).FreezeAccount)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAccount")
					return
				}
			case "faddbm":
				{
					var zb0014 []byte
					var zb0015 int
					zb0015, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAccount")
						return
					}
					if zb0015 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0015), uint64(maxBitmaskSize))
						return
					}
					zb0014, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFreezeAccount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAccount")
						return
					}
					(*z).BitmaskFreezeAccount = bitmask(zb0014)
				}
			case "faid":
				var zb0016 int
				var zb0017 bool
				zb0016, zb0017, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAsset")
					return
				}
				if zb0016 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0016), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "FreezeAsset")
					return
				}
				if zb0017 {
					(*z).FreezeAsset = nil
				} else if (*z).FreezeAsset != nil && cap((*z).FreezeAsset) >= zb0016 {
					(*z).FreezeAsset = ((*z).FreezeAsset)[:zb0016]
				} else {
					(*z).FreezeAsset = make([]basics.AssetIndex, zb0016)
				}
				for zb0001 := range (*z).FreezeAsset {
					bts, err = (*z).FreezeAsset[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "FreezeAsset", zb0001)
						return
					}
				}
			case "faidbm":
				{
					var zb0018 []byte
					var zb0019 int
					zb0019, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAsset")
						return
					}
					if zb0019 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0019), uint64(maxBitmaskSize))
						return
					}
					zb0018, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFreezeAsset))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAsset")
						return
					}
					(*z).BitmaskFreezeAsset = bitmask(zb0018)
				}
			case "afrzbm":
				{
					var zb0020 []byte
					var zb0021 int
					zb0021, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetFrozen")
						return
					}
					if zb0021 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0021), uint64(maxBitmaskSize))
						return
					}
					zb0020, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAssetFrozen))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetFrozen")
						return
					}
					(*z).BitmaskAssetFrozen = bitmask(zb0020)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedAssetFreezeTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetFreezeTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedAssetFreezeTxnFields) Msgsize() (s int) {
	s = 1 + 5 + msgp.BytesPrefixSize + len((*z).FreezeAccount) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskFreezeAccount)) + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).FreezeAsset {
		s += (*z).FreezeAsset[zb0001].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskFreezeAsset)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskAssetFrozen))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedAssetFreezeTxnFields) MsgIsZero() bool {
	return (len((*z).FreezeAccount) == 0) && (len((*z).BitmaskFreezeAccount) == 0) && (len((*z).FreezeAsset) == 0) && (len((*z).BitmaskFreezeAsset) == 0) && (len((*z).BitmaskAssetFrozen) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedAssetParams) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0006Len := uint32(21)
	var zb0006Mask uint32 /* 22 bits */
	if len((*z).MetadataHash) == 0 {
		zb0006Len--
		zb0006Mask |= 0x2
	}
	if len((*z).BitmaskMetadataHash) == 0 {
		zb0006Len--
		zb0006Mask |= 0x4
	}
	if len((*z).AssetName) == 0 {
		zb0006Len--
		zb0006Mask |= 0x8
	}
	if len((*z).BitmaskAssetName) == 0 {
		zb0006Len--
		zb0006Mask |= 0x10
	}
	if len((*z).URL) == 0 {
		zb0006Len--
		zb0006Mask |= 0x20
	}
	if len((*z).BitmaskURL) == 0 {
		zb0006Len--
		zb0006Mask |= 0x40
	}
	if len((*z).Clawback) == 0 {
		zb0006Len--
		zb0006Mask |= 0x80
	}
	if len((*z).BitmaskClawback) == 0 {
		zb0006Len--
		zb0006Mask |= 0x100
	}
	if len((*z).Decimals) == 0 {
		zb0006Len--
		zb0006Mask |= 0x200
	}
	if len((*z).BitmaskDecimals) == 0 {
		zb0006Len--
		zb0006Mask |= 0x400
	}
	if len((*z).BitmaskDefaultFrozen) == 0 {
		zb0006Len--
		zb0006Mask |= 0x800
	}
	if len((*z).Freeze) == 0 {
		zb0006Len--
		zb0006Mask |= 0x1000
	}
	if len((*z).BitmaskFreeze) == 0 {
		zb0006Len--
		zb0006Mask |= 0x2000
	}
	if len((*z).Manager) == 0 {
		zb0006Len--
		zb0006Mask |= 0x4000
	}
	if len((*z).BitmaskManager) == 0 {
		zb0006Len--
		zb0006Mask |= 0x8000
	}
	if len((*z).Reserve) == 0 {
		zb0006Len--
		zb0006Mask |= 0x10000
	}
	if len((*z).BitmaskReserve) == 0 {
		zb0006Len--
		zb0006Mask |= 0x20000
	}
	if len((*z).Total) == 0 {
		zb0006Len--
		zb0006Mask |= 0x40000
	}
	if len((*z).BitmaskTotal) == 0 {
		zb0006Len--
		zb0006Mask |= 0x80000
	}
	if len((*z).UnitName) == 0 {
		zb0006Len--
		zb0006Mask |= 0x100000
	}
	if len((*z).BitmaskUnitName) == 0 {
		zb0006Len--
		zb0006Mask |= 0x200000
	}
	// variable map header, size zb0006Len
	o = msgp.AppendMapHeader(o, zb0006Len)
	if zb0006Len != 0 {
		if (zb0006Mask & 0x2) == 0 { // if not empty
			// string "am"
			o = append(o, 0xa2, 0x61, 0x6d)
			o = msgp.AppendBytes(o, (*z).MetadataHash)
		}
		if (zb0006Mask & 0x4) == 0 { // if not empty
			// string "ambm"
			o = append(o, 0xa4, 0x61, 0x6d, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskMetadataHash))
		}
		if (zb0006Mask & 0x8) == 0 { // if not empty
			// string "an"
			o = append(o, 0xa2, 0x61, 0x6e)
			if (*z).AssetName == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).AssetName)))
			}
			for zb0004 := range (*z).AssetName {
				o = msgp.AppendString(o, (*z).AssetName[zb0004])
			}
		}
		if (zb0006Mask & 0x10) == 0 { // if not empty
			// string "anbm"
			o = append(o, 0xa4, 0x61, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskAssetName))
		}
		if (zb0006Mask & 0x20) == 0 { // if not empty
			// string "au"
			o = append(o, 0xa2, 0x61, 0x75)
			if (*z).URL == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).URL)))
			}
			for zb0005 := range (*z).URL {
				o = msgp.AppendString(o, (*z).URL[zb0005])
			}
		}
		if (zb0006Mask & 0x40) == 0 { // if not empty
			// string "aubm"
			o = append(o, 0xa4, 0x61, 0x75, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskURL))
		}
		if (zb0006Mask & 0x80) == 0 { // if not empty
			// string "c"
			o = append(o, 0xa1, 0x63)
			o = msgp.AppendBytes(o, (*z).Clawback)
		}
		if (zb0006Mask & 0x100) == 0 { // if not empty
			// string "cbm"
			o = append(o, 0xa3, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskClawback))
		}
		if (zb0006Mask & 0x200) == 0 { // if not empty
			// string "dc"
			o = append(o, 0xa2, 0x64, 0x63)
			if (*z).Decimals == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Decimals)))
			}
			for zb0002 := range (*z).Decimals {
				o = msgp.AppendUint32(o, (*z).Decimals[zb0002])
			}
		}
		if (zb0006Mask & 0x400) == 0 { // if not empty
			// string "dcbm"
			o = append(o, 0xa4, 0x64, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskDecimals))
		}
		if (zb0006Mask & 0x800) == 0 { // if not empty
			// string "dfbm"
			o = append(o, 0xa4, 0x64, 0x66, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskDefaultFrozen))
		}
		if (zb0006Mask & 0x1000) == 0 { // if not empty
			// string "f"
			o = append(o, 0xa1, 0x66)
			o = msgp.AppendBytes(o, (*z).Freeze)
		}
		if (zb0006Mask & 0x2000) == 0 { // if not empty
			// string "fbm"
			o = append(o, 0xa3, 0x66, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskFreeze))
		}
		if (zb0006Mask & 0x4000) == 0 { // if not empty
			// string "m"
			o = append(o, 0xa1, 0x6d)
			o = msgp.AppendBytes(o, (*z).Manager)
		}
		if (zb0006Mask & 0x8000) == 0 { // if not empty
			// string "mbm"
			o = append(o, 0xa3, 0x6d, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskManager))
		}
		if (zb0006Mask & 0x10000) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = msgp.AppendBytes(o, (*z).Reserve)
		}
		if (zb0006Mask & 0x20000) == 0 { // if not empty
			// string "rbm"
			o = append(o, 0xa3, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskReserve))
		}
		if (zb0006Mask & 0x40000) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			if (*z).Total == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Total)))
			}
			for zb0001 := range (*z).Total {
				o = msgp.AppendUint64(o, (*z).Total[zb0001])
			}
		}
		if (zb0006Mask & 0x80000) == 0 { // if not empty
			// string "tbm"
			o = append(o, 0xa3, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskTotal))
		}
		if (zb0006Mask & 0x100000) == 0 { // if not empty
			// string "un"
			o = append(o, 0xa2, 0x75, 0x6e)
			if (*z).UnitName == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).UnitName)))
			}
			for zb0003 := range (*z).UnitName {
				o = msgp.AppendString(o, (*z).UnitName[zb0003])
			}
		}
		if (zb0006Mask & 0x200000) == 0 { // if not empty
			// string "unbm"
			o = append(o, 0xa4, 0x75, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskUnitName))
		}
	}
	return
}

func (_ *encodedAssetParams) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetParams)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedAssetParams) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0006 int
	var zb0007 bool
	zb0006, zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0006 > 0 {
			zb0006--
			var zb0008 int
			var zb0009 bool
			zb0008, zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Total")
				return
			}
			if zb0008 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0008), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Total")
				return
			}
			if zb0009 {
				(*z).Total = nil
			} else if (*z).Total != nil && cap((*z).Total) >= zb0008 {
				(*z).Total = ((*z).Total)[:zb0008]
			} else {
				(*z).Total = make([]uint64, zb0008)
			}
			for zb0001 := range (*z).Total {
				(*z).Total[zb0001], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Total", zb0001)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0010 []byte
				var zb0011 int
				zb0011, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTotal")
					return
				}
				if zb0011 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0011), uint64(maxBitmaskSize))
					return
				}
				zb0010, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskTotal))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTotal")
					return
				}
				(*z).BitmaskTotal = bitmask(zb0010)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0012 int
			var zb0013 bool
			zb0012, zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Decimals")
				return
			}
			if zb0012 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0012), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Decimals")
				return
			}
			if zb0013 {
				(*z).Decimals = nil
			} else if (*z).Decimals != nil && cap((*z).Decimals) >= zb0012 {
				(*z).Decimals = ((*z).Decimals)[:zb0012]
			} else {
				(*z).Decimals = make([]uint32, zb0012)
			}
			for zb0002 := range (*z).Decimals {
				(*z).Decimals[zb0002], bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Decimals", zb0002)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0014 []byte
				var zb0015 int
				zb0015, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDecimals")
					return
				}
				if zb0015 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0015), uint64(maxBitmaskSize))
					return
				}
				zb0014, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskDecimals))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDecimals")
					return
				}
				(*z).BitmaskDecimals = bitmask(zb0014)
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0016 []byte
				var zb0017 int
				zb0017, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDefaultFrozen")
					return
				}
				if zb0017 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0017), uint64(maxBitmaskSize))
					return
				}
				zb0016, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskDefaultFrozen))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDefaultFrozen")
					return
				}
				(*z).BitmaskDefaultFrozen = bitmask(zb0016)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0018 int
			var zb0019 bool
			zb0018, zb0019, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UnitName")
				return
			}
			if zb0018 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0018), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "UnitName")
				return
			}
			if zb0019 {
				(*z).UnitName = nil
			} else if (*z).UnitName != nil && cap((*z).UnitName) >= zb0018 {
				(*z).UnitName = ((*z).UnitName)[:zb0018]
			} else {
				(*z).UnitName = make([]string, zb0018)
			}
			for zb0003 := range (*z).UnitName {
				(*z).UnitName[zb0003], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "UnitName", zb0003)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0020 []byte
				var zb0021 int
				zb0021, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskUnitName")
					return
				}
				if zb0021 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0021), uint64(maxBitmaskSize))
					return
				}
				zb0020, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskUnitName))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskUnitName")
					return
				}
				(*z).BitmaskUnitName = bitmask(zb0020)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0022 int
			var zb0023 bool
			zb0022, zb0023, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetName")
				return
			}
			if zb0022 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0022), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "AssetName")
				return
			}
			if zb0023 {
				(*z).AssetName = nil
			} else if (*z).AssetName != nil && cap((*z).AssetName) >= zb0022 {
				(*z).AssetName = ((*z).AssetName)[:zb0022]
			} else {
				(*z).AssetName = make([]string, zb0022)
			}
			for zb0004 := range (*z).AssetName {
				(*z).AssetName[zb0004], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AssetName", zb0004)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0024 []byte
				var zb0025 int
				zb0025, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetName")
					return
				}
				if zb0025 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0025), uint64(maxBitmaskSize))
					return
				}
				zb0024, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAssetName))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetName")
					return
				}
				(*z).BitmaskAssetName = bitmask(zb0024)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0026 int
			var zb0027 bool
			zb0026, zb0027, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "URL")
				return
			}
			if zb0026 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0026), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "URL")
				return
			}
			if zb0027 {
				(*z).URL = nil
			} else if (*z).URL != nil && cap((*z).URL) >= zb0026 {
				(*z).URL = ((*z).URL)[:zb0026]
			} else {
				(*z).URL = make([]string, zb0026)
			}
			for zb0005 := range (*z).URL {
				(*z).URL[zb0005], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "URL", zb0005)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0028 []byte
				var zb0029 int
				zb0029, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskURL")
					return
				}
				if zb0029 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0029), uint64(maxBitmaskSize))
					return
				}
				zb0028, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskURL))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskURL")
					return
				}
				(*z).BitmaskURL = bitmask(zb0028)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0030 int
			zb0030, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MetadataHash")
				return
			}
			if zb0030 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0030), uint64(maxAddressBytes))
				return
			}
			(*z).MetadataHash, bts, err = msgp.ReadBytesBytes(bts, (*z).MetadataHash)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MetadataHash")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0031 []byte
				var zb0032 int
				zb0032, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMetadataHash")
					return
				}
				if zb0032 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0032), uint64(maxBitmaskSize))
					return
				}
				zb0031, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskMetadataHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMetadataHash")
					return
				}
				(*z).BitmaskMetadataHash = bitmask(zb0031)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0033 int
			zb0033, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Manager")
				return
			}
			if zb0033 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0033), uint64(maxAddressBytes))
				return
			}
			(*z).Manager, bts, err = msgp.ReadBytesBytes(bts, (*z).Manager)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Manager")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0034 []byte
				var zb0035 int
				zb0035, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskManager")
					return
				}
				if zb0035 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0035), uint64(maxBitmaskSize))
					return
				}
				zb0034, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskManager))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskManager")
					return
				}
				(*z).BitmaskManager = bitmask(zb0034)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0036 int
			zb0036, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reserve")
				return
			}
			if zb0036 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0036), uint64(maxAddressBytes))
				return
			}
			(*z).Reserve, bts, err = msgp.ReadBytesBytes(bts, (*z).Reserve)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reserve")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0037 []byte
				var zb0038 int
				zb0038, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReserve")
					return
				}
				if zb0038 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0038), uint64(maxBitmaskSize))
					return
				}
				zb0037, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskReserve))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReserve")
					return
				}
				(*z).BitmaskReserve = bitmask(zb0037)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0039 int
			zb0039, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Freeze")
				return
			}
			if zb0039 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0039), uint64(maxAddressBytes))
				return
			}
			(*z).Freeze, bts, err = msgp.ReadBytesBytes(bts, (*z).Freeze)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Freeze")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0040 []byte
				var zb0041 int
				zb0041, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreeze")
					return
				}
				if zb0041 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0041), uint64(maxBitmaskSize))
					return
				}
				zb0040, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFreeze))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreeze")
					return
				}
				(*z).BitmaskFreeze = bitmask(zb0040)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0042 int
			zb0042, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Clawback")
				return
			}
			if zb0042 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0042), uint64(maxAddressBytes))
				return
			}
			(*z).Clawback, bts, err = msgp.ReadBytesBytes(bts, (*z).Clawback)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Clawback")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0043 []byte
				var zb0044 int
				zb0044, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClawback")
					return
				}
				if zb0044 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0044), uint64(maxBitmaskSize))
					return
				}
				zb0043, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskClawback))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClawback")
					return
				}
				(*z).BitmaskClawback = bitmask(zb0043)
			}
		}
		if zb0006 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0006)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0007 {
			(*z) = encodedAssetParams{}
		}
		for zb0006 > 0 {
			zb0006--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "t":
				var zb0045 int
				var zb0046 bool
				zb0045, zb0046, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Total")
					return
				}
				if zb0045 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0045), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Total")
					return
				}
				if zb0046 {
					(*z).Total = nil
				} else if (*z).Total != nil && cap((*z).Total) >= zb0045 {
					(*z).Total = ((*z).Total)[:zb0045]
				} else {
					(*z).Total = make([]uint64, zb0045)
				}
				for zb0001 := range (*z).Total {
					(*z).Total[zb0001], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Total", zb0001)
						return
					}
				}
			case "tbm":
				{
					var zb0047 []byte
					var zb0048 int
					zb0048, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTotal")
						return
					}
					if zb0048 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0048), uint64(maxBitmaskSize))
						return
					}
					zb0047, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskTotal))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTotal")
						return
					}
					(*z).BitmaskTotal = bitmask(zb0047)
				}
			case "dc":
				var zb0049 int
				var zb0050 bool
				zb0049, zb0050, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Decimals")
					return
				}
				if zb0049 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0049), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Decimals")
					return
				}
				if zb0050 {
					(*z).Decimals = nil
				} else if (*z).Decimals != nil && cap((*z).Decimals) >= zb0049 {
					(*z).Decimals = ((*z).Decimals)[:zb0049]
				} else {
					(*z).Decimals = make([]uint32, zb0049)
				}
				for zb0002 := range (*z).Decimals {
					(*z).Decimals[zb0002], bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Decimals", zb0002)
						return
					}
				}
			case "dcbm":
				{
					var zb0051 []byte
					var zb0052 int
					zb0052, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDecimals")
						return
					}
					if zb0052 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0052), uint64(maxBitmaskSize))
						return
					}
					zb0051, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskDecimals))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDecimals")
						return
					}
					(*z).BitmaskDecimals = bitmask(zb0051)
				}
			case "dfbm":
				{
					var zb0053 []byte
					var zb0054 int
					zb0054, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDefaultFrozen")
						return
					}
					if zb0054 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0054), uint64(maxBitmaskSize))
						return
					}
					zb0053, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskDefaultFrozen))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDefaultFrozen")
						return
					}
					(*z).BitmaskDefaultFrozen = bitmask(zb0053)
				}
			case "un":
				var zb0055 int
				var zb0056 bool
				zb0055, zb0056, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UnitName")
					return
				}
				if zb0055 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0055), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "UnitName")
					return
				}
				if zb0056 {
					(*z).UnitName = nil
				} else if (*z).UnitName != nil && cap((*z).UnitName) >= zb0055 {
					(*z).UnitName = ((*z).UnitName)[:zb0055]
				} else {
					(*z).UnitName = make([]string, zb0055)
				}
				for zb0003 := range (*z).UnitName {
					(*z).UnitName[zb0003], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "UnitName", zb0003)
						return
					}
				}
			case "unbm":
				{
					var zb0057 []byte
					var zb0058 int
					zb0058, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskUnitName")
						return
					}
					if zb0058 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0058), uint64(maxBitmaskSize))
						return
					}
					zb0057, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskUnitName))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskUnitName")
						return
					}
					(*z).BitmaskUnitName = bitmask(zb0057)
				}
			case "an":
				var zb0059 int
				var zb0060 bool
				zb0059, zb0060, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetName")
					return
				}
				if zb0059 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0059), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "AssetName")
					return
				}
				if zb0060 {
					(*z).AssetName = nil
				} else if (*z).AssetName != nil && cap((*z).AssetName) >= zb0059 {
					(*z).AssetName = ((*z).AssetName)[:zb0059]
				} else {
					(*z).AssetName = make([]string, zb0059)
				}
				for zb0004 := range (*z).AssetName {
					(*z).AssetName[zb0004], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AssetName", zb0004)
						return
					}
				}
			case "anbm":
				{
					var zb0061 []byte
					var zb0062 int
					zb0062, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetName")
						return
					}
					if zb0062 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0062), uint64(maxBitmaskSize))
						return
					}
					zb0061, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAssetName))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetName")
						return
					}
					(*z).BitmaskAssetName = bitmask(zb0061)
				}
			case "au":
				var zb0063 int
				var zb0064 bool
				zb0063, zb0064, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "URL")
					return
				}
				if zb0063 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0063), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "URL")
					return
				}
				if zb0064 {
					(*z).URL = nil
				} else if (*z).URL != nil && cap((*z).URL) >= zb0063 {
					(*z).URL = ((*z).URL)[:zb0063]
				} else {
					(*z).URL = make([]string, zb0063)
				}
				for zb0005 := range (*z).URL {
					(*z).URL[zb0005], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "URL", zb0005)
						return
					}
				}
			case "aubm":
				{
					var zb0065 []byte
					var zb0066 int
					zb0066, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskURL")
						return
					}
					if zb0066 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0066), uint64(maxBitmaskSize))
						return
					}
					zb0065, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskURL))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskURL")
						return
					}
					(*z).BitmaskURL = bitmask(zb0065)
				}
			case "am":
				var zb0067 int
				zb0067, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "MetadataHash")
					return
				}
				if zb0067 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0067), uint64(maxAddressBytes))
					return
				}
				(*z).MetadataHash, bts, err = msgp.ReadBytesBytes(bts, (*z).MetadataHash)
				if err != nil {
					err = msgp.WrapError(err, "MetadataHash")
					return
				}
			case "ambm":
				{
					var zb0068 []byte
					var zb0069 int
					zb0069, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMetadataHash")
						return
					}
					if zb0069 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0069), uint64(maxBitmaskSize))
						return
					}
					zb0068, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskMetadataHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMetadataHash")
						return
					}
					(*z).BitmaskMetadataHash = bitmask(zb0068)
				}
			case "m":
				var zb0070 int
				zb0070, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Manager")
					return
				}
				if zb0070 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0070), uint64(maxAddressBytes))
					return
				}
				(*z).Manager, bts, err = msgp.ReadBytesBytes(bts, (*z).Manager)
				if err != nil {
					err = msgp.WrapError(err, "Manager")
					return
				}
			case "mbm":
				{
					var zb0071 []byte
					var zb0072 int
					zb0072, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskManager")
						return
					}
					if zb0072 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0072), uint64(maxBitmaskSize))
						return
					}
					zb0071, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskManager))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskManager")
						return
					}
					(*z).BitmaskManager = bitmask(zb0071)
				}
			case "r":
				var zb0073 int
				zb0073, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reserve")
					return
				}
				if zb0073 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0073), uint64(maxAddressBytes))
					return
				}
				(*z).Reserve, bts, err = msgp.ReadBytesBytes(bts, (*z).Reserve)
				if err != nil {
					err = msgp.WrapError(err, "Reserve")
					return
				}
			case "rbm":
				{
					var zb0074 []byte
					var zb0075 int
					zb0075, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReserve")
						return
					}
					if zb0075 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0075), uint64(maxBitmaskSize))
						return
					}
					zb0074, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskReserve))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReserve")
						return
					}
					(*z).BitmaskReserve = bitmask(zb0074)
				}
			case "f":
				var zb0076 int
				zb0076, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Freeze")
					return
				}
				if zb0076 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0076), uint64(maxAddressBytes))
					return
				}
				(*z).Freeze, bts, err = msgp.ReadBytesBytes(bts, (*z).Freeze)
				if err != nil {
					err = msgp.WrapError(err, "Freeze")
					return
				}
			case "fbm":
				{
					var zb0077 []byte
					var zb0078 int
					zb0078, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreeze")
						return
					}
					if zb0078 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0078), uint64(maxBitmaskSize))
						return
					}
					zb0077, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFreeze))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreeze")
						return
					}
					(*z).BitmaskFreeze = bitmask(zb0077)
				}
			case "c":
				var zb0079 int
				zb0079, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Clawback")
					return
				}
				if zb0079 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0079), uint64(maxAddressBytes))
					return
				}
				(*z).Clawback, bts, err = msgp.ReadBytesBytes(bts, (*z).Clawback)
				if err != nil {
					err = msgp.WrapError(err, "Clawback")
					return
				}
			case "cbm":
				{
					var zb0080 []byte
					var zb0081 int
					zb0081, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClawback")
						return
					}
					if zb0081 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0081), uint64(maxBitmaskSize))
						return
					}
					zb0080, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskClawback))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClawback")
						return
					}
					(*z).BitmaskClawback = bitmask(zb0080)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedAssetParams) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetParams)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedAssetParams) Msgsize() (s int) {
	s = 3 + 2 + msgp.ArrayHeaderSize + (len((*z).Total) * (msgp.Uint64Size)) + 4 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskTotal)) + 3 + msgp.ArrayHeaderSize + (len((*z).Decimals) * (msgp.Uint32Size)) + 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskDecimals)) + 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskDefaultFrozen)) + 3 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).UnitName {
		s += msgp.StringPrefixSize + len((*z).UnitName[zb0003])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskUnitName)) + 3 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).AssetName {
		s += msgp.StringPrefixSize + len((*z).AssetName[zb0004])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskAssetName)) + 3 + msgp.ArrayHeaderSize
	for zb0005 := range (*z).URL {
		s += msgp.StringPrefixSize + len((*z).URL[zb0005])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskURL)) + 3 + msgp.BytesPrefixSize + len((*z).MetadataHash) + 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskMetadataHash)) + 2 + msgp.BytesPrefixSize + len((*z).Manager) + 4 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskManager)) + 2 + msgp.BytesPrefixSize + len((*z).Reserve) + 4 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskReserve)) + 2 + msgp.BytesPrefixSize + len((*z).Freeze) + 4 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskFreeze)) + 2 + msgp.BytesPrefixSize + len((*z).Clawback) + 4 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskClawback))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedAssetParams) MsgIsZero() bool {
	return (len((*z).Total) == 0) && (len((*z).BitmaskTotal) == 0) && (len((*z).Decimals) == 0) && (len((*z).BitmaskDecimals) == 0) && (len((*z).BitmaskDefaultFrozen) == 0) && (len((*z).UnitName) == 0) && (len((*z).BitmaskUnitName) == 0) && (len((*z).AssetName) == 0) && (len((*z).BitmaskAssetName) == 0) && (len((*z).URL) == 0) && (len((*z).BitmaskURL) == 0) && (len((*z).MetadataHash) == 0) && (len((*z).BitmaskMetadataHash) == 0) && (len((*z).Manager) == 0) && (len((*z).BitmaskManager) == 0) && (len((*z).Reserve) == 0) && (len((*z).BitmaskReserve) == 0) && (len((*z).Freeze) == 0) && (len((*z).BitmaskFreeze) == 0) && (len((*z).Clawback) == 0) && (len((*z).BitmaskClawback) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedAssetTransferTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(10)
	var zb0003Mask uint16 /* 11 bits */
	if len((*z).AssetAmount) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if len((*z).BitmaskAssetAmount) == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if len((*z).AssetCloseTo) == 0 {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if len((*z).BitmaskAssetCloseTo) == 0 {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if len((*z).AssetReceiver) == 0 {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if len((*z).BitmaskAssetReceiver) == 0 {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	if len((*z).AssetSender) == 0 {
		zb0003Len--
		zb0003Mask |= 0x80
	}
	if len((*z).BitmaskAssetSender) == 0 {
		zb0003Len--
		zb0003Mask |= 0x100
	}
	if len((*z).XferAsset) == 0 {
		zb0003Len--
		zb0003Mask |= 0x200
	}
	if len((*z).BitmaskXferAsset) == 0 {
		zb0003Len--
		zb0003Mask |= 0x400
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "aamt"
			o = append(o, 0xa4, 0x61, 0x61, 0x6d, 0x74)
			if (*z).AssetAmount == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).AssetAmount)))
			}
			for zb0002 := range (*z).AssetAmount {
				o = msgp.AppendUint64(o, (*z).AssetAmount[zb0002])
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "aamtbm"
			o = append(o, 0xa6, 0x61, 0x61, 0x6d, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskAssetAmount))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "aclose"
			o = append(o, 0xa6, 0x61, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			o = msgp.AppendBytes(o, (*z).AssetCloseTo)
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "aclosebm"
			o = append(o, 0xa8, 0x61, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskAssetCloseTo))
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "arcv"
			o = append(o, 0xa4, 0x61, 0x72, 0x63, 0x76)
			o = msgp.AppendBytes(o, (*z).AssetReceiver)
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "arcvbm"
			o = append(o, 0xa6, 0x61, 0x72, 0x63, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskAssetReceiver))
		}
		if (zb0003Mask & 0x80) == 0 { // if not empty
			// string "asnd"
			o = append(o, 0xa4, 0x61, 0x73, 0x6e, 0x64)
			o = msgp.AppendBytes(o, (*z).AssetSender)
		}
		if (zb0003Mask & 0x100) == 0 { // if not empty
			// string "asndbm"
			o = append(o, 0xa6, 0x61, 0x73, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskAssetSender))
		}
		if (zb0003Mask & 0x200) == 0 { // if not empty
			// string "xaid"
			o = append(o, 0xa4, 0x78, 0x61, 0x69, 0x64)
			if (*z).XferAsset == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).XferAsset)))
			}
			for zb0001 := range (*z).XferAsset {
				o = (*z).XferAsset[zb0001].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x400) == 0 { // if not empty
			// string "xaidbm"
			o = append(o, 0xa6, 0x78, 0x61, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskXferAsset))
		}
	}
	return
}

func (_ *encodedAssetTransferTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetTransferTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedAssetTransferTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "XferAsset")
				return
			}
			if zb0005 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0005), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "XferAsset")
				return
			}
			if zb0006 {
				(*z).XferAsset = nil
			} else if (*z).XferAsset != nil && cap((*z).XferAsset) >= zb0005 {
				(*z).XferAsset = ((*z).XferAsset)[:zb0005]
			} else {
				(*z).XferAsset = make([]basics.AssetIndex, zb0005)
			}
			for zb0001 := range (*z).XferAsset {
				bts, err = (*z).XferAsset[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "XferAsset", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0007 []byte
				var zb0008 int
				zb0008, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskXferAsset")
					return
				}
				if zb0008 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0008), uint64(maxBitmaskSize))
					return
				}
				zb0007, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskXferAsset))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskXferAsset")
					return
				}
				(*z).BitmaskXferAsset = bitmask(zb0007)
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetAmount")
				return
			}
			if zb0009 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "AssetAmount")
				return
			}
			if zb0010 {
				(*z).AssetAmount = nil
			} else if (*z).AssetAmount != nil && cap((*z).AssetAmount) >= zb0009 {
				(*z).AssetAmount = ((*z).AssetAmount)[:zb0009]
			} else {
				(*z).AssetAmount = make([]uint64, zb0009)
			}
			for zb0002 := range (*z).AssetAmount {
				(*z).AssetAmount[zb0002], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AssetAmount", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0011 []byte
				var zb0012 int
				zb0012, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetAmount")
					return
				}
				if zb0012 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0012), uint64(maxBitmaskSize))
					return
				}
				zb0011, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAssetAmount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetAmount")
					return
				}
				(*z).BitmaskAssetAmount = bitmask(zb0011)
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0013 int
			zb0013, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetSender")
				return
			}
			if zb0013 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0013), uint64(maxAddressBytes))
				return
			}
			(*z).AssetSender, bts, err = msgp.ReadBytesBytes(bts, (*z).AssetSender)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetSender")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0014 []byte
				var zb0015 int
				zb0015, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetSender")
					return
				}
				if zb0015 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0015), uint64(maxBitmaskSize))
					return
				}
				zb0014, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAssetSender))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetSender")
					return
				}
				(*z).BitmaskAssetSender = bitmask(zb0014)
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0016 int
			zb0016, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetReceiver")
				return
			}
			if zb0016 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0016), uint64(maxAddressBytes))
				return
			}
			(*z).AssetReceiver, bts, err = msgp.ReadBytesBytes(bts, (*z).AssetReceiver)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetReceiver")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0017 []byte
				var zb0018 int
				zb0018, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetReceiver")
					return
				}
				if zb0018 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0018), uint64(maxBitmaskSize))
					return
				}
				zb0017, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAssetReceiver))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetReceiver")
					return
				}
				(*z).BitmaskAssetReceiver = bitmask(zb0017)
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0019 int
			zb0019, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetCloseTo")
				return
			}
			if zb0019 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0019), uint64(maxAddressBytes))
				return
			}
			(*z).AssetCloseTo, bts, err = msgp.ReadBytesBytes(bts, (*z).AssetCloseTo)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetCloseTo")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0020 []byte
				var zb0021 int
				zb0021, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetCloseTo")
					return
				}
				if zb0021 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0021), uint64(maxBitmaskSize))
					return
				}
				zb0020, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAssetCloseTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetCloseTo")
					return
				}
				(*z).BitmaskAssetCloseTo = bitmask(zb0020)
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = encodedAssetTransferTxnFields{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "xaid":
				var zb0022 int
				var zb0023 bool
				zb0022, zb0023, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "XferAsset")
					return
				}
				if zb0022 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0022), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "XferAsset")
					return
				}
				if zb0023 {
					(*z).XferAsset = nil
				} else if (*z).XferAsset != nil && cap((*z).XferAsset) >= zb0022 {
					(*z).XferAsset = ((*z).XferAsset)[:zb0022]
				} else {
					(*z).XferAsset = make([]basics.AssetIndex, zb0022)
				}
				for zb0001 := range (*z).XferAsset {
					bts, err = (*z).XferAsset[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "XferAsset", zb0001)
						return
					}
				}
			case "xaidbm":
				{
					var zb0024 []byte
					var zb0025 int
					zb0025, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskXferAsset")
						return
					}
					if zb0025 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0025), uint64(maxBitmaskSize))
						return
					}
					zb0024, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskXferAsset))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskXferAsset")
						return
					}
					(*z).BitmaskXferAsset = bitmask(zb0024)
				}
			case "aamt":
				var zb0026 int
				var zb0027 bool
				zb0026, zb0027, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetAmount")
					return
				}
				if zb0026 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0026), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "AssetAmount")
					return
				}
				if zb0027 {
					(*z).AssetAmount = nil
				} else if (*z).AssetAmount != nil && cap((*z).AssetAmount) >= zb0026 {
					(*z).AssetAmount = ((*z).AssetAmount)[:zb0026]
				} else {
					(*z).AssetAmount = make([]uint64, zb0026)
				}
				for zb0002 := range (*z).AssetAmount {
					(*z).AssetAmount[zb0002], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AssetAmount", zb0002)
						return
					}
				}
			case "aamtbm":
				{
					var zb0028 []byte
					var zb0029 int
					zb0029, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetAmount")
						return
					}
					if zb0029 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0029), uint64(maxBitmaskSize))
						return
					}
					zb0028, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAssetAmount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetAmount")
						return
					}
					(*z).BitmaskAssetAmount = bitmask(zb0028)
				}
			case "asnd":
				var zb0030 int
				zb0030, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetSender")
					return
				}
				if zb0030 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0030), uint64(maxAddressBytes))
					return
				}
				(*z).AssetSender, bts, err = msgp.ReadBytesBytes(bts, (*z).AssetSender)
				if err != nil {
					err = msgp.WrapError(err, "AssetSender")
					return
				}
			case "asndbm":
				{
					var zb0031 []byte
					var zb0032 int
					zb0032, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetSender")
						return
					}
					if zb0032 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0032), uint64(maxBitmaskSize))
						return
					}
					zb0031, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAssetSender))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetSender")
						return
					}
					(*z).BitmaskAssetSender = bitmask(zb0031)
				}
			case "arcv":
				var zb0033 int
				zb0033, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetReceiver")
					return
				}
				if zb0033 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0033), uint64(maxAddressBytes))
					return
				}
				(*z).AssetReceiver, bts, err = msgp.ReadBytesBytes(bts, (*z).AssetReceiver)
				if err != nil {
					err = msgp.WrapError(err, "AssetReceiver")
					return
				}
			case "arcvbm":
				{
					var zb0034 []byte
					var zb0035 int
					zb0035, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetReceiver")
						return
					}
					if zb0035 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0035), uint64(maxBitmaskSize))
						return
					}
					zb0034, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAssetReceiver))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetReceiver")
						return
					}
					(*z).BitmaskAssetReceiver = bitmask(zb0034)
				}
			case "aclose":
				var zb0036 int
				zb0036, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetCloseTo")
					return
				}
				if zb0036 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0036), uint64(maxAddressBytes))
					return
				}
				(*z).AssetCloseTo, bts, err = msgp.ReadBytesBytes(bts, (*z).AssetCloseTo)
				if err != nil {
					err = msgp.WrapError(err, "AssetCloseTo")
					return
				}
			case "aclosebm":
				{
					var zb0037 []byte
					var zb0038 int
					zb0038, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetCloseTo")
						return
					}
					if zb0038 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0038), uint64(maxBitmaskSize))
						return
					}
					zb0037, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAssetCloseTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetCloseTo")
						return
					}
					(*z).BitmaskAssetCloseTo = bitmask(zb0037)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedAssetTransferTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetTransferTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedAssetTransferTxnFields) Msgsize() (s int) {
	s = 1 + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).XferAsset {
		s += (*z).XferAsset[zb0001].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskXferAsset)) + 5 + msgp.ArrayHeaderSize + (len((*z).AssetAmount) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskAssetAmount)) + 5 + msgp.BytesPrefixSize + len((*z).AssetSender) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskAssetSender)) + 5 + msgp.BytesPrefixSize + len((*z).AssetReceiver) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskAssetReceiver)) + 7 + msgp.BytesPrefixSize + len((*z).AssetCloseTo) + 9 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskAssetCloseTo))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedAssetTransferTxnFields) MsgIsZero() bool {
	return (len((*z).XferAsset) == 0) && (len((*z).BitmaskXferAsset) == 0) && (len((*z).AssetAmount) == 0) && (len((*z).BitmaskAssetAmount) == 0) && (len((*z).AssetSender) == 0) && (len((*z).BitmaskAssetSender) == 0) && (len((*z).AssetReceiver) == 0) && (len((*z).BitmaskAssetReceiver) == 0) && (len((*z).AssetCloseTo) == 0) && (len((*z).BitmaskAssetCloseTo) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedBloomFilter) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 5 bits */
	if (*z).ClearPrevious == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if len((*z).BloomFilter) == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if ((*z).EncodingParams.Offset == 0) && ((*z).EncodingParams.Modulator == 0) {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).BloomFilterType == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "c"
			o = append(o, 0xa1, 0x63)
			o = msgp.AppendByte(o, (*z).ClearPrevious)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "f"
			o = append(o, 0xa1, 0x66)
			o = msgp.AppendBytes(o, (*z).BloomFilter)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "p"
			o = append(o, 0xa1, 0x70)
			// omitempty: check for empty values
			zb0002Len := uint32(2)
			var zb0002Mask uint8 /* 3 bits */
			if (*z).EncodingParams.Modulator == 0 {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			if (*z).EncodingParams.Offset == 0 {
				zb0002Len--
				zb0002Mask |= 0x4
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x2) == 0 { // if not empty
				// string "m"
				o = append(o, 0xa1, 0x6d)
				o = msgp.AppendByte(o, (*z).EncodingParams.Modulator)
			}
			if (zb0002Mask & 0x4) == 0 { // if not empty
				// string "o"
				o = append(o, 0xa1, 0x6f)
				o = msgp.AppendByte(o, (*z).EncodingParams.Offset)
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			o = msgp.AppendByte(o, (*z).BloomFilterType)
		}
	}
	return
}

func (_ *encodedBloomFilter) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedBloomFilter)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedBloomFilter) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).BloomFilterType, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BloomFilterType")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0003 int
			var zb0004 bool
			zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EncodingParams")
					return
				}
				if zb0003 > 0 {
					zb0003--
					(*z).EncodingParams.Offset, bts, err = msgp.ReadByteBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "struct-from-array", "Offset")
						return
					}
				}
				if zb0003 > 0 {
					zb0003--
					(*z).EncodingParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "struct-from-array", "Modulator")
						return
					}
				}
				if zb0003 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0003)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EncodingParams")
					return
				}
				if zb0004 {
					(*z).EncodingParams = requestParams{}
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "EncodingParams")
						return
					}
					switch string(field) {
					case "o":
						(*z).EncodingParams.Offset, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "Offset")
							return
						}
					case "m":
						(*z).EncodingParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "Modulator")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "EncodingParams")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0005 int
			zb0005, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BloomFilter")
				return
			}
			if zb0005 > maxBloomFilterSize {
				err = msgp.ErrOverflow(uint64(zb0005), uint64(maxBloomFilterSize))
				return
			}
			(*z).BloomFilter, bts, err = msgp.ReadBytesBytes(bts, (*z).BloomFilter)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BloomFilter")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).ClearPrevious, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ClearPrevious")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = encodedBloomFilter{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "t":
				(*z).BloomFilterType, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BloomFilterType")
					return
				}
			case "p":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "EncodingParams")
						return
					}
					if zb0006 > 0 {
						zb0006--
						(*z).EncodingParams.Offset, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "EncodingParams", "struct-from-array", "Offset")
							return
						}
					}
					if zb0006 > 0 {
						zb0006--
						(*z).EncodingParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "EncodingParams", "struct-from-array", "Modulator")
							return
						}
					}
					if zb0006 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0006)
						if err != nil {
							err = msgp.WrapError(err, "EncodingParams", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "EncodingParams")
						return
					}
					if zb0007 {
						(*z).EncodingParams = requestParams{}
					}
					for zb0006 > 0 {
						zb0006--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "EncodingParams")
							return
						}
						switch string(field) {
						case "o":
							(*z).EncodingParams.Offset, bts, err = msgp.ReadByteBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "EncodingParams", "Offset")
								return
							}
						case "m":
							(*z).EncodingParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "EncodingParams", "Modulator")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "EncodingParams")
								return
							}
						}
					}
				}
			case "f":
				var zb0008 int
				zb0008, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "BloomFilter")
					return
				}
				if zb0008 > maxBloomFilterSize {
					err = msgp.ErrOverflow(uint64(zb0008), uint64(maxBloomFilterSize))
					return
				}
				(*z).BloomFilter, bts, err = msgp.ReadBytesBytes(bts, (*z).BloomFilter)
				if err != nil {
					err = msgp.WrapError(err, "BloomFilter")
					return
				}
			case "c":
				(*z).ClearPrevious, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ClearPrevious")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedBloomFilter) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedBloomFilter)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedBloomFilter) Msgsize() (s int) {
	s = 1 + 2 + msgp.ByteSize + 2 + 1 + 2 + msgp.ByteSize + 2 + msgp.ByteSize + 2 + msgp.BytesPrefixSize + len((*z).BloomFilter) + 2 + msgp.ByteSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedBloomFilter) MsgIsZero() bool {
	return ((*z).BloomFilterType == 0) && (((*z).EncodingParams.Offset == 0) && ((*z).EncodingParams.Modulator == 0)) && (len((*z).BloomFilter) == 0) && ((*z).ClearPrevious == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedCert) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0012Len := uint32(14)
	var zb0012Mask uint16 /* 15 bits */
	if len((*z).PartProofs) == 0 {
		zb0012Len--
		zb0012Mask |= 0x2
	}
	if len((*z).PartProofHashTypes) == 0 {
		zb0012Len--
		zb0012Mask |= 0x4
	}
	if len((*z).BitmaskPartHash) == 0 {
		zb0012Len--
		zb0012Mask |= 0x8
	}
	if len((*z).BitmaskPartProofs) == 0 {
		zb0012Len--
		zb0012Mask |= 0x10
	}
	if len((*z).SigProofs) == 0 {
		zb0012Len--
		zb0012Mask |= 0x20
	}
	if len((*z).SigProofHashTypes) == 0 {
		zb0012Len--
		zb0012Mask |= 0x40
	}
	if len((*z).BitmaskSigsHash) == 0 {
		zb0012Len--
		zb0012Mask |= 0x80
	}
	if len((*z).BitmaskSigProofs) == 0 {
		zb0012Len--
		zb0012Mask |= 0x100
	}
	if len((*z).SigCommit) == 0 {
		zb0012Len--
		zb0012Mask |= 0x200
	}
	if len((*z).BitmaskSigCommit) == 0 {
		zb0012Len--
		zb0012Mask |= 0x400
	}
	if len((*z).Reveals) == 0 {
		zb0012Len--
		zb0012Mask |= 0x800
	}
	if len((*z).BitmaskReveals) == 0 {
		zb0012Len--
		zb0012Mask |= 0x1000
	}
	if len((*z).SignedWeight) == 0 {
		zb0012Len--
		zb0012Mask |= 0x2000
	}
	if len((*z).BitmaskSignedWeight) == 0 {
		zb0012Len--
		zb0012Mask |= 0x4000
	}
	// variable map header, size zb0012Len
	o = append(o, 0x80|uint8(zb0012Len))
	if zb0012Len != 0 {
		if (zb0012Mask & 0x2) == 0 { // if not empty
			// string "certP"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x50)
			if (*z).PartProofs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).PartProofs)))
			}
			for zb0006 := range (*z).PartProofs {
				if (*z).PartProofs[zb0006] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).PartProofs[zb0006])))
				}
				for zb0007 := range (*z).PartProofs[zb0006] {
					o = (*z).PartProofs[zb0006][zb0007].MarshalMsg(o)
				}
			}
		}
		if (zb0012Mask & 0x4) == 0 { // if not empty
			// string "certPH"
			o = append(o, 0xa6, 0x63, 0x65, 0x72, 0x74, 0x50, 0x48)
			if (*z).PartProofHashTypes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).PartProofHashTypes)))
			}
			for zb0008 := range (*z).PartProofHashTypes {
				o = msgp.AppendUint64(o, (*z).PartProofHashTypes[zb0008])
			}
		}
		if (zb0012Mask & 0x8) == 0 { // if not empty
			// string "certPHbm"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x50, 0x48, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskPartHash))
		}
		if (zb0012Mask & 0x10) == 0 { // if not empty
			// string "certPbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x50, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskPartProofs))
		}
		if (zb0012Mask & 0x20) == 0 { // if not empty
			// string "certS"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x53)
			if (*z).SigProofs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).SigProofs)))
			}
			for zb0003 := range (*z).SigProofs {
				if (*z).SigProofs[zb0003] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).SigProofs[zb0003])))
				}
				for zb0004 := range (*z).SigProofs[zb0003] {
					o = (*z).SigProofs[zb0003][zb0004].MarshalMsg(o)
				}
			}
		}
		if (zb0012Mask & 0x40) == 0 { // if not empty
			// string "certSH"
			o = append(o, 0xa6, 0x63, 0x65, 0x72, 0x74, 0x53, 0x48)
			if (*z).SigProofHashTypes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).SigProofHashTypes)))
			}
			for zb0005 := range (*z).SigProofHashTypes {
				o = msgp.AppendUint64(o, (*z).SigProofHashTypes[zb0005])
			}
		}
		if (zb0012Mask & 0x80) == 0 { // if not empty
			// string "certSHbm"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x53, 0x48, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskSigsHash))
		}
		if (zb0012Mask & 0x100) == 0 { // if not empty
			// string "certSbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x53, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskSigProofs))
		}
		if (zb0012Mask & 0x200) == 0 { // if not empty
			// string "certc"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x63)
			if (*z).SigCommit == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).SigCommit)))
			}
			for zb0001 := range (*z).SigCommit {
				o = (*z).SigCommit[zb0001].MarshalMsg(o)
			}
		}
		if (zb0012Mask & 0x400) == 0 { // if not empty
			// string "certcbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskSigCommit))
		}
		if (zb0012Mask & 0x800) == 0 { // if not empty
			// string "certr"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x72)
			if (*z).Reveals == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Reveals)))
			}
			for zb0009 := range (*z).Reveals {
				if (*z).Reveals[zb0009] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendMapHeader(o, uint32(len((*z).Reveals[zb0009])))
				}
				zb0010_keys := make([]uint64, 0, len((*z).Reveals[zb0009]))
				for zb0010 := range (*z).Reveals[zb0009] {
					zb0010_keys = append(zb0010_keys, zb0010)
				}
				sort.Sort(SortUint64(zb0010_keys))
				for _, zb0010 := range zb0010_keys {
					zb0011 := (*z).Reveals[zb0009][zb0010]
					_ = zb0011
					o = msgp.AppendUint64(o, zb0010)
					o = zb0011.MarshalMsg(o)
				}
			}
		}
		if (zb0012Mask & 0x1000) == 0 { // if not empty
			// string "certrbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskReveals))
		}
		if (zb0012Mask & 0x2000) == 0 { // if not empty
			// string "certw"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x77)
			if (*z).SignedWeight == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).SignedWeight)))
			}
			for zb0002 := range (*z).SignedWeight {
				o = msgp.AppendUint64(o, (*z).SignedWeight[zb0002])
			}
		}
		if (zb0012Mask & 0x4000) == 0 { // if not empty
			// string "certwbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x77, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskSignedWeight))
		}
	}
	return
}

func (_ *encodedCert) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedCert)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedCert) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0012 int
	var zb0013 bool
	zb0012, zb0013, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0012, zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0012 > 0 {
			zb0012--
			var zb0014 int
			var zb0015 bool
			zb0014, zb0015, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigCommit")
				return
			}
			if zb0014 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0014), uint64(maxAddressBytes))
				err = msgp.WrapError(err, "struct-from-array", "SigCommit")
				return
			}
			if zb0015 {
				(*z).SigCommit = nil
			} else if (*z).SigCommit != nil && cap((*z).SigCommit) >= zb0014 {
				(*z).SigCommit = ((*z).SigCommit)[:zb0014]
			} else {
				(*z).SigCommit = make([]crypto.GenericDigest, zb0014)
			}
			for zb0001 := range (*z).SigCommit {
				bts, err = (*z).SigCommit[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigCommit", zb0001)
					return
				}
			}
		}
		if zb0012 > 0 {
			zb0012--
			{
				var zb0016 []byte
				var zb0017 int
				zb0017, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigCommit")
					return
				}
				if zb0017 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0017), uint64(maxBitmaskSize))
					return
				}
				zb0016, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSigCommit))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigCommit")
					return
				}
				(*z).BitmaskSigCommit = bitmask(zb0016)
			}
		}
		if zb0012 > 0 {
			zb0012--
			var zb0018 int
			var zb0019 bool
			zb0018, zb0019, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SignedWeight")
				return
			}
			if zb0018 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0018), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SignedWeight")
				return
			}
			if zb0019 {
				(*z).SignedWeight = nil
			} else if (*z).SignedWeight != nil && cap((*z).SignedWeight) >= zb0018 {
				(*z).SignedWeight = ((*z).SignedWeight)[:zb0018]
			} else {
				(*z).SignedWeight = make([]uint64, zb0018)
			}
			for zb0002 := range (*z).SignedWeight {
				(*z).SignedWeight[zb0002], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedWeight", zb0002)
					return
				}
			}
		}
		if zb0012 > 0 {
			zb0012--
			{
				var zb0020 []byte
				var zb0021 int
				zb0021, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSignedWeight")
					return
				}
				if zb0021 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0021), uint64(maxBitmaskSize))
					return
				}
				zb0020, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSignedWeight))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSignedWeight")
					return
				}
				(*z).BitmaskSignedWeight = bitmask(zb0020)
			}
		}
		if zb0012 > 0 {
			zb0012--
			var zb0022 int
			var zb0023 bool
			zb0022, zb0023, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigProofs")
				return
			}
			if zb0022 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0022), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SigProofs")
				return
			}
			if zb0023 {
				(*z).SigProofs = nil
			} else if (*z).SigProofs != nil && cap((*z).SigProofs) >= zb0022 {
				(*z).SigProofs = ((*z).SigProofs)[:zb0022]
			} else {
				(*z).SigProofs = make([]certProofs, zb0022)
			}
			for zb0003 := range (*z).SigProofs {
				var zb0024 int
				var zb0025 bool
				zb0024, zb0025, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0003)
					return
				}
				if zb0024 > compactcert.MaxProofDigests {
					err = msgp.ErrOverflow(uint64(zb0024), uint64(compactcert.MaxProofDigests))
					err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0003)
					return
				}
				if zb0025 {
					(*z).SigProofs[zb0003] = nil
				} else if (*z).SigProofs[zb0003] != nil && cap((*z).SigProofs[zb0003]) >= zb0024 {
					(*z).SigProofs[zb0003] = ((*z).SigProofs[zb0003])[:zb0024]
				} else {
					(*z).SigProofs[zb0003] = make(certProofs, zb0024)
				}
				for zb0004 := range (*z).SigProofs[zb0003] {
					bts, err = (*z).SigProofs[zb0003][zb0004].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0003, zb0004)
						return
					}
				}
			}
		}
		if zb0012 > 0 {
			zb0012--
			{
				var zb0026 []byte
				var zb0027 int
				zb0027, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigProofs")
					return
				}
				if zb0027 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0027), uint64(maxBitmaskSize))
					return
				}
				zb0026, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSigProofs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigProofs")
					return
				}
				(*z).BitmaskSigProofs = bitmask(zb0026)
			}
		}
		if zb0012 > 0 {
			zb0012--
			var zb0028 int
			var zb0029 bool
			zb0028, zb0029, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes")
				return
			}
			if zb0028 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0028), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes")
				return
			}
			if zb0029 {
				(*z).SigProofHashTypes = nil
			} else if (*z).SigProofHashTypes != nil && cap((*z).SigProofHashTypes) >= zb0028 {
				(*z).SigProofHashTypes = ((*z).SigProofHashTypes)[:zb0028]
			} else {
				(*z).SigProofHashTypes = make([]uint64, zb0028)
			}
			for zb0005 := range (*z).SigProofHashTypes {
				(*z).SigProofHashTypes[zb0005], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes", zb0005)
					return
				}
			}
		}
		if zb0012 > 0 {
			zb0012--
			{
				var zb0030 []byte
				var zb0031 int
				zb0031, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigsHash")
					return
				}
				if zb0031 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0031), uint64(maxBitmaskSize))
					return
				}
				zb0030, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSigsHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigsHash")
					return
				}
				(*z).BitmaskSigsHash = bitmask(zb0030)
			}
		}
		if zb0012 > 0 {
			zb0012--
			var zb0032 int
			var zb0033 bool
			zb0032, zb0033, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PartProofs")
				return
			}
			if zb0032 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0032), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "PartProofs")
				return
			}
			if zb0033 {
				(*z).PartProofs = nil
			} else if (*z).PartProofs != nil && cap((*z).PartProofs) >= zb0032 {
				(*z).PartProofs = ((*z).PartProofs)[:zb0032]
			} else {
				(*z).PartProofs = make([]certProofs, zb0032)
			}
			for zb0006 := range (*z).PartProofs {
				var zb0034 int
				var zb0035 bool
				zb0034, zb0035, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0006)
					return
				}
				if zb0034 > compactcert.MaxProofDigests {
					err = msgp.ErrOverflow(uint64(zb0034), uint64(compactcert.MaxProofDigests))
					err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0006)
					return
				}
				if zb0035 {
					(*z).PartProofs[zb0006] = nil
				} else if (*z).PartProofs[zb0006] != nil && cap((*z).PartProofs[zb0006]) >= zb0034 {
					(*z).PartProofs[zb0006] = ((*z).PartProofs[zb0006])[:zb0034]
				} else {
					(*z).PartProofs[zb0006] = make(certProofs, zb0034)
				}
				for zb0007 := range (*z).PartProofs[zb0006] {
					bts, err = (*z).PartProofs[zb0006][zb0007].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0006, zb0007)
						return
					}
				}
			}
		}
		if zb0012 > 0 {
			zb0012--
			{
				var zb0036 []byte
				var zb0037 int
				zb0037, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartProofs")
					return
				}
				if zb0037 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0037), uint64(maxBitmaskSize))
					return
				}
				zb0036, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskPartProofs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartProofs")
					return
				}
				(*z).BitmaskPartProofs = bitmask(zb0036)
			}
		}
		if zb0012 > 0 {
			zb0012--
			var zb0038 int
			var zb0039 bool
			zb0038, zb0039, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes")
				return
			}
			if zb0038 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0038), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes")
				return
			}
			if zb0039 {
				(*z).PartProofHashTypes = nil
			} else if (*z).PartProofHashTypes != nil && cap((*z).PartProofHashTypes) >= zb0038 {
				(*z).PartProofHashTypes = ((*z).PartProofHashTypes)[:zb0038]
			} else {
				(*z).PartProofHashTypes = make([]uint64, zb0038)
			}
			for zb0008 := range (*z).PartProofHashTypes {
				(*z).PartProofHashTypes[zb0008], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes", zb0008)
					return
				}
			}
		}
		if zb0012 > 0 {
			zb0012--
			{
				var zb0040 []byte
				var zb0041 int
				zb0041, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartHash")
					return
				}
				if zb0041 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0041), uint64(maxBitmaskSize))
					return
				}
				zb0040, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskPartHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartHash")
					return
				}
				(*z).BitmaskPartHash = bitmask(zb0040)
			}
		}
		if zb0012 > 0 {
			zb0012--
			var zb0042 int
			var zb0043 bool
			zb0042, zb0043, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reveals")
				return
			}
			if zb0042 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0042), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Reveals")
				return
			}
			if zb0043 {
				(*z).Reveals = nil
			} else if (*z).Reveals != nil && cap((*z).Reveals) >= zb0042 {
				(*z).Reveals = ((*z).Reveals)[:zb0042]
			} else {
				(*z).Reveals = make([]revealMap, zb0042)
			}
			for zb0009 := range (*z).Reveals {
				var zb0044 int
				var zb0045 bool
				zb0044, zb0045, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0009)
					return
				}
				if zb0044 > compactcert.MaxReveals {
					err = msgp.ErrOverflow(uint64(zb0044), uint64(compactcert.MaxReveals))
					err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0009)
					return
				}
				if zb0045 {
					(*z).Reveals[zb0009] = nil
				} else if (*z).Reveals[zb0009] == nil {
					(*z).Reveals[zb0009] = make(revealMap, zb0044)
				}
				for zb0044 > 0 {
					var zb0010 uint64
					var zb0011 compactcert.Reveal
					zb0044--
					zb0010, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0009)
						return
					}
					bts, err = zb0011.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0009, zb0010)
						return
					}
					(*z).Reveals[zb0009][zb0010] = zb0011
				}
			}
		}
		if zb0012 > 0 {
			zb0012--
			{
				var zb0046 []byte
				var zb0047 int
				zb0047, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReveals")
					return
				}
				if zb0047 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0047), uint64(maxBitmaskSize))
					return
				}
				zb0046, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskReveals))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReveals")
					return
				}
				(*z).BitmaskReveals = bitmask(zb0046)
			}
		}
		if zb0012 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0012)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0013 {
			(*z) = encodedCert{}
		}
		for zb0012 > 0 {
			zb0012--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "certc":
				var zb0048 int
				var zb0049 bool
				zb0048, zb0049, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigCommit")
					return
				}
				if zb0048 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0048), uint64(maxAddressBytes))
					err = msgp.WrapError(err, "SigCommit")
					return
				}
				if zb0049 {
					(*z).SigCommit = nil
				} else if (*z).SigCommit != nil && cap((*z).SigCommit) >= zb0048 {
					(*z).SigCommit = ((*z).SigCommit)[:zb0048]
				} else {
					(*z).SigCommit = make([]crypto.GenericDigest, zb0048)
				}
				for zb0001 := range (*z).SigCommit {
					bts, err = (*z).SigCommit[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigCommit", zb0001)
						return
					}
				}
			case "certcbm":
				{
					var zb0050 []byte
					var zb0051 int
					zb0051, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigCommit")
						return
					}
					if zb0051 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0051), uint64(maxBitmaskSize))
						return
					}
					zb0050, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSigCommit))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigCommit")
						return
					}
					(*z).BitmaskSigCommit = bitmask(zb0050)
				}
			case "certw":
				var zb0052 int
				var zb0053 bool
				zb0052, zb0053, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SignedWeight")
					return
				}
				if zb0052 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0052), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SignedWeight")
					return
				}
				if zb0053 {
					(*z).SignedWeight = nil
				} else if (*z).SignedWeight != nil && cap((*z).SignedWeight) >= zb0052 {
					(*z).SignedWeight = ((*z).SignedWeight)[:zb0052]
				} else {
					(*z).SignedWeight = make([]uint64, zb0052)
				}
				for zb0002 := range (*z).SignedWeight {
					(*z).SignedWeight[zb0002], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedWeight", zb0002)
						return
					}
				}
			case "certwbm":
				{
					var zb0054 []byte
					var zb0055 int
					zb0055, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSignedWeight")
						return
					}
					if zb0055 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0055), uint64(maxBitmaskSize))
						return
					}
					zb0054, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSignedWeight))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSignedWeight")
						return
					}
					(*z).BitmaskSignedWeight = bitmask(zb0054)
				}
			case "certS":
				var zb0056 int
				var zb0057 bool
				zb0056, zb0057, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigProofs")
					return
				}
				if zb0056 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0056), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SigProofs")
					return
				}
				if zb0057 {
					(*z).SigProofs = nil
				} else if (*z).SigProofs != nil && cap((*z).SigProofs) >= zb0056 {
					(*z).SigProofs = ((*z).SigProofs)[:zb0056]
				} else {
					(*z).SigProofs = make([]certProofs, zb0056)
				}
				for zb0003 := range (*z).SigProofs {
					var zb0058 int
					var zb0059 bool
					zb0058, zb0059, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigProofs", zb0003)
						return
					}
					if zb0058 > compactcert.MaxProofDigests {
						err = msgp.ErrOverflow(uint64(zb0058), uint64(compactcert.MaxProofDigests))
						err = msgp.WrapError(err, "SigProofs", zb0003)
						return
					}
					if zb0059 {
						(*z).SigProofs[zb0003] = nil
					} else if (*z).SigProofs[zb0003] != nil && cap((*z).SigProofs[zb0003]) >= zb0058 {
						(*z).SigProofs[zb0003] = ((*z).SigProofs[zb0003])[:zb0058]
					} else {
						(*z).SigProofs[zb0003] = make(certProofs, zb0058)
					}
					for zb0004 := range (*z).SigProofs[zb0003] {
						bts, err = (*z).SigProofs[zb0003][zb0004].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SigProofs", zb0003, zb0004)
							return
						}
					}
				}
			case "certSbm":
				{
					var zb0060 []byte
					var zb0061 int
					zb0061, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigProofs")
						return
					}
					if zb0061 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0061), uint64(maxBitmaskSize))
						return
					}
					zb0060, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSigProofs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigProofs")
						return
					}
					(*z).BitmaskSigProofs = bitmask(zb0060)
				}
			case "certSH":
				var zb0062 int
				var zb0063 bool
				zb0062, zb0063, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigProofHashTypes")
					return
				}
				if zb0062 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0062), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SigProofHashTypes")
					return
				}
				if zb0063 {
					(*z).SigProofHashTypes = nil
				} else if (*z).SigProofHashTypes != nil && cap((*z).SigProofHashTypes) >= zb0062 {
					(*z).SigProofHashTypes = ((*z).SigProofHashTypes)[:zb0062]
				} else {
					(*z).SigProofHashTypes = make([]uint64, zb0062)
				}
				for zb0005 := range (*z).SigProofHashTypes {
					(*z).SigProofHashTypes[zb0005], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigProofHashTypes", zb0005)
						return
					}
				}
			case "certSHbm":
				{
					var zb0064 []byte
					var zb0065 int
					zb0065, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigsHash")
						return
					}
					if zb0065 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0065), uint64(maxBitmaskSize))
						return
					}
					zb0064, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSigsHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigsHash")
						return
					}
					(*z).BitmaskSigsHash = bitmask(zb0064)
				}
			case "certP":
				var zb0066 int
				var zb0067 bool
				zb0066, zb0067, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PartProofs")
					return
				}
				if zb0066 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0066), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "PartProofs")
					return
				}
				if zb0067 {
					(*z).PartProofs = nil
				} else if (*z).PartProofs != nil && cap((*z).PartProofs) >= zb0066 {
					(*z).PartProofs = ((*z).PartProofs)[:zb0066]
				} else {
					(*z).PartProofs = make([]certProofs, zb0066)
				}
				for zb0006 := range (*z).PartProofs {
					var zb0068 int
					var zb0069 bool
					zb0068, zb0069, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PartProofs", zb0006)
						return
					}
					if zb0068 > compactcert.MaxProofDigests {
						err = msgp.ErrOverflow(uint64(zb0068), uint64(compactcert.MaxProofDigests))
						err = msgp.WrapError(err, "PartProofs", zb0006)
						return
					}
					if zb0069 {
						(*z).PartProofs[zb0006] = nil
					} else if (*z).PartProofs[zb0006] != nil && cap((*z).PartProofs[zb0006]) >= zb0068 {
						(*z).PartProofs[zb0006] = ((*z).PartProofs[zb0006])[:zb0068]
					} else {
						(*z).PartProofs[zb0006] = make(certProofs, zb0068)
					}
					for zb0007 := range (*z).PartProofs[zb0006] {
						bts, err = (*z).PartProofs[zb0006][zb0007].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "PartProofs", zb0006, zb0007)
							return
						}
					}
				}
			case "certPbm":
				{
					var zb0070 []byte
					var zb0071 int
					zb0071, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartProofs")
						return
					}
					if zb0071 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0071), uint64(maxBitmaskSize))
						return
					}
					zb0070, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskPartProofs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartProofs")
						return
					}
					(*z).BitmaskPartProofs = bitmask(zb0070)
				}
			case "certPH":
				var zb0072 int
				var zb0073 bool
				zb0072, zb0073, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PartProofHashTypes")
					return
				}
				if zb0072 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0072), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "PartProofHashTypes")
					return
				}
				if zb0073 {
					(*z).PartProofHashTypes = nil
				} else if (*z).PartProofHashTypes != nil && cap((*z).PartProofHashTypes) >= zb0072 {
					(*z).PartProofHashTypes = ((*z).PartProofHashTypes)[:zb0072]
				} else {
					(*z).PartProofHashTypes = make([]uint64, zb0072)
				}
				for zb0008 := range (*z).PartProofHashTypes {
					(*z).PartProofHashTypes[zb0008], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PartProofHashTypes", zb0008)
						return
					}
				}
			case "certPHbm":
				{
					var zb0074 []byte
					var zb0075 int
					zb0075, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartHash")
						return
					}
					if zb0075 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0075), uint64(maxBitmaskSize))
						return
					}
					zb0074, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskPartHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartHash")
						return
					}
					(*z).BitmaskPartHash = bitmask(zb0074)
				}
			case "certr":
				var zb0076 int
				var zb0077 bool
				zb0076, zb0077, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reveals")
					return
				}
				if zb0076 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0076), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Reveals")
					return
				}
				if zb0077 {
					(*z).Reveals = nil
				} else if (*z).Reveals != nil && cap((*z).Reveals) >= zb0076 {
					(*z).Reveals = ((*z).Reveals)[:zb0076]
				} else {
					(*z).Reveals = make([]revealMap, zb0076)
				}
				for zb0009 := range (*z).Reveals {
					var zb0078 int
					var zb0079 bool
					zb0078, zb0079, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Reveals", zb0009)
						return
					}
					if zb0078 > compactcert.MaxReveals {
						err = msgp.ErrOverflow(uint64(zb0078), uint64(compactcert.MaxReveals))
						err = msgp.WrapError(err, "Reveals", zb0009)
						return
					}
					if zb0079 {
						(*z).Reveals[zb0009] = nil
					} else if (*z).Reveals[zb0009] == nil {
						(*z).Reveals[zb0009] = make(revealMap, zb0078)
					}
					for zb0078 > 0 {
						var zb0010 uint64
						var zb0011 compactcert.Reveal
						zb0078--
						zb0010, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Reveals", zb0009)
							return
						}
						bts, err = zb0011.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Reveals", zb0009, zb0010)
							return
						}
						(*z).Reveals[zb0009][zb0010] = zb0011
					}
				}
			case "certrbm":
				{
					var zb0080 []byte
					var zb0081 int
					zb0081, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReveals")
						return
					}
					if zb0081 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0081), uint64(maxBitmaskSize))
						return
					}
					zb0080, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskReveals))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReveals")
						return
					}
					(*z).BitmaskReveals = bitmask(zb0080)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedCert) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedCert)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedCert) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).SigCommit {
		s += (*z).SigCommit[zb0001].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskSigCommit)) + 6 + msgp.ArrayHeaderSize + (len((*z).SignedWeight) * (msgp.Uint64Size)) + 8 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskSignedWeight)) + 6 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).SigProofs {
		s += msgp.ArrayHeaderSize
		for zb0004 := range (*z).SigProofs[zb0003] {
			s += (*z).SigProofs[zb0003][zb0004].Msgsize()
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskSigProofs)) + 7 + msgp.ArrayHeaderSize + (len((*z).SigProofHashTypes) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskSigsHash)) + 6 + msgp.ArrayHeaderSize
	for zb0006 := range (*z).PartProofs {
		s += msgp.ArrayHeaderSize
		for zb0007 := range (*z).PartProofs[zb0006] {
			s += (*z).PartProofs[zb0006][zb0007].Msgsize()
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskPartProofs)) + 7 + msgp.ArrayHeaderSize + (len((*z).PartProofHashTypes) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskPartHash)) + 6 + msgp.ArrayHeaderSize
	for zb0009 := range (*z).Reveals {
		s += msgp.MapHeaderSize
		if (*z).Reveals[zb0009] != nil {
			for zb0010, zb0011 := range (*z).Reveals[zb0009] {
				_ = zb0010
				_ = zb0011
				s += 0 + msgp.Uint64Size + zb0011.Msgsize()
			}
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskReveals))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedCert) MsgIsZero() bool {
	return (len((*z).SigCommit) == 0) && (len((*z).BitmaskSigCommit) == 0) && (len((*z).SignedWeight) == 0) && (len((*z).BitmaskSignedWeight) == 0) && (len((*z).SigProofs) == 0) && (len((*z).BitmaskSigProofs) == 0) && (len((*z).SigProofHashTypes) == 0) && (len((*z).BitmaskSigsHash) == 0) && (len((*z).PartProofs) == 0) && (len((*z).BitmaskPartProofs) == 0) && (len((*z).PartProofHashTypes) == 0) && (len((*z).BitmaskPartHash) == 0) && (len((*z).Reveals) == 0) && (len((*z).BitmaskReveals) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedCompactCertTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0014Len := uint32(18)
	var zb0014Mask uint32 /* 20 bits */
	if len((*z).encodedCert.PartProofs) == 0 {
		zb0014Len--
		zb0014Mask |= 0x4
	}
	if len((*z).encodedCert.PartProofHashTypes) == 0 {
		zb0014Len--
		zb0014Mask |= 0x8
	}
	if len((*z).encodedCert.BitmaskPartHash) == 0 {
		zb0014Len--
		zb0014Mask |= 0x10
	}
	if len((*z).encodedCert.BitmaskPartProofs) == 0 {
		zb0014Len--
		zb0014Mask |= 0x20
	}
	if len((*z).encodedCert.SigProofs) == 0 {
		zb0014Len--
		zb0014Mask |= 0x40
	}
	if len((*z).encodedCert.SigProofHashTypes) == 0 {
		zb0014Len--
		zb0014Mask |= 0x80
	}
	if len((*z).encodedCert.BitmaskSigsHash) == 0 {
		zb0014Len--
		zb0014Mask |= 0x100
	}
	if len((*z).encodedCert.BitmaskSigProofs) == 0 {
		zb0014Len--
		zb0014Mask |= 0x200
	}
	if len((*z).encodedCert.SigCommit) == 0 {
		zb0014Len--
		zb0014Mask |= 0x400
	}
	if len((*z).encodedCert.BitmaskSigCommit) == 0 {
		zb0014Len--
		zb0014Mask |= 0x800
	}
	if len((*z).encodedCert.Reveals) == 0 {
		zb0014Len--
		zb0014Mask |= 0x1000
	}
	if len((*z).encodedCert.BitmaskReveals) == 0 {
		zb0014Len--
		zb0014Mask |= 0x2000
	}
	if len((*z).CertRound) == 0 {
		zb0014Len--
		zb0014Mask |= 0x4000
	}
	if len((*z).BitmaskCertRound) == 0 {
		zb0014Len--
		zb0014Mask |= 0x8000
	}
	if len((*z).CertType) == 0 {
		zb0014Len--
		zb0014Mask |= 0x10000
	}
	if len((*z).BitmaskCertType) == 0 {
		zb0014Len--
		zb0014Mask |= 0x20000
	}
	if len((*z).encodedCert.SignedWeight) == 0 {
		zb0014Len--
		zb0014Mask |= 0x40000
	}
	if len((*z).encodedCert.BitmaskSignedWeight) == 0 {
		zb0014Len--
		zb0014Mask |= 0x80000
	}
	// variable map header, size zb0014Len
	o = msgp.AppendMapHeader(o, zb0014Len)
	if zb0014Len != 0 {
		if (zb0014Mask & 0x4) == 0 { // if not empty
			// string "certP"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x50)
			if (*z).encodedCert.PartProofs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCert.PartProofs)))
			}
			for zb0008 := range (*z).encodedCert.PartProofs {
				if (*z).encodedCert.PartProofs[zb0008] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCert.PartProofs[zb0008])))
				}
				for zb0009 := range (*z).encodedCert.PartProofs[zb0008] {
					o = (*z).encodedCert.PartProofs[zb0008][zb0009].MarshalMsg(o)
				}
			}
		}
		if (zb0014Mask & 0x8) == 0 { // if not empty
			// string "certPH"
			o = append(o, 0xa6, 0x63, 0x65, 0x72, 0x74, 0x50, 0x48)
			if (*z).encodedCert.PartProofHashTypes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCert.PartProofHashTypes)))
			}
			for zb0010 := range (*z).encodedCert.PartProofHashTypes {
				o = msgp.AppendUint64(o, (*z).encodedCert.PartProofHashTypes[zb0010])
			}
		}
		if (zb0014Mask & 0x10) == 0 { // if not empty
			// string "certPHbm"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x50, 0x48, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCert.BitmaskPartHash))
		}
		if (zb0014Mask & 0x20) == 0 { // if not empty
			// string "certPbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x50, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCert.BitmaskPartProofs))
		}
		if (zb0014Mask & 0x40) == 0 { // if not empty
			// string "certS"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x53)
			if (*z).encodedCert.SigProofs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCert.SigProofs)))
			}
			for zb0005 := range (*z).encodedCert.SigProofs {
				if (*z).encodedCert.SigProofs[zb0005] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCert.SigProofs[zb0005])))
				}
				for zb0006 := range (*z).encodedCert.SigProofs[zb0005] {
					o = (*z).encodedCert.SigProofs[zb0005][zb0006].MarshalMsg(o)
				}
			}
		}
		if (zb0014Mask & 0x80) == 0 { // if not empty
			// string "certSH"
			o = append(o, 0xa6, 0x63, 0x65, 0x72, 0x74, 0x53, 0x48)
			if (*z).encodedCert.SigProofHashTypes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCert.SigProofHashTypes)))
			}
			for zb0007 := range (*z).encodedCert.SigProofHashTypes {
				o = msgp.AppendUint64(o, (*z).encodedCert.SigProofHashTypes[zb0007])
			}
		}
		if (zb0014Mask & 0x100) == 0 { // if not empty
			// string "certSHbm"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x53, 0x48, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCert.BitmaskSigsHash))
		}
		if (zb0014Mask & 0x200) == 0 { // if not empty
			// string "certSbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x53, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCert.BitmaskSigProofs))
		}
		if (zb0014Mask & 0x400) == 0 { // if not empty
			// string "certc"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x63)
			if (*z).encodedCert.SigCommit == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCert.SigCommit)))
			}
			for zb0003 := range (*z).encodedCert.SigCommit {
				o = (*z).encodedCert.SigCommit[zb0003].MarshalMsg(o)
			}
		}
		if (zb0014Mask & 0x800) == 0 { // if not empty
			// string "certcbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCert.BitmaskSigCommit))
		}
		if (zb0014Mask & 0x1000) == 0 { // if not empty
			// string "certr"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x72)
			if (*z).encodedCert.Reveals == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCert.Reveals)))
			}
			for zb0011 := range (*z).encodedCert.Reveals {
				if (*z).encodedCert.Reveals[zb0011] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendMapHeader(o, uint32(len((*z).encodedCert.Reveals[zb0011])))
				}
				zb0012_keys := make([]uint64, 0, len((*z).encodedCert.Reveals[zb0011]))
				for zb0012 := range (*z).encodedCert.Reveals[zb0011] {
					zb0012_keys = append(zb0012_keys, zb0012)
				}
				sort.Sort(SortUint64(zb0012_keys))
				for _, zb0012 := range zb0012_keys {
					zb0013 := (*z).encodedCert.Reveals[zb0011][zb0012]
					_ = zb0013
					o = msgp.AppendUint64(o, zb0012)
					o = zb0013.MarshalMsg(o)
				}
			}
		}
		if (zb0014Mask & 0x2000) == 0 { // if not empty
			// string "certrbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCert.BitmaskReveals))
		}
		if (zb0014Mask & 0x4000) == 0 { // if not empty
			// string "certrnd"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x72, 0x6e, 0x64)
			if (*z).CertRound == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).CertRound)))
			}
			for zb0001 := range (*z).CertRound {
				o = (*z).CertRound[zb0001].MarshalMsg(o)
			}
		}
		if (zb0014Mask & 0x8000) == 0 { // if not empty
			// string "certrndbm"
			o = append(o, 0xa9, 0x63, 0x65, 0x72, 0x74, 0x72, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskCertRound))
		}
		if (zb0014Mask & 0x10000) == 0 { // if not empty
			// string "certtype"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x74, 0x79, 0x70, 0x65)
			if (*z).CertType == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).CertType)))
			}
			for zb0002 := range (*z).CertType {
				o = (*z).CertType[zb0002].MarshalMsg(o)
			}
		}
		if (zb0014Mask & 0x20000) == 0 { // if not empty
			// string "certtypebm"
			o = append(o, 0xaa, 0x63, 0x65, 0x72, 0x74, 0x74, 0x79, 0x70, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskCertType))
		}
		if (zb0014Mask & 0x40000) == 0 { // if not empty
			// string "certw"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x77)
			if (*z).encodedCert.SignedWeight == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCert.SignedWeight)))
			}
			for zb0004 := range (*z).encodedCert.SignedWeight {
				o = msgp.AppendUint64(o, (*z).encodedCert.SignedWeight[zb0004])
			}
		}
		if (zb0014Mask & 0x80000) == 0 { // if not empty
			// string "certwbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x77, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCert.BitmaskSignedWeight))
		}
	}
	return
}

func (_ *encodedCompactCertTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedCompactCertTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedCompactCertTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0014 int
	var zb0015 bool
	zb0014, zb0015, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0014, zb0015, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0014 > 0 {
			zb0014--
			var zb0016 int
			var zb0017 bool
			zb0016, zb0017, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CertRound")
				return
			}
			if zb0016 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0016), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "CertRound")
				return
			}
			if zb0017 {
				(*z).CertRound = nil
			} else if (*z).CertRound != nil && cap((*z).CertRound) >= zb0016 {
				(*z).CertRound = ((*z).CertRound)[:zb0016]
			} else {
				(*z).CertRound = make([]basics.Round, zb0016)
			}
			for zb0001 := range (*z).CertRound {
				bts, err = (*z).CertRound[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CertRound", zb0001)
					return
				}
			}
		}
		if zb0014 > 0 {
			zb0014--
			{
				var zb0018 []byte
				var zb0019 int
				zb0019, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertRound")
					return
				}
				if zb0019 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0019), uint64(maxBitmaskSize))
					return
				}
				zb0018, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskCertRound))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertRound")
					return
				}
				(*z).BitmaskCertRound = bitmask(zb0018)
			}
		}
		if zb0014 > 0 {
			zb0014--
			var zb0020 int
			var zb0021 bool
			zb0020, zb0021, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CertType")
				return
			}
			if zb0020 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0020), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "CertType")
				return
			}
			if zb0021 {
				(*z).CertType = nil
			} else if (*z).CertType != nil && cap((*z).CertType) >= zb0020 {
				(*z).CertType = ((*z).CertType)[:zb0020]
			} else {
				(*z).CertType = make([]protocol.CompactCertType, zb0020)
			}
			for zb0002 := range (*z).CertType {
				bts, err = (*z).CertType[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CertType", zb0002)
					return
				}
			}
		}
		if zb0014 > 0 {
			zb0014--
			{
				var zb0022 []byte
				var zb0023 int
				zb0023, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertType")
					return
				}
				if zb0023 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0023), uint64(maxBitmaskSize))
					return
				}
				zb0022, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskCertType))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertType")
					return
				}
				(*z).BitmaskCertType = bitmask(zb0022)
			}
		}
		if zb0014 > 0 {
			zb0014--
			var zb0024 int
			var zb0025 bool
			zb0024, zb0025, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigCommit")
				return
			}
			if zb0024 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0024), uint64(maxAddressBytes))
				err = msgp.WrapError(err, "struct-from-array", "SigCommit")
				return
			}
			if zb0025 {
				(*z).encodedCert.SigCommit = nil
			} else if (*z).encodedCert.SigCommit != nil && cap((*z).encodedCert.SigCommit) >= zb0024 {
				(*z).encodedCert.SigCommit = ((*z).encodedCert.SigCommit)[:zb0024]
			} else {
				(*z).encodedCert.SigCommit = make([]crypto.GenericDigest, zb0024)
			}
			for zb0003 := range (*z).encodedCert.SigCommit {
				bts, err = (*z).encodedCert.SigCommit[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigCommit", zb0003)
					return
				}
			}
		}
		if zb0014 > 0 {
			zb0014--
			{
				var zb0026 []byte
				var zb0027 int
				zb0027, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigCommit")
					return
				}
				if zb0027 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0027), uint64(maxBitmaskSize))
					return
				}
				zb0026, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskSigCommit))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigCommit")
					return
				}
				(*z).encodedCert.BitmaskSigCommit = bitmask(zb0026)
			}
		}
		if zb0014 > 0 {
			zb0014--
			var zb0028 int
			var zb0029 bool
			zb0028, zb0029, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SignedWeight")
				return
			}
			if zb0028 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0028), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SignedWeight")
				return
			}
			if zb0029 {
				(*z).encodedCert.SignedWeight = nil
			} else if (*z).encodedCert.SignedWeight != nil && cap((*z).encodedCert.SignedWeight) >= zb0028 {
				(*z).encodedCert.SignedWeight = ((*z).encodedCert.SignedWeight)[:zb0028]
			} else {
				(*z).encodedCert.SignedWeight = make([]uint64, zb0028)
			}
			for zb0004 := range (*z).encodedCert.SignedWeight {
				(*z).encodedCert.SignedWeight[zb0004], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedWeight", zb0004)
					return
				}
			}
		}
		if zb0014 > 0 {
			zb0014--
			{
				var zb0030 []byte
				var zb0031 int
				zb0031, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSignedWeight")
					return
				}
				if zb0031 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0031), uint64(maxBitmaskSize))
					return
				}
				zb0030, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskSignedWeight))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSignedWeight")
					return
				}
				(*z).encodedCert.BitmaskSignedWeight = bitmask(zb0030)
			}
		}
		if zb0014 > 0 {
			zb0014--
			var zb0032 int
			var zb0033 bool
			zb0032, zb0033, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigProofs")
				return
			}
			if zb0032 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0032), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SigProofs")
				return
			}
			if zb0033 {
				(*z).encodedCert.SigProofs = nil
			} else if (*z).encodedCert.SigProofs != nil && cap((*z).encodedCert.SigProofs) >= zb0032 {
				(*z).encodedCert.SigProofs = ((*z).encodedCert.SigProofs)[:zb0032]
			} else {
				(*z).encodedCert.SigProofs = make([]certProofs, zb0032)
			}
			for zb0005 := range (*z).encodedCert.SigProofs {
				var zb0034 int
				var zb0035 bool
				zb0034, zb0035, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0005)
					return
				}
				if zb0034 > compactcert.MaxProofDigests {
					err = msgp.ErrOverflow(uint64(zb0034), uint64(compactcert.MaxProofDigests))
					err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0005)
					return
				}
				if zb0035 {
					(*z).encodedCert.SigProofs[zb0005] = nil
				} else if (*z).encodedCert.SigProofs[zb0005] != nil && cap((*z).encodedCert.SigProofs[zb0005]) >= zb0034 {
					(*z).encodedCert.SigProofs[zb0005] = ((*z).encodedCert.SigProofs[zb0005])[:zb0034]
				} else {
					(*z).encodedCert.SigProofs[zb0005] = make(certProofs, zb0034)
				}
				for zb0006 := range (*z).encodedCert.SigProofs[zb0005] {
					bts, err = (*z).encodedCert.SigProofs[zb0005][zb0006].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0005, zb0006)
						return
					}
				}
			}
		}
		if zb0014 > 0 {
			zb0014--
			{
				var zb0036 []byte
				var zb0037 int
				zb0037, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigProofs")
					return
				}
				if zb0037 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0037), uint64(maxBitmaskSize))
					return
				}
				zb0036, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskSigProofs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigProofs")
					return
				}
				(*z).encodedCert.BitmaskSigProofs = bitmask(zb0036)
			}
		}
		if zb0014 > 0 {
			zb0014--
			var zb0038 int
			var zb0039 bool
			zb0038, zb0039, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes")
				return
			}
			if zb0038 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0038), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes")
				return
			}
			if zb0039 {
				(*z).encodedCert.SigProofHashTypes = nil
			} else if (*z).encodedCert.SigProofHashTypes != nil && cap((*z).encodedCert.SigProofHashTypes) >= zb0038 {
				(*z).encodedCert.SigProofHashTypes = ((*z).encodedCert.SigProofHashTypes)[:zb0038]
			} else {
				(*z).encodedCert.SigProofHashTypes = make([]uint64, zb0038)
			}
			for zb0007 := range (*z).encodedCert.SigProofHashTypes {
				(*z).encodedCert.SigProofHashTypes[zb0007], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes", zb0007)
					return
				}
			}
		}
		if zb0014 > 0 {
			zb0014--
			{
				var zb0040 []byte
				var zb0041 int
				zb0041, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigsHash")
					return
				}
				if zb0041 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0041), uint64(maxBitmaskSize))
					return
				}
				zb0040, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskSigsHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigsHash")
					return
				}
				(*z).encodedCert.BitmaskSigsHash = bitmask(zb0040)
			}
		}
		if zb0014 > 0 {
			zb0014--
			var zb0042 int
			var zb0043 bool
			zb0042, zb0043, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PartProofs")
				return
			}
			if zb0042 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0042), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "PartProofs")
				return
			}
			if zb0043 {
				(*z).encodedCert.PartProofs = nil
			} else if (*z).encodedCert.PartProofs != nil && cap((*z).encodedCert.PartProofs) >= zb0042 {
				(*z).encodedCert.PartProofs = ((*z).encodedCert.PartProofs)[:zb0042]
			} else {
				(*z).encodedCert.PartProofs = make([]certProofs, zb0042)
			}
			for zb0008 := range (*z).encodedCert.PartProofs {
				var zb0044 int
				var zb0045 bool
				zb0044, zb0045, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0008)
					return
				}
				if zb0044 > compactcert.MaxProofDigests {
					err = msgp.ErrOverflow(uint64(zb0044), uint64(compactcert.MaxProofDigests))
					err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0008)
					return
				}
				if zb0045 {
					(*z).encodedCert.PartProofs[zb0008] = nil
				} else if (*z).encodedCert.PartProofs[zb0008] != nil && cap((*z).encodedCert.PartProofs[zb0008]) >= zb0044 {
					(*z).encodedCert.PartProofs[zb0008] = ((*z).encodedCert.PartProofs[zb0008])[:zb0044]
				} else {
					(*z).encodedCert.PartProofs[zb0008] = make(certProofs, zb0044)
				}
				for zb0009 := range (*z).encodedCert.PartProofs[zb0008] {
					bts, err = (*z).encodedCert.PartProofs[zb0008][zb0009].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0008, zb0009)
						return
					}
				}
			}
		}
		if zb0014 > 0 {
			zb0014--
			{
				var zb0046 []byte
				var zb0047 int
				zb0047, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartProofs")
					return
				}
				if zb0047 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0047), uint64(maxBitmaskSize))
					return
				}
				zb0046, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskPartProofs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartProofs")
					return
				}
				(*z).encodedCert.BitmaskPartProofs = bitmask(zb0046)
			}
		}
		if zb0014 > 0 {
			zb0014--
			var zb0048 int
			var zb0049 bool
			zb0048, zb0049, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes")
				return
			}
			if zb0048 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0048), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes")
				return
			}
			if zb0049 {
				(*z).encodedCert.PartProofHashTypes = nil
			} else if (*z).encodedCert.PartProofHashTypes != nil && cap((*z).encodedCert.PartProofHashTypes) >= zb0048 {
				(*z).encodedCert.PartProofHashTypes = ((*z).encodedCert.PartProofHashTypes)[:zb0048]
			} else {
				(*z).encodedCert.PartProofHashTypes = make([]uint64, zb0048)
			}
			for zb0010 := range (*z).encodedCert.PartProofHashTypes {
				(*z).encodedCert.PartProofHashTypes[zb0010], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes", zb0010)
					return
				}
			}
		}
		if zb0014 > 0 {
			zb0014--
			{
				var zb0050 []byte
				var zb0051 int
				zb0051, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartHash")
					return
				}
				if zb0051 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0051), uint64(maxBitmaskSize))
					return
				}
				zb0050, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskPartHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartHash")
					return
				}
				(*z).encodedCert.BitmaskPartHash = bitmask(zb0050)
			}
		}
		if zb0014 > 0 {
			zb0014--
			var zb0052 int
			var zb0053 bool
			zb0052, zb0053, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reveals")
				return
			}
			if zb0052 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0052), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Reveals")
				return
			}
			if zb0053 {
				(*z).encodedCert.Reveals = nil
			} else if (*z).encodedCert.Reveals != nil && cap((*z).encodedCert.Reveals) >= zb0052 {
				(*z).encodedCert.Reveals = ((*z).encodedCert.Reveals)[:zb0052]
			} else {
				(*z).encodedCert.Reveals = make([]revealMap, zb0052)
			}
			for zb0011 := range (*z).encodedCert.Reveals {
				var zb0054 int
				var zb0055 bool
				zb0054, zb0055, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0011)
					return
				}
				if zb0054 > compactcert.MaxReveals {
					err = msgp.ErrOverflow(uint64(zb0054), uint64(compactcert.MaxReveals))
					err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0011)
					return
				}
				if zb0055 {
					(*z).encodedCert.Reveals[zb0011] = nil
				} else if (*z).encodedCert.Reveals[zb0011] == nil {
					(*z).encodedCert.Reveals[zb0011] = make(revealMap, zb0054)
				}
				for zb0054 > 0 {
					var zb0012 uint64
					var zb0013 compactcert.Reveal
					zb0054--
					zb0012, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0011)
						return
					}
					bts, err = zb0013.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0011, zb0012)
						return
					}
					(*z).encodedCert.Reveals[zb0011][zb0012] = zb0013
				}
			}
		}
		if zb0014 > 0 {
			zb0014--
			{
				var zb0056 []byte
				var zb0057 int
				zb0057, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReveals")
					return
				}
				if zb0057 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0057), uint64(maxBitmaskSize))
					return
				}
				zb0056, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskReveals))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReveals")
					return
				}
				(*z).encodedCert.BitmaskReveals = bitmask(zb0056)
			}
		}
		if zb0014 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0014)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0015 {
			(*z) = encodedCompactCertTxnFields{}
		}
		for zb0014 > 0 {
			zb0014--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "certrnd":
				var zb0058 int
				var zb0059 bool
				zb0058, zb0059, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CertRound")
					return
				}
				if zb0058 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0058), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "CertRound")
					return
				}
				if zb0059 {
					(*z).CertRound = nil
				} else if (*z).CertRound != nil && cap((*z).CertRound) >= zb0058 {
					(*z).CertRound = ((*z).CertRound)[:zb0058]
				} else {
					(*z).CertRound = make([]basics.Round, zb0058)
				}
				for zb0001 := range (*z).CertRound {
					bts, err = (*z).CertRound[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CertRound", zb0001)
						return
					}
				}
			case "certrndbm":
				{
					var zb0060 []byte
					var zb0061 int
					zb0061, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertRound")
						return
					}
					if zb0061 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0061), uint64(maxBitmaskSize))
						return
					}
					zb0060, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskCertRound))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertRound")
						return
					}
					(*z).BitmaskCertRound = bitmask(zb0060)
				}
			case "certtype":
				var zb0062 int
				var zb0063 bool
				zb0062, zb0063, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CertType")
					return
				}
				if zb0062 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0062), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "CertType")
					return
				}
				if zb0063 {
					(*z).CertType = nil
				} else if (*z).CertType != nil && cap((*z).CertType) >= zb0062 {
					(*z).CertType = ((*z).CertType)[:zb0062]
				} else {
					(*z).CertType = make([]protocol.CompactCertType, zb0062)
				}
				for zb0002 := range (*z).CertType {
					bts, err = (*z).CertType[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CertType", zb0002)
						return
					}
				}
			case "certtypebm":
				{
					var zb0064 []byte
					var zb0065 int
					zb0065, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertType")
						return
					}
					if zb0065 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0065), uint64(maxBitmaskSize))
						return
					}
					zb0064, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskCertType))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertType")
						return
					}
					(*z).BitmaskCertType = bitmask(zb0064)
				}
			case "certc":
				var zb0066 int
				var zb0067 bool
				zb0066, zb0067, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigCommit")
					return
				}
				if zb0066 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0066), uint64(maxAddressBytes))
					err = msgp.WrapError(err, "SigCommit")
					return
				}
				if zb0067 {
					(*z).encodedCert.SigCommit = nil
				} else if (*z).encodedCert.SigCommit != nil && cap((*z).encodedCert.SigCommit) >= zb0066 {
					(*z).encodedCert.SigCommit = ((*z).encodedCert.SigCommit)[:zb0066]
				} else {
					(*z).encodedCert.SigCommit = make([]crypto.GenericDigest, zb0066)
				}
				for zb0003 := range (*z).encodedCert.SigCommit {
					bts, err = (*z).encodedCert.SigCommit[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigCommit", zb0003)
						return
					}
				}
			case "certcbm":
				{
					var zb0068 []byte
					var zb0069 int
					zb0069, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigCommit")
						return
					}
					if zb0069 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0069), uint64(maxBitmaskSize))
						return
					}
					zb0068, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskSigCommit))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigCommit")
						return
					}
					(*z).encodedCert.BitmaskSigCommit = bitmask(zb0068)
				}
			case "certw":
				var zb0070 int
				var zb0071 bool
				zb0070, zb0071, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SignedWeight")
					return
				}
				if zb0070 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0070), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SignedWeight")
					return
				}
				if zb0071 {
					(*z).encodedCert.SignedWeight = nil
				} else if (*z).encodedCert.SignedWeight != nil && cap((*z).encodedCert.SignedWeight) >= zb0070 {
					(*z).encodedCert.SignedWeight = ((*z).encodedCert.SignedWeight)[:zb0070]
				} else {
					(*z).encodedCert.SignedWeight = make([]uint64, zb0070)
				}
				for zb0004 := range (*z).encodedCert.SignedWeight {
					(*z).encodedCert.SignedWeight[zb0004], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedWeight", zb0004)
						return
					}
				}
			case "certwbm":
				{
					var zb0072 []byte
					var zb0073 int
					zb0073, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSignedWeight")
						return
					}
					if zb0073 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0073), uint64(maxBitmaskSize))
						return
					}
					zb0072, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskSignedWeight))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSignedWeight")
						return
					}
					(*z).encodedCert.BitmaskSignedWeight = bitmask(zb0072)
				}
			case "certS":
				var zb0074 int
				var zb0075 bool
				zb0074, zb0075, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigProofs")
					return
				}
				if zb0074 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0074), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SigProofs")
					return
				}
				if zb0075 {
					(*z).encodedCert.SigProofs = nil
				} else if (*z).encodedCert.SigProofs != nil && cap((*z).encodedCert.SigProofs) >= zb0074 {
					(*z).encodedCert.SigProofs = ((*z).encodedCert.SigProofs)[:zb0074]
				} else {
					(*z).encodedCert.SigProofs = make([]certProofs, zb0074)
				}
				for zb0005 := range (*z).encodedCert.SigProofs {
					var zb0076 int
					var zb0077 bool
					zb0076, zb0077, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigProofs", zb0005)
						return
					}
					if zb0076 > compactcert.MaxProofDigests {
						err = msgp.ErrOverflow(uint64(zb0076), uint64(compactcert.MaxProofDigests))
						err = msgp.WrapError(err, "SigProofs", zb0005)
						return
					}
					if zb0077 {
						(*z).encodedCert.SigProofs[zb0005] = nil
					} else if (*z).encodedCert.SigProofs[zb0005] != nil && cap((*z).encodedCert.SigProofs[zb0005]) >= zb0076 {
						(*z).encodedCert.SigProofs[zb0005] = ((*z).encodedCert.SigProofs[zb0005])[:zb0076]
					} else {
						(*z).encodedCert.SigProofs[zb0005] = make(certProofs, zb0076)
					}
					for zb0006 := range (*z).encodedCert.SigProofs[zb0005] {
						bts, err = (*z).encodedCert.SigProofs[zb0005][zb0006].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SigProofs", zb0005, zb0006)
							return
						}
					}
				}
			case "certSbm":
				{
					var zb0078 []byte
					var zb0079 int
					zb0079, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigProofs")
						return
					}
					if zb0079 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0079), uint64(maxBitmaskSize))
						return
					}
					zb0078, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskSigProofs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigProofs")
						return
					}
					(*z).encodedCert.BitmaskSigProofs = bitmask(zb0078)
				}
			case "certSH":
				var zb0080 int
				var zb0081 bool
				zb0080, zb0081, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigProofHashTypes")
					return
				}
				if zb0080 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0080), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SigProofHashTypes")
					return
				}
				if zb0081 {
					(*z).encodedCert.SigProofHashTypes = nil
				} else if (*z).encodedCert.SigProofHashTypes != nil && cap((*z).encodedCert.SigProofHashTypes) >= zb0080 {
					(*z).encodedCert.SigProofHashTypes = ((*z).encodedCert.SigProofHashTypes)[:zb0080]
				} else {
					(*z).encodedCert.SigProofHashTypes = make([]uint64, zb0080)
				}
				for zb0007 := range (*z).encodedCert.SigProofHashTypes {
					(*z).encodedCert.SigProofHashTypes[zb0007], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigProofHashTypes", zb0007)
						return
					}
				}
			case "certSHbm":
				{
					var zb0082 []byte
					var zb0083 int
					zb0083, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigsHash")
						return
					}
					if zb0083 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0083), uint64(maxBitmaskSize))
						return
					}
					zb0082, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskSigsHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigsHash")
						return
					}
					(*z).encodedCert.BitmaskSigsHash = bitmask(zb0082)
				}
			case "certP":
				var zb0084 int
				var zb0085 bool
				zb0084, zb0085, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PartProofs")
					return
				}
				if zb0084 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0084), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "PartProofs")
					return
				}
				if zb0085 {
					(*z).encodedCert.PartProofs = nil
				} else if (*z).encodedCert.PartProofs != nil && cap((*z).encodedCert.PartProofs) >= zb0084 {
					(*z).encodedCert.PartProofs = ((*z).encodedCert.PartProofs)[:zb0084]
				} else {
					(*z).encodedCert.PartProofs = make([]certProofs, zb0084)
				}
				for zb0008 := range (*z).encodedCert.PartProofs {
					var zb0086 int
					var zb0087 bool
					zb0086, zb0087, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PartProofs", zb0008)
						return
					}
					if zb0086 > compactcert.MaxProofDigests {
						err = msgp.ErrOverflow(uint64(zb0086), uint64(compactcert.MaxProofDigests))
						err = msgp.WrapError(err, "PartProofs", zb0008)
						return
					}
					if zb0087 {
						(*z).encodedCert.PartProofs[zb0008] = nil
					} else if (*z).encodedCert.PartProofs[zb0008] != nil && cap((*z).encodedCert.PartProofs[zb0008]) >= zb0086 {
						(*z).encodedCert.PartProofs[zb0008] = ((*z).encodedCert.PartProofs[zb0008])[:zb0086]
					} else {
						(*z).encodedCert.PartProofs[zb0008] = make(certProofs, zb0086)
					}
					for zb0009 := range (*z).encodedCert.PartProofs[zb0008] {
						bts, err = (*z).encodedCert.PartProofs[zb0008][zb0009].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "PartProofs", zb0008, zb0009)
							return
						}
					}
				}
			case "certPbm":
				{
					var zb0088 []byte
					var zb0089 int
					zb0089, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartProofs")
						return
					}
					if zb0089 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0089), uint64(maxBitmaskSize))
						return
					}
					zb0088, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskPartProofs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartProofs")
						return
					}
					(*z).encodedCert.BitmaskPartProofs = bitmask(zb0088)
				}
			case "certPH":
				var zb0090 int
				var zb0091 bool
				zb0090, zb0091, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PartProofHashTypes")
					return
				}
				if zb0090 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0090), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "PartProofHashTypes")
					return
				}
				if zb0091 {
					(*z).encodedCert.PartProofHashTypes = nil
				} else if (*z).encodedCert.PartProofHashTypes != nil && cap((*z).encodedCert.PartProofHashTypes) >= zb0090 {
					(*z).encodedCert.PartProofHashTypes = ((*z).encodedCert.PartProofHashTypes)[:zb0090]
				} else {
					(*z).encodedCert.PartProofHashTypes = make([]uint64, zb0090)
				}
				for zb0010 := range (*z).encodedCert.PartProofHashTypes {
					(*z).encodedCert.PartProofHashTypes[zb0010], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PartProofHashTypes", zb0010)
						return
					}
				}
			case "certPHbm":
				{
					var zb0092 []byte
					var zb0093 int
					zb0093, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartHash")
						return
					}
					if zb0093 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0093), uint64(maxBitmaskSize))
						return
					}
					zb0092, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskPartHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartHash")
						return
					}
					(*z).encodedCert.BitmaskPartHash = bitmask(zb0092)
				}
			case "certr":
				var zb0094 int
				var zb0095 bool
				zb0094, zb0095, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reveals")
					return
				}
				if zb0094 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0094), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Reveals")
					return
				}
				if zb0095 {
					(*z).encodedCert.Reveals = nil
				} else if (*z).encodedCert.Reveals != nil && cap((*z).encodedCert.Reveals) >= zb0094 {
					(*z).encodedCert.Reveals = ((*z).encodedCert.Reveals)[:zb0094]
				} else {
					(*z).encodedCert.Reveals = make([]revealMap, zb0094)
				}
				for zb0011 := range (*z).encodedCert.Reveals {
					var zb0096 int
					var zb0097 bool
					zb0096, zb0097, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Reveals", zb0011)
						return
					}
					if zb0096 > compactcert.MaxReveals {
						err = msgp.ErrOverflow(uint64(zb0096), uint64(compactcert.MaxReveals))
						err = msgp.WrapError(err, "Reveals", zb0011)
						return
					}
					if zb0097 {
						(*z).encodedCert.Reveals[zb0011] = nil
					} else if (*z).encodedCert.Reveals[zb0011] == nil {
						(*z).encodedCert.Reveals[zb0011] = make(revealMap, zb0096)
					}
					for zb0096 > 0 {
						var zb0012 uint64
						var zb0013 compactcert.Reveal
						zb0096--
						zb0012, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Reveals", zb0011)
							return
						}
						bts, err = zb0013.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Reveals", zb0011, zb0012)
							return
						}
						(*z).encodedCert.Reveals[zb0011][zb0012] = zb0013
					}
				}
			case "certrbm":
				{
					var zb0098 []byte
					var zb0099 int
					zb0099, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReveals")
						return
					}
					if zb0099 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0099), uint64(maxBitmaskSize))
						return
					}
					zb0098, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCert.BitmaskReveals))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReveals")
						return
					}
					(*z).encodedCert.BitmaskReveals = bitmask(zb0098)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedCompactCertTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedCompactCertTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedCompactCertTxnFields) Msgsize() (s int) {
	s = 3 + 8 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).CertRound {
		s += (*z).CertRound[zb0001].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskCertRound)) + 9 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).CertType {
		s += (*z).CertType[zb0002].Msgsize()
	}
	s += 11 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskCertType)) + 6 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).encodedCert.SigCommit {
		s += (*z).encodedCert.SigCommit[zb0003].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedCert.BitmaskSigCommit)) + 6 + msgp.ArrayHeaderSize + (len((*z).encodedCert.SignedWeight) * (msgp.Uint64Size)) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedCert.BitmaskSignedWeight)) + 6 + msgp.ArrayHeaderSize
	for zb0005 := range (*z).encodedCert.SigProofs {
		s += msgp.ArrayHeaderSize
		for zb0006 := range (*z).encodedCert.SigProofs[zb0005] {
			s += (*z).encodedCert.SigProofs[zb0005][zb0006].Msgsize()
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedCert.BitmaskSigProofs)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedCert.SigProofHashTypes) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedCert.BitmaskSigsHash)) + 6 + msgp.ArrayHeaderSize
	for zb0008 := range (*z).encodedCert.PartProofs {
		s += msgp.ArrayHeaderSize
		for zb0009 := range (*z).encodedCert.PartProofs[zb0008] {
			s += (*z).encodedCert.PartProofs[zb0008][zb0009].Msgsize()
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedCert.BitmaskPartProofs)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedCert.PartProofHashTypes) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedCert.BitmaskPartHash)) + 6 + msgp.ArrayHeaderSize
	for zb0011 := range (*z).encodedCert.Reveals {
		s += msgp.MapHeaderSize
		if (*z).encodedCert.Reveals[zb0011] != nil {
			for zb0012, zb0013 := range (*z).encodedCert.Reveals[zb0011] {
				_ = zb0012
				_ = zb0013
				s += 0 + msgp.Uint64Size + zb0013.Msgsize()
			}
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedCert.BitmaskReveals))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedCompactCertTxnFields) MsgIsZero() bool {
	return (len((*z).CertRound) == 0) && (len((*z).BitmaskCertRound) == 0) && (len((*z).CertType) == 0) && (len((*z).BitmaskCertType) == 0) && (len((*z).encodedCert.SigCommit) == 0) && (len((*z).encodedCert.BitmaskSigCommit) == 0) && (len((*z).encodedCert.SignedWeight) == 0) && (len((*z).encodedCert.BitmaskSignedWeight) == 0) && (len((*z).encodedCert.SigProofs) == 0) && (len((*z).encodedCert.BitmaskSigProofs) == 0) && (len((*z).encodedCert.SigProofHashTypes) == 0) && (len((*z).encodedCert.BitmaskSigsHash) == 0) && (len((*z).encodedCert.PartProofs) == 0) && (len((*z).encodedCert.BitmaskPartProofs) == 0) && (len((*z).encodedCert.PartProofHashTypes) == 0) && (len((*z).encodedCert.BitmaskPartHash) == 0) && (len((*z).encodedCert.Reveals) == 0) && (len((*z).encodedCert.BitmaskReveals) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedKeyregTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0005Len := uint32(11)
	var zb0005Mask uint16 /* 12 bits */
	if len((*z).CommitmentRoot) == 0 {
		zb0005Len--
		zb0005Mask |= 0x2
	}
	if len((*z).BitmaskNonparticipation) == 0 {
		zb0005Len--
		zb0005Mask |= 0x4
	}
	if len((*z).SelectionPK) == 0 {
		zb0005Len--
		zb0005Mask |= 0x8
	}
	if len((*z).HasValidRoot) == 0 {
		zb0005Len--
		zb0005Mask |= 0x10
	}
	if len((*z).VoteFirst) == 0 {
		zb0005Len--
		zb0005Mask |= 0x20
	}
	if len((*z).BitmaskVoteFirst) == 0 {
		zb0005Len--
		zb0005Mask |= 0x40
	}
	if len((*z).BitmaskKeys) == 0 {
		zb0005Len--
		zb0005Mask |= 0x80
	}
	if len((*z).VoteKeyDilution) == 0 {
		zb0005Len--
		zb0005Mask |= 0x100
	}
	if len((*z).VotePK) == 0 {
		zb0005Len--
		zb0005Mask |= 0x200
	}
	if len((*z).VoteLast) == 0 {
		zb0005Len--
		zb0005Mask |= 0x400
	}
	if len((*z).BitmaskVoteLast) == 0 {
		zb0005Len--
		zb0005Mask |= 0x800
	}
	// variable map header, size zb0005Len
	o = append(o, 0x80|uint8(zb0005Len))
	if zb0005Len != 0 {
		if (zb0005Mask & 0x2) == 0 { // if not empty
			// string "comt"
			o = append(o, 0xa4, 0x63, 0x6f, 0x6d, 0x74)
			o = msgp.AppendBytes(o, (*z).CommitmentRoot)
		}
		if (zb0005Mask & 0x4) == 0 { // if not empty
			// string "nonpartbm"
			o = append(o, 0xa9, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskNonparticipation))
		}
		if (zb0005Mask & 0x8) == 0 { // if not empty
			// string "selkey"
			o = append(o, 0xa6, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79)
			o = msgp.AppendBytes(o, (*z).SelectionPK)
		}
		if (zb0005Mask & 0x10) == 0 { // if not empty
			// string "vldrt"
			o = append(o, 0xa5, 0x76, 0x6c, 0x64, 0x72, 0x74)
			if (*z).HasValidRoot == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).HasValidRoot)))
			}
			for zb0004 := range (*z).HasValidRoot {
				o = msgp.AppendBool(o, (*z).HasValidRoot[zb0004])
			}
		}
		if (zb0005Mask & 0x20) == 0 { // if not empty
			// string "votefst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74)
			if (*z).VoteFirst == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).VoteFirst)))
			}
			for zb0001 := range (*z).VoteFirst {
				o = (*z).VoteFirst[zb0001].MarshalMsg(o)
			}
		}
		if (zb0005Mask & 0x40) == 0 { // if not empty
			// string "votefstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskVoteFirst))
		}
		if (zb0005Mask & 0x80) == 0 { // if not empty
			// string "votekbm"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskKeys))
		}
		if (zb0005Mask & 0x100) == 0 { // if not empty
			// string "votekd"
			o = append(o, 0xa6, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64)
			if (*z).VoteKeyDilution == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).VoteKeyDilution)))
			}
			for zb0003 := range (*z).VoteKeyDilution {
				o = msgp.AppendUint64(o, (*z).VoteKeyDilution[zb0003])
			}
		}
		if (zb0005Mask & 0x200) == 0 { // if not empty
			// string "votekey"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79)
			o = msgp.AppendBytes(o, (*z).VotePK)
		}
		if (zb0005Mask & 0x400) == 0 { // if not empty
			// string "votelst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74)
			if (*z).VoteLast == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).VoteLast)))
			}
			for zb0002 := range (*z).VoteLast {
				o = (*z).VoteLast[zb0002].MarshalMsg(o)
			}
		}
		if (zb0005Mask & 0x800) == 0 { // if not empty
			// string "votelstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskVoteLast))
		}
	}
	return
}

func (_ *encodedKeyregTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedKeyregTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedKeyregTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0005 int
	var zb0006 bool
	zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0005 > 0 {
			zb0005--
			var zb0007 int
			zb0007, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
			if zb0007 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0007), uint64(maxAddressBytes))
				return
			}
			(*z).VotePK, bts, err = msgp.ReadBytesBytes(bts, (*z).VotePK)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0008 int
			zb0008, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
			if zb0008 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0008), uint64(maxAddressBytes))
				return
			}
			(*z).SelectionPK, bts, err = msgp.ReadBytesBytes(bts, (*z).SelectionPK)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0009 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0010 {
				(*z).VoteFirst = nil
			} else if (*z).VoteFirst != nil && cap((*z).VoteFirst) >= zb0009 {
				(*z).VoteFirst = ((*z).VoteFirst)[:zb0009]
			} else {
				(*z).VoteFirst = make([]basics.Round, zb0009)
			}
			for zb0001 := range (*z).VoteFirst {
				bts, err = (*z).VoteFirst[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteFirst", zb0001)
					return
				}
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0011 []byte
				var zb0012 int
				zb0012, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteFirst")
					return
				}
				if zb0012 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0012), uint64(maxBitmaskSize))
					return
				}
				zb0011, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVoteFirst))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteFirst")
					return
				}
				(*z).BitmaskVoteFirst = bitmask(zb0011)
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0013 int
			var zb0014 bool
			zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0013 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0013), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0014 {
				(*z).VoteLast = nil
			} else if (*z).VoteLast != nil && cap((*z).VoteLast) >= zb0013 {
				(*z).VoteLast = ((*z).VoteLast)[:zb0013]
			} else {
				(*z).VoteLast = make([]basics.Round, zb0013)
			}
			for zb0002 := range (*z).VoteLast {
				bts, err = (*z).VoteLast[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteLast", zb0002)
					return
				}
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0015 []byte
				var zb0016 int
				zb0016, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteLast")
					return
				}
				if zb0016 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0016), uint64(maxBitmaskSize))
					return
				}
				zb0015, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVoteLast))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteLast")
					return
				}
				(*z).BitmaskVoteLast = bitmask(zb0015)
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0017 int
			var zb0018 bool
			zb0017, zb0018, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0017 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0017), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0018 {
				(*z).VoteKeyDilution = nil
			} else if (*z).VoteKeyDilution != nil && cap((*z).VoteKeyDilution) >= zb0017 {
				(*z).VoteKeyDilution = ((*z).VoteKeyDilution)[:zb0017]
			} else {
				(*z).VoteKeyDilution = make([]uint64, zb0017)
			}
			for zb0003 := range (*z).VoteKeyDilution {
				(*z).VoteKeyDilution[zb0003], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution", zb0003)
					return
				}
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0019 []byte
				var zb0020 int
				zb0020, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskKeys")
					return
				}
				if zb0020 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0020), uint64(maxBitmaskSize))
					return
				}
				zb0019, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskKeys))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskKeys")
					return
				}
				(*z).BitmaskKeys = bitmask(zb0019)
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0021 []byte
				var zb0022 int
				zb0022, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNonparticipation")
					return
				}
				if zb0022 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0022), uint64(maxBitmaskSize))
					return
				}
				zb0021, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskNonparticipation))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNonparticipation")
					return
				}
				(*z).BitmaskNonparticipation = bitmask(zb0021)
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0023 int
			var zb0024 bool
			zb0023, zb0024, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "HasValidRoot")
				return
			}
			if zb0023 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0023), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "HasValidRoot")
				return
			}
			if zb0024 {
				(*z).HasValidRoot = nil
			} else if (*z).HasValidRoot != nil && cap((*z).HasValidRoot) >= zb0023 {
				(*z).HasValidRoot = ((*z).HasValidRoot)[:zb0023]
			} else {
				(*z).HasValidRoot = make([]bool, zb0023)
			}
			for zb0004 := range (*z).HasValidRoot {
				(*z).HasValidRoot[zb0004], bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "HasValidRoot", zb0004)
					return
				}
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0025 int
			zb0025, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CommitmentRoot")
				return
			}
			if zb0025 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0025), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).CommitmentRoot, bts, err = msgp.ReadBytesBytes(bts, (*z).CommitmentRoot)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CommitmentRoot")
				return
			}
		}
		if zb0005 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0005)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0006 {
			(*z) = encodedKeyregTxnFields{}
		}
		for zb0005 > 0 {
			zb0005--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "votekey":
				var zb0026 int
				zb0026, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
				if zb0026 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0026), uint64(maxAddressBytes))
					return
				}
				(*z).VotePK, bts, err = msgp.ReadBytesBytes(bts, (*z).VotePK)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
			case "selkey":
				var zb0027 int
				zb0027, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
				if zb0027 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0027), uint64(maxAddressBytes))
					return
				}
				(*z).SelectionPK, bts, err = msgp.ReadBytesBytes(bts, (*z).SelectionPK)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
			case "votefst":
				var zb0028 int
				var zb0029 bool
				zb0028, zb0029, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0028 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0028), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0029 {
					(*z).VoteFirst = nil
				} else if (*z).VoteFirst != nil && cap((*z).VoteFirst) >= zb0028 {
					(*z).VoteFirst = ((*z).VoteFirst)[:zb0028]
				} else {
					(*z).VoteFirst = make([]basics.Round, zb0028)
				}
				for zb0001 := range (*z).VoteFirst {
					bts, err = (*z).VoteFirst[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteFirst", zb0001)
						return
					}
				}
			case "votefstbm":
				{
					var zb0030 []byte
					var zb0031 int
					zb0031, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteFirst")
						return
					}
					if zb0031 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0031), uint64(maxBitmaskSize))
						return
					}
					zb0030, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVoteFirst))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteFirst")
						return
					}
					(*z).BitmaskVoteFirst = bitmask(zb0030)
				}
			case "votelst":
				var zb0032 int
				var zb0033 bool
				zb0032, zb0033, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0032 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0032), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0033 {
					(*z).VoteLast = nil
				} else if (*z).VoteLast != nil && cap((*z).VoteLast) >= zb0032 {
					(*z).VoteLast = ((*z).VoteLast)[:zb0032]
				} else {
					(*z).VoteLast = make([]basics.Round, zb0032)
				}
				for zb0002 := range (*z).VoteLast {
					bts, err = (*z).VoteLast[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteLast", zb0002)
						return
					}
				}
			case "votelstbm":
				{
					var zb0034 []byte
					var zb0035 int
					zb0035, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteLast")
						return
					}
					if zb0035 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0035), uint64(maxBitmaskSize))
						return
					}
					zb0034, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVoteLast))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteLast")
						return
					}
					(*z).BitmaskVoteLast = bitmask(zb0034)
				}
			case "votekd":
				var zb0036 int
				var zb0037 bool
				zb0036, zb0037, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0036 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0036), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0037 {
					(*z).VoteKeyDilution = nil
				} else if (*z).VoteKeyDilution != nil && cap((*z).VoteKeyDilution) >= zb0036 {
					(*z).VoteKeyDilution = ((*z).VoteKeyDilution)[:zb0036]
				} else {
					(*z).VoteKeyDilution = make([]uint64, zb0036)
				}
				for zb0003 := range (*z).VoteKeyDilution {
					(*z).VoteKeyDilution[zb0003], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteKeyDilution", zb0003)
						return
					}
				}
			case "votekbm":
				{
					var zb0038 []byte
					var zb0039 int
					zb0039, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskKeys")
						return
					}
					if zb0039 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0039), uint64(maxBitmaskSize))
						return
					}
					zb0038, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskKeys))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskKeys")
						return
					}
					(*z).BitmaskKeys = bitmask(zb0038)
				}
			case "nonpartbm":
				{
					var zb0040 []byte
					var zb0041 int
					zb0041, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNonparticipation")
						return
					}
					if zb0041 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0041), uint64(maxBitmaskSize))
						return
					}
					zb0040, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskNonparticipation))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNonparticipation")
						return
					}
					(*z).BitmaskNonparticipation = bitmask(zb0040)
				}
			case "vldrt":
				var zb0042 int
				var zb0043 bool
				zb0042, zb0043, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HasValidRoot")
					return
				}
				if zb0042 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0042), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "HasValidRoot")
					return
				}
				if zb0043 {
					(*z).HasValidRoot = nil
				} else if (*z).HasValidRoot != nil && cap((*z).HasValidRoot) >= zb0042 {
					(*z).HasValidRoot = ((*z).HasValidRoot)[:zb0042]
				} else {
					(*z).HasValidRoot = make([]bool, zb0042)
				}
				for zb0004 := range (*z).HasValidRoot {
					(*z).HasValidRoot[zb0004], bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "HasValidRoot", zb0004)
						return
					}
				}
			case "comt":
				var zb0044 int
				zb0044, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "CommitmentRoot")
					return
				}
				if zb0044 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0044), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).CommitmentRoot, bts, err = msgp.ReadBytesBytes(bts, (*z).CommitmentRoot)
				if err != nil {
					err = msgp.WrapError(err, "CommitmentRoot")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedKeyregTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedKeyregTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedKeyregTxnFields) Msgsize() (s int) {
	s = 1 + 8 + msgp.BytesPrefixSize + len((*z).VotePK) + 7 + msgp.BytesPrefixSize + len((*z).SelectionPK) + 8 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).VoteFirst {
		s += (*z).VoteFirst[zb0001].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskVoteFirst)) + 8 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).VoteLast {
		s += (*z).VoteLast[zb0002].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskVoteLast)) + 7 + msgp.ArrayHeaderSize + (len((*z).VoteKeyDilution) * (msgp.Uint64Size)) + 8 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskKeys)) + 10 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskNonparticipation)) + 6 + msgp.ArrayHeaderSize + (len((*z).HasValidRoot) * (msgp.BoolSize)) + 5 + msgp.BytesPrefixSize + len((*z).CommitmentRoot)
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedKeyregTxnFields) MsgIsZero() bool {
	return (len((*z).VotePK) == 0) && (len((*z).SelectionPK) == 0) && (len((*z).VoteFirst) == 0) && (len((*z).BitmaskVoteFirst) == 0) && (len((*z).VoteLast) == 0) && (len((*z).BitmaskVoteLast) == 0) && (len((*z).VoteKeyDilution) == 0) && (len((*z).BitmaskKeys) == 0) && (len((*z).BitmaskNonparticipation) == 0) && (len((*z).HasValidRoot) == 0) && (len((*z).CommitmentRoot) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedLsigs) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0004Len := uint32(4)
	var zb0004Mask uint8 /* 5 bits */
	if len((*z).LogicArgs) == 0 {
		zb0004Len--
		zb0004Mask |= 0x2
	}
	if len((*z).BitmaskLogicArgs) == 0 {
		zb0004Len--
		zb0004Mask |= 0x4
	}
	if len((*z).Logic) == 0 {
		zb0004Len--
		zb0004Mask |= 0x8
	}
	if len((*z).BitmaskLogic) == 0 {
		zb0004Len--
		zb0004Mask |= 0x10
	}
	// variable map header, size zb0004Len
	o = append(o, 0x80|uint8(zb0004Len))
	if zb0004Len != 0 {
		if (zb0004Mask & 0x2) == 0 { // if not empty
			// string "lsigarg"
			o = append(o, 0xa7, 0x6c, 0x73, 0x69, 0x67, 0x61, 0x72, 0x67)
			if (*z).LogicArgs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).LogicArgs)))
			}
			for zb0002 := range (*z).LogicArgs {
				if (*z).LogicArgs[zb0002] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).LogicArgs[zb0002])))
				}
				for zb0003 := range (*z).LogicArgs[zb0002] {
					o = msgp.AppendBytes(o, (*z).LogicArgs[zb0002][zb0003])
				}
			}
		}
		if (zb0004Mask & 0x4) == 0 { // if not empty
			// string "lsigargbm"
			o = append(o, 0xa9, 0x6c, 0x73, 0x69, 0x67, 0x61, 0x72, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskLogicArgs))
		}
		if (zb0004Mask & 0x8) == 0 { // if not empty
			// string "lsigl"
			o = append(o, 0xa5, 0x6c, 0x73, 0x69, 0x67, 0x6c)
			if (*z).Logic == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Logic)))
			}
			for zb0001 := range (*z).Logic {
				o = msgp.AppendBytes(o, (*z).Logic[zb0001])
			}
		}
		if (zb0004Mask & 0x10) == 0 { // if not empty
			// string "lsiglbm"
			o = append(o, 0xa7, 0x6c, 0x73, 0x69, 0x67, 0x6c, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskLogic))
		}
	}
	return
}

func (_ *encodedLsigs) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedLsigs)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedLsigs) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0004 int
	var zb0005 bool
	zb0004, zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 > 0 {
			zb0004--
			var zb0006 int
			var zb0007 bool
			zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Logic")
				return
			}
			if zb0006 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0006), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Logic")
				return
			}
			if zb0007 {
				(*z).Logic = nil
			} else if (*z).Logic != nil && cap((*z).Logic) >= zb0006 {
				(*z).Logic = ((*z).Logic)[:zb0006]
			} else {
				(*z).Logic = make([][]byte, zb0006)
			}
			for zb0001 := range (*z).Logic {
				var zb0008 int
				zb0008, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Logic", zb0001)
					return
				}
				if zb0008 > config.MaxLogicSigMaxSize {
					err = msgp.ErrOverflow(uint64(zb0008), uint64(config.MaxLogicSigMaxSize))
					return
				}
				(*z).Logic[zb0001], bts, err = msgp.ReadBytesBytes(bts, (*z).Logic[zb0001])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Logic", zb0001)
					return
				}
			}
		}
		if zb0004 > 0 {
			zb0004--
			{
				var zb0009 []byte
				var zb0010 int
				zb0010, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLogic")
					return
				}
				if zb0010 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0010), uint64(maxBitmaskSize))
					return
				}
				zb0009, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLogic))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLogic")
					return
				}
				(*z).BitmaskLogic = bitmask(zb0009)
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0011 int
			var zb0012 bool
			zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LogicArgs")
				return
			}
			if zb0011 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0011), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LogicArgs")
				return
			}
			if zb0012 {
				(*z).LogicArgs = nil
			} else if (*z).LogicArgs != nil && cap((*z).LogicArgs) >= zb0011 {
				(*z).LogicArgs = ((*z).LogicArgs)[:zb0011]
			} else {
				(*z).LogicArgs = make([][][]byte, zb0011)
			}
			for zb0002 := range (*z).LogicArgs {
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LogicArgs", zb0002)
					return
				}
				if zb0013 > transactions.EvalMaxArgs {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(transactions.EvalMaxArgs))
					err = msgp.WrapError(err, "struct-from-array", "LogicArgs", zb0002)
					return
				}
				if zb0014 {
					(*z).LogicArgs[zb0002] = nil
				} else if (*z).LogicArgs[zb0002] != nil && cap((*z).LogicArgs[zb0002]) >= zb0013 {
					(*z).LogicArgs[zb0002] = ((*z).LogicArgs[zb0002])[:zb0013]
				} else {
					(*z).LogicArgs[zb0002] = make([][]byte, zb0013)
				}
				for zb0003 := range (*z).LogicArgs[zb0002] {
					var zb0015 int
					zb0015, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "LogicArgs", zb0002, zb0003)
						return
					}
					if zb0015 > config.MaxLogicSigMaxSize {
						err = msgp.ErrOverflow(uint64(zb0015), uint64(config.MaxLogicSigMaxSize))
						return
					}
					(*z).LogicArgs[zb0002][zb0003], bts, err = msgp.ReadBytesBytes(bts, (*z).LogicArgs[zb0002][zb0003])
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "LogicArgs", zb0002, zb0003)
						return
					}
				}
			}
		}
		if zb0004 > 0 {
			zb0004--
			{
				var zb0016 []byte
				var zb0017 int
				zb0017, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLogicArgs")
					return
				}
				if zb0017 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0017), uint64(maxBitmaskSize))
					return
				}
				zb0016, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLogicArgs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLogicArgs")
					return
				}
				(*z).BitmaskLogicArgs = bitmask(zb0016)
			}
		}
		if zb0004 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0004)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0005 {
			(*z) = encodedLsigs{}
		}
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "lsigl":
				var zb0018 int
				var zb0019 bool
				zb0018, zb0019, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Logic")
					return
				}
				if zb0018 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0018), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Logic")
					return
				}
				if zb0019 {
					(*z).Logic = nil
				} else if (*z).Logic != nil && cap((*z).Logic) >= zb0018 {
					(*z).Logic = ((*z).Logic)[:zb0018]
				} else {
					(*z).Logic = make([][]byte, zb0018)
				}
				for zb0001 := range (*z).Logic {
					var zb0020 int
					zb0020, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "Logic", zb0001)
						return
					}
					if zb0020 > config.MaxLogicSigMaxSize {
						err = msgp.ErrOverflow(uint64(zb0020), uint64(config.MaxLogicSigMaxSize))
						return
					}
					(*z).Logic[zb0001], bts, err = msgp.ReadBytesBytes(bts, (*z).Logic[zb0001])
					if err != nil {
						err = msgp.WrapError(err, "Logic", zb0001)
						return
					}
				}
			case "lsiglbm":
				{
					var zb0021 []byte
					var zb0022 int
					zb0022, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLogic")
						return
					}
					if zb0022 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0022), uint64(maxBitmaskSize))
						return
					}
					zb0021, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLogic))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLogic")
						return
					}
					(*z).BitmaskLogic = bitmask(zb0021)
				}
			case "lsigarg":
				var zb0023 int
				var zb0024 bool
				zb0023, zb0024, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LogicArgs")
					return
				}
				if zb0023 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0023), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LogicArgs")
					return
				}
				if zb0024 {
					(*z).LogicArgs = nil
				} else if (*z).LogicArgs != nil && cap((*z).LogicArgs) >= zb0023 {
					(*z).LogicArgs = ((*z).LogicArgs)[:zb0023]
				} else {
					(*z).LogicArgs = make([][][]byte, zb0023)
				}
				for zb0002 := range (*z).LogicArgs {
					var zb0025 int
					var zb0026 bool
					zb0025, zb0026, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LogicArgs", zb0002)
						return
					}
					if zb0025 > transactions.EvalMaxArgs {
						err = msgp.ErrOverflow(uint64(zb0025), uint64(transactions.EvalMaxArgs))
						err = msgp.WrapError(err, "LogicArgs", zb0002)
						return
					}
					if zb0026 {
						(*z).LogicArgs[zb0002] = nil
					} else if (*z).LogicArgs[zb0002] != nil && cap((*z).LogicArgs[zb0002]) >= zb0025 {
						(*z).LogicArgs[zb0002] = ((*z).LogicArgs[zb0002])[:zb0025]
					} else {
						(*z).LogicArgs[zb0002] = make([][]byte, zb0025)
					}
					for zb0003 := range (*z).LogicArgs[zb0002] {
						var zb0027 int
						zb0027, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "LogicArgs", zb0002, zb0003)
							return
						}
						if zb0027 > config.MaxLogicSigMaxSize {
							err = msgp.ErrOverflow(uint64(zb0027), uint64(config.MaxLogicSigMaxSize))
							return
						}
						(*z).LogicArgs[zb0002][zb0003], bts, err = msgp.ReadBytesBytes(bts, (*z).LogicArgs[zb0002][zb0003])
						if err != nil {
							err = msgp.WrapError(err, "LogicArgs", zb0002, zb0003)
							return
						}
					}
				}
			case "lsigargbm":
				{
					var zb0028 []byte
					var zb0029 int
					zb0029, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLogicArgs")
						return
					}
					if zb0029 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0029), uint64(maxBitmaskSize))
						return
					}
					zb0028, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLogicArgs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLogicArgs")
						return
					}
					(*z).BitmaskLogicArgs = bitmask(zb0028)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedLsigs) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedLsigs)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedLsigs) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Logic {
		s += msgp.BytesPrefixSize + len((*z).Logic[zb0001])
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskLogic)) + 8 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).LogicArgs {
		s += msgp.ArrayHeaderSize
		for zb0003 := range (*z).LogicArgs[zb0002] {
			s += msgp.BytesPrefixSize + len((*z).LogicArgs[zb0002][zb0003])
		}
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskLogicArgs))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedLsigs) MsgIsZero() bool {
	return (len((*z).Logic) == 0) && (len((*z).BitmaskLogic) == 0) && (len((*z).LogicArgs) == 0) && (len((*z).BitmaskLogicArgs) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedMsigs) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(6)
	var zb0003Mask uint8 /* 7 bits */
	if len((*z).Threshold) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if len((*z).BitmaskThreshold) == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if len((*z).Version) == 0 {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if len((*z).BitmaskVersion) == 0 {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if len((*z).Subsigs) == 0 {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if len((*z).BitmaskSubsigs) == 0 {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "msigthr"
			o = append(o, 0xa7, 0x6d, 0x73, 0x69, 0x67, 0x74, 0x68, 0x72)
			o = msgp.AppendBytes(o, (*z).Threshold)
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "msigthrbm"
			o = append(o, 0xa9, 0x6d, 0x73, 0x69, 0x67, 0x74, 0x68, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskThreshold))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "msigv"
			o = append(o, 0xa5, 0x6d, 0x73, 0x69, 0x67, 0x76)
			o = msgp.AppendBytes(o, (*z).Version)
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "msigvbm"
			o = append(o, 0xa7, 0x6d, 0x73, 0x69, 0x67, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskVersion))
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "subsig"
			o = append(o, 0xa6, 0x73, 0x75, 0x62, 0x73, 0x69, 0x67)
			if (*z).Subsigs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Subsigs)))
			}
			for zb0001 := range (*z).Subsigs {
				if (*z).Subsigs[zb0001] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).Subsigs[zb0001])))
				}
				for zb0002 := range (*z).Subsigs[zb0001] {
					o = (*z).Subsigs[zb0001][zb0002].MarshalMsg(o)
				}
			}
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "subsigsbm"
			o = append(o, 0xa9, 0x73, 0x75, 0x62, 0x73, 0x69, 0x67, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskSubsigs))
		}
	}
	return
}

func (_ *encodedMsigs) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedMsigs)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedMsigs) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			zb0005, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Version")
				return
			}
			if zb0005 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0005), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).Version, bts, err = msgp.ReadBytesBytes(bts, (*z).Version)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Version")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0006 []byte
				var zb0007 int
				zb0007, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVersion")
					return
				}
				if zb0007 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0007), uint64(maxBitmaskSize))
					return
				}
				zb0006, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVersion))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVersion")
					return
				}
				(*z).BitmaskVersion = bitmask(zb0006)
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0008 int
			zb0008, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Threshold")
				return
			}
			if zb0008 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0008), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).Threshold, bts, err = msgp.ReadBytesBytes(bts, (*z).Threshold)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Threshold")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0009 []byte
				var zb0010 int
				zb0010, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskThreshold")
					return
				}
				if zb0010 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0010), uint64(maxBitmaskSize))
					return
				}
				zb0009, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskThreshold))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskThreshold")
					return
				}
				(*z).BitmaskThreshold = bitmask(zb0009)
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0011 int
			var zb0012 bool
			zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Subsigs")
				return
			}
			if zb0011 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0011), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Subsigs")
				return
			}
			if zb0012 {
				(*z).Subsigs = nil
			} else if (*z).Subsigs != nil && cap((*z).Subsigs) >= zb0011 {
				(*z).Subsigs = ((*z).Subsigs)[:zb0011]
			} else {
				(*z).Subsigs = make([][]crypto.MultisigSubsig, zb0011)
			}
			for zb0001 := range (*z).Subsigs {
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Subsigs", zb0001)
					return
				}
				if zb0013 > crypto.MaxMultisig {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(crypto.MaxMultisig))
					err = msgp.WrapError(err, "struct-from-array", "Subsigs", zb0001)
					return
				}
				if zb0014 {
					(*z).Subsigs[zb0001] = nil
				} else if (*z).Subsigs[zb0001] != nil && cap((*z).Subsigs[zb0001]) >= zb0013 {
					(*z).Subsigs[zb0001] = ((*z).Subsigs[zb0001])[:zb0013]
				} else {
					(*z).Subsigs[zb0001] = make([]crypto.MultisigSubsig, zb0013)
				}
				for zb0002 := range (*z).Subsigs[zb0001] {
					bts, err = (*z).Subsigs[zb0001][zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Subsigs", zb0001, zb0002)
						return
					}
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0015 []byte
				var zb0016 int
				zb0016, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSubsigs")
					return
				}
				if zb0016 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0016), uint64(maxBitmaskSize))
					return
				}
				zb0015, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSubsigs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSubsigs")
					return
				}
				(*z).BitmaskSubsigs = bitmask(zb0015)
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = encodedMsigs{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "msigv":
				var zb0017 int
				zb0017, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Version")
					return
				}
				if zb0017 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0017), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).Version, bts, err = msgp.ReadBytesBytes(bts, (*z).Version)
				if err != nil {
					err = msgp.WrapError(err, "Version")
					return
				}
			case "msigvbm":
				{
					var zb0018 []byte
					var zb0019 int
					zb0019, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVersion")
						return
					}
					if zb0019 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0019), uint64(maxBitmaskSize))
						return
					}
					zb0018, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVersion))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVersion")
						return
					}
					(*z).BitmaskVersion = bitmask(zb0018)
				}
			case "msigthr":
				var zb0020 int
				zb0020, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Threshold")
					return
				}
				if zb0020 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0020), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).Threshold, bts, err = msgp.ReadBytesBytes(bts, (*z).Threshold)
				if err != nil {
					err = msgp.WrapError(err, "Threshold")
					return
				}
			case "msigthrbm":
				{
					var zb0021 []byte
					var zb0022 int
					zb0022, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskThreshold")
						return
					}
					if zb0022 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0022), uint64(maxBitmaskSize))
						return
					}
					zb0021, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskThreshold))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskThreshold")
						return
					}
					(*z).BitmaskThreshold = bitmask(zb0021)
				}
			case "subsig":
				var zb0023 int
				var zb0024 bool
				zb0023, zb0024, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Subsigs")
					return
				}
				if zb0023 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0023), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Subsigs")
					return
				}
				if zb0024 {
					(*z).Subsigs = nil
				} else if (*z).Subsigs != nil && cap((*z).Subsigs) >= zb0023 {
					(*z).Subsigs = ((*z).Subsigs)[:zb0023]
				} else {
					(*z).Subsigs = make([][]crypto.MultisigSubsig, zb0023)
				}
				for zb0001 := range (*z).Subsigs {
					var zb0025 int
					var zb0026 bool
					zb0025, zb0026, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Subsigs", zb0001)
						return
					}
					if zb0025 > crypto.MaxMultisig {
						err = msgp.ErrOverflow(uint64(zb0025), uint64(crypto.MaxMultisig))
						err = msgp.WrapError(err, "Subsigs", zb0001)
						return
					}
					if zb0026 {
						(*z).Subsigs[zb0001] = nil
					} else if (*z).Subsigs[zb0001] != nil && cap((*z).Subsigs[zb0001]) >= zb0025 {
						(*z).Subsigs[zb0001] = ((*z).Subsigs[zb0001])[:zb0025]
					} else {
						(*z).Subsigs[zb0001] = make([]crypto.MultisigSubsig, zb0025)
					}
					for zb0002 := range (*z).Subsigs[zb0001] {
						bts, err = (*z).Subsigs[zb0001][zb0002].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Subsigs", zb0001, zb0002)
							return
						}
					}
				}
			case "subsigsbm":
				{
					var zb0027 []byte
					var zb0028 int
					zb0028, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSubsigs")
						return
					}
					if zb0028 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0028), uint64(maxBitmaskSize))
						return
					}
					zb0027, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSubsigs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSubsigs")
						return
					}
					(*z).BitmaskSubsigs = bitmask(zb0027)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedMsigs) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedMsigs)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedMsigs) Msgsize() (s int) {
	s = 1 + 6 + msgp.BytesPrefixSize + len((*z).Version) + 8 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskVersion)) + 8 + msgp.BytesPrefixSize + len((*z).Threshold) + 10 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskThreshold)) + 7 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Subsigs {
		s += msgp.ArrayHeaderSize
		for zb0002 := range (*z).Subsigs[zb0001] {
			s += (*z).Subsigs[zb0001][zb0002].Msgsize()
		}
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskSubsigs))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedMsigs) MsgIsZero() bool {
	return (len((*z).Version) == 0) && (len((*z).BitmaskVersion) == 0) && (len((*z).Threshold) == 0) && (len((*z).BitmaskThreshold) == 0) && (len((*z).Subsigs) == 0) && (len((*z).BitmaskSubsigs) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedPaymentTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(6)
	var zb0002Mask uint8 /* 7 bits */
	if len((*z).Amount) == 0 {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	if len((*z).BitmaskAmount) == 0 {
		zb0002Len--
		zb0002Mask |= 0x4
	}
	if len((*z).CloseRemainderTo) == 0 {
		zb0002Len--
		zb0002Mask |= 0x8
	}
	if len((*z).BitmaskCloseRemainderTo) == 0 {
		zb0002Len--
		zb0002Mask |= 0x10
	}
	if len((*z).Receiver) == 0 {
		zb0002Len--
		zb0002Mask |= 0x20
	}
	if len((*z).BitmaskReceiver) == 0 {
		zb0002Len--
		zb0002Mask |= 0x40
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "amt"
			o = append(o, 0xa3, 0x61, 0x6d, 0x74)
			if (*z).Amount == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Amount)))
			}
			for zb0001 := range (*z).Amount {
				o = (*z).Amount[zb0001].MarshalMsg(o)
			}
		}
		if (zb0002Mask & 0x4) == 0 { // if not empty
			// string "amtbm"
			o = append(o, 0xa5, 0x61, 0x6d, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskAmount))
		}
		if (zb0002Mask & 0x8) == 0 { // if not empty
			// string "close"
			o = append(o, 0xa5, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			o = msgp.AppendBytes(o, (*z).CloseRemainderTo)
		}
		if (zb0002Mask & 0x10) == 0 { // if not empty
			// string "closebm"
			o = append(o, 0xa7, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskCloseRemainderTo))
		}
		if (zb0002Mask & 0x20) == 0 { // if not empty
			// string "rcv"
			o = append(o, 0xa3, 0x72, 0x63, 0x76)
			o = msgp.AppendBytes(o, (*z).Receiver)
		}
		if (zb0002Mask & 0x40) == 0 { // if not empty
			// string "rcvbm"
			o = append(o, 0xa5, 0x72, 0x63, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskReceiver))
		}
	}
	return
}

func (_ *encodedPaymentTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedPaymentTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedPaymentTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			var zb0004 int
			zb0004, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
			if zb0004 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0004), uint64(maxAddressBytes))
				return
			}
			(*z).Receiver, bts, err = msgp.ReadBytesBytes(bts, (*z).Receiver)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			{
				var zb0005 []byte
				var zb0006 int
				zb0006, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReceiver")
					return
				}
				if zb0006 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0006), uint64(maxBitmaskSize))
					return
				}
				zb0005, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskReceiver))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReceiver")
					return
				}
				(*z).BitmaskReceiver = bitmask(zb0005)
			}
		}
		if zb0002 > 0 {
			zb0002--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0007 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0007), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0008 {
				(*z).Amount = nil
			} else if (*z).Amount != nil && cap((*z).Amount) >= zb0007 {
				(*z).Amount = ((*z).Amount)[:zb0007]
			} else {
				(*z).Amount = make([]basics.MicroAlgos, zb0007)
			}
			for zb0001 := range (*z).Amount {
				bts, err = (*z).Amount[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Amount", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			zb0002--
			{
				var zb0009 []byte
				var zb0010 int
				zb0010, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAmount")
					return
				}
				if zb0010 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0010), uint64(maxBitmaskSize))
					return
				}
				zb0009, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAmount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAmount")
					return
				}
				(*z).BitmaskAmount = bitmask(zb0009)
			}
		}
		if zb0002 > 0 {
			zb0002--
			var zb0011 int
			zb0011, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
			if zb0011 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0011), uint64(maxAddressBytes))
				return
			}
			(*z).CloseRemainderTo, bts, err = msgp.ReadBytesBytes(bts, (*z).CloseRemainderTo)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			{
				var zb0012 []byte
				var zb0013 int
				zb0013, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCloseRemainderTo")
					return
				}
				if zb0013 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(maxBitmaskSize))
					return
				}
				zb0012, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskCloseRemainderTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCloseRemainderTo")
					return
				}
				(*z).BitmaskCloseRemainderTo = bitmask(zb0012)
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = encodedPaymentTxnFields{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rcv":
				var zb0014 int
				zb0014, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
				if zb0014 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0014), uint64(maxAddressBytes))
					return
				}
				(*z).Receiver, bts, err = msgp.ReadBytesBytes(bts, (*z).Receiver)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
			case "rcvbm":
				{
					var zb0015 []byte
					var zb0016 int
					zb0016, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReceiver")
						return
					}
					if zb0016 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0016), uint64(maxBitmaskSize))
						return
					}
					zb0015, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskReceiver))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReceiver")
						return
					}
					(*z).BitmaskReceiver = bitmask(zb0015)
				}
			case "amt":
				var zb0017 int
				var zb0018 bool
				zb0017, zb0018, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0017 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0017), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0018 {
					(*z).Amount = nil
				} else if (*z).Amount != nil && cap((*z).Amount) >= zb0017 {
					(*z).Amount = ((*z).Amount)[:zb0017]
				} else {
					(*z).Amount = make([]basics.MicroAlgos, zb0017)
				}
				for zb0001 := range (*z).Amount {
					bts, err = (*z).Amount[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Amount", zb0001)
						return
					}
				}
			case "amtbm":
				{
					var zb0019 []byte
					var zb0020 int
					zb0020, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAmount")
						return
					}
					if zb0020 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0020), uint64(maxBitmaskSize))
						return
					}
					zb0019, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAmount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAmount")
						return
					}
					(*z).BitmaskAmount = bitmask(zb0019)
				}
			case "close":
				var zb0021 int
				zb0021, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
				if zb0021 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0021), uint64(maxAddressBytes))
					return
				}
				(*z).CloseRemainderTo, bts, err = msgp.ReadBytesBytes(bts, (*z).CloseRemainderTo)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
			case "closebm":
				{
					var zb0022 []byte
					var zb0023 int
					zb0023, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCloseRemainderTo")
						return
					}
					if zb0023 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0023), uint64(maxBitmaskSize))
						return
					}
					zb0022, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskCloseRemainderTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCloseRemainderTo")
						return
					}
					(*z).BitmaskCloseRemainderTo = bitmask(zb0022)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedPaymentTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedPaymentTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedPaymentTxnFields) Msgsize() (s int) {
	s = 1 + 4 + msgp.BytesPrefixSize + len((*z).Receiver) + 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskReceiver)) + 4 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Amount {
		s += (*z).Amount[zb0001].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskAmount)) + 6 + msgp.BytesPrefixSize + len((*z).CloseRemainderTo) + 8 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskCloseRemainderTo))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedPaymentTxnFields) MsgIsZero() bool {
	return (len((*z).Receiver) == 0) && (len((*z).BitmaskReceiver) == 0) && (len((*z).Amount) == 0) && (len((*z).BitmaskAmount) == 0) && (len((*z).CloseRemainderTo) == 0) && (len((*z).BitmaskCloseRemainderTo) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedSignedTxns) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0053Len := uint32(132)
	var zb0053Mask [3]uint64 /* 146 bits */
	if len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x4000
	}
	if len((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x8000
	}
	if len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x10000
	}
	if len((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x20000
	}
	if len((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x40000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x80000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x100000
	}
	if len((*z).encodedTxns.encodedPaymentTxnFields.Amount) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x200000
	}
	if len((*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x400000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x800000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x1000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x2000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x4000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.OnCompletion) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x8000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x10000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x20000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x40000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x80000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x100000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.Accounts) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x200000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x400000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x800000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x1000000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x2000000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x4000000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x8000000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x10000000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x20000000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x40000000000
	}
	if len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetReceiver) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x80000000000
	}
	if len((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x100000000000
	}
	if len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetSender) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x200000000000
	}
	if len((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x400000000000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x800000000000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x1000000000000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x2000000000000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x4000000000000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x8000000000000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x10000000000000
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x20000000000000
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x40000000000000
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x80000000000000
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x100000000000000
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x200000000000000
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x400000000000000
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x800000000000000
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x1000000000000000
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x2000000000000000
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x4000000000000000
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x8000000000000000
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x1
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.CertRound) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x2
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x4
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.CertType) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x8
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertType) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x10
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x20
	}
	if len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x40
	}
	if len((*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x80
	}
	if len((*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x100
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.CommitmentRoot) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x200
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x400
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x800
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x1000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x2000
	}
	if len((*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x4000
	}
	if len((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x8000
	}
	if len((*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x10000
	}
	if len((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x20000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x40000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.Fee) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x80000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskFee) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x100000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.FirstValid) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x200000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x400000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x800000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x1000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x2000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x4000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x8000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskGroup) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x10000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x20000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x40000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x80000000
	}
	if len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x100000000
	}
	if len((*z).encodedLsigs.LogicArgs) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x200000000
	}
	if len((*z).encodedLsigs.BitmaskLogicArgs) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x400000000
	}
	if len((*z).encodedLsigs.Logic) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x800000000
	}
	if len((*z).encodedLsigs.BitmaskLogic) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x1000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.LastValid) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x2000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x4000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.Lease) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x8000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskLease) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x10000000000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x20000000000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x40000000000
	}
	if len((*z).encodedMsigs.Threshold) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x80000000000
	}
	if len((*z).encodedMsigs.BitmaskThreshold) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x100000000000
	}
	if len((*z).encodedMsigs.Version) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x200000000000
	}
	if len((*z).encodedMsigs.BitmaskVersion) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x400000000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x800000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.Note) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x1000000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskNote) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x2000000000000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x4000000000000
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x8000000000000
	}
	if len((*z).encodedTxns.encodedPaymentTxnFields.Receiver) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x10000000000000
	}
	if len((*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x20000000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.RekeyTo) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x40000000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x80000000000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.SelectionPK) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x100000000000000
	}
	if len((*z).AuthAddr) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x200000000000000
	}
	if len((*z).BitmaskAuthAddr) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x400000000000000
	}
	if len((*z).Sig) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x800000000000000
	}
	if len((*z).BitmaskSig) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x1000000000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.Sender) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x2000000000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskSender) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x4000000000000000
	}
	if len((*z).encodedMsigs.Subsigs) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x8000000000000000
	}
	if len((*z).encodedMsigs.BitmaskSubsigs) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x1
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x2
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x4
	}
	if len((*z).encodedTxns.TxType) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x8
	}
	if len((*z).encodedTxns.BitmaskTxType) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x10
	}
	if (*z).encodedTxns.TxTypeOffset == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x20
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x40
	}
	if len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x80
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x100
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x200
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x400
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskKeys) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x800
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x1000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.VotePK) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x2000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.VoteLast) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x4000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x8000
	}
	if len((*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x10000
	}
	if len((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x20000
	}
	// variable map header, size zb0053Len
	o = msgp.AppendMapHeader(o, zb0053Len)
	if zb0053Len != 0 {
		if (zb0053Mask[0] & 0x4000) == 0 { // if not empty
			// string "aamt"
			o = append(o, 0xa4, 0x61, 0x61, 0x6d, 0x74)
			if (*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount)))
			}
			for zb0022 := range (*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount {
				o = msgp.AppendUint64(o, (*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount[zb0022])
			}
		}
		if (zb0053Mask[0] & 0x8000) == 0 { // if not empty
			// string "aamtbm"
			o = append(o, 0xa6, 0x61, 0x61, 0x6d, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount))
		}
		if (zb0053Mask[0] & 0x10000) == 0 { // if not empty
			// string "aclose"
			o = append(o, 0xa6, 0x61, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo)
		}
		if (zb0053Mask[0] & 0x20000) == 0 { // if not empty
			// string "aclosebm"
			o = append(o, 0xa8, 0x61, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo))
		}
		if (zb0053Mask[0] & 0x40000) == 0 { // if not empty
			// string "afrzbm"
			o = append(o, 0xa6, 0x61, 0x66, 0x72, 0x7a, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen))
		}
		if (zb0053Mask[0] & 0x80000) == 0 { // if not empty
			// string "am"
			o = append(o, 0xa2, 0x61, 0x6d)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash)
		}
		if (zb0053Mask[0] & 0x100000) == 0 { // if not empty
			// string "ambm"
			o = append(o, 0xa4, 0x61, 0x6d, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash))
		}
		if (zb0053Mask[0] & 0x200000) == 0 { // if not empty
			// string "amt"
			o = append(o, 0xa3, 0x61, 0x6d, 0x74)
			if (*z).encodedTxns.encodedPaymentTxnFields.Amount == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedPaymentTxnFields.Amount)))
			}
			for zb0014 := range (*z).encodedTxns.encodedPaymentTxnFields.Amount {
				o = (*z).encodedTxns.encodedPaymentTxnFields.Amount[zb0014].MarshalMsg(o)
			}
		}
		if (zb0053Mask[0] & 0x400000) == 0 { // if not empty
			// string "amtbm"
			o = append(o, 0xa5, 0x61, 0x6d, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount))
		}
		if (zb0053Mask[0] & 0x800000) == 0 { // if not empty
			// string "an"
			o = append(o, 0xa2, 0x61, 0x6e)
			if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName)))
			}
			for zb0019 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName {
				o = msgp.AppendString(o, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName[zb0019])
			}
		}
		if (zb0053Mask[0] & 0x1000000) == 0 { // if not empty
			// string "anbm"
			o = append(o, 0xa4, 0x61, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName))
		}
		if (zb0053Mask[0] & 0x2000000) == 0 { // if not empty
			// string "apaa"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x61)
			if (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs)))
			}
			for zb0025 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs {
				if (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025])))
				}
				for zb0026 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] {
					o = msgp.AppendBytes(o, (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025][zb0026])
				}
			}
		}
		if (zb0053Mask[0] & 0x4000000) == 0 { // if not empty
			// string "apaabm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x61, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs))
		}
		if (zb0053Mask[0] & 0x8000000) == 0 { // if not empty
			// string "apan"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x6e)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedApplicationCallTxnFields.OnCompletion)
		}
		if (zb0053Mask[0] & 0x10000000) == 0 { // if not empty
			// string "apanbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion))
		}
		if (zb0053Mask[0] & 0x20000000) == 0 { // if not empty
			// string "apap"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x70)
			if (*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram)))
			}
			for zb0037 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram {
				o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram[zb0037]))
			}
		}
		if (zb0053Mask[0] & 0x40000000) == 0 { // if not empty
			// string "apapbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x70, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram))
		}
		if (zb0053Mask[0] & 0x80000000) == 0 { // if not empty
			// string "apas"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x73)
			if (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets)))
			}
			for zb0031 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets {
				if (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031])))
				}
				for zb0032 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] {
					o = (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031][zb0032].MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[0] & 0x100000000) == 0 { // if not empty
			// string "apasbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets))
		}
		if (zb0053Mask[0] & 0x200000000) == 0 { // if not empty
			// string "apat"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x74)
			if (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.Accounts)))
			}
			for zb0027 := range (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts {
				if (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027])))
				}
				for zb0028 := range (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] {
					o = (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027][zb0028].MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[0] & 0x400000000) == 0 { // if not empty
			// string "apatbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts))
		}
		if (zb0053Mask[0] & 0x800000000) == 0 { // if not empty
			// string "apep"
			o = append(o, 0xa4, 0x61, 0x70, 0x65, 0x70)
			if (*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages)))
			}
			for zb0039 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages {
				o = msgp.AppendUint32(o, (*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages[zb0039])
			}
		}
		if (zb0053Mask[0] & 0x1000000000) == 0 { // if not empty
			// string "apepbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x65, 0x70, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages))
		}
		if (zb0053Mask[0] & 0x2000000000) == 0 { // if not empty
			// string "apfa"
			o = append(o, 0xa4, 0x61, 0x70, 0x66, 0x61)
			if (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps)))
			}
			for zb0029 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps {
				if (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029])))
				}
				for zb0030 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] {
					o = (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029][zb0030].MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[0] & 0x4000000000) == 0 { // if not empty
			// string "apfabm"
			o = append(o, 0xa6, 0x61, 0x70, 0x66, 0x61, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps))
		}
		if (zb0053Mask[0] & 0x8000000000) == 0 { // if not empty
			// string "apid"
			o = append(o, 0xa4, 0x61, 0x70, 0x69, 0x64)
			if (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID)))
			}
			for zb0024 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID {
				o = (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID[zb0024].MarshalMsg(o)
			}
		}
		if (zb0053Mask[0] & 0x10000000000) == 0 { // if not empty
			// string "apidbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID))
		}
		if (zb0053Mask[0] & 0x20000000000) == 0 { // if not empty
			// string "apsu"
			o = append(o, 0xa4, 0x61, 0x70, 0x73, 0x75)
			if (*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram)))
			}
			for zb0038 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram {
				o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram[zb0038]))
			}
		}
		if (zb0053Mask[0] & 0x40000000000) == 0 { // if not empty
			// string "apsubm"
			o = append(o, 0xa6, 0x61, 0x70, 0x73, 0x75, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram))
		}
		if (zb0053Mask[0] & 0x80000000000) == 0 { // if not empty
			// string "arcv"
			o = append(o, 0xa4, 0x61, 0x72, 0x63, 0x76)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedAssetTransferTxnFields.AssetReceiver)
		}
		if (zb0053Mask[0] & 0x100000000000) == 0 { // if not empty
			// string "arcvbm"
			o = append(o, 0xa6, 0x61, 0x72, 0x63, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver))
		}
		if (zb0053Mask[0] & 0x200000000000) == 0 { // if not empty
			// string "asnd"
			o = append(o, 0xa4, 0x61, 0x73, 0x6e, 0x64)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedAssetTransferTxnFields.AssetSender)
		}
		if (zb0053Mask[0] & 0x400000000000) == 0 { // if not empty
			// string "asndbm"
			o = append(o, 0xa6, 0x61, 0x73, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender))
		}
		if (zb0053Mask[0] & 0x800000000000) == 0 { // if not empty
			// string "au"
			o = append(o, 0xa2, 0x61, 0x75)
			if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL)))
			}
			for zb0020 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL {
				o = msgp.AppendString(o, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL[zb0020])
			}
		}
		if (zb0053Mask[0] & 0x1000000000000) == 0 { // if not empty
			// string "aubm"
			o = append(o, 0xa4, 0x61, 0x75, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL))
		}
		if (zb0053Mask[0] & 0x2000000000000) == 0 { // if not empty
			// string "c"
			o = append(o, 0xa1, 0x63)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback)
		}
		if (zb0053Mask[0] & 0x4000000000000) == 0 { // if not empty
			// string "caid"
			o = append(o, 0xa4, 0x63, 0x61, 0x69, 0x64)
			if (*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset)))
			}
			for zb0015 := range (*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset {
				o = (*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset[zb0015].MarshalMsg(o)
			}
		}
		if (zb0053Mask[0] & 0x8000000000000) == 0 { // if not empty
			// string "caidbm"
			o = append(o, 0xa6, 0x63, 0x61, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset))
		}
		if (zb0053Mask[0] & 0x10000000000000) == 0 { // if not empty
			// string "cbm"
			o = append(o, 0xa3, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback))
		}
		if (zb0053Mask[0] & 0x20000000000000) == 0 { // if not empty
			// string "certP"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x50)
			if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs)))
			}
			for zb0047 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs {
				if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047])))
				}
				for zb0048 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] {
					o = (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047][zb0048].MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[0] & 0x40000000000000) == 0 { // if not empty
			// string "certPH"
			o = append(o, 0xa6, 0x63, 0x65, 0x72, 0x74, 0x50, 0x48)
			if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes)))
			}
			for zb0049 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes {
				o = msgp.AppendUint64(o, (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes[zb0049])
			}
		}
		if (zb0053Mask[0] & 0x80000000000000) == 0 { // if not empty
			// string "certPHbm"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x50, 0x48, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash))
		}
		if (zb0053Mask[0] & 0x100000000000000) == 0 { // if not empty
			// string "certPbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x50, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs))
		}
		if (zb0053Mask[0] & 0x200000000000000) == 0 { // if not empty
			// string "certS"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x53)
			if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs)))
			}
			for zb0044 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs {
				if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044])))
				}
				for zb0045 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] {
					o = (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044][zb0045].MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[0] & 0x400000000000000) == 0 { // if not empty
			// string "certSH"
			o = append(o, 0xa6, 0x63, 0x65, 0x72, 0x74, 0x53, 0x48)
			if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes)))
			}
			for zb0046 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes {
				o = msgp.AppendUint64(o, (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes[zb0046])
			}
		}
		if (zb0053Mask[0] & 0x800000000000000) == 0 { // if not empty
			// string "certSHbm"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x53, 0x48, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash))
		}
		if (zb0053Mask[0] & 0x1000000000000000) == 0 { // if not empty
			// string "certSbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x53, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs))
		}
		if (zb0053Mask[0] & 0x2000000000000000) == 0 { // if not empty
			// string "certc"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x63)
			if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit)))
			}
			for zb0042 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit {
				o = (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit[zb0042].MarshalMsg(o)
			}
		}
		if (zb0053Mask[0] & 0x4000000000000000) == 0 { // if not empty
			// string "certcbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit))
		}
		if (zb0053Mask[0] & 0x8000000000000000) == 0 { // if not empty
			// string "certr"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x72)
			if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals)))
			}
			for zb0050 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals {
				if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendMapHeader(o, uint32(len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050])))
				}
				zb0051_keys := make([]uint64, 0, len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050]))
				for zb0051 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] {
					zb0051_keys = append(zb0051_keys, zb0051)
				}
				sort.Sort(SortUint64(zb0051_keys))
				for _, zb0051 := range zb0051_keys {
					zb0052 := (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050][zb0051]
					_ = zb0052
					o = msgp.AppendUint64(o, zb0051)
					o = zb0052.MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[1] & 0x1) == 0 { // if not empty
			// string "certrbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals))
		}
		if (zb0053Mask[1] & 0x2) == 0 { // if not empty
			// string "certrnd"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x72, 0x6e, 0x64)
			if (*z).encodedTxns.encodedCompactCertTxnFields.CertRound == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedCompactCertTxnFields.CertRound)))
			}
			for zb0040 := range (*z).encodedTxns.encodedCompactCertTxnFields.CertRound {
				o = (*z).encodedTxns.encodedCompactCertTxnFields.CertRound[zb0040].MarshalMsg(o)
			}
		}
		if (zb0053Mask[1] & 0x4) == 0 { // if not empty
			// string "certrndbm"
			o = append(o, 0xa9, 0x63, 0x65, 0x72, 0x74, 0x72, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound))
		}
		if (zb0053Mask[1] & 0x8) == 0 { // if not empty
			// string "certtype"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x74, 0x79, 0x70, 0x65)
			if (*z).encodedTxns.encodedCompactCertTxnFields.CertType == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedCompactCertTxnFields.CertType)))
			}
			for zb0041 := range (*z).encodedTxns.encodedCompactCertTxnFields.CertType {
				o = (*z).encodedTxns.encodedCompactCertTxnFields.CertType[zb0041].MarshalMsg(o)
			}
		}
		if (zb0053Mask[1] & 0x10) == 0 { // if not empty
			// string "certtypebm"
			o = append(o, 0xaa, 0x63, 0x65, 0x72, 0x74, 0x74, 0x79, 0x70, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertType))
		}
		if (zb0053Mask[1] & 0x20) == 0 { // if not empty
			// string "certw"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x77)
			if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight)))
			}
			for zb0043 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight {
				o = msgp.AppendUint64(o, (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight[zb0043])
			}
		}
		if (zb0053Mask[1] & 0x40) == 0 { // if not empty
			// string "certwbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x77, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight))
		}
		if (zb0053Mask[1] & 0x80) == 0 { // if not empty
			// string "close"
			o = append(o, 0xa5, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo)
		}
		if (zb0053Mask[1] & 0x100) == 0 { // if not empty
			// string "closebm"
			o = append(o, 0xa7, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
		}
		if (zb0053Mask[1] & 0x200) == 0 { // if not empty
			// string "comt"
			o = append(o, 0xa4, 0x63, 0x6f, 0x6d, 0x74)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedKeyregTxnFields.CommitmentRoot)
		}
		if (zb0053Mask[1] & 0x400) == 0 { // if not empty
			// string "dc"
			o = append(o, 0xa2, 0x64, 0x63)
			if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals)))
			}
			for zb0017 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals {
				o = msgp.AppendUint32(o, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals[zb0017])
			}
		}
		if (zb0053Mask[1] & 0x800) == 0 { // if not empty
			// string "dcbm"
			o = append(o, 0xa4, 0x64, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals))
		}
		if (zb0053Mask[1] & 0x1000) == 0 { // if not empty
			// string "dfbm"
			o = append(o, 0xa4, 0x64, 0x66, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen))
		}
		if (zb0053Mask[1] & 0x2000) == 0 { // if not empty
			// string "f"
			o = append(o, 0xa1, 0x66)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze)
		}
		if (zb0053Mask[1] & 0x4000) == 0 { // if not empty
			// string "fadd"
			o = append(o, 0xa4, 0x66, 0x61, 0x64, 0x64)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount)
		}
		if (zb0053Mask[1] & 0x8000) == 0 { // if not empty
			// string "faddbm"
			o = append(o, 0xa6, 0x66, 0x61, 0x64, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount))
		}
		if (zb0053Mask[1] & 0x10000) == 0 { // if not empty
			// string "faid"
			o = append(o, 0xa4, 0x66, 0x61, 0x69, 0x64)
			if (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset)))
			}
			for zb0023 := range (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset {
				o = (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset[zb0023].MarshalMsg(o)
			}
		}
		if (zb0053Mask[1] & 0x20000) == 0 { // if not empty
			// string "faidbm"
			o = append(o, 0xa6, 0x66, 0x61, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset))
		}
		if (zb0053Mask[1] & 0x40000) == 0 { // if not empty
			// string "fbm"
			o = append(o, 0xa3, 0x66, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze))
		}
		if (zb0053Mask[1] & 0x80000) == 0 { // if not empty
			// string "fee"
			o = append(o, 0xa3, 0x66, 0x65, 0x65)
			if (*z).encodedTxns.encodedTxnHeaders.Fee == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedTxnHeaders.Fee)))
			}
			for zb0006 := range (*z).encodedTxns.encodedTxnHeaders.Fee {
				o = (*z).encodedTxns.encodedTxnHeaders.Fee[zb0006].MarshalMsg(o)
			}
		}
		if (zb0053Mask[1] & 0x100000) == 0 { // if not empty
			// string "feebm"
			o = append(o, 0xa5, 0x66, 0x65, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFee))
		}
		if (zb0053Mask[1] & 0x200000) == 0 { // if not empty
			// string "fv"
			o = append(o, 0xa2, 0x66, 0x76)
			if (*z).encodedTxns.encodedTxnHeaders.FirstValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedTxnHeaders.FirstValid)))
			}
			for zb0007 := range (*z).encodedTxns.encodedTxnHeaders.FirstValid {
				o = (*z).encodedTxns.encodedTxnHeaders.FirstValid[zb0007].MarshalMsg(o)
			}
		}
		if (zb0053Mask[1] & 0x400000) == 0 { // if not empty
			// string "fvbm"
			o = append(o, 0xa4, 0x66, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid))
		}
		if (zb0053Mask[1] & 0x800000) == 0 { // if not empty
			// string "genbm"
			o = append(o, 0xa5, 0x67, 0x65, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID))
		}
		if (zb0053Mask[1] & 0x1000000) == 0 { // if not empty
			// string "gnbs"
			o = append(o, 0xa4, 0x67, 0x6e, 0x62, 0x73)
			if (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice)))
			}
			for zb0036 := range (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice {
				o = msgp.AppendUint64(o, (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice[zb0036])
			}
		}
		if (zb0053Mask[1] & 0x2000000) == 0 { // if not empty
			// string "gnbsbm"
			o = append(o, 0xa6, 0x67, 0x6e, 0x62, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice))
		}
		if (zb0053Mask[1] & 0x4000000) == 0 { // if not empty
			// string "gnui"
			o = append(o, 0xa4, 0x67, 0x6e, 0x75, 0x69)
			if (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint)))
			}
			for zb0035 := range (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint {
				o = msgp.AppendUint64(o, (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint[zb0035])
			}
		}
		if (zb0053Mask[1] & 0x8000000) == 0 { // if not empty
			// string "gnuibm"
			o = append(o, 0xa6, 0x67, 0x6e, 0x75, 0x69, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint))
		}
		if (zb0053Mask[1] & 0x10000000) == 0 { // if not empty
			// string "grpbm"
			o = append(o, 0xa5, 0x67, 0x72, 0x70, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGroup))
		}
		if (zb0053Mask[1] & 0x20000000) == 0 { // if not empty
			// string "lnbs"
			o = append(o, 0xa4, 0x6c, 0x6e, 0x62, 0x73)
			if (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice)))
			}
			for zb0034 := range (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice {
				o = msgp.AppendUint64(o, (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice[zb0034])
			}
		}
		if (zb0053Mask[1] & 0x40000000) == 0 { // if not empty
			// string "lnbsbm"
			o = append(o, 0xa6, 0x6c, 0x6e, 0x62, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice))
		}
		if (zb0053Mask[1] & 0x80000000) == 0 { // if not empty
			// string "lnui"
			o = append(o, 0xa4, 0x6c, 0x6e, 0x75, 0x69)
			if (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint)))
			}
			for zb0033 := range (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint {
				o = msgp.AppendUint64(o, (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint[zb0033])
			}
		}
		if (zb0053Mask[1] & 0x100000000) == 0 { // if not empty
			// string "lnuibm"
			o = append(o, 0xa6, 0x6c, 0x6e, 0x75, 0x69, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint))
		}
		if (zb0053Mask[1] & 0x200000000) == 0 { // if not empty
			// string "lsigarg"
			o = append(o, 0xa7, 0x6c, 0x73, 0x69, 0x67, 0x61, 0x72, 0x67)
			if (*z).encodedLsigs.LogicArgs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedLsigs.LogicArgs)))
			}
			for zb0004 := range (*z).encodedLsigs.LogicArgs {
				if (*z).encodedLsigs.LogicArgs[zb0004] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedLsigs.LogicArgs[zb0004])))
				}
				for zb0005 := range (*z).encodedLsigs.LogicArgs[zb0004] {
					o = msgp.AppendBytes(o, (*z).encodedLsigs.LogicArgs[zb0004][zb0005])
				}
			}
		}
		if (zb0053Mask[1] & 0x400000000) == 0 { // if not empty
			// string "lsigargbm"
			o = append(o, 0xa9, 0x6c, 0x73, 0x69, 0x67, 0x61, 0x72, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedLsigs.BitmaskLogicArgs))
		}
		if (zb0053Mask[1] & 0x800000000) == 0 { // if not empty
			// string "lsigl"
			o = append(o, 0xa5, 0x6c, 0x73, 0x69, 0x67, 0x6c)
			if (*z).encodedLsigs.Logic == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedLsigs.Logic)))
			}
			for zb0003 := range (*z).encodedLsigs.Logic {
				o = msgp.AppendBytes(o, (*z).encodedLsigs.Logic[zb0003])
			}
		}
		if (zb0053Mask[1] & 0x1000000000) == 0 { // if not empty
			// string "lsiglbm"
			o = append(o, 0xa7, 0x6c, 0x73, 0x69, 0x67, 0x6c, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedLsigs.BitmaskLogic))
		}
		if (zb0053Mask[1] & 0x2000000000) == 0 { // if not empty
			// string "lv"
			o = append(o, 0xa2, 0x6c, 0x76)
			if (*z).encodedTxns.encodedTxnHeaders.LastValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedTxnHeaders.LastValid)))
			}
			for zb0008 := range (*z).encodedTxns.encodedTxnHeaders.LastValid {
				o = (*z).encodedTxns.encodedTxnHeaders.LastValid[zb0008].MarshalMsg(o)
			}
		}
		if (zb0053Mask[1] & 0x4000000000) == 0 { // if not empty
			// string "lvbm"
			o = append(o, 0xa4, 0x6c, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid))
		}
		if (zb0053Mask[1] & 0x8000000000) == 0 { // if not empty
			// string "lx"
			o = append(o, 0xa2, 0x6c, 0x78)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedTxnHeaders.Lease)
		}
		if (zb0053Mask[1] & 0x10000000000) == 0 { // if not empty
			// string "lxbm"
			o = append(o, 0xa4, 0x6c, 0x78, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLease))
		}
		if (zb0053Mask[1] & 0x20000000000) == 0 { // if not empty
			// string "m"
			o = append(o, 0xa1, 0x6d)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager)
		}
		if (zb0053Mask[1] & 0x40000000000) == 0 { // if not empty
			// string "mbm"
			o = append(o, 0xa3, 0x6d, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager))
		}
		if (zb0053Mask[1] & 0x80000000000) == 0 { // if not empty
			// string "msigthr"
			o = append(o, 0xa7, 0x6d, 0x73, 0x69, 0x67, 0x74, 0x68, 0x72)
			o = msgp.AppendBytes(o, (*z).encodedMsigs.Threshold)
		}
		if (zb0053Mask[1] & 0x100000000000) == 0 { // if not empty
			// string "msigthrbm"
			o = append(o, 0xa9, 0x6d, 0x73, 0x69, 0x67, 0x74, 0x68, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedMsigs.BitmaskThreshold))
		}
		if (zb0053Mask[1] & 0x200000000000) == 0 { // if not empty
			// string "msigv"
			o = append(o, 0xa5, 0x6d, 0x73, 0x69, 0x67, 0x76)
			o = msgp.AppendBytes(o, (*z).encodedMsigs.Version)
		}
		if (zb0053Mask[1] & 0x400000000000) == 0 { // if not empty
			// string "msigvbm"
			o = append(o, 0xa7, 0x6d, 0x73, 0x69, 0x67, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedMsigs.BitmaskVersion))
		}
		if (zb0053Mask[1] & 0x800000000000) == 0 { // if not empty
			// string "nonpartbm"
			o = append(o, 0xa9, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation))
		}
		if (zb0053Mask[1] & 0x1000000000000) == 0 { // if not empty
			// string "note"
			o = append(o, 0xa4, 0x6e, 0x6f, 0x74, 0x65)
			if (*z).encodedTxns.encodedTxnHeaders.Note == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedTxnHeaders.Note)))
			}
			for zb0009 := range (*z).encodedTxns.encodedTxnHeaders.Note {
				o = msgp.AppendBytes(o, (*z).encodedTxns.encodedTxnHeaders.Note[zb0009])
			}
		}
		if (zb0053Mask[1] & 0x2000000000000) == 0 { // if not empty
			// string "notebm"
			o = append(o, 0xa6, 0x6e, 0x6f, 0x74, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskNote))
		}
		if (zb0053Mask[1] & 0x4000000000000) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve)
		}
		if (zb0053Mask[1] & 0x8000000000000) == 0 { // if not empty
			// string "rbm"
			o = append(o, 0xa3, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve))
		}
		if (zb0053Mask[1] & 0x10000000000000) == 0 { // if not empty
			// string "rcv"
			o = append(o, 0xa3, 0x72, 0x63, 0x76)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedPaymentTxnFields.Receiver)
		}
		if (zb0053Mask[1] & 0x20000000000000) == 0 { // if not empty
			// string "rcvbm"
			o = append(o, 0xa5, 0x72, 0x63, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver))
		}
		if (zb0053Mask[1] & 0x40000000000000) == 0 { // if not empty
			// string "rekey"
			o = append(o, 0xa5, 0x72, 0x65, 0x6b, 0x65, 0x79)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedTxnHeaders.RekeyTo)
		}
		if (zb0053Mask[1] & 0x80000000000000) == 0 { // if not empty
			// string "rekeybm"
			o = append(o, 0xa7, 0x72, 0x65, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo))
		}
		if (zb0053Mask[1] & 0x100000000000000) == 0 { // if not empty
			// string "selkey"
			o = append(o, 0xa6, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK)
		}
		if (zb0053Mask[1] & 0x200000000000000) == 0 { // if not empty
			// string "sgnr"
			o = append(o, 0xa4, 0x73, 0x67, 0x6e, 0x72)
			o = msgp.AppendBytes(o, (*z).AuthAddr)
		}
		if (zb0053Mask[1] & 0x400000000000000) == 0 { // if not empty
			// string "sgnrbm"
			o = append(o, 0xa6, 0x73, 0x67, 0x6e, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskAuthAddr))
		}
		if (zb0053Mask[1] & 0x800000000000000) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o = msgp.AppendBytes(o, (*z).Sig)
		}
		if (zb0053Mask[1] & 0x1000000000000000) == 0 { // if not empty
			// string "sigbm"
			o = append(o, 0xa5, 0x73, 0x69, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskSig))
		}
		if (zb0053Mask[1] & 0x2000000000000000) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedTxnHeaders.Sender)
		}
		if (zb0053Mask[1] & 0x4000000000000000) == 0 { // if not empty
			// string "sndbm"
			o = append(o, 0xa5, 0x73, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskSender))
		}
		if (zb0053Mask[1] & 0x8000000000000000) == 0 { // if not empty
			// string "subsig"
			o = append(o, 0xa6, 0x73, 0x75, 0x62, 0x73, 0x69, 0x67)
			if (*z).encodedMsigs.Subsigs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedMsigs.Subsigs)))
			}
			for zb0001 := range (*z).encodedMsigs.Subsigs {
				if (*z).encodedMsigs.Subsigs[zb0001] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedMsigs.Subsigs[zb0001])))
				}
				for zb0002 := range (*z).encodedMsigs.Subsigs[zb0001] {
					o = (*z).encodedMsigs.Subsigs[zb0001][zb0002].MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[2] & 0x1) == 0 { // if not empty
			// string "subsigsbm"
			o = append(o, 0xa9, 0x73, 0x75, 0x62, 0x73, 0x69, 0x67, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedMsigs.BitmaskSubsigs))
		}
		if (zb0053Mask[2] & 0x2) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total)))
			}
			for zb0016 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total {
				o = msgp.AppendUint64(o, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total[zb0016])
			}
		}
		if (zb0053Mask[2] & 0x4) == 0 { // if not empty
			// string "tbm"
			o = append(o, 0xa3, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal))
		}
		if (zb0053Mask[2] & 0x8) == 0 { // if not empty
			// string "type"
			o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
			o = msgp.AppendBytes(o, (*z).encodedTxns.TxType)
		}
		if (zb0053Mask[2] & 0x10) == 0 { // if not empty
			// string "typebm"
			o = append(o, 0xa6, 0x74, 0x79, 0x70, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.BitmaskTxType))
		}
		if (zb0053Mask[2] & 0x20) == 0 { // if not empty
			// string "typeo"
			o = append(o, 0xa5, 0x74, 0x79, 0x70, 0x65, 0x6f)
			o = msgp.AppendByte(o, (*z).encodedTxns.TxTypeOffset)
		}
		if (zb0053Mask[2] & 0x40) == 0 { // if not empty
			// string "un"
			o = append(o, 0xa2, 0x75, 0x6e)
			if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName)))
			}
			for zb0018 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName {
				o = msgp.AppendString(o, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName[zb0018])
			}
		}
		if (zb0053Mask[2] & 0x80) == 0 { // if not empty
			// string "unbm"
			o = append(o, 0xa4, 0x75, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName))
		}
		if (zb0053Mask[2] & 0x100) == 0 { // if not empty
			// string "vldrt"
			o = append(o, 0xa5, 0x76, 0x6c, 0x64, 0x72, 0x74)
			if (*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot)))
			}
			for zb0013 := range (*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot {
				o = msgp.AppendBool(o, (*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot[zb0013])
			}
		}
		if (zb0053Mask[2] & 0x200) == 0 { // if not empty
			// string "votefst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74)
			if (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst)))
			}
			for zb0010 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst {
				o = (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0010].MarshalMsg(o)
			}
		}
		if (zb0053Mask[2] & 0x400) == 0 { // if not empty
			// string "votefstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst))
		}
		if (zb0053Mask[2] & 0x800) == 0 { // if not empty
			// string "votekbm"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskKeys))
		}
		if (zb0053Mask[2] & 0x1000) == 0 { // if not empty
			// string "votekd"
			o = append(o, 0xa6, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64)
			if (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution)))
			}
			for zb0012 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution {
				o = msgp.AppendUint64(o, (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution[zb0012])
			}
		}
		if (zb0053Mask[2] & 0x2000) == 0 { // if not empty
			// string "votekey"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79)
			o = msgp.AppendBytes(o, (*z).encodedTxns.encodedKeyregTxnFields.VotePK)
		}
		if (zb0053Mask[2] & 0x4000) == 0 { // if not empty
			// string "votelst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74)
			if (*z).encodedTxns.encodedKeyregTxnFields.VoteLast == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedKeyregTxnFields.VoteLast)))
			}
			for zb0011 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteLast {
				o = (*z).encodedTxns.encodedKeyregTxnFields.VoteLast[zb0011].MarshalMsg(o)
			}
		}
		if (zb0053Mask[2] & 0x8000) == 0 { // if not empty
			// string "votelstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast))
		}
		if (zb0053Mask[2] & 0x10000) == 0 { // if not empty
			// string "xaid"
			o = append(o, 0xa4, 0x78, 0x61, 0x69, 0x64)
			if (*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset)))
			}
			for zb0021 := range (*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset {
				o = (*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset[zb0021].MarshalMsg(o)
			}
		}
		if (zb0053Mask[2] & 0x20000) == 0 { // if not empty
			// string "xaidbm"
			o = append(o, 0xa6, 0x78, 0x61, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset))
		}
	}
	return
}

func (_ *encodedSignedTxns) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedSignedTxns)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedSignedTxns) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0053 int
	var zb0054 bool
	zb0053, zb0054, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0053, zb0054, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0053 > 0 {
			zb0053--
			var zb0055 int
			zb0055, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
			if zb0055 > maxSignatureBytes {
				err = msgp.ErrOverflow(uint64(zb0055), uint64(maxSignatureBytes))
				return
			}
			(*z).Sig, bts, err = msgp.ReadBytesBytes(bts, (*z).Sig)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0056 []byte
				var zb0057 int
				zb0057, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSig")
					return
				}
				if zb0057 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0057), uint64(maxBitmaskSize))
					return
				}
				zb0056, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSig")
					return
				}
				(*z).BitmaskSig = bitmask(zb0056)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0058 int
			zb0058, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Version")
				return
			}
			if zb0058 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0058), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).encodedMsigs.Version, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedMsigs.Version)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Version")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0059 []byte
				var zb0060 int
				zb0060, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVersion")
					return
				}
				if zb0060 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0060), uint64(maxBitmaskSize))
					return
				}
				zb0059, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedMsigs.BitmaskVersion))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVersion")
					return
				}
				(*z).encodedMsigs.BitmaskVersion = bitmask(zb0059)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0061 int
			zb0061, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Threshold")
				return
			}
			if zb0061 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0061), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).encodedMsigs.Threshold, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedMsigs.Threshold)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Threshold")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0062 []byte
				var zb0063 int
				zb0063, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskThreshold")
					return
				}
				if zb0063 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0063), uint64(maxBitmaskSize))
					return
				}
				zb0062, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedMsigs.BitmaskThreshold))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskThreshold")
					return
				}
				(*z).encodedMsigs.BitmaskThreshold = bitmask(zb0062)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0064 int
			var zb0065 bool
			zb0064, zb0065, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Subsigs")
				return
			}
			if zb0064 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0064), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Subsigs")
				return
			}
			if zb0065 {
				(*z).encodedMsigs.Subsigs = nil
			} else if (*z).encodedMsigs.Subsigs != nil && cap((*z).encodedMsigs.Subsigs) >= zb0064 {
				(*z).encodedMsigs.Subsigs = ((*z).encodedMsigs.Subsigs)[:zb0064]
			} else {
				(*z).encodedMsigs.Subsigs = make([][]crypto.MultisigSubsig, zb0064)
			}
			for zb0001 := range (*z).encodedMsigs.Subsigs {
				var zb0066 int
				var zb0067 bool
				zb0066, zb0067, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Subsigs", zb0001)
					return
				}
				if zb0066 > crypto.MaxMultisig {
					err = msgp.ErrOverflow(uint64(zb0066), uint64(crypto.MaxMultisig))
					err = msgp.WrapError(err, "struct-from-array", "Subsigs", zb0001)
					return
				}
				if zb0067 {
					(*z).encodedMsigs.Subsigs[zb0001] = nil
				} else if (*z).encodedMsigs.Subsigs[zb0001] != nil && cap((*z).encodedMsigs.Subsigs[zb0001]) >= zb0066 {
					(*z).encodedMsigs.Subsigs[zb0001] = ((*z).encodedMsigs.Subsigs[zb0001])[:zb0066]
				} else {
					(*z).encodedMsigs.Subsigs[zb0001] = make([]crypto.MultisigSubsig, zb0066)
				}
				for zb0002 := range (*z).encodedMsigs.Subsigs[zb0001] {
					bts, err = (*z).encodedMsigs.Subsigs[zb0001][zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Subsigs", zb0001, zb0002)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0068 []byte
				var zb0069 int
				zb0069, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSubsigs")
					return
				}
				if zb0069 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0069), uint64(maxBitmaskSize))
					return
				}
				zb0068, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedMsigs.BitmaskSubsigs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSubsigs")
					return
				}
				(*z).encodedMsigs.BitmaskSubsigs = bitmask(zb0068)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0070 int
			var zb0071 bool
			zb0070, zb0071, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Logic")
				return
			}
			if zb0070 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0070), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Logic")
				return
			}
			if zb0071 {
				(*z).encodedLsigs.Logic = nil
			} else if (*z).encodedLsigs.Logic != nil && cap((*z).encodedLsigs.Logic) >= zb0070 {
				(*z).encodedLsigs.Logic = ((*z).encodedLsigs.Logic)[:zb0070]
			} else {
				(*z).encodedLsigs.Logic = make([][]byte, zb0070)
			}
			for zb0003 := range (*z).encodedLsigs.Logic {
				var zb0072 int
				zb0072, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Logic", zb0003)
					return
				}
				if zb0072 > config.MaxLogicSigMaxSize {
					err = msgp.ErrOverflow(uint64(zb0072), uint64(config.MaxLogicSigMaxSize))
					return
				}
				(*z).encodedLsigs.Logic[zb0003], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedLsigs.Logic[zb0003])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Logic", zb0003)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0073 []byte
				var zb0074 int
				zb0074, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLogic")
					return
				}
				if zb0074 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0074), uint64(maxBitmaskSize))
					return
				}
				zb0073, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedLsigs.BitmaskLogic))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLogic")
					return
				}
				(*z).encodedLsigs.BitmaskLogic = bitmask(zb0073)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0075 int
			var zb0076 bool
			zb0075, zb0076, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LogicArgs")
				return
			}
			if zb0075 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0075), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LogicArgs")
				return
			}
			if zb0076 {
				(*z).encodedLsigs.LogicArgs = nil
			} else if (*z).encodedLsigs.LogicArgs != nil && cap((*z).encodedLsigs.LogicArgs) >= zb0075 {
				(*z).encodedLsigs.LogicArgs = ((*z).encodedLsigs.LogicArgs)[:zb0075]
			} else {
				(*z).encodedLsigs.LogicArgs = make([][][]byte, zb0075)
			}
			for zb0004 := range (*z).encodedLsigs.LogicArgs {
				var zb0077 int
				var zb0078 bool
				zb0077, zb0078, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LogicArgs", zb0004)
					return
				}
				if zb0077 > transactions.EvalMaxArgs {
					err = msgp.ErrOverflow(uint64(zb0077), uint64(transactions.EvalMaxArgs))
					err = msgp.WrapError(err, "struct-from-array", "LogicArgs", zb0004)
					return
				}
				if zb0078 {
					(*z).encodedLsigs.LogicArgs[zb0004] = nil
				} else if (*z).encodedLsigs.LogicArgs[zb0004] != nil && cap((*z).encodedLsigs.LogicArgs[zb0004]) >= zb0077 {
					(*z).encodedLsigs.LogicArgs[zb0004] = ((*z).encodedLsigs.LogicArgs[zb0004])[:zb0077]
				} else {
					(*z).encodedLsigs.LogicArgs[zb0004] = make([][]byte, zb0077)
				}
				for zb0005 := range (*z).encodedLsigs.LogicArgs[zb0004] {
					var zb0079 int
					zb0079, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "LogicArgs", zb0004, zb0005)
						return
					}
					if zb0079 > config.MaxLogicSigMaxSize {
						err = msgp.ErrOverflow(uint64(zb0079), uint64(config.MaxLogicSigMaxSize))
						return
					}
					(*z).encodedLsigs.LogicArgs[zb0004][zb0005], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedLsigs.LogicArgs[zb0004][zb0005])
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "LogicArgs", zb0004, zb0005)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0080 []byte
				var zb0081 int
				zb0081, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLogicArgs")
					return
				}
				if zb0081 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0081), uint64(maxBitmaskSize))
					return
				}
				zb0080, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedLsigs.BitmaskLogicArgs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLogicArgs")
					return
				}
				(*z).encodedLsigs.BitmaskLogicArgs = bitmask(zb0080)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0082 int
			zb0082, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
			if zb0082 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0082), uint64(maxAddressBytes))
				return
			}
			(*z).AuthAddr, bts, err = msgp.ReadBytesBytes(bts, (*z).AuthAddr)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0083 []byte
				var zb0084 int
				zb0084, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAuthAddr")
					return
				}
				if zb0084 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0084), uint64(maxBitmaskSize))
					return
				}
				zb0083, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAuthAddr))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAuthAddr")
					return
				}
				(*z).BitmaskAuthAddr = bitmask(zb0083)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0085 int
			zb0085, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
			if zb0085 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0085), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).encodedTxns.TxType, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.TxType)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0086 []byte
				var zb0087 int
				zb0087, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTxType")
					return
				}
				if zb0087 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0087), uint64(maxBitmaskSize))
					return
				}
				zb0086, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.BitmaskTxType))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTxType")
					return
				}
				(*z).encodedTxns.BitmaskTxType = bitmask(zb0086)
			}
		}
		if zb0053 > 0 {
			zb0053--
			(*z).encodedTxns.TxTypeOffset, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxTypeOffset")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0088 int
			zb0088, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
			if zb0088 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0088), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedTxnHeaders.Sender, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedTxnHeaders.Sender)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0089 []byte
				var zb0090 int
				zb0090, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSender")
					return
				}
				if zb0090 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0090), uint64(maxBitmaskSize))
					return
				}
				zb0089, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskSender))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSender")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskSender = bitmask(zb0089)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0091 int
			var zb0092 bool
			zb0091, zb0092, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0091 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0091), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0092 {
				(*z).encodedTxns.encodedTxnHeaders.Fee = nil
			} else if (*z).encodedTxns.encodedTxnHeaders.Fee != nil && cap((*z).encodedTxns.encodedTxnHeaders.Fee) >= zb0091 {
				(*z).encodedTxns.encodedTxnHeaders.Fee = ((*z).encodedTxns.encodedTxnHeaders.Fee)[:zb0091]
			} else {
				(*z).encodedTxns.encodedTxnHeaders.Fee = make([]basics.MicroAlgos, zb0091)
			}
			for zb0006 := range (*z).encodedTxns.encodedTxnHeaders.Fee {
				bts, err = (*z).encodedTxns.encodedTxnHeaders.Fee[zb0006].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Fee", zb0006)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0093 []byte
				var zb0094 int
				zb0094, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFee")
					return
				}
				if zb0094 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0094), uint64(maxBitmaskSize))
					return
				}
				zb0093, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFee))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFee")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskFee = bitmask(zb0093)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0095 int
			var zb0096 bool
			zb0095, zb0096, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0095 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0095), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0096 {
				(*z).encodedTxns.encodedTxnHeaders.FirstValid = nil
			} else if (*z).encodedTxns.encodedTxnHeaders.FirstValid != nil && cap((*z).encodedTxns.encodedTxnHeaders.FirstValid) >= zb0095 {
				(*z).encodedTxns.encodedTxnHeaders.FirstValid = ((*z).encodedTxns.encodedTxnHeaders.FirstValid)[:zb0095]
			} else {
				(*z).encodedTxns.encodedTxnHeaders.FirstValid = make([]basics.Round, zb0095)
			}
			for zb0007 := range (*z).encodedTxns.encodedTxnHeaders.FirstValid {
				bts, err = (*z).encodedTxns.encodedTxnHeaders.FirstValid[zb0007].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "FirstValid", zb0007)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0097 []byte
				var zb0098 int
				zb0098, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFirstValid")
					return
				}
				if zb0098 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0098), uint64(maxBitmaskSize))
					return
				}
				zb0097, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFirstValid")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid = bitmask(zb0097)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0099 int
			var zb0100 bool
			zb0099, zb0100, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0099 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0099), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0100 {
				(*z).encodedTxns.encodedTxnHeaders.LastValid = nil
			} else if (*z).encodedTxns.encodedTxnHeaders.LastValid != nil && cap((*z).encodedTxns.encodedTxnHeaders.LastValid) >= zb0099 {
				(*z).encodedTxns.encodedTxnHeaders.LastValid = ((*z).encodedTxns.encodedTxnHeaders.LastValid)[:zb0099]
			} else {
				(*z).encodedTxns.encodedTxnHeaders.LastValid = make([]basics.Round, zb0099)
			}
			for zb0008 := range (*z).encodedTxns.encodedTxnHeaders.LastValid {
				bts, err = (*z).encodedTxns.encodedTxnHeaders.LastValid[zb0008].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LastValid", zb0008)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0101 []byte
				var zb0102 int
				zb0102, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLastValid")
					return
				}
				if zb0102 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0102), uint64(maxBitmaskSize))
					return
				}
				zb0101, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLastValid")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid = bitmask(zb0101)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0103 int
			var zb0104 bool
			zb0103, zb0104, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0103 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0103), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0104 {
				(*z).encodedTxns.encodedTxnHeaders.Note = nil
			} else if (*z).encodedTxns.encodedTxnHeaders.Note != nil && cap((*z).encodedTxns.encodedTxnHeaders.Note) >= zb0103 {
				(*z).encodedTxns.encodedTxnHeaders.Note = ((*z).encodedTxns.encodedTxnHeaders.Note)[:zb0103]
			} else {
				(*z).encodedTxns.encodedTxnHeaders.Note = make([][]byte, zb0103)
			}
			for zb0009 := range (*z).encodedTxns.encodedTxnHeaders.Note {
				var zb0105 int
				zb0105, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Note", zb0009)
					return
				}
				if zb0105 > config.MaxTxnNoteBytes {
					err = msgp.ErrOverflow(uint64(zb0105), uint64(config.MaxTxnNoteBytes))
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.Note[zb0009], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedTxnHeaders.Note[zb0009])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Note", zb0009)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0106 []byte
				var zb0107 int
				zb0107, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNote")
					return
				}
				if zb0107 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0107), uint64(maxBitmaskSize))
					return
				}
				zb0106, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskNote))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNote")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskNote = bitmask(zb0106)
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0108 []byte
				var zb0109 int
				zb0109, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisID")
					return
				}
				if zb0109 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0109), uint64(maxBitmaskSize))
					return
				}
				zb0108, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisID")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID = bitmask(zb0108)
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0110 []byte
				var zb0111 int
				zb0111, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGroup")
					return
				}
				if zb0111 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0111), uint64(maxBitmaskSize))
					return
				}
				zb0110, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGroup))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGroup")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskGroup = bitmask(zb0110)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0112 int
			zb0112, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
			if zb0112 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0112), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedTxnHeaders.Lease, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedTxnHeaders.Lease)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0113 []byte
				var zb0114 int
				zb0114, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLease")
					return
				}
				if zb0114 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0114), uint64(maxBitmaskSize))
					return
				}
				zb0113, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLease))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLease")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskLease = bitmask(zb0113)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0115 int
			zb0115, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
			if zb0115 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0115), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedTxnHeaders.RekeyTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedTxnHeaders.RekeyTo)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0116 []byte
				var zb0117 int
				zb0117, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskRekeyTo")
					return
				}
				if zb0117 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0117), uint64(maxBitmaskSize))
					return
				}
				zb0116, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskRekeyTo")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo = bitmask(zb0116)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0118 int
			zb0118, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
			if zb0118 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0118), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedKeyregTxnFields.VotePK, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedKeyregTxnFields.VotePK)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0119 int
			zb0119, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
			if zb0119 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0119), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedKeyregTxnFields.SelectionPK, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0120 int
			var zb0121 bool
			zb0120, zb0121, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0120 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0120), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0121 {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteFirst = nil
			} else if (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst) >= zb0120 {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteFirst = ((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst)[:zb0120]
			} else {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteFirst = make([]basics.Round, zb0120)
			}
			for zb0010 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst {
				bts, err = (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0010].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteFirst", zb0010)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0122 []byte
				var zb0123 int
				zb0123, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteFirst")
					return
				}
				if zb0123 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0123), uint64(maxBitmaskSize))
					return
				}
				zb0122, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteFirst")
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst = bitmask(zb0122)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0124 int
			var zb0125 bool
			zb0124, zb0125, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0124 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0124), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0125 {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteLast = nil
			} else if (*z).encodedTxns.encodedKeyregTxnFields.VoteLast != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VoteLast) >= zb0124 {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteLast = ((*z).encodedTxns.encodedKeyregTxnFields.VoteLast)[:zb0124]
			} else {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteLast = make([]basics.Round, zb0124)
			}
			for zb0011 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteLast {
				bts, err = (*z).encodedTxns.encodedKeyregTxnFields.VoteLast[zb0011].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteLast", zb0011)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0126 []byte
				var zb0127 int
				zb0127, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteLast")
					return
				}
				if zb0127 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0127), uint64(maxBitmaskSize))
					return
				}
				zb0126, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteLast")
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast = bitmask(zb0126)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0128 int
			var zb0129 bool
			zb0128, zb0129, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0128 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0128), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0129 {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = nil
			} else if (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) >= zb0128 {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = ((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution)[:zb0128]
			} else {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = make([]uint64, zb0128)
			}
			for zb0012 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution[zb0012], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution", zb0012)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0130 []byte
				var zb0131 int
				zb0131, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskKeys")
					return
				}
				if zb0131 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0131), uint64(maxBitmaskSize))
					return
				}
				zb0130, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskKeys))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskKeys")
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.BitmaskKeys = bitmask(zb0130)
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0132 []byte
				var zb0133 int
				zb0133, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNonparticipation")
					return
				}
				if zb0133 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0133), uint64(maxBitmaskSize))
					return
				}
				zb0132, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNonparticipation")
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation = bitmask(zb0132)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0134 int
			var zb0135 bool
			zb0134, zb0135, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "HasValidRoot")
				return
			}
			if zb0134 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0134), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "HasValidRoot")
				return
			}
			if zb0135 {
				(*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot = nil
			} else if (*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot) >= zb0134 {
				(*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot = ((*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot)[:zb0134]
			} else {
				(*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot = make([]bool, zb0134)
			}
			for zb0013 := range (*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot {
				(*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot[zb0013], bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "HasValidRoot", zb0013)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0136 int
			zb0136, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CommitmentRoot")
				return
			}
			if zb0136 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0136), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).encodedTxns.encodedKeyregTxnFields.CommitmentRoot, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedKeyregTxnFields.CommitmentRoot)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CommitmentRoot")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0137 int
			zb0137, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
			if zb0137 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0137), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedPaymentTxnFields.Receiver, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedPaymentTxnFields.Receiver)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0138 []byte
				var zb0139 int
				zb0139, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReceiver")
					return
				}
				if zb0139 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0139), uint64(maxBitmaskSize))
					return
				}
				zb0138, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReceiver")
					return
				}
				(*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver = bitmask(zb0138)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0140 int
			var zb0141 bool
			zb0140, zb0141, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0140 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0140), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0141 {
				(*z).encodedTxns.encodedPaymentTxnFields.Amount = nil
			} else if (*z).encodedTxns.encodedPaymentTxnFields.Amount != nil && cap((*z).encodedTxns.encodedPaymentTxnFields.Amount) >= zb0140 {
				(*z).encodedTxns.encodedPaymentTxnFields.Amount = ((*z).encodedTxns.encodedPaymentTxnFields.Amount)[:zb0140]
			} else {
				(*z).encodedTxns.encodedPaymentTxnFields.Amount = make([]basics.MicroAlgos, zb0140)
			}
			for zb0014 := range (*z).encodedTxns.encodedPaymentTxnFields.Amount {
				bts, err = (*z).encodedTxns.encodedPaymentTxnFields.Amount[zb0014].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Amount", zb0014)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0142 []byte
				var zb0143 int
				zb0143, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAmount")
					return
				}
				if zb0143 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0143), uint64(maxBitmaskSize))
					return
				}
				zb0142, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAmount")
					return
				}
				(*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount = bitmask(zb0142)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0144 int
			zb0144, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
			if zb0144 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0144), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0145 []byte
				var zb0146 int
				zb0146, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCloseRemainderTo")
					return
				}
				if zb0146 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0146), uint64(maxBitmaskSize))
					return
				}
				zb0145, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCloseRemainderTo")
					return
				}
				(*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo = bitmask(zb0145)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0147 int
			var zb0148 bool
			zb0147, zb0148, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ConfigAsset")
				return
			}
			if zb0147 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0147), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ConfigAsset")
				return
			}
			if zb0148 {
				(*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset = nil
			} else if (*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset != nil && cap((*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset) >= zb0147 {
				(*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset = ((*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset)[:zb0147]
			} else {
				(*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset = make([]basics.AssetIndex, zb0147)
			}
			for zb0015 := range (*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset {
				bts, err = (*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset[zb0015].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ConfigAsset", zb0015)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0149 []byte
				var zb0150 int
				zb0150, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskConfigAsset")
					return
				}
				if zb0150 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0150), uint64(maxBitmaskSize))
					return
				}
				zb0149, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskConfigAsset")
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset = bitmask(zb0149)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0151 int
			var zb0152 bool
			zb0151, zb0152, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Total")
				return
			}
			if zb0151 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0151), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Total")
				return
			}
			if zb0152 {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total = nil
			} else if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total != nil && cap((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total) >= zb0151 {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total = ((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total)[:zb0151]
			} else {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total = make([]uint64, zb0151)
			}
			for zb0016 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total[zb0016], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Total", zb0016)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0153 []byte
				var zb0154 int
				zb0154, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTotal")
					return
				}
				if zb0154 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0154), uint64(maxBitmaskSize))
					return
				}
				zb0153, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTotal")
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal = bitmask(zb0153)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0155 int
			var zb0156 bool
			zb0155, zb0156, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Decimals")
				return
			}
			if zb0155 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0155), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Decimals")
				return
			}
			if zb0156 {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals = nil
			} else if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals != nil && cap((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals) >= zb0155 {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals = ((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals)[:zb0155]
			} else {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals = make([]uint32, zb0155)
			}
			for zb0017 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals[zb0017], bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Decimals", zb0017)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0157 []byte
				var zb0158 int
				zb0158, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDecimals")
					return
				}
				if zb0158 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0158), uint64(maxBitmaskSize))
					return
				}
				zb0157, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDecimals")
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals = bitmask(zb0157)
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0159 []byte
				var zb0160 int
				zb0160, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDefaultFrozen")
					return
				}
				if zb0160 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0160), uint64(maxBitmaskSize))
					return
				}
				zb0159, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDefaultFrozen")
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen = bitmask(zb0159)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0161 int
			var zb0162 bool
			zb0161, zb0162, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UnitName")
				return
			}
			if zb0161 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0161), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "UnitName")
				return
			}
			if zb0162 {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName = nil
			} else if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName != nil && cap((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName) >= zb0161 {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName = ((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName)[:zb0161]
			} else {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName = make([]string, zb0161)
			}
			for zb0018 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName[zb0018], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "UnitName", zb0018)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0163 []byte
				var zb0164 int
				zb0164, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskUnitName")
					return
				}
				if zb0164 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0164), uint64(maxBitmaskSize))
					return
				}
				zb0163, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskUnitName")
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName = bitmask(zb0163)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0165 int
			var zb0166 bool
			zb0165, zb0166, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetName")
				return
			}
			if zb0165 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0165), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "AssetName")
				return
			}
			if zb0166 {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName = nil
			} else if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName != nil && cap((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName) >= zb0165 {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName = ((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName)[:zb0165]
			} else {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName = make([]string, zb0165)
			}
			for zb0019 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName[zb0019], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AssetName", zb0019)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0167 []byte
				var zb0168 int
				zb0168, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetName")
					return
				}
				if zb0168 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0168), uint64(maxBitmaskSize))
					return
				}
				zb0167, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetName")
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName = bitmask(zb0167)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0169 int
			var zb0170 bool
			zb0169, zb0170, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "URL")
				return
			}
			if zb0169 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0169), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "URL")
				return
			}
			if zb0170 {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL = nil
			} else if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL != nil && cap((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL) >= zb0169 {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL = ((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL)[:zb0169]
			} else {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL = make([]string, zb0169)
			}
			for zb0020 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL {
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL[zb0020], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "URL", zb0020)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0171 []byte
				var zb0172 int
				zb0172, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskURL")
					return
				}
				if zb0172 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0172), uint64(maxBitmaskSize))
					return
				}
				zb0171, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskURL")
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL = bitmask(zb0171)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0173 int
			zb0173, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MetadataHash")
				return
			}
			if zb0173 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0173), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MetadataHash")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0174 []byte
				var zb0175 int
				zb0175, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMetadataHash")
					return
				}
				if zb0175 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0175), uint64(maxBitmaskSize))
					return
				}
				zb0174, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMetadataHash")
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash = bitmask(zb0174)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0176 int
			zb0176, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Manager")
				return
			}
			if zb0176 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0176), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Manager")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0177 []byte
				var zb0178 int
				zb0178, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskManager")
					return
				}
				if zb0178 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0178), uint64(maxBitmaskSize))
					return
				}
				zb0177, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskManager")
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager = bitmask(zb0177)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0179 int
			zb0179, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reserve")
				return
			}
			if zb0179 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0179), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reserve")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0180 []byte
				var zb0181 int
				zb0181, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReserve")
					return
				}
				if zb0181 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0181), uint64(maxBitmaskSize))
					return
				}
				zb0180, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReserve")
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve = bitmask(zb0180)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0182 int
			zb0182, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Freeze")
				return
			}
			if zb0182 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0182), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Freeze")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0183 []byte
				var zb0184 int
				zb0184, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreeze")
					return
				}
				if zb0184 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0184), uint64(maxBitmaskSize))
					return
				}
				zb0183, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreeze")
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze = bitmask(zb0183)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0185 int
			zb0185, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Clawback")
				return
			}
			if zb0185 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0185), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Clawback")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0186 []byte
				var zb0187 int
				zb0187, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClawback")
					return
				}
				if zb0187 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0187), uint64(maxBitmaskSize))
					return
				}
				zb0186, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClawback")
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback = bitmask(zb0186)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0188 int
			var zb0189 bool
			zb0188, zb0189, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "XferAsset")
				return
			}
			if zb0188 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0188), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "XferAsset")
				return
			}
			if zb0189 {
				(*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset = nil
			} else if (*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset != nil && cap((*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset) >= zb0188 {
				(*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset = ((*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset)[:zb0188]
			} else {
				(*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset = make([]basics.AssetIndex, zb0188)
			}
			for zb0021 := range (*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset {
				bts, err = (*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset[zb0021].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "XferAsset", zb0021)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0190 []byte
				var zb0191 int
				zb0191, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskXferAsset")
					return
				}
				if zb0191 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0191), uint64(maxBitmaskSize))
					return
				}
				zb0190, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskXferAsset")
					return
				}
				(*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset = bitmask(zb0190)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0192 int
			var zb0193 bool
			zb0192, zb0193, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetAmount")
				return
			}
			if zb0192 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0192), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "AssetAmount")
				return
			}
			if zb0193 {
				(*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount = nil
			} else if (*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount != nil && cap((*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount) >= zb0192 {
				(*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount = ((*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount)[:zb0192]
			} else {
				(*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount = make([]uint64, zb0192)
			}
			for zb0022 := range (*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount {
				(*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount[zb0022], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AssetAmount", zb0022)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0194 []byte
				var zb0195 int
				zb0195, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetAmount")
					return
				}
				if zb0195 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0195), uint64(maxBitmaskSize))
					return
				}
				zb0194, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetAmount")
					return
				}
				(*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount = bitmask(zb0194)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0196 int
			zb0196, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetSender")
				return
			}
			if zb0196 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0196), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedAssetTransferTxnFields.AssetSender, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetTransferTxnFields.AssetSender)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetSender")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0197 []byte
				var zb0198 int
				zb0198, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetSender")
					return
				}
				if zb0198 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0198), uint64(maxBitmaskSize))
					return
				}
				zb0197, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetSender")
					return
				}
				(*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender = bitmask(zb0197)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0199 int
			zb0199, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetReceiver")
				return
			}
			if zb0199 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0199), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedAssetTransferTxnFields.AssetReceiver, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetTransferTxnFields.AssetReceiver)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetReceiver")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0200 []byte
				var zb0201 int
				zb0201, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetReceiver")
					return
				}
				if zb0201 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0201), uint64(maxBitmaskSize))
					return
				}
				zb0200, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetReceiver")
					return
				}
				(*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver = bitmask(zb0200)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0202 int
			zb0202, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetCloseTo")
				return
			}
			if zb0202 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0202), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetCloseTo")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0203 []byte
				var zb0204 int
				zb0204, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetCloseTo")
					return
				}
				if zb0204 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0204), uint64(maxBitmaskSize))
					return
				}
				zb0203, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetCloseTo")
					return
				}
				(*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo = bitmask(zb0203)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0205 int
			zb0205, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAccount")
				return
			}
			if zb0205 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0205), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAccount")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0206 []byte
				var zb0207 int
				zb0207, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAccount")
					return
				}
				if zb0207 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0207), uint64(maxBitmaskSize))
					return
				}
				zb0206, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAccount")
					return
				}
				(*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount = bitmask(zb0206)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0208 int
			var zb0209 bool
			zb0208, zb0209, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAsset")
				return
			}
			if zb0208 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0208), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "FreezeAsset")
				return
			}
			if zb0209 {
				(*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset = nil
			} else if (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset != nil && cap((*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset) >= zb0208 {
				(*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset = ((*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset)[:zb0208]
			} else {
				(*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset = make([]basics.AssetIndex, zb0208)
			}
			for zb0023 := range (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset {
				bts, err = (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset[zb0023].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "FreezeAsset", zb0023)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0210 []byte
				var zb0211 int
				zb0211, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAsset")
					return
				}
				if zb0211 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0211), uint64(maxBitmaskSize))
					return
				}
				zb0210, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAsset")
					return
				}
				(*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset = bitmask(zb0210)
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0212 []byte
				var zb0213 int
				zb0213, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetFrozen")
					return
				}
				if zb0213 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0213), uint64(maxBitmaskSize))
					return
				}
				zb0212, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetFrozen")
					return
				}
				(*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen = bitmask(zb0212)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0214 int
			var zb0215 bool
			zb0214, zb0215, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ApplicationID")
				return
			}
			if zb0214 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0214), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ApplicationID")
				return
			}
			if zb0215 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID = nil
			} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID) >= zb0214 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID = ((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID)[:zb0214]
			} else {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID = make([]basics.AppIndex, zb0214)
			}
			for zb0024 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID {
				bts, err = (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID[zb0024].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ApplicationID", zb0024)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0216 []byte
				var zb0217 int
				zb0217, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationID")
					return
				}
				if zb0217 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0217), uint64(maxBitmaskSize))
					return
				}
				zb0216, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationID")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID = bitmask(zb0216)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0218 int
			zb0218, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OnCompletion")
				return
			}
			if zb0218 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0218), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).encodedTxns.encodedApplicationCallTxnFields.OnCompletion, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedApplicationCallTxnFields.OnCompletion)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OnCompletion")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0219 []byte
				var zb0220 int
				zb0220, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskOnCompletion")
					return
				}
				if zb0220 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0220), uint64(maxBitmaskSize))
					return
				}
				zb0219, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskOnCompletion")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion = bitmask(zb0219)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0221 int
			var zb0222 bool
			zb0221, zb0222, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs")
				return
			}
			if zb0221 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0221), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs")
				return
			}
			if zb0222 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs = nil
			} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs) >= zb0221 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs = ((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs)[:zb0221]
			} else {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs = make([]applicationArgs, zb0221)
			}
			for zb0025 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs {
				var zb0223 int
				var zb0224 bool
				zb0223, zb0224, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs", zb0025)
					return
				}
				if zb0223 > transactions.EncodedMaxApplicationArgs {
					err = msgp.ErrOverflow(uint64(zb0223), uint64(transactions.EncodedMaxApplicationArgs))
					err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs", zb0025)
					return
				}
				if zb0224 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025]) >= zb0223 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] = ((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025])[:zb0223]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] = make(applicationArgs, zb0223)
				}
				for zb0026 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025][zb0026], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025][zb0026])
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs", zb0025, zb0026)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0225 []byte
				var zb0226 int
				zb0226, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationArgs")
					return
				}
				if zb0226 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0226), uint64(maxBitmaskSize))
					return
				}
				zb0225, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationArgs")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs = bitmask(zb0225)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0227 int
			var zb0228 bool
			zb0227, zb0228, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Accounts")
				return
			}
			if zb0227 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0227), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Accounts")
				return
			}
			if zb0228 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.Accounts = nil
			} else if (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.Accounts) >= zb0227 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.Accounts = ((*z).encodedTxns.encodedApplicationCallTxnFields.Accounts)[:zb0227]
			} else {
				(*z).encodedTxns.encodedApplicationCallTxnFields.Accounts = make([]addresses, zb0227)
			}
			for zb0027 := range (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts {
				var zb0229 int
				var zb0230 bool
				zb0229, zb0230, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Accounts", zb0027)
					return
				}
				if zb0229 > transactions.EncodedMaxAccounts {
					err = msgp.ErrOverflow(uint64(zb0229), uint64(transactions.EncodedMaxAccounts))
					err = msgp.WrapError(err, "struct-from-array", "Accounts", zb0027)
					return
				}
				if zb0230 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027]) >= zb0229 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] = ((*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027])[:zb0229]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] = make(addresses, zb0229)
				}
				for zb0028 := range (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] {
					bts, err = (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027][zb0028].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Accounts", zb0027, zb0028)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0231 []byte
				var zb0232 int
				zb0232, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAccounts")
					return
				}
				if zb0232 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0232), uint64(maxBitmaskSize))
					return
				}
				zb0231, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAccounts")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts = bitmask(zb0231)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0233 int
			var zb0234 bool
			zb0233, zb0234, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ForeignApps")
				return
			}
			if zb0233 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0233), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ForeignApps")
				return
			}
			if zb0234 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps = nil
			} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps) >= zb0233 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps = ((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps)[:zb0233]
			} else {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps = make([]appIndices, zb0233)
			}
			for zb0029 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps {
				var zb0235 int
				var zb0236 bool
				zb0235, zb0236, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ForeignApps", zb0029)
					return
				}
				if zb0235 > transactions.EncodedMaxForeignApps {
					err = msgp.ErrOverflow(uint64(zb0235), uint64(transactions.EncodedMaxForeignApps))
					err = msgp.WrapError(err, "struct-from-array", "ForeignApps", zb0029)
					return
				}
				if zb0236 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029]) >= zb0235 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] = ((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029])[:zb0235]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] = make(appIndices, zb0235)
				}
				for zb0030 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] {
					bts, err = (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029][zb0030].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ForeignApps", zb0029, zb0030)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0237 []byte
				var zb0238 int
				zb0238, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignApps")
					return
				}
				if zb0238 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0238), uint64(maxBitmaskSize))
					return
				}
				zb0237, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignApps")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps = bitmask(zb0237)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0239 int
			var zb0240 bool
			zb0239, zb0240, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ForeignAssets")
				return
			}
			if zb0239 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0239), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ForeignAssets")
				return
			}
			if zb0240 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets = nil
			} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets) >= zb0239 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets = ((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets)[:zb0239]
			} else {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets = make([]assetIndices, zb0239)
			}
			for zb0031 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets {
				var zb0241 int
				var zb0242 bool
				zb0241, zb0242, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ForeignAssets", zb0031)
					return
				}
				if zb0241 > transactions.EncodedMaxForeignAssets {
					err = msgp.ErrOverflow(uint64(zb0241), uint64(transactions.EncodedMaxForeignAssets))
					err = msgp.WrapError(err, "struct-from-array", "ForeignAssets", zb0031)
					return
				}
				if zb0242 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031]) >= zb0241 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] = ((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031])[:zb0241]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] = make(assetIndices, zb0241)
				}
				for zb0032 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] {
					bts, err = (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031][zb0032].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ForeignAssets", zb0031, zb0032)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0243 []byte
				var zb0244 int
				zb0244, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignAssets")
					return
				}
				if zb0244 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0244), uint64(maxBitmaskSize))
					return
				}
				zb0243, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignAssets")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets = bitmask(zb0243)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0245 int
			var zb0246 bool
			zb0245, zb0246, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LocalNumUint")
				return
			}
			if zb0245 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0245), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LocalNumUint")
				return
			}
			if zb0246 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint = nil
			} else if (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint) >= zb0245 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint = ((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint)[:zb0245]
			} else {
				(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint = make([]uint64, zb0245)
			}
			for zb0033 := range (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint {
				(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint[zb0033], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LocalNumUint", zb0033)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0247 []byte
				var zb0248 int
				zb0248, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumUint")
					return
				}
				if zb0248 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0248), uint64(maxBitmaskSize))
					return
				}
				zb0247, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumUint")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint = bitmask(zb0247)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0249 int
			var zb0250 bool
			zb0249, zb0250, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LocalNumByteSlice")
				return
			}
			if zb0249 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0249), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LocalNumByteSlice")
				return
			}
			if zb0250 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice = nil
			} else if (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice) >= zb0249 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice = ((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice)[:zb0249]
			} else {
				(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice = make([]uint64, zb0249)
			}
			for zb0034 := range (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice {
				(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice[zb0034], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LocalNumByteSlice", zb0034)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0251 []byte
				var zb0252 int
				zb0252, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumByteSlice")
					return
				}
				if zb0252 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0252), uint64(maxBitmaskSize))
					return
				}
				zb0251, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumByteSlice")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice = bitmask(zb0251)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0253 int
			var zb0254 bool
			zb0253, zb0254, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumUint")
				return
			}
			if zb0253 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0253), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumUint")
				return
			}
			if zb0254 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint = nil
			} else if (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint) >= zb0253 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint = ((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint)[:zb0253]
			} else {
				(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint = make([]uint64, zb0253)
			}
			for zb0035 := range (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint {
				(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint[zb0035], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "GlobalNumUint", zb0035)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0255 []byte
				var zb0256 int
				zb0256, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumUint")
					return
				}
				if zb0256 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0256), uint64(maxBitmaskSize))
					return
				}
				zb0255, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumUint")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint = bitmask(zb0255)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0257 int
			var zb0258 bool
			zb0257, zb0258, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumByteSlice")
				return
			}
			if zb0257 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0257), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumByteSlice")
				return
			}
			if zb0258 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice = nil
			} else if (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice) >= zb0257 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice = ((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice)[:zb0257]
			} else {
				(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice = make([]uint64, zb0257)
			}
			for zb0036 := range (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice {
				(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice[zb0036], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "GlobalNumByteSlice", zb0036)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0259 []byte
				var zb0260 int
				zb0260, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumByteSlice")
					return
				}
				if zb0260 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0260), uint64(maxBitmaskSize))
					return
				}
				zb0259, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumByteSlice")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice = bitmask(zb0259)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0261 int
			var zb0262 bool
			zb0261, zb0262, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram")
				return
			}
			if zb0261 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0261), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram")
				return
			}
			if zb0262 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram = nil
			} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram) >= zb0261 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram = ((*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram)[:zb0261]
			} else {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram = make([]program, zb0261)
			}
			for zb0037 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram {
				{
					var zb0263 []byte
					var zb0264 int
					zb0264, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram", zb0037)
						return
					}
					if zb0264 > config.MaxAvailableAppProgramLen {
						err = msgp.ErrOverflow(uint64(zb0264), uint64(config.MaxAvailableAppProgramLen))
						return
					}
					zb0263, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram[zb0037]))
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram", zb0037)
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram[zb0037] = program(zb0263)
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0265 []byte
				var zb0266 int
				zb0266, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApprovalProgram")
					return
				}
				if zb0266 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0266), uint64(maxBitmaskSize))
					return
				}
				zb0265, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApprovalProgram")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram = bitmask(zb0265)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0267 int
			var zb0268 bool
			zb0267, zb0268, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram")
				return
			}
			if zb0267 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0267), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram")
				return
			}
			if zb0268 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram = nil
			} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram) >= zb0267 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram = ((*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram)[:zb0267]
			} else {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram = make([]program, zb0267)
			}
			for zb0038 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram {
				{
					var zb0269 []byte
					var zb0270 int
					zb0270, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram", zb0038)
						return
					}
					if zb0270 > config.MaxAvailableAppProgramLen {
						err = msgp.ErrOverflow(uint64(zb0270), uint64(config.MaxAvailableAppProgramLen))
						return
					}
					zb0269, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram[zb0038]))
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram", zb0038)
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram[zb0038] = program(zb0269)
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0271 []byte
				var zb0272 int
				zb0272, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClearStateProgram")
					return
				}
				if zb0272 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0272), uint64(maxBitmaskSize))
					return
				}
				zb0271, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClearStateProgram")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram = bitmask(zb0271)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0273 int
			var zb0274 bool
			zb0273, zb0274, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ExtraProgramPages")
				return
			}
			if zb0273 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0273), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ExtraProgramPages")
				return
			}
			if zb0274 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages = nil
			} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages) >= zb0273 {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages = ((*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages)[:zb0273]
			} else {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages = make([]uint32, zb0273)
			}
			for zb0039 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages {
				(*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages[zb0039], bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ExtraProgramPages", zb0039)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0275 []byte
				var zb0276 int
				zb0276, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskExtraProgramPages")
					return
				}
				if zb0276 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0276), uint64(maxBitmaskSize))
					return
				}
				zb0275, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskExtraProgramPages")
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages = bitmask(zb0275)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0277 int
			var zb0278 bool
			zb0277, zb0278, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CertRound")
				return
			}
			if zb0277 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0277), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "CertRound")
				return
			}
			if zb0278 {
				(*z).encodedTxns.encodedCompactCertTxnFields.CertRound = nil
			} else if (*z).encodedTxns.encodedCompactCertTxnFields.CertRound != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.CertRound) >= zb0277 {
				(*z).encodedTxns.encodedCompactCertTxnFields.CertRound = ((*z).encodedTxns.encodedCompactCertTxnFields.CertRound)[:zb0277]
			} else {
				(*z).encodedTxns.encodedCompactCertTxnFields.CertRound = make([]basics.Round, zb0277)
			}
			for zb0040 := range (*z).encodedTxns.encodedCompactCertTxnFields.CertRound {
				bts, err = (*z).encodedTxns.encodedCompactCertTxnFields.CertRound[zb0040].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CertRound", zb0040)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0279 []byte
				var zb0280 int
				zb0280, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertRound")
					return
				}
				if zb0280 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0280), uint64(maxBitmaskSize))
					return
				}
				zb0279, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertRound")
					return
				}
				(*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound = bitmask(zb0279)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0281 int
			var zb0282 bool
			zb0281, zb0282, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CertType")
				return
			}
			if zb0281 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0281), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "CertType")
				return
			}
			if zb0282 {
				(*z).encodedTxns.encodedCompactCertTxnFields.CertType = nil
			} else if (*z).encodedTxns.encodedCompactCertTxnFields.CertType != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.CertType) >= zb0281 {
				(*z).encodedTxns.encodedCompactCertTxnFields.CertType = ((*z).encodedTxns.encodedCompactCertTxnFields.CertType)[:zb0281]
			} else {
				(*z).encodedTxns.encodedCompactCertTxnFields.CertType = make([]protocol.CompactCertType, zb0281)
			}
			for zb0041 := range (*z).encodedTxns.encodedCompactCertTxnFields.CertType {
				bts, err = (*z).encodedTxns.encodedCompactCertTxnFields.CertType[zb0041].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CertType", zb0041)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0283 []byte
				var zb0284 int
				zb0284, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertType")
					return
				}
				if zb0284 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0284), uint64(maxBitmaskSize))
					return
				}
				zb0283, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertType))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertType")
					return
				}
				(*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertType = bitmask(zb0283)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0285 int
			var zb0286 bool
			zb0285, zb0286, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigCommit")
				return
			}
			if zb0285 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0285), uint64(maxAddressBytes))
				err = msgp.WrapError(err, "struct-from-array", "SigCommit")
				return
			}
			if zb0286 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit = nil
			} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit) >= zb0285 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit)[:zb0285]
			} else {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit = make([]crypto.GenericDigest, zb0285)
			}
			for zb0042 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit {
				bts, err = (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit[zb0042].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigCommit", zb0042)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0287 []byte
				var zb0288 int
				zb0288, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigCommit")
					return
				}
				if zb0288 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0288), uint64(maxBitmaskSize))
					return
				}
				zb0287, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigCommit")
					return
				}
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit = bitmask(zb0287)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0289 int
			var zb0290 bool
			zb0289, zb0290, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SignedWeight")
				return
			}
			if zb0289 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0289), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SignedWeight")
				return
			}
			if zb0290 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight = nil
			} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight) >= zb0289 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight)[:zb0289]
			} else {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight = make([]uint64, zb0289)
			}
			for zb0043 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight[zb0043], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedWeight", zb0043)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0291 []byte
				var zb0292 int
				zb0292, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSignedWeight")
					return
				}
				if zb0292 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0292), uint64(maxBitmaskSize))
					return
				}
				zb0291, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSignedWeight")
					return
				}
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight = bitmask(zb0291)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0293 int
			var zb0294 bool
			zb0293, zb0294, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigProofs")
				return
			}
			if zb0293 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0293), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SigProofs")
				return
			}
			if zb0294 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs = nil
			} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs) >= zb0293 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs)[:zb0293]
			} else {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs = make([]certProofs, zb0293)
			}
			for zb0044 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs {
				var zb0295 int
				var zb0296 bool
				zb0295, zb0296, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0044)
					return
				}
				if zb0295 > compactcert.MaxProofDigests {
					err = msgp.ErrOverflow(uint64(zb0295), uint64(compactcert.MaxProofDigests))
					err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0044)
					return
				}
				if zb0296 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] = nil
				} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044]) >= zb0295 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044])[:zb0295]
				} else {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] = make(certProofs, zb0295)
				}
				for zb0045 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] {
					bts, err = (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044][zb0045].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0044, zb0045)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0297 []byte
				var zb0298 int
				zb0298, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigProofs")
					return
				}
				if zb0298 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0298), uint64(maxBitmaskSize))
					return
				}
				zb0297, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigProofs")
					return
				}
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs = bitmask(zb0297)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0299 int
			var zb0300 bool
			zb0299, zb0300, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes")
				return
			}
			if zb0299 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0299), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes")
				return
			}
			if zb0300 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = nil
			} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) >= zb0299 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes)[:zb0299]
			} else {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = make([]uint64, zb0299)
			}
			for zb0046 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes[zb0046], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes", zb0046)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0301 []byte
				var zb0302 int
				zb0302, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigsHash")
					return
				}
				if zb0302 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0302), uint64(maxBitmaskSize))
					return
				}
				zb0301, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigsHash")
					return
				}
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash = bitmask(zb0301)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0303 int
			var zb0304 bool
			zb0303, zb0304, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PartProofs")
				return
			}
			if zb0303 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0303), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "PartProofs")
				return
			}
			if zb0304 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs = nil
			} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs) >= zb0303 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs)[:zb0303]
			} else {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs = make([]certProofs, zb0303)
			}
			for zb0047 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs {
				var zb0305 int
				var zb0306 bool
				zb0305, zb0306, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0047)
					return
				}
				if zb0305 > compactcert.MaxProofDigests {
					err = msgp.ErrOverflow(uint64(zb0305), uint64(compactcert.MaxProofDigests))
					err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0047)
					return
				}
				if zb0306 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] = nil
				} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047]) >= zb0305 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047])[:zb0305]
				} else {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] = make(certProofs, zb0305)
				}
				for zb0048 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] {
					bts, err = (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047][zb0048].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0047, zb0048)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0307 []byte
				var zb0308 int
				zb0308, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartProofs")
					return
				}
				if zb0308 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0308), uint64(maxBitmaskSize))
					return
				}
				zb0307, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartProofs")
					return
				}
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs = bitmask(zb0307)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0309 int
			var zb0310 bool
			zb0309, zb0310, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes")
				return
			}
			if zb0309 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0309), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes")
				return
			}
			if zb0310 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = nil
			} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) >= zb0309 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes)[:zb0309]
			} else {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = make([]uint64, zb0309)
			}
			for zb0049 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes[zb0049], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes", zb0049)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0311 []byte
				var zb0312 int
				zb0312, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartHash")
					return
				}
				if zb0312 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0312), uint64(maxBitmaskSize))
					return
				}
				zb0311, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartHash")
					return
				}
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash = bitmask(zb0311)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0313 int
			var zb0314 bool
			zb0313, zb0314, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reveals")
				return
			}
			if zb0313 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0313), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Reveals")
				return
			}
			if zb0314 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals = nil
			} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals) >= zb0313 {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals)[:zb0313]
			} else {
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals = make([]revealMap, zb0313)
			}
			for zb0050 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals {
				var zb0315 int
				var zb0316 bool
				zb0315, zb0316, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0050)
					return
				}
				if zb0315 > compactcert.MaxReveals {
					err = msgp.ErrOverflow(uint64(zb0315), uint64(compactcert.MaxReveals))
					err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0050)
					return
				}
				if zb0316 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] = nil
				} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] == nil {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] = make(revealMap, zb0315)
				}
				for zb0315 > 0 {
					var zb0051 uint64
					var zb0052 compactcert.Reveal
					zb0315--
					zb0051, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0050)
						return
					}
					bts, err = zb0052.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0050, zb0051)
						return
					}
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050][zb0051] = zb0052
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0317 []byte
				var zb0318 int
				zb0318, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReveals")
					return
				}
				if zb0318 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0318), uint64(maxBitmaskSize))
					return
				}
				zb0317, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReveals")
					return
				}
				(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals = bitmask(zb0317)
			}
		}
		if zb0053 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0053)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0054 {
			(*z) = encodedSignedTxns{}
		}
		for zb0053 > 0 {
			zb0053--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "sig":
				var zb0319 int
				zb0319, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
				if zb0319 > maxSignatureBytes {
					err = msgp.ErrOverflow(uint64(zb0319), uint64(maxSignatureBytes))
					return
				}
				(*z).Sig, bts, err = msgp.ReadBytesBytes(bts, (*z).Sig)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			case "sigbm":
				{
					var zb0320 []byte
					var zb0321 int
					zb0321, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSig")
						return
					}
					if zb0321 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0321), uint64(maxBitmaskSize))
						return
					}
					zb0320, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSig")
						return
					}
					(*z).BitmaskSig = bitmask(zb0320)
				}
			case "msigv":
				var zb0322 int
				zb0322, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Version")
					return
				}
				if zb0322 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0322), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).encodedMsigs.Version, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedMsigs.Version)
				if err != nil {
					err = msgp.WrapError(err, "Version")
					return
				}
			case "msigvbm":
				{
					var zb0323 []byte
					var zb0324 int
					zb0324, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVersion")
						return
					}
					if zb0324 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0324), uint64(maxBitmaskSize))
						return
					}
					zb0323, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedMsigs.BitmaskVersion))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVersion")
						return
					}
					(*z).encodedMsigs.BitmaskVersion = bitmask(zb0323)
				}
			case "msigthr":
				var zb0325 int
				zb0325, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Threshold")
					return
				}
				if zb0325 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0325), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).encodedMsigs.Threshold, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedMsigs.Threshold)
				if err != nil {
					err = msgp.WrapError(err, "Threshold")
					return
				}
			case "msigthrbm":
				{
					var zb0326 []byte
					var zb0327 int
					zb0327, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskThreshold")
						return
					}
					if zb0327 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0327), uint64(maxBitmaskSize))
						return
					}
					zb0326, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedMsigs.BitmaskThreshold))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskThreshold")
						return
					}
					(*z).encodedMsigs.BitmaskThreshold = bitmask(zb0326)
				}
			case "subsig":
				var zb0328 int
				var zb0329 bool
				zb0328, zb0329, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Subsigs")
					return
				}
				if zb0328 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0328), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Subsigs")
					return
				}
				if zb0329 {
					(*z).encodedMsigs.Subsigs = nil
				} else if (*z).encodedMsigs.Subsigs != nil && cap((*z).encodedMsigs.Subsigs) >= zb0328 {
					(*z).encodedMsigs.Subsigs = ((*z).encodedMsigs.Subsigs)[:zb0328]
				} else {
					(*z).encodedMsigs.Subsigs = make([][]crypto.MultisigSubsig, zb0328)
				}
				for zb0001 := range (*z).encodedMsigs.Subsigs {
					var zb0330 int
					var zb0331 bool
					zb0330, zb0331, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Subsigs", zb0001)
						return
					}
					if zb0330 > crypto.MaxMultisig {
						err = msgp.ErrOverflow(uint64(zb0330), uint64(crypto.MaxMultisig))
						err = msgp.WrapError(err, "Subsigs", zb0001)
						return
					}
					if zb0331 {
						(*z).encodedMsigs.Subsigs[zb0001] = nil
					} else if (*z).encodedMsigs.Subsigs[zb0001] != nil && cap((*z).encodedMsigs.Subsigs[zb0001]) >= zb0330 {
						(*z).encodedMsigs.Subsigs[zb0001] = ((*z).encodedMsigs.Subsigs[zb0001])[:zb0330]
					} else {
						(*z).encodedMsigs.Subsigs[zb0001] = make([]crypto.MultisigSubsig, zb0330)
					}
					for zb0002 := range (*z).encodedMsigs.Subsigs[zb0001] {
						bts, err = (*z).encodedMsigs.Subsigs[zb0001][zb0002].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Subsigs", zb0001, zb0002)
							return
						}
					}
				}
			case "subsigsbm":
				{
					var zb0332 []byte
					var zb0333 int
					zb0333, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSubsigs")
						return
					}
					if zb0333 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0333), uint64(maxBitmaskSize))
						return
					}
					zb0332, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedMsigs.BitmaskSubsigs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSubsigs")
						return
					}
					(*z).encodedMsigs.BitmaskSubsigs = bitmask(zb0332)
				}
			case "lsigl":
				var zb0334 int
				var zb0335 bool
				zb0334, zb0335, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Logic")
					return
				}
				if zb0334 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0334), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Logic")
					return
				}
				if zb0335 {
					(*z).encodedLsigs.Logic = nil
				} else if (*z).encodedLsigs.Logic != nil && cap((*z).encodedLsigs.Logic) >= zb0334 {
					(*z).encodedLsigs.Logic = ((*z).encodedLsigs.Logic)[:zb0334]
				} else {
					(*z).encodedLsigs.Logic = make([][]byte, zb0334)
				}
				for zb0003 := range (*z).encodedLsigs.Logic {
					var zb0336 int
					zb0336, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "Logic", zb0003)
						return
					}
					if zb0336 > config.MaxLogicSigMaxSize {
						err = msgp.ErrOverflow(uint64(zb0336), uint64(config.MaxLogicSigMaxSize))
						return
					}
					(*z).encodedLsigs.Logic[zb0003], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedLsigs.Logic[zb0003])
					if err != nil {
						err = msgp.WrapError(err, "Logic", zb0003)
						return
					}
				}
			case "lsiglbm":
				{
					var zb0337 []byte
					var zb0338 int
					zb0338, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLogic")
						return
					}
					if zb0338 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0338), uint64(maxBitmaskSize))
						return
					}
					zb0337, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedLsigs.BitmaskLogic))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLogic")
						return
					}
					(*z).encodedLsigs.BitmaskLogic = bitmask(zb0337)
				}
			case "lsigarg":
				var zb0339 int
				var zb0340 bool
				zb0339, zb0340, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LogicArgs")
					return
				}
				if zb0339 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0339), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LogicArgs")
					return
				}
				if zb0340 {
					(*z).encodedLsigs.LogicArgs = nil
				} else if (*z).encodedLsigs.LogicArgs != nil && cap((*z).encodedLsigs.LogicArgs) >= zb0339 {
					(*z).encodedLsigs.LogicArgs = ((*z).encodedLsigs.LogicArgs)[:zb0339]
				} else {
					(*z).encodedLsigs.LogicArgs = make([][][]byte, zb0339)
				}
				for zb0004 := range (*z).encodedLsigs.LogicArgs {
					var zb0341 int
					var zb0342 bool
					zb0341, zb0342, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LogicArgs", zb0004)
						return
					}
					if zb0341 > transactions.EvalMaxArgs {
						err = msgp.ErrOverflow(uint64(zb0341), uint64(transactions.EvalMaxArgs))
						err = msgp.WrapError(err, "LogicArgs", zb0004)
						return
					}
					if zb0342 {
						(*z).encodedLsigs.LogicArgs[zb0004] = nil
					} else if (*z).encodedLsigs.LogicArgs[zb0004] != nil && cap((*z).encodedLsigs.LogicArgs[zb0004]) >= zb0341 {
						(*z).encodedLsigs.LogicArgs[zb0004] = ((*z).encodedLsigs.LogicArgs[zb0004])[:zb0341]
					} else {
						(*z).encodedLsigs.LogicArgs[zb0004] = make([][]byte, zb0341)
					}
					for zb0005 := range (*z).encodedLsigs.LogicArgs[zb0004] {
						var zb0343 int
						zb0343, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "LogicArgs", zb0004, zb0005)
							return
						}
						if zb0343 > config.MaxLogicSigMaxSize {
							err = msgp.ErrOverflow(uint64(zb0343), uint64(config.MaxLogicSigMaxSize))
							return
						}
						(*z).encodedLsigs.LogicArgs[zb0004][zb0005], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedLsigs.LogicArgs[zb0004][zb0005])
						if err != nil {
							err = msgp.WrapError(err, "LogicArgs", zb0004, zb0005)
							return
						}
					}
				}
			case "lsigargbm":
				{
					var zb0344 []byte
					var zb0345 int
					zb0345, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLogicArgs")
						return
					}
					if zb0345 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0345), uint64(maxBitmaskSize))
						return
					}
					zb0344, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedLsigs.BitmaskLogicArgs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLogicArgs")
						return
					}
					(*z).encodedLsigs.BitmaskLogicArgs = bitmask(zb0344)
				}
			case "sgnr":
				var zb0346 int
				zb0346, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
				if zb0346 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0346), uint64(maxAddressBytes))
					return
				}
				(*z).AuthAddr, bts, err = msgp.ReadBytesBytes(bts, (*z).AuthAddr)
				if err != nil {
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
			case "sgnrbm":
				{
					var zb0347 []byte
					var zb0348 int
					zb0348, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAuthAddr")
						return
					}
					if zb0348 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0348), uint64(maxBitmaskSize))
						return
					}
					zb0347, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAuthAddr))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAuthAddr")
						return
					}
					(*z).BitmaskAuthAddr = bitmask(zb0347)
				}
			case "type":
				var zb0349 int
				zb0349, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
				if zb0349 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0349), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).encodedTxns.TxType, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.TxType)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
			case "typebm":
				{
					var zb0350 []byte
					var zb0351 int
					zb0351, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTxType")
						return
					}
					if zb0351 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0351), uint64(maxBitmaskSize))
						return
					}
					zb0350, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.BitmaskTxType))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTxType")
						return
					}
					(*z).encodedTxns.BitmaskTxType = bitmask(zb0350)
				}
			case "typeo":
				(*z).encodedTxns.TxTypeOffset, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxTypeOffset")
					return
				}
			case "snd":
				var zb0352 int
				zb0352, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				if zb0352 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0352), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.Sender, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedTxnHeaders.Sender)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "sndbm":
				{
					var zb0353 []byte
					var zb0354 int
					zb0354, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSender")
						return
					}
					if zb0354 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0354), uint64(maxBitmaskSize))
						return
					}
					zb0353, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskSender))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSender")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskSender = bitmask(zb0353)
				}
			case "fee":
				var zb0355 int
				var zb0356 bool
				zb0355, zb0356, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0355 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0355), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0356 {
					(*z).encodedTxns.encodedTxnHeaders.Fee = nil
				} else if (*z).encodedTxns.encodedTxnHeaders.Fee != nil && cap((*z).encodedTxns.encodedTxnHeaders.Fee) >= zb0355 {
					(*z).encodedTxns.encodedTxnHeaders.Fee = ((*z).encodedTxns.encodedTxnHeaders.Fee)[:zb0355]
				} else {
					(*z).encodedTxns.encodedTxnHeaders.Fee = make([]basics.MicroAlgos, zb0355)
				}
				for zb0006 := range (*z).encodedTxns.encodedTxnHeaders.Fee {
					bts, err = (*z).encodedTxns.encodedTxnHeaders.Fee[zb0006].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Fee", zb0006)
						return
					}
				}
			case "feebm":
				{
					var zb0357 []byte
					var zb0358 int
					zb0358, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFee")
						return
					}
					if zb0358 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0358), uint64(maxBitmaskSize))
						return
					}
					zb0357, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFee))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFee")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskFee = bitmask(zb0357)
				}
			case "fv":
				var zb0359 int
				var zb0360 bool
				zb0359, zb0360, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0359 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0359), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0360 {
					(*z).encodedTxns.encodedTxnHeaders.FirstValid = nil
				} else if (*z).encodedTxns.encodedTxnHeaders.FirstValid != nil && cap((*z).encodedTxns.encodedTxnHeaders.FirstValid) >= zb0359 {
					(*z).encodedTxns.encodedTxnHeaders.FirstValid = ((*z).encodedTxns.encodedTxnHeaders.FirstValid)[:zb0359]
				} else {
					(*z).encodedTxns.encodedTxnHeaders.FirstValid = make([]basics.Round, zb0359)
				}
				for zb0007 := range (*z).encodedTxns.encodedTxnHeaders.FirstValid {
					bts, err = (*z).encodedTxns.encodedTxnHeaders.FirstValid[zb0007].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "FirstValid", zb0007)
						return
					}
				}
			case "fvbm":
				{
					var zb0361 []byte
					var zb0362 int
					zb0362, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFirstValid")
						return
					}
					if zb0362 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0362), uint64(maxBitmaskSize))
						return
					}
					zb0361, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFirstValid")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid = bitmask(zb0361)
				}
			case "lv":
				var zb0363 int
				var zb0364 bool
				zb0363, zb0364, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0363 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0363), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0364 {
					(*z).encodedTxns.encodedTxnHeaders.LastValid = nil
				} else if (*z).encodedTxns.encodedTxnHeaders.LastValid != nil && cap((*z).encodedTxns.encodedTxnHeaders.LastValid) >= zb0363 {
					(*z).encodedTxns.encodedTxnHeaders.LastValid = ((*z).encodedTxns.encodedTxnHeaders.LastValid)[:zb0363]
				} else {
					(*z).encodedTxns.encodedTxnHeaders.LastValid = make([]basics.Round, zb0363)
				}
				for zb0008 := range (*z).encodedTxns.encodedTxnHeaders.LastValid {
					bts, err = (*z).encodedTxns.encodedTxnHeaders.LastValid[zb0008].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastValid", zb0008)
						return
					}
				}
			case "lvbm":
				{
					var zb0365 []byte
					var zb0366 int
					zb0366, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLastValid")
						return
					}
					if zb0366 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0366), uint64(maxBitmaskSize))
						return
					}
					zb0365, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLastValid")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid = bitmask(zb0365)
				}
			case "note":
				var zb0367 int
				var zb0368 bool
				zb0367, zb0368, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0367 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0367), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0368 {
					(*z).encodedTxns.encodedTxnHeaders.Note = nil
				} else if (*z).encodedTxns.encodedTxnHeaders.Note != nil && cap((*z).encodedTxns.encodedTxnHeaders.Note) >= zb0367 {
					(*z).encodedTxns.encodedTxnHeaders.Note = ((*z).encodedTxns.encodedTxnHeaders.Note)[:zb0367]
				} else {
					(*z).encodedTxns.encodedTxnHeaders.Note = make([][]byte, zb0367)
				}
				for zb0009 := range (*z).encodedTxns.encodedTxnHeaders.Note {
					var zb0369 int
					zb0369, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "Note", zb0009)
						return
					}
					if zb0369 > config.MaxTxnNoteBytes {
						err = msgp.ErrOverflow(uint64(zb0369), uint64(config.MaxTxnNoteBytes))
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.Note[zb0009], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedTxnHeaders.Note[zb0009])
					if err != nil {
						err = msgp.WrapError(err, "Note", zb0009)
						return
					}
				}
			case "notebm":
				{
					var zb0370 []byte
					var zb0371 int
					zb0371, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNote")
						return
					}
					if zb0371 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0371), uint64(maxBitmaskSize))
						return
					}
					zb0370, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskNote))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNote")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskNote = bitmask(zb0370)
				}
			case "genbm":
				{
					var zb0372 []byte
					var zb0373 int
					zb0373, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisID")
						return
					}
					if zb0373 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0373), uint64(maxBitmaskSize))
						return
					}
					zb0372, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisID")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID = bitmask(zb0372)
				}
			case "grpbm":
				{
					var zb0374 []byte
					var zb0375 int
					zb0375, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGroup")
						return
					}
					if zb0375 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0375), uint64(maxBitmaskSize))
						return
					}
					zb0374, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGroup))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGroup")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskGroup = bitmask(zb0374)
				}
			case "lx":
				var zb0376 int
				zb0376, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
				if zb0376 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0376), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.Lease, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedTxnHeaders.Lease)
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
			case "lxbm":
				{
					var zb0377 []byte
					var zb0378 int
					zb0378, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLease")
						return
					}
					if zb0378 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0378), uint64(maxBitmaskSize))
						return
					}
					zb0377, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLease))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLease")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskLease = bitmask(zb0377)
				}
			case "rekey":
				var zb0379 int
				zb0379, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
				if zb0379 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0379), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.RekeyTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedTxnHeaders.RekeyTo)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
			case "rekeybm":
				{
					var zb0380 []byte
					var zb0381 int
					zb0381, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskRekeyTo")
						return
					}
					if zb0381 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0381), uint64(maxBitmaskSize))
						return
					}
					zb0380, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskRekeyTo")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo = bitmask(zb0380)
				}
			case "votekey":
				var zb0382 int
				zb0382, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
				if zb0382 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0382), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.VotePK, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedKeyregTxnFields.VotePK)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
			case "selkey":
				var zb0383 int
				zb0383, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
				if zb0383 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0383), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.SelectionPK, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
			case "votefst":
				var zb0384 int
				var zb0385 bool
				zb0384, zb0385, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0384 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0384), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0385 {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteFirst = nil
				} else if (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst) >= zb0384 {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteFirst = ((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst)[:zb0384]
				} else {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteFirst = make([]basics.Round, zb0384)
				}
				for zb0010 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst {
					bts, err = (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0010].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteFirst", zb0010)
						return
					}
				}
			case "votefstbm":
				{
					var zb0386 []byte
					var zb0387 int
					zb0387, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteFirst")
						return
					}
					if zb0387 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0387), uint64(maxBitmaskSize))
						return
					}
					zb0386, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteFirst")
						return
					}
					(*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst = bitmask(zb0386)
				}
			case "votelst":
				var zb0388 int
				var zb0389 bool
				zb0388, zb0389, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0388 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0388), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0389 {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteLast = nil
				} else if (*z).encodedTxns.encodedKeyregTxnFields.VoteLast != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VoteLast) >= zb0388 {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteLast = ((*z).encodedTxns.encodedKeyregTxnFields.VoteLast)[:zb0388]
				} else {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteLast = make([]basics.Round, zb0388)
				}
				for zb0011 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteLast {
					bts, err = (*z).encodedTxns.encodedKeyregTxnFields.VoteLast[zb0011].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteLast", zb0011)
						return
					}
				}
			case "votelstbm":
				{
					var zb0390 []byte
					var zb0391 int
					zb0391, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteLast")
						return
					}
					if zb0391 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0391), uint64(maxBitmaskSize))
						return
					}
					zb0390, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteLast")
						return
					}
					(*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast = bitmask(zb0390)
				}
			case "votekd":
				var zb0392 int
				var zb0393 bool
				zb0392, zb0393, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0392 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0392), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0393 {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = nil
				} else if (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) >= zb0392 {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = ((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution)[:zb0392]
				} else {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = make([]uint64, zb0392)
				}
				for zb0012 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution[zb0012], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteKeyDilution", zb0012)
						return
					}
				}
			case "votekbm":
				{
					var zb0394 []byte
					var zb0395 int
					zb0395, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskKeys")
						return
					}
					if zb0395 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0395), uint64(maxBitmaskSize))
						return
					}
					zb0394, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskKeys))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskKeys")
						return
					}
					(*z).encodedTxns.encodedKeyregTxnFields.BitmaskKeys = bitmask(zb0394)
				}
			case "nonpartbm":
				{
					var zb0396 []byte
					var zb0397 int
					zb0397, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNonparticipation")
						return
					}
					if zb0397 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0397), uint64(maxBitmaskSize))
						return
					}
					zb0396, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNonparticipation")
						return
					}
					(*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation = bitmask(zb0396)
				}
			case "vldrt":
				var zb0398 int
				var zb0399 bool
				zb0398, zb0399, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HasValidRoot")
					return
				}
				if zb0398 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0398), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "HasValidRoot")
					return
				}
				if zb0399 {
					(*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot = nil
				} else if (*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot) >= zb0398 {
					(*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot = ((*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot)[:zb0398]
				} else {
					(*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot = make([]bool, zb0398)
				}
				for zb0013 := range (*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot {
					(*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot[zb0013], bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "HasValidRoot", zb0013)
						return
					}
				}
			case "comt":
				var zb0400 int
				zb0400, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "CommitmentRoot")
					return
				}
				if zb0400 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0400), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.CommitmentRoot, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedKeyregTxnFields.CommitmentRoot)
				if err != nil {
					err = msgp.WrapError(err, "CommitmentRoot")
					return
				}
			case "rcv":
				var zb0401 int
				zb0401, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
				if zb0401 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0401), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedPaymentTxnFields.Receiver, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedPaymentTxnFields.Receiver)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
			case "rcvbm":
				{
					var zb0402 []byte
					var zb0403 int
					zb0403, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReceiver")
						return
					}
					if zb0403 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0403), uint64(maxBitmaskSize))
						return
					}
					zb0402, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReceiver")
						return
					}
					(*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver = bitmask(zb0402)
				}
			case "amt":
				var zb0404 int
				var zb0405 bool
				zb0404, zb0405, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0404 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0404), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0405 {
					(*z).encodedTxns.encodedPaymentTxnFields.Amount = nil
				} else if (*z).encodedTxns.encodedPaymentTxnFields.Amount != nil && cap((*z).encodedTxns.encodedPaymentTxnFields.Amount) >= zb0404 {
					(*z).encodedTxns.encodedPaymentTxnFields.Amount = ((*z).encodedTxns.encodedPaymentTxnFields.Amount)[:zb0404]
				} else {
					(*z).encodedTxns.encodedPaymentTxnFields.Amount = make([]basics.MicroAlgos, zb0404)
				}
				for zb0014 := range (*z).encodedTxns.encodedPaymentTxnFields.Amount {
					bts, err = (*z).encodedTxns.encodedPaymentTxnFields.Amount[zb0014].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Amount", zb0014)
						return
					}
				}
			case "amtbm":
				{
					var zb0406 []byte
					var zb0407 int
					zb0407, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAmount")
						return
					}
					if zb0407 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0407), uint64(maxBitmaskSize))
						return
					}
					zb0406, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAmount")
						return
					}
					(*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount = bitmask(zb0406)
				}
			case "close":
				var zb0408 int
				zb0408, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
				if zb0408 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0408), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
			case "closebm":
				{
					var zb0409 []byte
					var zb0410 int
					zb0410, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCloseRemainderTo")
						return
					}
					if zb0410 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0410), uint64(maxBitmaskSize))
						return
					}
					zb0409, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCloseRemainderTo")
						return
					}
					(*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo = bitmask(zb0409)
				}
			case "caid":
				var zb0411 int
				var zb0412 bool
				zb0411, zb0412, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ConfigAsset")
					return
				}
				if zb0411 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0411), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ConfigAsset")
					return
				}
				if zb0412 {
					(*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset = nil
				} else if (*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset != nil && cap((*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset) >= zb0411 {
					(*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset = ((*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset)[:zb0411]
				} else {
					(*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset = make([]basics.AssetIndex, zb0411)
				}
				for zb0015 := range (*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset {
					bts, err = (*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset[zb0015].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ConfigAsset", zb0015)
						return
					}
				}
			case "caidbm":
				{
					var zb0413 []byte
					var zb0414 int
					zb0414, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskConfigAsset")
						return
					}
					if zb0414 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0414), uint64(maxBitmaskSize))
						return
					}
					zb0413, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskConfigAsset")
						return
					}
					(*z).encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset = bitmask(zb0413)
				}
			case "t":
				var zb0415 int
				var zb0416 bool
				zb0415, zb0416, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Total")
					return
				}
				if zb0415 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0415), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Total")
					return
				}
				if zb0416 {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total = nil
				} else if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total != nil && cap((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total) >= zb0415 {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total = ((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total)[:zb0415]
				} else {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total = make([]uint64, zb0415)
				}
				for zb0016 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total[zb0016], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Total", zb0016)
						return
					}
				}
			case "tbm":
				{
					var zb0417 []byte
					var zb0418 int
					zb0418, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTotal")
						return
					}
					if zb0418 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0418), uint64(maxBitmaskSize))
						return
					}
					zb0417, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTotal")
						return
					}
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal = bitmask(zb0417)
				}
			case "dc":
				var zb0419 int
				var zb0420 bool
				zb0419, zb0420, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Decimals")
					return
				}
				if zb0419 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0419), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Decimals")
					return
				}
				if zb0420 {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals = nil
				} else if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals != nil && cap((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals) >= zb0419 {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals = ((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals)[:zb0419]
				} else {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals = make([]uint32, zb0419)
				}
				for zb0017 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals[zb0017], bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Decimals", zb0017)
						return
					}
				}
			case "dcbm":
				{
					var zb0421 []byte
					var zb0422 int
					zb0422, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDecimals")
						return
					}
					if zb0422 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0422), uint64(maxBitmaskSize))
						return
					}
					zb0421, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDecimals")
						return
					}
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals = bitmask(zb0421)
				}
			case "dfbm":
				{
					var zb0423 []byte
					var zb0424 int
					zb0424, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDefaultFrozen")
						return
					}
					if zb0424 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0424), uint64(maxBitmaskSize))
						return
					}
					zb0423, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDefaultFrozen")
						return
					}
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen = bitmask(zb0423)
				}
			case "un":
				var zb0425 int
				var zb0426 bool
				zb0425, zb0426, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UnitName")
					return
				}
				if zb0425 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0425), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "UnitName")
					return
				}
				if zb0426 {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName = nil
				} else if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName != nil && cap((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName) >= zb0425 {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName = ((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName)[:zb0425]
				} else {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName = make([]string, zb0425)
				}
				for zb0018 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName[zb0018], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "UnitName", zb0018)
						return
					}
				}
			case "unbm":
				{
					var zb0427 []byte
					var zb0428 int
					zb0428, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskUnitName")
						return
					}
					if zb0428 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0428), uint64(maxBitmaskSize))
						return
					}
					zb0427, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskUnitName")
						return
					}
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName = bitmask(zb0427)
				}
			case "an":
				var zb0429 int
				var zb0430 bool
				zb0429, zb0430, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetName")
					return
				}
				if zb0429 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0429), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "AssetName")
					return
				}
				if zb0430 {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName = nil
				} else if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName != nil && cap((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName) >= zb0429 {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName = ((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName)[:zb0429]
				} else {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName = make([]string, zb0429)
				}
				for zb0019 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName[zb0019], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AssetName", zb0019)
						return
					}
				}
			case "anbm":
				{
					var zb0431 []byte
					var zb0432 int
					zb0432, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetName")
						return
					}
					if zb0432 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0432), uint64(maxBitmaskSize))
						return
					}
					zb0431, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetName")
						return
					}
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName = bitmask(zb0431)
				}
			case "au":
				var zb0433 int
				var zb0434 bool
				zb0433, zb0434, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "URL")
					return
				}
				if zb0433 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0433), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "URL")
					return
				}
				if zb0434 {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL = nil
				} else if (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL != nil && cap((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL) >= zb0433 {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL = ((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL)[:zb0433]
				} else {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL = make([]string, zb0433)
				}
				for zb0020 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL {
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL[zb0020], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "URL", zb0020)
						return
					}
				}
			case "aubm":
				{
					var zb0435 []byte
					var zb0436 int
					zb0436, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskURL")
						return
					}
					if zb0436 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0436), uint64(maxBitmaskSize))
						return
					}
					zb0435, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskURL")
						return
					}
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL = bitmask(zb0435)
				}
			case "am":
				var zb0437 int
				zb0437, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "MetadataHash")
					return
				}
				if zb0437 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0437), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash)
				if err != nil {
					err = msgp.WrapError(err, "MetadataHash")
					return
				}
			case "ambm":
				{
					var zb0438 []byte
					var zb0439 int
					zb0439, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMetadataHash")
						return
					}
					if zb0439 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0439), uint64(maxBitmaskSize))
						return
					}
					zb0438, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMetadataHash")
						return
					}
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash = bitmask(zb0438)
				}
			case "m":
				var zb0440 int
				zb0440, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Manager")
					return
				}
				if zb0440 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0440), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager)
				if err != nil {
					err = msgp.WrapError(err, "Manager")
					return
				}
			case "mbm":
				{
					var zb0441 []byte
					var zb0442 int
					zb0442, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskManager")
						return
					}
					if zb0442 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0442), uint64(maxBitmaskSize))
						return
					}
					zb0441, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskManager")
						return
					}
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager = bitmask(zb0441)
				}
			case "r":
				var zb0443 int
				zb0443, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reserve")
					return
				}
				if zb0443 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0443), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve)
				if err != nil {
					err = msgp.WrapError(err, "Reserve")
					return
				}
			case "rbm":
				{
					var zb0444 []byte
					var zb0445 int
					zb0445, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReserve")
						return
					}
					if zb0445 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0445), uint64(maxBitmaskSize))
						return
					}
					zb0444, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReserve")
						return
					}
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve = bitmask(zb0444)
				}
			case "f":
				var zb0446 int
				zb0446, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Freeze")
					return
				}
				if zb0446 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0446), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze)
				if err != nil {
					err = msgp.WrapError(err, "Freeze")
					return
				}
			case "fbm":
				{
					var zb0447 []byte
					var zb0448 int
					zb0448, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreeze")
						return
					}
					if zb0448 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0448), uint64(maxBitmaskSize))
						return
					}
					zb0447, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreeze")
						return
					}
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze = bitmask(zb0447)
				}
			case "c":
				var zb0449 int
				zb0449, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Clawback")
					return
				}
				if zb0449 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0449), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback)
				if err != nil {
					err = msgp.WrapError(err, "Clawback")
					return
				}
			case "cbm":
				{
					var zb0450 []byte
					var zb0451 int
					zb0451, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClawback")
						return
					}
					if zb0451 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0451), uint64(maxBitmaskSize))
						return
					}
					zb0450, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClawback")
						return
					}
					(*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback = bitmask(zb0450)
				}
			case "xaid":
				var zb0452 int
				var zb0453 bool
				zb0452, zb0453, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "XferAsset")
					return
				}
				if zb0452 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0452), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "XferAsset")
					return
				}
				if zb0453 {
					(*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset = nil
				} else if (*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset != nil && cap((*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset) >= zb0452 {
					(*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset = ((*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset)[:zb0452]
				} else {
					(*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset = make([]basics.AssetIndex, zb0452)
				}
				for zb0021 := range (*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset {
					bts, err = (*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset[zb0021].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "XferAsset", zb0021)
						return
					}
				}
			case "xaidbm":
				{
					var zb0454 []byte
					var zb0455 int
					zb0455, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskXferAsset")
						return
					}
					if zb0455 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0455), uint64(maxBitmaskSize))
						return
					}
					zb0454, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskXferAsset")
						return
					}
					(*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset = bitmask(zb0454)
				}
			case "aamt":
				var zb0456 int
				var zb0457 bool
				zb0456, zb0457, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetAmount")
					return
				}
				if zb0456 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0456), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "AssetAmount")
					return
				}
				if zb0457 {
					(*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount = nil
				} else if (*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount != nil && cap((*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount) >= zb0456 {
					(*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount = ((*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount)[:zb0456]
				} else {
					(*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount = make([]uint64, zb0456)
				}
				for zb0022 := range (*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount {
					(*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount[zb0022], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AssetAmount", zb0022)
						return
					}
				}
			case "aamtbm":
				{
					var zb0458 []byte
					var zb0459 int
					zb0459, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetAmount")
						return
					}
					if zb0459 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0459), uint64(maxBitmaskSize))
						return
					}
					zb0458, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetAmount")
						return
					}
					(*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount = bitmask(zb0458)
				}
			case "asnd":
				var zb0460 int
				zb0460, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetSender")
					return
				}
				if zb0460 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0460), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedAssetTransferTxnFields.AssetSender, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetTransferTxnFields.AssetSender)
				if err != nil {
					err = msgp.WrapError(err, "AssetSender")
					return
				}
			case "asndbm":
				{
					var zb0461 []byte
					var zb0462 int
					zb0462, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetSender")
						return
					}
					if zb0462 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0462), uint64(maxBitmaskSize))
						return
					}
					zb0461, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetSender")
						return
					}
					(*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender = bitmask(zb0461)
				}
			case "arcv":
				var zb0463 int
				zb0463, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetReceiver")
					return
				}
				if zb0463 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0463), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedAssetTransferTxnFields.AssetReceiver, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetTransferTxnFields.AssetReceiver)
				if err != nil {
					err = msgp.WrapError(err, "AssetReceiver")
					return
				}
			case "arcvbm":
				{
					var zb0464 []byte
					var zb0465 int
					zb0465, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetReceiver")
						return
					}
					if zb0465 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0465), uint64(maxBitmaskSize))
						return
					}
					zb0464, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetReceiver")
						return
					}
					(*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver = bitmask(zb0464)
				}
			case "aclose":
				var zb0466 int
				zb0466, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetCloseTo")
					return
				}
				if zb0466 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0466), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo)
				if err != nil {
					err = msgp.WrapError(err, "AssetCloseTo")
					return
				}
			case "aclosebm":
				{
					var zb0467 []byte
					var zb0468 int
					zb0468, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetCloseTo")
						return
					}
					if zb0468 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0468), uint64(maxBitmaskSize))
						return
					}
					zb0467, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetCloseTo")
						return
					}
					(*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo = bitmask(zb0467)
				}
			case "fadd":
				var zb0469 int
				zb0469, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAccount")
					return
				}
				if zb0469 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0469), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAccount")
					return
				}
			case "faddbm":
				{
					var zb0470 []byte
					var zb0471 int
					zb0471, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAccount")
						return
					}
					if zb0471 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0471), uint64(maxBitmaskSize))
						return
					}
					zb0470, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAccount")
						return
					}
					(*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount = bitmask(zb0470)
				}
			case "faid":
				var zb0472 int
				var zb0473 bool
				zb0472, zb0473, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAsset")
					return
				}
				if zb0472 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0472), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "FreezeAsset")
					return
				}
				if zb0473 {
					(*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset = nil
				} else if (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset != nil && cap((*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset) >= zb0472 {
					(*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset = ((*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset)[:zb0472]
				} else {
					(*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset = make([]basics.AssetIndex, zb0472)
				}
				for zb0023 := range (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset {
					bts, err = (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset[zb0023].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "FreezeAsset", zb0023)
						return
					}
				}
			case "faidbm":
				{
					var zb0474 []byte
					var zb0475 int
					zb0475, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAsset")
						return
					}
					if zb0475 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0475), uint64(maxBitmaskSize))
						return
					}
					zb0474, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAsset")
						return
					}
					(*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset = bitmask(zb0474)
				}
			case "afrzbm":
				{
					var zb0476 []byte
					var zb0477 int
					zb0477, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetFrozen")
						return
					}
					if zb0477 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0477), uint64(maxBitmaskSize))
						return
					}
					zb0476, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetFrozen")
						return
					}
					(*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen = bitmask(zb0476)
				}
			case "apid":
				var zb0478 int
				var zb0479 bool
				zb0478, zb0479, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ApplicationID")
					return
				}
				if zb0478 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0478), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ApplicationID")
					return
				}
				if zb0479 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID) >= zb0478 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID = ((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID)[:zb0478]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID = make([]basics.AppIndex, zb0478)
				}
				for zb0024 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID {
					bts, err = (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID[zb0024].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ApplicationID", zb0024)
						return
					}
				}
			case "apidbm":
				{
					var zb0480 []byte
					var zb0481 int
					zb0481, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationID")
						return
					}
					if zb0481 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0481), uint64(maxBitmaskSize))
						return
					}
					zb0480, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationID")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID = bitmask(zb0480)
				}
			case "apan":
				var zb0482 int
				zb0482, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "OnCompletion")
					return
				}
				if zb0482 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0482), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).encodedTxns.encodedApplicationCallTxnFields.OnCompletion, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedApplicationCallTxnFields.OnCompletion)
				if err != nil {
					err = msgp.WrapError(err, "OnCompletion")
					return
				}
			case "apanbm":
				{
					var zb0483 []byte
					var zb0484 int
					zb0484, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskOnCompletion")
						return
					}
					if zb0484 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0484), uint64(maxBitmaskSize))
						return
					}
					zb0483, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskOnCompletion")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion = bitmask(zb0483)
				}
			case "apaa":
				var zb0485 int
				var zb0486 bool
				zb0485, zb0486, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ApplicationArgs")
					return
				}
				if zb0485 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0485), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ApplicationArgs")
					return
				}
				if zb0486 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs) >= zb0485 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs = ((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs)[:zb0485]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs = make([]applicationArgs, zb0485)
				}
				for zb0025 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs {
					var zb0487 int
					var zb0488 bool
					zb0487, zb0488, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ApplicationArgs", zb0025)
						return
					}
					if zb0487 > transactions.EncodedMaxApplicationArgs {
						err = msgp.ErrOverflow(uint64(zb0487), uint64(transactions.EncodedMaxApplicationArgs))
						err = msgp.WrapError(err, "ApplicationArgs", zb0025)
						return
					}
					if zb0488 {
						(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] = nil
					} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025]) >= zb0487 {
						(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] = ((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025])[:zb0487]
					} else {
						(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] = make(applicationArgs, zb0487)
					}
					for zb0026 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] {
						(*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025][zb0026], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025][zb0026])
						if err != nil {
							err = msgp.WrapError(err, "ApplicationArgs", zb0025, zb0026)
							return
						}
					}
				}
			case "apaabm":
				{
					var zb0489 []byte
					var zb0490 int
					zb0490, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationArgs")
						return
					}
					if zb0490 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0490), uint64(maxBitmaskSize))
						return
					}
					zb0489, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationArgs")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs = bitmask(zb0489)
				}
			case "apat":
				var zb0491 int
				var zb0492 bool
				zb0491, zb0492, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Accounts")
					return
				}
				if zb0491 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0491), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Accounts")
					return
				}
				if zb0492 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.Accounts = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.Accounts) >= zb0491 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.Accounts = ((*z).encodedTxns.encodedApplicationCallTxnFields.Accounts)[:zb0491]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.Accounts = make([]addresses, zb0491)
				}
				for zb0027 := range (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts {
					var zb0493 int
					var zb0494 bool
					zb0493, zb0494, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Accounts", zb0027)
						return
					}
					if zb0493 > transactions.EncodedMaxAccounts {
						err = msgp.ErrOverflow(uint64(zb0493), uint64(transactions.EncodedMaxAccounts))
						err = msgp.WrapError(err, "Accounts", zb0027)
						return
					}
					if zb0494 {
						(*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] = nil
					} else if (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027]) >= zb0493 {
						(*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] = ((*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027])[:zb0493]
					} else {
						(*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] = make(addresses, zb0493)
					}
					for zb0028 := range (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] {
						bts, err = (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027][zb0028].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Accounts", zb0027, zb0028)
							return
						}
					}
				}
			case "apatbm":
				{
					var zb0495 []byte
					var zb0496 int
					zb0496, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAccounts")
						return
					}
					if zb0496 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0496), uint64(maxBitmaskSize))
						return
					}
					zb0495, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAccounts")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts = bitmask(zb0495)
				}
			case "apfa":
				var zb0497 int
				var zb0498 bool
				zb0497, zb0498, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ForeignApps")
					return
				}
				if zb0497 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0497), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ForeignApps")
					return
				}
				if zb0498 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps) >= zb0497 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps = ((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps)[:zb0497]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps = make([]appIndices, zb0497)
				}
				for zb0029 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps {
					var zb0499 int
					var zb0500 bool
					zb0499, zb0500, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ForeignApps", zb0029)
						return
					}
					if zb0499 > transactions.EncodedMaxForeignApps {
						err = msgp.ErrOverflow(uint64(zb0499), uint64(transactions.EncodedMaxForeignApps))
						err = msgp.WrapError(err, "ForeignApps", zb0029)
						return
					}
					if zb0500 {
						(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] = nil
					} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029]) >= zb0499 {
						(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] = ((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029])[:zb0499]
					} else {
						(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] = make(appIndices, zb0499)
					}
					for zb0030 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] {
						bts, err = (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029][zb0030].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "ForeignApps", zb0029, zb0030)
							return
						}
					}
				}
			case "apfabm":
				{
					var zb0501 []byte
					var zb0502 int
					zb0502, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignApps")
						return
					}
					if zb0502 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0502), uint64(maxBitmaskSize))
						return
					}
					zb0501, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignApps")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps = bitmask(zb0501)
				}
			case "apas":
				var zb0503 int
				var zb0504 bool
				zb0503, zb0504, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ForeignAssets")
					return
				}
				if zb0503 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0503), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ForeignAssets")
					return
				}
				if zb0504 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets) >= zb0503 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets = ((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets)[:zb0503]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets = make([]assetIndices, zb0503)
				}
				for zb0031 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets {
					var zb0505 int
					var zb0506 bool
					zb0505, zb0506, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ForeignAssets", zb0031)
						return
					}
					if zb0505 > transactions.EncodedMaxForeignAssets {
						err = msgp.ErrOverflow(uint64(zb0505), uint64(transactions.EncodedMaxForeignAssets))
						err = msgp.WrapError(err, "ForeignAssets", zb0031)
						return
					}
					if zb0506 {
						(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] = nil
					} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031]) >= zb0505 {
						(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] = ((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031])[:zb0505]
					} else {
						(*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] = make(assetIndices, zb0505)
					}
					for zb0032 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] {
						bts, err = (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031][zb0032].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "ForeignAssets", zb0031, zb0032)
							return
						}
					}
				}
			case "apasbm":
				{
					var zb0507 []byte
					var zb0508 int
					zb0508, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignAssets")
						return
					}
					if zb0508 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0508), uint64(maxBitmaskSize))
						return
					}
					zb0507, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignAssets")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets = bitmask(zb0507)
				}
			case "lnui":
				var zb0509 int
				var zb0510 bool
				zb0509, zb0510, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LocalNumUint")
					return
				}
				if zb0509 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0509), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LocalNumUint")
					return
				}
				if zb0510 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint) >= zb0509 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint = ((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint)[:zb0509]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint = make([]uint64, zb0509)
				}
				for zb0033 := range (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint {
					(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint[zb0033], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LocalNumUint", zb0033)
						return
					}
				}
			case "lnuibm":
				{
					var zb0511 []byte
					var zb0512 int
					zb0512, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumUint")
						return
					}
					if zb0512 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0512), uint64(maxBitmaskSize))
						return
					}
					zb0511, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumUint")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint = bitmask(zb0511)
				}
			case "lnbs":
				var zb0513 int
				var zb0514 bool
				zb0513, zb0514, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LocalNumByteSlice")
					return
				}
				if zb0513 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0513), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LocalNumByteSlice")
					return
				}
				if zb0514 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice) >= zb0513 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice = ((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice)[:zb0513]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice = make([]uint64, zb0513)
				}
				for zb0034 := range (*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice {
					(*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice[zb0034], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LocalNumByteSlice", zb0034)
						return
					}
				}
			case "lnbsbm":
				{
					var zb0515 []byte
					var zb0516 int
					zb0516, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumByteSlice")
						return
					}
					if zb0516 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0516), uint64(maxBitmaskSize))
						return
					}
					zb0515, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumByteSlice")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice = bitmask(zb0515)
				}
			case "gnui":
				var zb0517 int
				var zb0518 bool
				zb0517, zb0518, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GlobalNumUint")
					return
				}
				if zb0517 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0517), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "GlobalNumUint")
					return
				}
				if zb0518 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint) >= zb0517 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint = ((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint)[:zb0517]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint = make([]uint64, zb0517)
				}
				for zb0035 := range (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint {
					(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint[zb0035], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "GlobalNumUint", zb0035)
						return
					}
				}
			case "gnuibm":
				{
					var zb0519 []byte
					var zb0520 int
					zb0520, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumUint")
						return
					}
					if zb0520 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0520), uint64(maxBitmaskSize))
						return
					}
					zb0519, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumUint")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint = bitmask(zb0519)
				}
			case "gnbs":
				var zb0521 int
				var zb0522 bool
				zb0521, zb0522, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GlobalNumByteSlice")
					return
				}
				if zb0521 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0521), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "GlobalNumByteSlice")
					return
				}
				if zb0522 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice) >= zb0521 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice = ((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice)[:zb0521]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice = make([]uint64, zb0521)
				}
				for zb0036 := range (*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice {
					(*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice[zb0036], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "GlobalNumByteSlice", zb0036)
						return
					}
				}
			case "gnbsbm":
				{
					var zb0523 []byte
					var zb0524 int
					zb0524, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumByteSlice")
						return
					}
					if zb0524 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0524), uint64(maxBitmaskSize))
						return
					}
					zb0523, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumByteSlice")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice = bitmask(zb0523)
				}
			case "apap":
				var zb0525 int
				var zb0526 bool
				zb0525, zb0526, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ApprovalProgram")
					return
				}
				if zb0525 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0525), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ApprovalProgram")
					return
				}
				if zb0526 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram) >= zb0525 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram = ((*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram)[:zb0525]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram = make([]program, zb0525)
				}
				for zb0037 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram {
					{
						var zb0527 []byte
						var zb0528 int
						zb0528, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "ApprovalProgram", zb0037)
							return
						}
						if zb0528 > config.MaxAvailableAppProgramLen {
							err = msgp.ErrOverflow(uint64(zb0528), uint64(config.MaxAvailableAppProgramLen))
							return
						}
						zb0527, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram[zb0037]))
						if err != nil {
							err = msgp.WrapError(err, "ApprovalProgram", zb0037)
							return
						}
						(*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram[zb0037] = program(zb0527)
					}
				}
			case "apapbm":
				{
					var zb0529 []byte
					var zb0530 int
					zb0530, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApprovalProgram")
						return
					}
					if zb0530 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0530), uint64(maxBitmaskSize))
						return
					}
					zb0529, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApprovalProgram")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram = bitmask(zb0529)
				}
			case "apsu":
				var zb0531 int
				var zb0532 bool
				zb0531, zb0532, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ClearStateProgram")
					return
				}
				if zb0531 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0531), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ClearStateProgram")
					return
				}
				if zb0532 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram) >= zb0531 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram = ((*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram)[:zb0531]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram = make([]program, zb0531)
				}
				for zb0038 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram {
					{
						var zb0533 []byte
						var zb0534 int
						zb0534, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "ClearStateProgram", zb0038)
							return
						}
						if zb0534 > config.MaxAvailableAppProgramLen {
							err = msgp.ErrOverflow(uint64(zb0534), uint64(config.MaxAvailableAppProgramLen))
							return
						}
						zb0533, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram[zb0038]))
						if err != nil {
							err = msgp.WrapError(err, "ClearStateProgram", zb0038)
							return
						}
						(*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram[zb0038] = program(zb0533)
					}
				}
			case "apsubm":
				{
					var zb0535 []byte
					var zb0536 int
					zb0536, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClearStateProgram")
						return
					}
					if zb0536 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0536), uint64(maxBitmaskSize))
						return
					}
					zb0535, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClearStateProgram")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram = bitmask(zb0535)
				}
			case "apep":
				var zb0537 int
				var zb0538 bool
				zb0537, zb0538, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExtraProgramPages")
					return
				}
				if zb0537 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0537), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ExtraProgramPages")
					return
				}
				if zb0538 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages = nil
				} else if (*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages != nil && cap((*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages) >= zb0537 {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages = ((*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages)[:zb0537]
				} else {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages = make([]uint32, zb0537)
				}
				for zb0039 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages {
					(*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages[zb0039], bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ExtraProgramPages", zb0039)
						return
					}
				}
			case "apepbm":
				{
					var zb0539 []byte
					var zb0540 int
					zb0540, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskExtraProgramPages")
						return
					}
					if zb0540 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0540), uint64(maxBitmaskSize))
						return
					}
					zb0539, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskExtraProgramPages")
						return
					}
					(*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages = bitmask(zb0539)
				}
			case "certrnd":
				var zb0541 int
				var zb0542 bool
				zb0541, zb0542, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CertRound")
					return
				}
				if zb0541 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0541), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "CertRound")
					return
				}
				if zb0542 {
					(*z).encodedTxns.encodedCompactCertTxnFields.CertRound = nil
				} else if (*z).encodedTxns.encodedCompactCertTxnFields.CertRound != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.CertRound) >= zb0541 {
					(*z).encodedTxns.encodedCompactCertTxnFields.CertRound = ((*z).encodedTxns.encodedCompactCertTxnFields.CertRound)[:zb0541]
				} else {
					(*z).encodedTxns.encodedCompactCertTxnFields.CertRound = make([]basics.Round, zb0541)
				}
				for zb0040 := range (*z).encodedTxns.encodedCompactCertTxnFields.CertRound {
					bts, err = (*z).encodedTxns.encodedCompactCertTxnFields.CertRound[zb0040].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CertRound", zb0040)
						return
					}
				}
			case "certrndbm":
				{
					var zb0543 []byte
					var zb0544 int
					zb0544, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertRound")
						return
					}
					if zb0544 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0544), uint64(maxBitmaskSize))
						return
					}
					zb0543, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertRound")
						return
					}
					(*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound = bitmask(zb0543)
				}
			case "certtype":
				var zb0545 int
				var zb0546 bool
				zb0545, zb0546, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CertType")
					return
				}
				if zb0545 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0545), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "CertType")
					return
				}
				if zb0546 {
					(*z).encodedTxns.encodedCompactCertTxnFields.CertType = nil
				} else if (*z).encodedTxns.encodedCompactCertTxnFields.CertType != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.CertType) >= zb0545 {
					(*z).encodedTxns.encodedCompactCertTxnFields.CertType = ((*z).encodedTxns.encodedCompactCertTxnFields.CertType)[:zb0545]
				} else {
					(*z).encodedTxns.encodedCompactCertTxnFields.CertType = make([]protocol.CompactCertType, zb0545)
				}
				for zb0041 := range (*z).encodedTxns.encodedCompactCertTxnFields.CertType {
					bts, err = (*z).encodedTxns.encodedCompactCertTxnFields.CertType[zb0041].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CertType", zb0041)
						return
					}
				}
			case "certtypebm":
				{
					var zb0547 []byte
					var zb0548 int
					zb0548, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertType")
						return
					}
					if zb0548 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0548), uint64(maxBitmaskSize))
						return
					}
					zb0547, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertType))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertType")
						return
					}
					(*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertType = bitmask(zb0547)
				}
			case "certc":
				var zb0549 int
				var zb0550 bool
				zb0549, zb0550, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigCommit")
					return
				}
				if zb0549 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0549), uint64(maxAddressBytes))
					err = msgp.WrapError(err, "SigCommit")
					return
				}
				if zb0550 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit = nil
				} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit) >= zb0549 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit)[:zb0549]
				} else {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit = make([]crypto.GenericDigest, zb0549)
				}
				for zb0042 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit {
					bts, err = (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit[zb0042].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigCommit", zb0042)
						return
					}
				}
			case "certcbm":
				{
					var zb0551 []byte
					var zb0552 int
					zb0552, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigCommit")
						return
					}
					if zb0552 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0552), uint64(maxBitmaskSize))
						return
					}
					zb0551, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigCommit")
						return
					}
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit = bitmask(zb0551)
				}
			case "certw":
				var zb0553 int
				var zb0554 bool
				zb0553, zb0554, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SignedWeight")
					return
				}
				if zb0553 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0553), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SignedWeight")
					return
				}
				if zb0554 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight = nil
				} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight) >= zb0553 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight)[:zb0553]
				} else {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight = make([]uint64, zb0553)
				}
				for zb0043 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight[zb0043], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedWeight", zb0043)
						return
					}
				}
			case "certwbm":
				{
					var zb0555 []byte
					var zb0556 int
					zb0556, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSignedWeight")
						return
					}
					if zb0556 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0556), uint64(maxBitmaskSize))
						return
					}
					zb0555, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSignedWeight")
						return
					}
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight = bitmask(zb0555)
				}
			case "certS":
				var zb0557 int
				var zb0558 bool
				zb0557, zb0558, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigProofs")
					return
				}
				if zb0557 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0557), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SigProofs")
					return
				}
				if zb0558 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs = nil
				} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs) >= zb0557 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs)[:zb0557]
				} else {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs = make([]certProofs, zb0557)
				}
				for zb0044 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs {
					var zb0559 int
					var zb0560 bool
					zb0559, zb0560, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigProofs", zb0044)
						return
					}
					if zb0559 > compactcert.MaxProofDigests {
						err = msgp.ErrOverflow(uint64(zb0559), uint64(compactcert.MaxProofDigests))
						err = msgp.WrapError(err, "SigProofs", zb0044)
						return
					}
					if zb0560 {
						(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] = nil
					} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044]) >= zb0559 {
						(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044])[:zb0559]
					} else {
						(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] = make(certProofs, zb0559)
					}
					for zb0045 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] {
						bts, err = (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044][zb0045].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SigProofs", zb0044, zb0045)
							return
						}
					}
				}
			case "certSbm":
				{
					var zb0561 []byte
					var zb0562 int
					zb0562, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigProofs")
						return
					}
					if zb0562 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0562), uint64(maxBitmaskSize))
						return
					}
					zb0561, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigProofs")
						return
					}
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs = bitmask(zb0561)
				}
			case "certSH":
				var zb0563 int
				var zb0564 bool
				zb0563, zb0564, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigProofHashTypes")
					return
				}
				if zb0563 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0563), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SigProofHashTypes")
					return
				}
				if zb0564 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = nil
				} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) >= zb0563 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes)[:zb0563]
				} else {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = make([]uint64, zb0563)
				}
				for zb0046 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes[zb0046], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigProofHashTypes", zb0046)
						return
					}
				}
			case "certSHbm":
				{
					var zb0565 []byte
					var zb0566 int
					zb0566, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigsHash")
						return
					}
					if zb0566 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0566), uint64(maxBitmaskSize))
						return
					}
					zb0565, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigsHash")
						return
					}
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash = bitmask(zb0565)
				}
			case "certP":
				var zb0567 int
				var zb0568 bool
				zb0567, zb0568, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PartProofs")
					return
				}
				if zb0567 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0567), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "PartProofs")
					return
				}
				if zb0568 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs = nil
				} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs) >= zb0567 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs)[:zb0567]
				} else {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs = make([]certProofs, zb0567)
				}
				for zb0047 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs {
					var zb0569 int
					var zb0570 bool
					zb0569, zb0570, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PartProofs", zb0047)
						return
					}
					if zb0569 > compactcert.MaxProofDigests {
						err = msgp.ErrOverflow(uint64(zb0569), uint64(compactcert.MaxProofDigests))
						err = msgp.WrapError(err, "PartProofs", zb0047)
						return
					}
					if zb0570 {
						(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] = nil
					} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047]) >= zb0569 {
						(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047])[:zb0569]
					} else {
						(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] = make(certProofs, zb0569)
					}
					for zb0048 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] {
						bts, err = (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047][zb0048].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "PartProofs", zb0047, zb0048)
							return
						}
					}
				}
			case "certPbm":
				{
					var zb0571 []byte
					var zb0572 int
					zb0572, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartProofs")
						return
					}
					if zb0572 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0572), uint64(maxBitmaskSize))
						return
					}
					zb0571, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartProofs")
						return
					}
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs = bitmask(zb0571)
				}
			case "certPH":
				var zb0573 int
				var zb0574 bool
				zb0573, zb0574, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PartProofHashTypes")
					return
				}
				if zb0573 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0573), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "PartProofHashTypes")
					return
				}
				if zb0574 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = nil
				} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) >= zb0573 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes)[:zb0573]
				} else {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = make([]uint64, zb0573)
				}
				for zb0049 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes[zb0049], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PartProofHashTypes", zb0049)
						return
					}
				}
			case "certPHbm":
				{
					var zb0575 []byte
					var zb0576 int
					zb0576, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartHash")
						return
					}
					if zb0576 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0576), uint64(maxBitmaskSize))
						return
					}
					zb0575, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartHash")
						return
					}
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash = bitmask(zb0575)
				}
			case "certr":
				var zb0577 int
				var zb0578 bool
				zb0577, zb0578, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reveals")
					return
				}
				if zb0577 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0577), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Reveals")
					return
				}
				if zb0578 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals = nil
				} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals != nil && cap((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals) >= zb0577 {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals = ((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals)[:zb0577]
				} else {
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals = make([]revealMap, zb0577)
				}
				for zb0050 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals {
					var zb0579 int
					var zb0580 bool
					zb0579, zb0580, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Reveals", zb0050)
						return
					}
					if zb0579 > compactcert.MaxReveals {
						err = msgp.ErrOverflow(uint64(zb0579), uint64(compactcert.MaxReveals))
						err = msgp.WrapError(err, "Reveals", zb0050)
						return
					}
					if zb0580 {
						(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] = nil
					} else if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] == nil {
						(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] = make(revealMap, zb0579)
					}
					for zb0579 > 0 {
						var zb0051 uint64
						var zb0052 compactcert.Reveal
						zb0579--
						zb0051, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Reveals", zb0050)
							return
						}
						bts, err = zb0052.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Reveals", zb0050, zb0051)
							return
						}
						(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050][zb0051] = zb0052
					}
				}
			case "certrbm":
				{
					var zb0581 []byte
					var zb0582 int
					zb0582, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReveals")
						return
					}
					if zb0582 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0582), uint64(maxBitmaskSize))
						return
					}
					zb0581, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReveals")
						return
					}
					(*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals = bitmask(zb0581)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedSignedTxns) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedSignedTxns)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedSignedTxns) Msgsize() (s int) {
	s = 3 + 4 + msgp.BytesPrefixSize + len((*z).Sig) + 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskSig)) + 6 + msgp.BytesPrefixSize + len((*z).encodedMsigs.Version) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedMsigs.BitmaskVersion)) + 8 + msgp.BytesPrefixSize + len((*z).encodedMsigs.Threshold) + 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedMsigs.BitmaskThreshold)) + 7 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).encodedMsigs.Subsigs {
		s += msgp.ArrayHeaderSize
		for zb0002 := range (*z).encodedMsigs.Subsigs[zb0001] {
			s += (*z).encodedMsigs.Subsigs[zb0001][zb0002].Msgsize()
		}
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedMsigs.BitmaskSubsigs)) + 6 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).encodedLsigs.Logic {
		s += msgp.BytesPrefixSize + len((*z).encodedLsigs.Logic[zb0003])
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedLsigs.BitmaskLogic)) + 8 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).encodedLsigs.LogicArgs {
		s += msgp.ArrayHeaderSize
		for zb0005 := range (*z).encodedLsigs.LogicArgs[zb0004] {
			s += msgp.BytesPrefixSize + len((*z).encodedLsigs.LogicArgs[zb0004][zb0005])
		}
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedLsigs.BitmaskLogicArgs)) + 5 + msgp.BytesPrefixSize + len((*z).AuthAddr) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskAuthAddr)) + 5 + msgp.BytesPrefixSize + len((*z).encodedTxns.TxType) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.BitmaskTxType)) + 6 + msgp.ByteSize + 4 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedTxnHeaders.Sender) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskSender)) + 4 + msgp.ArrayHeaderSize
	for zb0006 := range (*z).encodedTxns.encodedTxnHeaders.Fee {
		s += (*z).encodedTxns.encodedTxnHeaders.Fee[zb0006].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFee)) + 3 + msgp.ArrayHeaderSize
	for zb0007 := range (*z).encodedTxns.encodedTxnHeaders.FirstValid {
		s += (*z).encodedTxns.encodedTxnHeaders.FirstValid[zb0007].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid)) + 3 + msgp.ArrayHeaderSize
	for zb0008 := range (*z).encodedTxns.encodedTxnHeaders.LastValid {
		s += (*z).encodedTxns.encodedTxnHeaders.LastValid[zb0008].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid)) + 5 + msgp.ArrayHeaderSize
	for zb0009 := range (*z).encodedTxns.encodedTxnHeaders.Note {
		s += msgp.BytesPrefixSize + len((*z).encodedTxns.encodedTxnHeaders.Note[zb0009])
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskNote)) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID)) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGroup)) + 3 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedTxnHeaders.Lease) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLease)) + 6 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedTxnHeaders.RekeyTo) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo)) + 8 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedKeyregTxnFields.VotePK) + 7 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedKeyregTxnFields.SelectionPK) + 8 + msgp.ArrayHeaderSize
	for zb0010 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst {
		s += (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0010].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst)) + 8 + msgp.ArrayHeaderSize
	for zb0011 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteLast {
		s += (*z).encodedTxns.encodedKeyregTxnFields.VoteLast[zb0011].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) * (msgp.Uint64Size)) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskKeys)) + 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation)) + 6 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot) * (msgp.BoolSize)) + 5 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedKeyregTxnFields.CommitmentRoot) + 4 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedPaymentTxnFields.Receiver) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver)) + 4 + msgp.ArrayHeaderSize
	for zb0014 := range (*z).encodedTxns.encodedPaymentTxnFields.Amount {
		s += (*z).encodedTxns.encodedPaymentTxnFields.Amount[zb0014].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount)) + 6 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo)) + 5 + msgp.ArrayHeaderSize
	for zb0015 := range (*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset {
		s += (*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset[zb0015].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset)) + 2 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total) * (msgp.Uint64Size)) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal)) + 3 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals) * (msgp.Uint32Size)) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals)) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen)) + 3 + msgp.ArrayHeaderSize
	for zb0018 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName {
		s += msgp.StringPrefixSize + len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName[zb0018])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName)) + 3 + msgp.ArrayHeaderSize
	for zb0019 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName {
		s += msgp.StringPrefixSize + len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName[zb0019])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName)) + 3 + msgp.ArrayHeaderSize
	for zb0020 := range (*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL {
		s += msgp.StringPrefixSize + len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL[zb0020])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL)) + 3 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash)) + 2 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager)) + 2 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve)) + 2 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze)) + 2 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback)) + 5 + msgp.ArrayHeaderSize
	for zb0021 := range (*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset {
		s += (*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset[zb0021].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount)) + 5 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetSender) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender)) + 5 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetReceiver) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver)) + 7 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo)) + 5 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount)) + 5 + msgp.ArrayHeaderSize
	for zb0023 := range (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset {
		s += (*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset[zb0023].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen)) + 5 + msgp.ArrayHeaderSize
	for zb0024 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID {
		s += (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID[zb0024].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID)) + 5 + msgp.BytesPrefixSize + len((*z).encodedTxns.encodedApplicationCallTxnFields.OnCompletion) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion)) + 5 + msgp.ArrayHeaderSize
	for zb0025 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs {
		s += msgp.ArrayHeaderSize
		for zb0026 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] {
			s += msgp.BytesPrefixSize + len((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025][zb0026])
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs)) + 5 + msgp.ArrayHeaderSize
	for zb0027 := range (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts {
		s += msgp.ArrayHeaderSize
		for zb0028 := range (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] {
			s += (*z).encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027][zb0028].Msgsize()
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts)) + 5 + msgp.ArrayHeaderSize
	for zb0029 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps {
		s += msgp.ArrayHeaderSize
		for zb0030 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] {
			s += (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029][zb0030].Msgsize()
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps)) + 5 + msgp.ArrayHeaderSize
	for zb0031 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets {
		s += msgp.ArrayHeaderSize
		for zb0032 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] {
			s += (*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031][zb0032].Msgsize()
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice)) + 5 + msgp.ArrayHeaderSize
	for zb0037 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram {
		s += msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram[zb0037]))
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram)) + 5 + msgp.ArrayHeaderSize
	for zb0038 := range (*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram {
		s += msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram[zb0038]))
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages) * (msgp.Uint32Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages)) + 8 + msgp.ArrayHeaderSize
	for zb0040 := range (*z).encodedTxns.encodedCompactCertTxnFields.CertRound {
		s += (*z).encodedTxns.encodedCompactCertTxnFields.CertRound[zb0040].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound)) + 9 + msgp.ArrayHeaderSize
	for zb0041 := range (*z).encodedTxns.encodedCompactCertTxnFields.CertType {
		s += (*z).encodedTxns.encodedCompactCertTxnFields.CertType[zb0041].Msgsize()
	}
	s += 11 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertType)) + 6 + msgp.ArrayHeaderSize
	for zb0042 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit {
		s += (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit[zb0042].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit)) + 6 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight) * (msgp.Uint64Size)) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight)) + 6 + msgp.ArrayHeaderSize
	for zb0044 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs {
		s += msgp.ArrayHeaderSize
		for zb0045 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] {
			s += (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044][zb0045].Msgsize()
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash)) + 6 + msgp.ArrayHeaderSize
	for zb0047 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs {
		s += msgp.ArrayHeaderSize
		for zb0048 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] {
			s += (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047][zb0048].Msgsize()
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash)) + 6 + msgp.ArrayHeaderSize
	for zb0050 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals {
		s += msgp.MapHeaderSize
		if (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] != nil {
			for zb0051, zb0052 := range (*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] {
				_ = zb0051
				_ = zb0052
				s += 0 + msgp.Uint64Size + zb0052.Msgsize()
			}
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedSignedTxns) MsgIsZero() bool {
	return (len((*z).Sig) == 0) && (len((*z).BitmaskSig) == 0) && (len((*z).encodedMsigs.Version) == 0) && (len((*z).encodedMsigs.BitmaskVersion) == 0) && (len((*z).encodedMsigs.Threshold) == 0) && (len((*z).encodedMsigs.BitmaskThreshold) == 0) && (len((*z).encodedMsigs.Subsigs) == 0) && (len((*z).encodedMsigs.BitmaskSubsigs) == 0) && (len((*z).encodedLsigs.Logic) == 0) && (len((*z).encodedLsigs.BitmaskLogic) == 0) && (len((*z).encodedLsigs.LogicArgs) == 0) && (len((*z).encodedLsigs.BitmaskLogicArgs) == 0) && (len((*z).AuthAddr) == 0) && (len((*z).BitmaskAuthAddr) == 0) && (len((*z).encodedTxns.TxType) == 0) && (len((*z).encodedTxns.BitmaskTxType) == 0) && ((*z).encodedTxns.TxTypeOffset == 0) && (len((*z).encodedTxns.encodedTxnHeaders.Sender) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskSender) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.Fee) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskFee) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.FirstValid) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.LastValid) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.Note) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskNote) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskGroup) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.Lease) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskLease) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.RekeyTo) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.VotePK) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.SelectionPK) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.VoteLast) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskKeys) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.HasValidRoot) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.CommitmentRoot) == 0) && (len((*z).encodedTxns.encodedPaymentTxnFields.Receiver) == 0) && (len((*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver) == 0) && (len((*z).encodedTxns.encodedPaymentTxnFields.Amount) == 0) && (len((*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount) == 0) && (len((*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) == 0) && (len((*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.ConfigAsset) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback) == 0) && (len((*z).encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback) == 0) && (len((*z).encodedTxns.encodedAssetTransferTxnFields.XferAsset) == 0) && (len((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset) == 0) && (len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetAmount) == 0) && (len((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount) == 0) && (len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetSender) == 0) && (len((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender) == 0) && (len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetReceiver) == 0) && (len((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver) == 0) && (len((*z).encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo) == 0) && (len((*z).encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo) == 0) && (len((*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount) == 0) && (len((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount) == 0) && (len((*z).encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset) == 0) && (len((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset) == 0) && (len((*z).encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationID) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.OnCompletion) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.Accounts) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignApps) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.ForeignAssets) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumUint) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages) == 0) && (len((*z).encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.CertRound) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.CertType) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.BitmaskCertType) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals) == 0) && (len((*z).encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedTxnHeaders) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0005Len := uint32(16)
	var zb0005Mask uint32 /* 17 bits */
	if len((*z).Fee) == 0 {
		zb0005Len--
		zb0005Mask |= 0x2
	}
	if len((*z).BitmaskFee) == 0 {
		zb0005Len--
		zb0005Mask |= 0x4
	}
	if len((*z).FirstValid) == 0 {
		zb0005Len--
		zb0005Mask |= 0x8
	}
	if len((*z).BitmaskFirstValid) == 0 {
		zb0005Len--
		zb0005Mask |= 0x10
	}
	if len((*z).BitmaskGenesisID) == 0 {
		zb0005Len--
		zb0005Mask |= 0x20
	}
	if len((*z).BitmaskGroup) == 0 {
		zb0005Len--
		zb0005Mask |= 0x40
	}
	if len((*z).LastValid) == 0 {
		zb0005Len--
		zb0005Mask |= 0x80
	}
	if len((*z).BitmaskLastValid) == 0 {
		zb0005Len--
		zb0005Mask |= 0x100
	}
	if len((*z).Lease) == 0 {
		zb0005Len--
		zb0005Mask |= 0x200
	}
	if len((*z).BitmaskLease) == 0 {
		zb0005Len--
		zb0005Mask |= 0x400
	}
	if len((*z).Note) == 0 {
		zb0005Len--
		zb0005Mask |= 0x800
	}
	if len((*z).BitmaskNote) == 0 {
		zb0005Len--
		zb0005Mask |= 0x1000
	}
	if len((*z).RekeyTo) == 0 {
		zb0005Len--
		zb0005Mask |= 0x2000
	}
	if len((*z).BitmaskRekeyTo) == 0 {
		zb0005Len--
		zb0005Mask |= 0x4000
	}
	if len((*z).Sender) == 0 {
		zb0005Len--
		zb0005Mask |= 0x8000
	}
	if len((*z).BitmaskSender) == 0 {
		zb0005Len--
		zb0005Mask |= 0x10000
	}
	// variable map header, size zb0005Len
	o = msgp.AppendMapHeader(o, zb0005Len)
	if zb0005Len != 0 {
		if (zb0005Mask & 0x2) == 0 { // if not empty
			// string "fee"
			o = append(o, 0xa3, 0x66, 0x65, 0x65)
			if (*z).Fee == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Fee)))
			}
			for zb0001 := range (*z).Fee {
				o = (*z).Fee[zb0001].MarshalMsg(o)
			}
		}
		if (zb0005Mask & 0x4) == 0 { // if not empty
			// string "feebm"
			o = append(o, 0xa5, 0x66, 0x65, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskFee))
		}
		if (zb0005Mask & 0x8) == 0 { // if not empty
			// string "fv"
			o = append(o, 0xa2, 0x66, 0x76)
			if (*z).FirstValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).FirstValid)))
			}
			for zb0002 := range (*z).FirstValid {
				o = (*z).FirstValid[zb0002].MarshalMsg(o)
			}
		}
		if (zb0005Mask & 0x10) == 0 { // if not empty
			// string "fvbm"
			o = append(o, 0xa4, 0x66, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskFirstValid))
		}
		if (zb0005Mask & 0x20) == 0 { // if not empty
			// string "genbm"
			o = append(o, 0xa5, 0x67, 0x65, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskGenesisID))
		}
		if (zb0005Mask & 0x40) == 0 { // if not empty
			// string "grpbm"
			o = append(o, 0xa5, 0x67, 0x72, 0x70, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskGroup))
		}
		if (zb0005Mask & 0x80) == 0 { // if not empty
			// string "lv"
			o = append(o, 0xa2, 0x6c, 0x76)
			if (*z).LastValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).LastValid)))
			}
			for zb0003 := range (*z).LastValid {
				o = (*z).LastValid[zb0003].MarshalMsg(o)
			}
		}
		if (zb0005Mask & 0x100) == 0 { // if not empty
			// string "lvbm"
			o = append(o, 0xa4, 0x6c, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskLastValid))
		}
		if (zb0005Mask & 0x200) == 0 { // if not empty
			// string "lx"
			o = append(o, 0xa2, 0x6c, 0x78)
			o = msgp.AppendBytes(o, (*z).Lease)
		}
		if (zb0005Mask & 0x400) == 0 { // if not empty
			// string "lxbm"
			o = append(o, 0xa4, 0x6c, 0x78, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskLease))
		}
		if (zb0005Mask & 0x800) == 0 { // if not empty
			// string "note"
			o = append(o, 0xa4, 0x6e, 0x6f, 0x74, 0x65)
			if (*z).Note == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Note)))
			}
			for zb0004 := range (*z).Note {
				o = msgp.AppendBytes(o, (*z).Note[zb0004])
			}
		}
		if (zb0005Mask & 0x1000) == 0 { // if not empty
			// string "notebm"
			o = append(o, 0xa6, 0x6e, 0x6f, 0x74, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskNote))
		}
		if (zb0005Mask & 0x2000) == 0 { // if not empty
			// string "rekey"
			o = append(o, 0xa5, 0x72, 0x65, 0x6b, 0x65, 0x79)
			o = msgp.AppendBytes(o, (*z).RekeyTo)
		}
		if (zb0005Mask & 0x4000) == 0 { // if not empty
			// string "rekeybm"
			o = append(o, 0xa7, 0x72, 0x65, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskRekeyTo))
		}
		if (zb0005Mask & 0x8000) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o = msgp.AppendBytes(o, (*z).Sender)
		}
		if (zb0005Mask & 0x10000) == 0 { // if not empty
			// string "sndbm"
			o = append(o, 0xa5, 0x73, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskSender))
		}
	}
	return
}

func (_ *encodedTxnHeaders) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedTxnHeaders)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedTxnHeaders) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0005 int
	var zb0006 bool
	zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0005 > 0 {
			zb0005--
			var zb0007 int
			zb0007, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
			if zb0007 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0007), uint64(maxAddressBytes))
				return
			}
			(*z).Sender, bts, err = msgp.ReadBytesBytes(bts, (*z).Sender)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0008 []byte
				var zb0009 int
				zb0009, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSender")
					return
				}
				if zb0009 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0009), uint64(maxBitmaskSize))
					return
				}
				zb0008, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSender))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSender")
					return
				}
				(*z).BitmaskSender = bitmask(zb0008)
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0010 int
			var zb0011 bool
			zb0010, zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0010 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0010), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0011 {
				(*z).Fee = nil
			} else if (*z).Fee != nil && cap((*z).Fee) >= zb0010 {
				(*z).Fee = ((*z).Fee)[:zb0010]
			} else {
				(*z).Fee = make([]basics.MicroAlgos, zb0010)
			}
			for zb0001 := range (*z).Fee {
				bts, err = (*z).Fee[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Fee", zb0001)
					return
				}
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0012 []byte
				var zb0013 int
				zb0013, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFee")
					return
				}
				if zb0013 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(maxBitmaskSize))
					return
				}
				zb0012, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFee))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFee")
					return
				}
				(*z).BitmaskFee = bitmask(zb0012)
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0014 int
			var zb0015 bool
			zb0014, zb0015, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0014 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0014), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0015 {
				(*z).FirstValid = nil
			} else if (*z).FirstValid != nil && cap((*z).FirstValid) >= zb0014 {
				(*z).FirstValid = ((*z).FirstValid)[:zb0014]
			} else {
				(*z).FirstValid = make([]basics.Round, zb0014)
			}
			for zb0002 := range (*z).FirstValid {
				bts, err = (*z).FirstValid[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "FirstValid", zb0002)
					return
				}
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0016 []byte
				var zb0017 int
				zb0017, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFirstValid")
					return
				}
				if zb0017 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0017), uint64(maxBitmaskSize))
					return
				}
				zb0016, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFirstValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFirstValid")
					return
				}
				(*z).BitmaskFirstValid = bitmask(zb0016)
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0018 int
			var zb0019 bool
			zb0018, zb0019, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0018 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0018), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0019 {
				(*z).LastValid = nil
			} else if (*z).LastValid != nil && cap((*z).LastValid) >= zb0018 {
				(*z).LastValid = ((*z).LastValid)[:zb0018]
			} else {
				(*z).LastValid = make([]basics.Round, zb0018)
			}
			for zb0003 := range (*z).LastValid {
				bts, err = (*z).LastValid[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LastValid", zb0003)
					return
				}
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0020 []byte
				var zb0021 int
				zb0021, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLastValid")
					return
				}
				if zb0021 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0021), uint64(maxBitmaskSize))
					return
				}
				zb0020, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLastValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLastValid")
					return
				}
				(*z).BitmaskLastValid = bitmask(zb0020)
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0022 int
			var zb0023 bool
			zb0022, zb0023, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0022 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0022), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0023 {
				(*z).Note = nil
			} else if (*z).Note != nil && cap((*z).Note) >= zb0022 {
				(*z).Note = ((*z).Note)[:zb0022]
			} else {
				(*z).Note = make([][]byte, zb0022)
			}
			for zb0004 := range (*z).Note {
				var zb0024 int
				zb0024, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Note", zb0004)
					return
				}
				if zb0024 > config.MaxTxnNoteBytes {
					err = msgp.ErrOverflow(uint64(zb0024), uint64(config.MaxTxnNoteBytes))
					return
				}
				(*z).Note[zb0004], bts, err = msgp.ReadBytesBytes(bts, (*z).Note[zb0004])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Note", zb0004)
					return
				}
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0025 []byte
				var zb0026 int
				zb0026, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNote")
					return
				}
				if zb0026 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0026), uint64(maxBitmaskSize))
					return
				}
				zb0025, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskNote))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNote")
					return
				}
				(*z).BitmaskNote = bitmask(zb0025)
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0027 []byte
				var zb0028 int
				zb0028, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisID")
					return
				}
				if zb0028 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0028), uint64(maxBitmaskSize))
					return
				}
				zb0027, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskGenesisID))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisID")
					return
				}
				(*z).BitmaskGenesisID = bitmask(zb0027)
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0029 []byte
				var zb0030 int
				zb0030, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGroup")
					return
				}
				if zb0030 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0030), uint64(maxBitmaskSize))
					return
				}
				zb0029, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskGroup))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGroup")
					return
				}
				(*z).BitmaskGroup = bitmask(zb0029)
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0031 int
			zb0031, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
			if zb0031 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0031), uint64(maxAddressBytes))
				return
			}
			(*z).Lease, bts, err = msgp.ReadBytesBytes(bts, (*z).Lease)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0032 []byte
				var zb0033 int
				zb0033, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLease")
					return
				}
				if zb0033 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0033), uint64(maxBitmaskSize))
					return
				}
				zb0032, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLease))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLease")
					return
				}
				(*z).BitmaskLease = bitmask(zb0032)
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0034 int
			zb0034, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
			if zb0034 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0034), uint64(maxAddressBytes))
				return
			}
			(*z).RekeyTo, bts, err = msgp.ReadBytesBytes(bts, (*z).RekeyTo)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
		}
		if zb0005 > 0 {
			zb0005--
			{
				var zb0035 []byte
				var zb0036 int
				zb0036, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskRekeyTo")
					return
				}
				if zb0036 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0036), uint64(maxBitmaskSize))
					return
				}
				zb0035, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskRekeyTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskRekeyTo")
					return
				}
				(*z).BitmaskRekeyTo = bitmask(zb0035)
			}
		}
		if zb0005 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0005)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0006 {
			(*z) = encodedTxnHeaders{}
		}
		for zb0005 > 0 {
			zb0005--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				var zb0037 int
				zb0037, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				if zb0037 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0037), uint64(maxAddressBytes))
					return
				}
				(*z).Sender, bts, err = msgp.ReadBytesBytes(bts, (*z).Sender)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "sndbm":
				{
					var zb0038 []byte
					var zb0039 int
					zb0039, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSender")
						return
					}
					if zb0039 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0039), uint64(maxBitmaskSize))
						return
					}
					zb0038, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSender))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSender")
						return
					}
					(*z).BitmaskSender = bitmask(zb0038)
				}
			case "fee":
				var zb0040 int
				var zb0041 bool
				zb0040, zb0041, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0040 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0040), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0041 {
					(*z).Fee = nil
				} else if (*z).Fee != nil && cap((*z).Fee) >= zb0040 {
					(*z).Fee = ((*z).Fee)[:zb0040]
				} else {
					(*z).Fee = make([]basics.MicroAlgos, zb0040)
				}
				for zb0001 := range (*z).Fee {
					bts, err = (*z).Fee[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Fee", zb0001)
						return
					}
				}
			case "feebm":
				{
					var zb0042 []byte
					var zb0043 int
					zb0043, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFee")
						return
					}
					if zb0043 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0043), uint64(maxBitmaskSize))
						return
					}
					zb0042, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFee))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFee")
						return
					}
					(*z).BitmaskFee = bitmask(zb0042)
				}
			case "fv":
				var zb0044 int
				var zb0045 bool
				zb0044, zb0045, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0044 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0044), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0045 {
					(*z).FirstValid = nil
				} else if (*z).FirstValid != nil && cap((*z).FirstValid) >= zb0044 {
					(*z).FirstValid = ((*z).FirstValid)[:zb0044]
				} else {
					(*z).FirstValid = make([]basics.Round, zb0044)
				}
				for zb0002 := range (*z).FirstValid {
					bts, err = (*z).FirstValid[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "FirstValid", zb0002)
						return
					}
				}
			case "fvbm":
				{
					var zb0046 []byte
					var zb0047 int
					zb0047, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFirstValid")
						return
					}
					if zb0047 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0047), uint64(maxBitmaskSize))
						return
					}
					zb0046, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFirstValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFirstValid")
						return
					}
					(*z).BitmaskFirstValid = bitmask(zb0046)
				}
			case "lv":
				var zb0048 int
				var zb0049 bool
				zb0048, zb0049, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0048 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0048), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0049 {
					(*z).LastValid = nil
				} else if (*z).LastValid != nil && cap((*z).LastValid) >= zb0048 {
					(*z).LastValid = ((*z).LastValid)[:zb0048]
				} else {
					(*z).LastValid = make([]basics.Round, zb0048)
				}
				for zb0003 := range (*z).LastValid {
					bts, err = (*z).LastValid[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastValid", zb0003)
						return
					}
				}
			case "lvbm":
				{
					var zb0050 []byte
					var zb0051 int
					zb0051, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLastValid")
						return
					}
					if zb0051 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0051), uint64(maxBitmaskSize))
						return
					}
					zb0050, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLastValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLastValid")
						return
					}
					(*z).BitmaskLastValid = bitmask(zb0050)
				}
			case "note":
				var zb0052 int
				var zb0053 bool
				zb0052, zb0053, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0052 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0052), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0053 {
					(*z).Note = nil
				} else if (*z).Note != nil && cap((*z).Note) >= zb0052 {
					(*z).Note = ((*z).Note)[:zb0052]
				} else {
					(*z).Note = make([][]byte, zb0052)
				}
				for zb0004 := range (*z).Note {
					var zb0054 int
					zb0054, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "Note", zb0004)
						return
					}
					if zb0054 > config.MaxTxnNoteBytes {
						err = msgp.ErrOverflow(uint64(zb0054), uint64(config.MaxTxnNoteBytes))
						return
					}
					(*z).Note[zb0004], bts, err = msgp.ReadBytesBytes(bts, (*z).Note[zb0004])
					if err != nil {
						err = msgp.WrapError(err, "Note", zb0004)
						return
					}
				}
			case "notebm":
				{
					var zb0055 []byte
					var zb0056 int
					zb0056, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNote")
						return
					}
					if zb0056 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0056), uint64(maxBitmaskSize))
						return
					}
					zb0055, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskNote))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNote")
						return
					}
					(*z).BitmaskNote = bitmask(zb0055)
				}
			case "genbm":
				{
					var zb0057 []byte
					var zb0058 int
					zb0058, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisID")
						return
					}
					if zb0058 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0058), uint64(maxBitmaskSize))
						return
					}
					zb0057, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskGenesisID))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisID")
						return
					}
					(*z).BitmaskGenesisID = bitmask(zb0057)
				}
			case "grpbm":
				{
					var zb0059 []byte
					var zb0060 int
					zb0060, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGroup")
						return
					}
					if zb0060 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0060), uint64(maxBitmaskSize))
						return
					}
					zb0059, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskGroup))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGroup")
						return
					}
					(*z).BitmaskGroup = bitmask(zb0059)
				}
			case "lx":
				var zb0061 int
				zb0061, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
				if zb0061 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0061), uint64(maxAddressBytes))
					return
				}
				(*z).Lease, bts, err = msgp.ReadBytesBytes(bts, (*z).Lease)
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
			case "lxbm":
				{
					var zb0062 []byte
					var zb0063 int
					zb0063, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLease")
						return
					}
					if zb0063 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0063), uint64(maxBitmaskSize))
						return
					}
					zb0062, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLease))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLease")
						return
					}
					(*z).BitmaskLease = bitmask(zb0062)
				}
			case "rekey":
				var zb0064 int
				zb0064, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
				if zb0064 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0064), uint64(maxAddressBytes))
					return
				}
				(*z).RekeyTo, bts, err = msgp.ReadBytesBytes(bts, (*z).RekeyTo)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
			case "rekeybm":
				{
					var zb0065 []byte
					var zb0066 int
					zb0066, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskRekeyTo")
						return
					}
					if zb0066 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0066), uint64(maxBitmaskSize))
						return
					}
					zb0065, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskRekeyTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskRekeyTo")
						return
					}
					(*z).BitmaskRekeyTo = bitmask(zb0065)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedTxnHeaders) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedTxnHeaders)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedTxnHeaders) Msgsize() (s int) {
	s = 3 + 4 + msgp.BytesPrefixSize + len((*z).Sender) + 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskSender)) + 4 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Fee {
		s += (*z).Fee[zb0001].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskFee)) + 3 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).FirstValid {
		s += (*z).FirstValid[zb0002].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskFirstValid)) + 3 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).LastValid {
		s += (*z).LastValid[zb0003].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskLastValid)) + 5 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).Note {
		s += msgp.BytesPrefixSize + len((*z).Note[zb0004])
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskNote)) + 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskGenesisID)) + 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskGroup)) + 3 + msgp.BytesPrefixSize + len((*z).Lease) + 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskLease)) + 6 + msgp.BytesPrefixSize + len((*z).RekeyTo) + 8 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskRekeyTo))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedTxnHeaders) MsgIsZero() bool {
	return (len((*z).Sender) == 0) && (len((*z).BitmaskSender) == 0) && (len((*z).Fee) == 0) && (len((*z).BitmaskFee) == 0) && (len((*z).FirstValid) == 0) && (len((*z).BitmaskFirstValid) == 0) && (len((*z).LastValid) == 0) && (len((*z).BitmaskLastValid) == 0) && (len((*z).Note) == 0) && (len((*z).BitmaskNote) == 0) && (len((*z).BitmaskGenesisID) == 0) && (len((*z).BitmaskGroup) == 0) && (len((*z).Lease) == 0) && (len((*z).BitmaskLease) == 0) && (len((*z).RekeyTo) == 0) && (len((*z).BitmaskRekeyTo) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedTxns) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0048Len := uint32(118)
	var zb0048Mask [3]uint64 /* 129 bits */
	if len((*z).encodedAssetTransferTxnFields.AssetAmount) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x800
	}
	if len((*z).encodedAssetTransferTxnFields.BitmaskAssetAmount) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x1000
	}
	if len((*z).encodedAssetTransferTxnFields.AssetCloseTo) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x2000
	}
	if len((*z).encodedAssetTransferTxnFields.BitmaskAssetCloseTo) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x4000
	}
	if len((*z).encodedAssetFreezeTxnFields.BitmaskAssetFrozen) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x8000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x10000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x20000
	}
	if len((*z).encodedPaymentTxnFields.Amount) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x40000
	}
	if len((*z).encodedPaymentTxnFields.BitmaskAmount) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x80000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x100000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x200000
	}
	if len((*z).encodedApplicationCallTxnFields.ApplicationArgs) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x400000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskApplicationArgs) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x800000
	}
	if len((*z).encodedApplicationCallTxnFields.OnCompletion) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x1000000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskOnCompletion) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x2000000
	}
	if len((*z).encodedApplicationCallTxnFields.ApprovalProgram) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x4000000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskApprovalProgram) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x8000000
	}
	if len((*z).encodedApplicationCallTxnFields.ForeignAssets) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x10000000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskForeignAssets) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x20000000
	}
	if len((*z).encodedApplicationCallTxnFields.Accounts) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x40000000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskAccounts) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x80000000
	}
	if len((*z).encodedApplicationCallTxnFields.ExtraProgramPages) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x100000000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskExtraProgramPages) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x200000000
	}
	if len((*z).encodedApplicationCallTxnFields.ForeignApps) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x400000000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskForeignApps) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x800000000
	}
	if len((*z).encodedApplicationCallTxnFields.ApplicationID) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x1000000000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskApplicationID) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x2000000000
	}
	if len((*z).encodedApplicationCallTxnFields.ClearStateProgram) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x4000000000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskClearStateProgram) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x8000000000
	}
	if len((*z).encodedAssetTransferTxnFields.AssetReceiver) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x10000000000
	}
	if len((*z).encodedAssetTransferTxnFields.BitmaskAssetReceiver) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x20000000000
	}
	if len((*z).encodedAssetTransferTxnFields.AssetSender) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x40000000000
	}
	if len((*z).encodedAssetTransferTxnFields.BitmaskAssetSender) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x80000000000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.URL) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x100000000000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x200000000000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Clawback) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x400000000000
	}
	if len((*z).encodedAssetConfigTxnFields.ConfigAsset) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x800000000000
	}
	if len((*z).encodedAssetConfigTxnFields.BitmaskConfigAsset) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x1000000000000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x2000000000000
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.PartProofs) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x4000000000000
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x8000000000000
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartHash) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x10000000000000
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x20000000000000
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.SigProofs) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x40000000000000
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x80000000000000
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x100000000000000
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x200000000000000
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.SigCommit) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x400000000000000
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x800000000000000
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.Reveals) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x1000000000000000
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskReveals) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x2000000000000000
	}
	if len((*z).encodedCompactCertTxnFields.CertRound) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x4000000000000000
	}
	if len((*z).encodedCompactCertTxnFields.BitmaskCertRound) == 0 {
		zb0048Len--
		zb0048Mask[0] |= 0x8000000000000000
	}
	if len((*z).encodedCompactCertTxnFields.CertType) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x1
	}
	if len((*z).encodedCompactCertTxnFields.BitmaskCertType) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x2
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.SignedWeight) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x4
	}
	if len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x8
	}
	if len((*z).encodedPaymentTxnFields.CloseRemainderTo) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x10
	}
	if len((*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x20
	}
	if len((*z).encodedKeyregTxnFields.CommitmentRoot) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x40
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x80
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x100
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x200
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Freeze) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x400
	}
	if len((*z).encodedAssetFreezeTxnFields.FreezeAccount) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x800
	}
	if len((*z).encodedAssetFreezeTxnFields.BitmaskFreezeAccount) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x1000
	}
	if len((*z).encodedAssetFreezeTxnFields.FreezeAsset) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x2000
	}
	if len((*z).encodedAssetFreezeTxnFields.BitmaskFreezeAsset) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x4000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x8000
	}
	if len((*z).encodedTxnHeaders.Fee) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x10000
	}
	if len((*z).encodedTxnHeaders.BitmaskFee) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x20000
	}
	if len((*z).encodedTxnHeaders.FirstValid) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x40000
	}
	if len((*z).encodedTxnHeaders.BitmaskFirstValid) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x80000
	}
	if len((*z).encodedTxnHeaders.BitmaskGenesisID) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x100000
	}
	if len((*z).encodedApplicationCallTxnFields.GlobalNumByteSlice) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x200000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x400000
	}
	if len((*z).encodedApplicationCallTxnFields.GlobalNumUint) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x800000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskGlobalNumUint) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x1000000
	}
	if len((*z).encodedTxnHeaders.BitmaskGroup) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x2000000
	}
	if len((*z).encodedApplicationCallTxnFields.LocalNumByteSlice) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x4000000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x8000000
	}
	if len((*z).encodedApplicationCallTxnFields.LocalNumUint) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x10000000
	}
	if len((*z).encodedApplicationCallTxnFields.BitmaskLocalNumUint) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x20000000
	}
	if len((*z).encodedTxnHeaders.LastValid) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x40000000
	}
	if len((*z).encodedTxnHeaders.BitmaskLastValid) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x80000000
	}
	if len((*z).encodedTxnHeaders.Lease) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x100000000
	}
	if len((*z).encodedTxnHeaders.BitmaskLease) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x200000000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Manager) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x400000000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x800000000
	}
	if len((*z).encodedKeyregTxnFields.BitmaskNonparticipation) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x1000000000
	}
	if len((*z).encodedTxnHeaders.Note) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x2000000000
	}
	if len((*z).encodedTxnHeaders.BitmaskNote) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x4000000000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Reserve) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x8000000000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x10000000000
	}
	if len((*z).encodedPaymentTxnFields.Receiver) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x20000000000
	}
	if len((*z).encodedPaymentTxnFields.BitmaskReceiver) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x40000000000
	}
	if len((*z).encodedTxnHeaders.RekeyTo) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x80000000000
	}
	if len((*z).encodedTxnHeaders.BitmaskRekeyTo) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x100000000000
	}
	if len((*z).encodedKeyregTxnFields.SelectionPK) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x200000000000
	}
	if len((*z).encodedTxnHeaders.Sender) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x400000000000
	}
	if len((*z).encodedTxnHeaders.BitmaskSender) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x800000000000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Total) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x1000000000000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x2000000000000
	}
	if len((*z).TxType) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x4000000000000
	}
	if len((*z).BitmaskTxType) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x8000000000000
	}
	if (*z).TxTypeOffset == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x10000000000000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x20000000000000
	}
	if len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x40000000000000
	}
	if len((*z).encodedKeyregTxnFields.HasValidRoot) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x80000000000000
	}
	if len((*z).encodedKeyregTxnFields.VoteFirst) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x100000000000000
	}
	if len((*z).encodedKeyregTxnFields.BitmaskVoteFirst) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x200000000000000
	}
	if len((*z).encodedKeyregTxnFields.BitmaskKeys) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x400000000000000
	}
	if len((*z).encodedKeyregTxnFields.VoteKeyDilution) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x800000000000000
	}
	if len((*z).encodedKeyregTxnFields.VotePK) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x1000000000000000
	}
	if len((*z).encodedKeyregTxnFields.VoteLast) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x2000000000000000
	}
	if len((*z).encodedKeyregTxnFields.BitmaskVoteLast) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x4000000000000000
	}
	if len((*z).encodedAssetTransferTxnFields.XferAsset) == 0 {
		zb0048Len--
		zb0048Mask[1] |= 0x8000000000000000
	}
	if len((*z).encodedAssetTransferTxnFields.BitmaskXferAsset) == 0 {
		zb0048Len--
		zb0048Mask[2] |= 0x1
	}
	// variable map header, size zb0048Len
	o = msgp.AppendMapHeader(o, zb0048Len)
	if zb0048Len != 0 {
		if (zb0048Mask[0] & 0x800) == 0 { // if not empty
			// string "aamt"
			o = append(o, 0xa4, 0x61, 0x61, 0x6d, 0x74)
			if (*z).encodedAssetTransferTxnFields.AssetAmount == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetTransferTxnFields.AssetAmount)))
			}
			for zb0017 := range (*z).encodedAssetTransferTxnFields.AssetAmount {
				o = msgp.AppendUint64(o, (*z).encodedAssetTransferTxnFields.AssetAmount[zb0017])
			}
		}
		if (zb0048Mask[0] & 0x1000) == 0 { // if not empty
			// string "aamtbm"
			o = append(o, 0xa6, 0x61, 0x61, 0x6d, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetTransferTxnFields.BitmaskAssetAmount))
		}
		if (zb0048Mask[0] & 0x2000) == 0 { // if not empty
			// string "aclose"
			o = append(o, 0xa6, 0x61, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			o = msgp.AppendBytes(o, (*z).encodedAssetTransferTxnFields.AssetCloseTo)
		}
		if (zb0048Mask[0] & 0x4000) == 0 { // if not empty
			// string "aclosebm"
			o = append(o, 0xa8, 0x61, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetTransferTxnFields.BitmaskAssetCloseTo))
		}
		if (zb0048Mask[0] & 0x8000) == 0 { // if not empty
			// string "afrzbm"
			o = append(o, 0xa6, 0x61, 0x66, 0x72, 0x7a, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetFreezeTxnFields.BitmaskAssetFrozen))
		}
		if (zb0048Mask[0] & 0x10000) == 0 { // if not empty
			// string "am"
			o = append(o, 0xa2, 0x61, 0x6d)
			o = msgp.AppendBytes(o, (*z).encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash)
		}
		if (zb0048Mask[0] & 0x20000) == 0 { // if not empty
			// string "ambm"
			o = append(o, 0xa4, 0x61, 0x6d, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash))
		}
		if (zb0048Mask[0] & 0x40000) == 0 { // if not empty
			// string "amt"
			o = append(o, 0xa3, 0x61, 0x6d, 0x74)
			if (*z).encodedPaymentTxnFields.Amount == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedPaymentTxnFields.Amount)))
			}
			for zb0009 := range (*z).encodedPaymentTxnFields.Amount {
				o = (*z).encodedPaymentTxnFields.Amount[zb0009].MarshalMsg(o)
			}
		}
		if (zb0048Mask[0] & 0x80000) == 0 { // if not empty
			// string "amtbm"
			o = append(o, 0xa5, 0x61, 0x6d, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedPaymentTxnFields.BitmaskAmount))
		}
		if (zb0048Mask[0] & 0x100000) == 0 { // if not empty
			// string "an"
			o = append(o, 0xa2, 0x61, 0x6e)
			if (*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName)))
			}
			for zb0014 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName {
				o = msgp.AppendString(o, (*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName[zb0014])
			}
		}
		if (zb0048Mask[0] & 0x200000) == 0 { // if not empty
			// string "anbm"
			o = append(o, 0xa4, 0x61, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName))
		}
		if (zb0048Mask[0] & 0x400000) == 0 { // if not empty
			// string "apaa"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x61)
			if (*z).encodedApplicationCallTxnFields.ApplicationArgs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.ApplicationArgs)))
			}
			for zb0020 := range (*z).encodedApplicationCallTxnFields.ApplicationArgs {
				if (*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020])))
				}
				for zb0021 := range (*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] {
					o = msgp.AppendBytes(o, (*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020][zb0021])
				}
			}
		}
		if (zb0048Mask[0] & 0x800000) == 0 { // if not empty
			// string "apaabm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x61, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskApplicationArgs))
		}
		if (zb0048Mask[0] & 0x1000000) == 0 { // if not empty
			// string "apan"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x6e)
			o = msgp.AppendBytes(o, (*z).encodedApplicationCallTxnFields.OnCompletion)
		}
		if (zb0048Mask[0] & 0x2000000) == 0 { // if not empty
			// string "apanbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskOnCompletion))
		}
		if (zb0048Mask[0] & 0x4000000) == 0 { // if not empty
			// string "apap"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x70)
			if (*z).encodedApplicationCallTxnFields.ApprovalProgram == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.ApprovalProgram)))
			}
			for zb0032 := range (*z).encodedApplicationCallTxnFields.ApprovalProgram {
				o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.ApprovalProgram[zb0032]))
			}
		}
		if (zb0048Mask[0] & 0x8000000) == 0 { // if not empty
			// string "apapbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x70, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskApprovalProgram))
		}
		if (zb0048Mask[0] & 0x10000000) == 0 { // if not empty
			// string "apas"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x73)
			if (*z).encodedApplicationCallTxnFields.ForeignAssets == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.ForeignAssets)))
			}
			for zb0026 := range (*z).encodedApplicationCallTxnFields.ForeignAssets {
				if (*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026])))
				}
				for zb0027 := range (*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] {
					o = (*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026][zb0027].MarshalMsg(o)
				}
			}
		}
		if (zb0048Mask[0] & 0x20000000) == 0 { // if not empty
			// string "apasbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskForeignAssets))
		}
		if (zb0048Mask[0] & 0x40000000) == 0 { // if not empty
			// string "apat"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x74)
			if (*z).encodedApplicationCallTxnFields.Accounts == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.Accounts)))
			}
			for zb0022 := range (*z).encodedApplicationCallTxnFields.Accounts {
				if (*z).encodedApplicationCallTxnFields.Accounts[zb0022] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.Accounts[zb0022])))
				}
				for zb0023 := range (*z).encodedApplicationCallTxnFields.Accounts[zb0022] {
					o = (*z).encodedApplicationCallTxnFields.Accounts[zb0022][zb0023].MarshalMsg(o)
				}
			}
		}
		if (zb0048Mask[0] & 0x80000000) == 0 { // if not empty
			// string "apatbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskAccounts))
		}
		if (zb0048Mask[0] & 0x100000000) == 0 { // if not empty
			// string "apep"
			o = append(o, 0xa4, 0x61, 0x70, 0x65, 0x70)
			if (*z).encodedApplicationCallTxnFields.ExtraProgramPages == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.ExtraProgramPages)))
			}
			for zb0034 := range (*z).encodedApplicationCallTxnFields.ExtraProgramPages {
				o = msgp.AppendUint32(o, (*z).encodedApplicationCallTxnFields.ExtraProgramPages[zb0034])
			}
		}
		if (zb0048Mask[0] & 0x200000000) == 0 { // if not empty
			// string "apepbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x65, 0x70, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskExtraProgramPages))
		}
		if (zb0048Mask[0] & 0x400000000) == 0 { // if not empty
			// string "apfa"
			o = append(o, 0xa4, 0x61, 0x70, 0x66, 0x61)
			if (*z).encodedApplicationCallTxnFields.ForeignApps == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.ForeignApps)))
			}
			for zb0024 := range (*z).encodedApplicationCallTxnFields.ForeignApps {
				if (*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.ForeignApps[zb0024])))
				}
				for zb0025 := range (*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] {
					o = (*z).encodedApplicationCallTxnFields.ForeignApps[zb0024][zb0025].MarshalMsg(o)
				}
			}
		}
		if (zb0048Mask[0] & 0x800000000) == 0 { // if not empty
			// string "apfabm"
			o = append(o, 0xa6, 0x61, 0x70, 0x66, 0x61, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskForeignApps))
		}
		if (zb0048Mask[0] & 0x1000000000) == 0 { // if not empty
			// string "apid"
			o = append(o, 0xa4, 0x61, 0x70, 0x69, 0x64)
			if (*z).encodedApplicationCallTxnFields.ApplicationID == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.ApplicationID)))
			}
			for zb0019 := range (*z).encodedApplicationCallTxnFields.ApplicationID {
				o = (*z).encodedApplicationCallTxnFields.ApplicationID[zb0019].MarshalMsg(o)
			}
		}
		if (zb0048Mask[0] & 0x2000000000) == 0 { // if not empty
			// string "apidbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskApplicationID))
		}
		if (zb0048Mask[0] & 0x4000000000) == 0 { // if not empty
			// string "apsu"
			o = append(o, 0xa4, 0x61, 0x70, 0x73, 0x75)
			if (*z).encodedApplicationCallTxnFields.ClearStateProgram == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.ClearStateProgram)))
			}
			for zb0033 := range (*z).encodedApplicationCallTxnFields.ClearStateProgram {
				o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.ClearStateProgram[zb0033]))
			}
		}
		if (zb0048Mask[0] & 0x8000000000) == 0 { // if not empty
			// string "apsubm"
			o = append(o, 0xa6, 0x61, 0x70, 0x73, 0x75, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskClearStateProgram))
		}
		if (zb0048Mask[0] & 0x10000000000) == 0 { // if not empty
			// string "arcv"
			o = append(o, 0xa4, 0x61, 0x72, 0x63, 0x76)
			o = msgp.AppendBytes(o, (*z).encodedAssetTransferTxnFields.AssetReceiver)
		}
		if (zb0048Mask[0] & 0x20000000000) == 0 { // if not empty
			// string "arcvbm"
			o = append(o, 0xa6, 0x61, 0x72, 0x63, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetTransferTxnFields.BitmaskAssetReceiver))
		}
		if (zb0048Mask[0] & 0x40000000000) == 0 { // if not empty
			// string "asnd"
			o = append(o, 0xa4, 0x61, 0x73, 0x6e, 0x64)
			o = msgp.AppendBytes(o, (*z).encodedAssetTransferTxnFields.AssetSender)
		}
		if (zb0048Mask[0] & 0x80000000000) == 0 { // if not empty
			// string "asndbm"
			o = append(o, 0xa6, 0x61, 0x73, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetTransferTxnFields.BitmaskAssetSender))
		}
		if (zb0048Mask[0] & 0x100000000000) == 0 { // if not empty
			// string "au"
			o = append(o, 0xa2, 0x61, 0x75)
			if (*z).encodedAssetConfigTxnFields.encodedAssetParams.URL == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetConfigTxnFields.encodedAssetParams.URL)))
			}
			for zb0015 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.URL {
				o = msgp.AppendString(o, (*z).encodedAssetConfigTxnFields.encodedAssetParams.URL[zb0015])
			}
		}
		if (zb0048Mask[0] & 0x200000000000) == 0 { // if not empty
			// string "aubm"
			o = append(o, 0xa4, 0x61, 0x75, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL))
		}
		if (zb0048Mask[0] & 0x400000000000) == 0 { // if not empty
			// string "c"
			o = append(o, 0xa1, 0x63)
			o = msgp.AppendBytes(o, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Clawback)
		}
		if (zb0048Mask[0] & 0x800000000000) == 0 { // if not empty
			// string "caid"
			o = append(o, 0xa4, 0x63, 0x61, 0x69, 0x64)
			if (*z).encodedAssetConfigTxnFields.ConfigAsset == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetConfigTxnFields.ConfigAsset)))
			}
			for zb0010 := range (*z).encodedAssetConfigTxnFields.ConfigAsset {
				o = (*z).encodedAssetConfigTxnFields.ConfigAsset[zb0010].MarshalMsg(o)
			}
		}
		if (zb0048Mask[0] & 0x1000000000000) == 0 { // if not empty
			// string "caidbm"
			o = append(o, 0xa6, 0x63, 0x61, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetConfigTxnFields.BitmaskConfigAsset))
		}
		if (zb0048Mask[0] & 0x2000000000000) == 0 { // if not empty
			// string "cbm"
			o = append(o, 0xa3, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback))
		}
		if (zb0048Mask[0] & 0x4000000000000) == 0 { // if not empty
			// string "certP"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x50)
			if (*z).encodedCompactCertTxnFields.encodedCert.PartProofs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCompactCertTxnFields.encodedCert.PartProofs)))
			}
			for zb0042 := range (*z).encodedCompactCertTxnFields.encodedCert.PartProofs {
				if (*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042])))
				}
				for zb0043 := range (*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] {
					o = (*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042][zb0043].MarshalMsg(o)
				}
			}
		}
		if (zb0048Mask[0] & 0x8000000000000) == 0 { // if not empty
			// string "certPH"
			o = append(o, 0xa6, 0x63, 0x65, 0x72, 0x74, 0x50, 0x48)
			if (*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes)))
			}
			for zb0044 := range (*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes {
				o = msgp.AppendUint64(o, (*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes[zb0044])
			}
		}
		if (zb0048Mask[0] & 0x10000000000000) == 0 { // if not empty
			// string "certPHbm"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x50, 0x48, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartHash))
		}
		if (zb0048Mask[0] & 0x20000000000000) == 0 { // if not empty
			// string "certPbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x50, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs))
		}
		if (zb0048Mask[0] & 0x40000000000000) == 0 { // if not empty
			// string "certS"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x53)
			if (*z).encodedCompactCertTxnFields.encodedCert.SigProofs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCompactCertTxnFields.encodedCert.SigProofs)))
			}
			for zb0039 := range (*z).encodedCompactCertTxnFields.encodedCert.SigProofs {
				if (*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039])))
				}
				for zb0040 := range (*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] {
					o = (*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039][zb0040].MarshalMsg(o)
				}
			}
		}
		if (zb0048Mask[0] & 0x80000000000000) == 0 { // if not empty
			// string "certSH"
			o = append(o, 0xa6, 0x63, 0x65, 0x72, 0x74, 0x53, 0x48)
			if (*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes)))
			}
			for zb0041 := range (*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes {
				o = msgp.AppendUint64(o, (*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes[zb0041])
			}
		}
		if (zb0048Mask[0] & 0x100000000000000) == 0 { // if not empty
			// string "certSHbm"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x53, 0x48, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash))
		}
		if (zb0048Mask[0] & 0x200000000000000) == 0 { // if not empty
			// string "certSbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x53, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs))
		}
		if (zb0048Mask[0] & 0x400000000000000) == 0 { // if not empty
			// string "certc"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x63)
			if (*z).encodedCompactCertTxnFields.encodedCert.SigCommit == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCompactCertTxnFields.encodedCert.SigCommit)))
			}
			for zb0037 := range (*z).encodedCompactCertTxnFields.encodedCert.SigCommit {
				o = (*z).encodedCompactCertTxnFields.encodedCert.SigCommit[zb0037].MarshalMsg(o)
			}
		}
		if (zb0048Mask[0] & 0x800000000000000) == 0 { // if not empty
			// string "certcbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit))
		}
		if (zb0048Mask[0] & 0x1000000000000000) == 0 { // if not empty
			// string "certr"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x72)
			if (*z).encodedCompactCertTxnFields.encodedCert.Reveals == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCompactCertTxnFields.encodedCert.Reveals)))
			}
			for zb0045 := range (*z).encodedCompactCertTxnFields.encodedCert.Reveals {
				if (*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendMapHeader(o, uint32(len((*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045])))
				}
				zb0046_keys := make([]uint64, 0, len((*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045]))
				for zb0046 := range (*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045] {
					zb0046_keys = append(zb0046_keys, zb0046)
				}
				sort.Sort(SortUint64(zb0046_keys))
				for _, zb0046 := range zb0046_keys {
					zb0047 := (*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045][zb0046]
					_ = zb0047
					o = msgp.AppendUint64(o, zb0046)
					o = zb0047.MarshalMsg(o)
				}
			}
		}
		if (zb0048Mask[0] & 0x2000000000000000) == 0 { // if not empty
			// string "certrbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskReveals))
		}
		if (zb0048Mask[0] & 0x4000000000000000) == 0 { // if not empty
			// string "certrnd"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x72, 0x6e, 0x64)
			if (*z).encodedCompactCertTxnFields.CertRound == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCompactCertTxnFields.CertRound)))
			}
			for zb0035 := range (*z).encodedCompactCertTxnFields.CertRound {
				o = (*z).encodedCompactCertTxnFields.CertRound[zb0035].MarshalMsg(o)
			}
		}
		if (zb0048Mask[0] & 0x8000000000000000) == 0 { // if not empty
			// string "certrndbm"
			o = append(o, 0xa9, 0x63, 0x65, 0x72, 0x74, 0x72, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCompactCertTxnFields.BitmaskCertRound))
		}
		if (zb0048Mask[1] & 0x1) == 0 { // if not empty
			// string "certtype"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x74, 0x79, 0x70, 0x65)
			if (*z).encodedCompactCertTxnFields.CertType == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCompactCertTxnFields.CertType)))
			}
			for zb0036 := range (*z).encodedCompactCertTxnFields.CertType {
				o = (*z).encodedCompactCertTxnFields.CertType[zb0036].MarshalMsg(o)
			}
		}
		if (zb0048Mask[1] & 0x2) == 0 { // if not empty
			// string "certtypebm"
			o = append(o, 0xaa, 0x63, 0x65, 0x72, 0x74, 0x74, 0x79, 0x70, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCompactCertTxnFields.BitmaskCertType))
		}
		if (zb0048Mask[1] & 0x4) == 0 { // if not empty
			// string "certw"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x77)
			if (*z).encodedCompactCertTxnFields.encodedCert.SignedWeight == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedCompactCertTxnFields.encodedCert.SignedWeight)))
			}
			for zb0038 := range (*z).encodedCompactCertTxnFields.encodedCert.SignedWeight {
				o = msgp.AppendUint64(o, (*z).encodedCompactCertTxnFields.encodedCert.SignedWeight[zb0038])
			}
		}
		if (zb0048Mask[1] & 0x8) == 0 { // if not empty
			// string "certwbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x77, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight))
		}
		if (zb0048Mask[1] & 0x10) == 0 { // if not empty
			// string "close"
			o = append(o, 0xa5, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			o = msgp.AppendBytes(o, (*z).encodedPaymentTxnFields.CloseRemainderTo)
		}
		if (zb0048Mask[1] & 0x20) == 0 { // if not empty
			// string "closebm"
			o = append(o, 0xa7, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo))
		}
		if (zb0048Mask[1] & 0x40) == 0 { // if not empty
			// string "comt"
			o = append(o, 0xa4, 0x63, 0x6f, 0x6d, 0x74)
			o = msgp.AppendBytes(o, (*z).encodedKeyregTxnFields.CommitmentRoot)
		}
		if (zb0048Mask[1] & 0x80) == 0 { // if not empty
			// string "dc"
			o = append(o, 0xa2, 0x64, 0x63)
			if (*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals)))
			}
			for zb0012 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals {
				o = msgp.AppendUint32(o, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals[zb0012])
			}
		}
		if (zb0048Mask[1] & 0x100) == 0 { // if not empty
			// string "dcbm"
			o = append(o, 0xa4, 0x64, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals))
		}
		if (zb0048Mask[1] & 0x200) == 0 { // if not empty
			// string "dfbm"
			o = append(o, 0xa4, 0x64, 0x66, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen))
		}
		if (zb0048Mask[1] & 0x400) == 0 { // if not empty
			// string "f"
			o = append(o, 0xa1, 0x66)
			o = msgp.AppendBytes(o, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Freeze)
		}
		if (zb0048Mask[1] & 0x800) == 0 { // if not empty
			// string "fadd"
			o = append(o, 0xa4, 0x66, 0x61, 0x64, 0x64)
			o = msgp.AppendBytes(o, (*z).encodedAssetFreezeTxnFields.FreezeAccount)
		}
		if (zb0048Mask[1] & 0x1000) == 0 { // if not empty
			// string "faddbm"
			o = append(o, 0xa6, 0x66, 0x61, 0x64, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetFreezeTxnFields.BitmaskFreezeAccount))
		}
		if (zb0048Mask[1] & 0x2000) == 0 { // if not empty
			// string "faid"
			o = append(o, 0xa4, 0x66, 0x61, 0x69, 0x64)
			if (*z).encodedAssetFreezeTxnFields.FreezeAsset == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetFreezeTxnFields.FreezeAsset)))
			}
			for zb0018 := range (*z).encodedAssetFreezeTxnFields.FreezeAsset {
				o = (*z).encodedAssetFreezeTxnFields.FreezeAsset[zb0018].MarshalMsg(o)
			}
		}
		if (zb0048Mask[1] & 0x4000) == 0 { // if not empty
			// string "faidbm"
			o = append(o, 0xa6, 0x66, 0x61, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetFreezeTxnFields.BitmaskFreezeAsset))
		}
		if (zb0048Mask[1] & 0x8000) == 0 { // if not empty
			// string "fbm"
			o = append(o, 0xa3, 0x66, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze))
		}
		if (zb0048Mask[1] & 0x10000) == 0 { // if not empty
			// string "fee"
			o = append(o, 0xa3, 0x66, 0x65, 0x65)
			if (*z).encodedTxnHeaders.Fee == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxnHeaders.Fee)))
			}
			for zb0001 := range (*z).encodedTxnHeaders.Fee {
				o = (*z).encodedTxnHeaders.Fee[zb0001].MarshalMsg(o)
			}
		}
		if (zb0048Mask[1] & 0x20000) == 0 { // if not empty
			// string "feebm"
			o = append(o, 0xa5, 0x66, 0x65, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskFee))
		}
		if (zb0048Mask[1] & 0x40000) == 0 { // if not empty
			// string "fv"
			o = append(o, 0xa2, 0x66, 0x76)
			if (*z).encodedTxnHeaders.FirstValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxnHeaders.FirstValid)))
			}
			for zb0002 := range (*z).encodedTxnHeaders.FirstValid {
				o = (*z).encodedTxnHeaders.FirstValid[zb0002].MarshalMsg(o)
			}
		}
		if (zb0048Mask[1] & 0x80000) == 0 { // if not empty
			// string "fvbm"
			o = append(o, 0xa4, 0x66, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskFirstValid))
		}
		if (zb0048Mask[1] & 0x100000) == 0 { // if not empty
			// string "genbm"
			o = append(o, 0xa5, 0x67, 0x65, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskGenesisID))
		}
		if (zb0048Mask[1] & 0x200000) == 0 { // if not empty
			// string "gnbs"
			o = append(o, 0xa4, 0x67, 0x6e, 0x62, 0x73)
			if (*z).encodedApplicationCallTxnFields.GlobalNumByteSlice == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.GlobalNumByteSlice)))
			}
			for zb0031 := range (*z).encodedApplicationCallTxnFields.GlobalNumByteSlice {
				o = msgp.AppendUint64(o, (*z).encodedApplicationCallTxnFields.GlobalNumByteSlice[zb0031])
			}
		}
		if (zb0048Mask[1] & 0x400000) == 0 { // if not empty
			// string "gnbsbm"
			o = append(o, 0xa6, 0x67, 0x6e, 0x62, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice))
		}
		if (zb0048Mask[1] & 0x800000) == 0 { // if not empty
			// string "gnui"
			o = append(o, 0xa4, 0x67, 0x6e, 0x75, 0x69)
			if (*z).encodedApplicationCallTxnFields.GlobalNumUint == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.GlobalNumUint)))
			}
			for zb0030 := range (*z).encodedApplicationCallTxnFields.GlobalNumUint {
				o = msgp.AppendUint64(o, (*z).encodedApplicationCallTxnFields.GlobalNumUint[zb0030])
			}
		}
		if (zb0048Mask[1] & 0x1000000) == 0 { // if not empty
			// string "gnuibm"
			o = append(o, 0xa6, 0x67, 0x6e, 0x75, 0x69, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskGlobalNumUint))
		}
		if (zb0048Mask[1] & 0x2000000) == 0 { // if not empty
			// string "grpbm"
			o = append(o, 0xa5, 0x67, 0x72, 0x70, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskGroup))
		}
		if (zb0048Mask[1] & 0x4000000) == 0 { // if not empty
			// string "lnbs"
			o = append(o, 0xa4, 0x6c, 0x6e, 0x62, 0x73)
			if (*z).encodedApplicationCallTxnFields.LocalNumByteSlice == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.LocalNumByteSlice)))
			}
			for zb0029 := range (*z).encodedApplicationCallTxnFields.LocalNumByteSlice {
				o = msgp.AppendUint64(o, (*z).encodedApplicationCallTxnFields.LocalNumByteSlice[zb0029])
			}
		}
		if (zb0048Mask[1] & 0x8000000) == 0 { // if not empty
			// string "lnbsbm"
			o = append(o, 0xa6, 0x6c, 0x6e, 0x62, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice))
		}
		if (zb0048Mask[1] & 0x10000000) == 0 { // if not empty
			// string "lnui"
			o = append(o, 0xa4, 0x6c, 0x6e, 0x75, 0x69)
			if (*z).encodedApplicationCallTxnFields.LocalNumUint == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedApplicationCallTxnFields.LocalNumUint)))
			}
			for zb0028 := range (*z).encodedApplicationCallTxnFields.LocalNumUint {
				o = msgp.AppendUint64(o, (*z).encodedApplicationCallTxnFields.LocalNumUint[zb0028])
			}
		}
		if (zb0048Mask[1] & 0x20000000) == 0 { // if not empty
			// string "lnuibm"
			o = append(o, 0xa6, 0x6c, 0x6e, 0x75, 0x69, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedApplicationCallTxnFields.BitmaskLocalNumUint))
		}
		if (zb0048Mask[1] & 0x40000000) == 0 { // if not empty
			// string "lv"
			o = append(o, 0xa2, 0x6c, 0x76)
			if (*z).encodedTxnHeaders.LastValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxnHeaders.LastValid)))
			}
			for zb0003 := range (*z).encodedTxnHeaders.LastValid {
				o = (*z).encodedTxnHeaders.LastValid[zb0003].MarshalMsg(o)
			}
		}
		if (zb0048Mask[1] & 0x80000000) == 0 { // if not empty
			// string "lvbm"
			o = append(o, 0xa4, 0x6c, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskLastValid))
		}
		if (zb0048Mask[1] & 0x100000000) == 0 { // if not empty
			// string "lx"
			o = append(o, 0xa2, 0x6c, 0x78)
			o = msgp.AppendBytes(o, (*z).encodedTxnHeaders.Lease)
		}
		if (zb0048Mask[1] & 0x200000000) == 0 { // if not empty
			// string "lxbm"
			o = append(o, 0xa4, 0x6c, 0x78, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskLease))
		}
		if (zb0048Mask[1] & 0x400000000) == 0 { // if not empty
			// string "m"
			o = append(o, 0xa1, 0x6d)
			o = msgp.AppendBytes(o, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Manager)
		}
		if (zb0048Mask[1] & 0x800000000) == 0 { // if not empty
			// string "mbm"
			o = append(o, 0xa3, 0x6d, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager))
		}
		if (zb0048Mask[1] & 0x1000000000) == 0 { // if not empty
			// string "nonpartbm"
			o = append(o, 0xa9, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedKeyregTxnFields.BitmaskNonparticipation))
		}
		if (zb0048Mask[1] & 0x2000000000) == 0 { // if not empty
			// string "note"
			o = append(o, 0xa4, 0x6e, 0x6f, 0x74, 0x65)
			if (*z).encodedTxnHeaders.Note == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxnHeaders.Note)))
			}
			for zb0004 := range (*z).encodedTxnHeaders.Note {
				o = msgp.AppendBytes(o, (*z).encodedTxnHeaders.Note[zb0004])
			}
		}
		if (zb0048Mask[1] & 0x4000000000) == 0 { // if not empty
			// string "notebm"
			o = append(o, 0xa6, 0x6e, 0x6f, 0x74, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskNote))
		}
		if (zb0048Mask[1] & 0x8000000000) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = msgp.AppendBytes(o, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Reserve)
		}
		if (zb0048Mask[1] & 0x10000000000) == 0 { // if not empty
			// string "rbm"
			o = append(o, 0xa3, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve))
		}
		if (zb0048Mask[1] & 0x20000000000) == 0 { // if not empty
			// string "rcv"
			o = append(o, 0xa3, 0x72, 0x63, 0x76)
			o = msgp.AppendBytes(o, (*z).encodedPaymentTxnFields.Receiver)
		}
		if (zb0048Mask[1] & 0x40000000000) == 0 { // if not empty
			// string "rcvbm"
			o = append(o, 0xa5, 0x72, 0x63, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedPaymentTxnFields.BitmaskReceiver))
		}
		if (zb0048Mask[1] & 0x80000000000) == 0 { // if not empty
			// string "rekey"
			o = append(o, 0xa5, 0x72, 0x65, 0x6b, 0x65, 0x79)
			o = msgp.AppendBytes(o, (*z).encodedTxnHeaders.RekeyTo)
		}
		if (zb0048Mask[1] & 0x100000000000) == 0 { // if not empty
			// string "rekeybm"
			o = append(o, 0xa7, 0x72, 0x65, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskRekeyTo))
		}
		if (zb0048Mask[1] & 0x200000000000) == 0 { // if not empty
			// string "selkey"
			o = append(o, 0xa6, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79)
			o = msgp.AppendBytes(o, (*z).encodedKeyregTxnFields.SelectionPK)
		}
		if (zb0048Mask[1] & 0x400000000000) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o = msgp.AppendBytes(o, (*z).encodedTxnHeaders.Sender)
		}
		if (zb0048Mask[1] & 0x800000000000) == 0 { // if not empty
			// string "sndbm"
			o = append(o, 0xa5, 0x73, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskSender))
		}
		if (zb0048Mask[1] & 0x1000000000000) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			if (*z).encodedAssetConfigTxnFields.encodedAssetParams.Total == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Total)))
			}
			for zb0011 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.Total {
				o = msgp.AppendUint64(o, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Total[zb0011])
			}
		}
		if (zb0048Mask[1] & 0x2000000000000) == 0 { // if not empty
			// string "tbm"
			o = append(o, 0xa3, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal))
		}
		if (zb0048Mask[1] & 0x4000000000000) == 0 { // if not empty
			// string "type"
			o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
			o = msgp.AppendBytes(o, (*z).TxType)
		}
		if (zb0048Mask[1] & 0x8000000000000) == 0 { // if not empty
			// string "typebm"
			o = append(o, 0xa6, 0x74, 0x79, 0x70, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskTxType))
		}
		if (zb0048Mask[1] & 0x10000000000000) == 0 { // if not empty
			// string "typeo"
			o = append(o, 0xa5, 0x74, 0x79, 0x70, 0x65, 0x6f)
			o = msgp.AppendByte(o, (*z).TxTypeOffset)
		}
		if (zb0048Mask[1] & 0x20000000000000) == 0 { // if not empty
			// string "un"
			o = append(o, 0xa2, 0x75, 0x6e)
			if (*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName)))
			}
			for zb0013 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName {
				o = msgp.AppendString(o, (*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName[zb0013])
			}
		}
		if (zb0048Mask[1] & 0x40000000000000) == 0 { // if not empty
			// string "unbm"
			o = append(o, 0xa4, 0x75, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName))
		}
		if (zb0048Mask[1] & 0x80000000000000) == 0 { // if not empty
			// string "vldrt"
			o = append(o, 0xa5, 0x76, 0x6c, 0x64, 0x72, 0x74)
			if (*z).encodedKeyregTxnFields.HasValidRoot == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedKeyregTxnFields.HasValidRoot)))
			}
			for zb0008 := range (*z).encodedKeyregTxnFields.HasValidRoot {
				o = msgp.AppendBool(o, (*z).encodedKeyregTxnFields.HasValidRoot[zb0008])
			}
		}
		if (zb0048Mask[1] & 0x100000000000000) == 0 { // if not empty
			// string "votefst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74)
			if (*z).encodedKeyregTxnFields.VoteFirst == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedKeyregTxnFields.VoteFirst)))
			}
			for zb0005 := range (*z).encodedKeyregTxnFields.VoteFirst {
				o = (*z).encodedKeyregTxnFields.VoteFirst[zb0005].MarshalMsg(o)
			}
		}
		if (zb0048Mask[1] & 0x200000000000000) == 0 { // if not empty
			// string "votefstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedKeyregTxnFields.BitmaskVoteFirst))
		}
		if (zb0048Mask[1] & 0x400000000000000) == 0 { // if not empty
			// string "votekbm"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedKeyregTxnFields.BitmaskKeys))
		}
		if (zb0048Mask[1] & 0x800000000000000) == 0 { // if not empty
			// string "votekd"
			o = append(o, 0xa6, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64)
			if (*z).encodedKeyregTxnFields.VoteKeyDilution == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedKeyregTxnFields.VoteKeyDilution)))
			}
			for zb0007 := range (*z).encodedKeyregTxnFields.VoteKeyDilution {
				o = msgp.AppendUint64(o, (*z).encodedKeyregTxnFields.VoteKeyDilution[zb0007])
			}
		}
		if (zb0048Mask[1] & 0x1000000000000000) == 0 { // if not empty
			// string "votekey"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79)
			o = msgp.AppendBytes(o, (*z).encodedKeyregTxnFields.VotePK)
		}
		if (zb0048Mask[1] & 0x2000000000000000) == 0 { // if not empty
			// string "votelst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74)
			if (*z).encodedKeyregTxnFields.VoteLast == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedKeyregTxnFields.VoteLast)))
			}
			for zb0006 := range (*z).encodedKeyregTxnFields.VoteLast {
				o = (*z).encodedKeyregTxnFields.VoteLast[zb0006].MarshalMsg(o)
			}
		}
		if (zb0048Mask[1] & 0x4000000000000000) == 0 { // if not empty
			// string "votelstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedKeyregTxnFields.BitmaskVoteLast))
		}
		if (zb0048Mask[1] & 0x8000000000000000) == 0 { // if not empty
			// string "xaid"
			o = append(o, 0xa4, 0x78, 0x61, 0x69, 0x64)
			if (*z).encodedAssetTransferTxnFields.XferAsset == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedAssetTransferTxnFields.XferAsset)))
			}
			for zb0016 := range (*z).encodedAssetTransferTxnFields.XferAsset {
				o = (*z).encodedAssetTransferTxnFields.XferAsset[zb0016].MarshalMsg(o)
			}
		}
		if (zb0048Mask[2] & 0x1) == 0 { // if not empty
			// string "xaidbm"
			o = append(o, 0xa6, 0x78, 0x61, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedAssetTransferTxnFields.BitmaskXferAsset))
		}
	}
	return
}

func (_ *encodedTxns) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedTxns)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedTxns) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0048 int
	var zb0049 bool
	zb0048, zb0049, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0048, zb0049, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0048 > 0 {
			zb0048--
			var zb0050 int
			zb0050, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
			if zb0050 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0050), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).TxType, bts, err = msgp.ReadBytesBytes(bts, (*z).TxType)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0051 []byte
				var zb0052 int
				zb0052, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTxType")
					return
				}
				if zb0052 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0052), uint64(maxBitmaskSize))
					return
				}
				zb0051, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskTxType))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTxType")
					return
				}
				(*z).BitmaskTxType = bitmask(zb0051)
			}
		}
		if zb0048 > 0 {
			zb0048--
			(*z).TxTypeOffset, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxTypeOffset")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0053 int
			zb0053, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
			if zb0053 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0053), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxnHeaders.Sender, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxnHeaders.Sender)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0054 []byte
				var zb0055 int
				zb0055, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSender")
					return
				}
				if zb0055 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0055), uint64(maxBitmaskSize))
					return
				}
				zb0054, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskSender))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSender")
					return
				}
				(*z).encodedTxnHeaders.BitmaskSender = bitmask(zb0054)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0056 int
			var zb0057 bool
			zb0056, zb0057, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0056 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0056), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0057 {
				(*z).encodedTxnHeaders.Fee = nil
			} else if (*z).encodedTxnHeaders.Fee != nil && cap((*z).encodedTxnHeaders.Fee) >= zb0056 {
				(*z).encodedTxnHeaders.Fee = ((*z).encodedTxnHeaders.Fee)[:zb0056]
			} else {
				(*z).encodedTxnHeaders.Fee = make([]basics.MicroAlgos, zb0056)
			}
			for zb0001 := range (*z).encodedTxnHeaders.Fee {
				bts, err = (*z).encodedTxnHeaders.Fee[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Fee", zb0001)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0058 []byte
				var zb0059 int
				zb0059, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFee")
					return
				}
				if zb0059 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0059), uint64(maxBitmaskSize))
					return
				}
				zb0058, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskFee))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFee")
					return
				}
				(*z).encodedTxnHeaders.BitmaskFee = bitmask(zb0058)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0060 int
			var zb0061 bool
			zb0060, zb0061, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0060 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0060), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0061 {
				(*z).encodedTxnHeaders.FirstValid = nil
			} else if (*z).encodedTxnHeaders.FirstValid != nil && cap((*z).encodedTxnHeaders.FirstValid) >= zb0060 {
				(*z).encodedTxnHeaders.FirstValid = ((*z).encodedTxnHeaders.FirstValid)[:zb0060]
			} else {
				(*z).encodedTxnHeaders.FirstValid = make([]basics.Round, zb0060)
			}
			for zb0002 := range (*z).encodedTxnHeaders.FirstValid {
				bts, err = (*z).encodedTxnHeaders.FirstValid[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "FirstValid", zb0002)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0062 []byte
				var zb0063 int
				zb0063, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFirstValid")
					return
				}
				if zb0063 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0063), uint64(maxBitmaskSize))
					return
				}
				zb0062, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskFirstValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFirstValid")
					return
				}
				(*z).encodedTxnHeaders.BitmaskFirstValid = bitmask(zb0062)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0064 int
			var zb0065 bool
			zb0064, zb0065, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0064 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0064), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0065 {
				(*z).encodedTxnHeaders.LastValid = nil
			} else if (*z).encodedTxnHeaders.LastValid != nil && cap((*z).encodedTxnHeaders.LastValid) >= zb0064 {
				(*z).encodedTxnHeaders.LastValid = ((*z).encodedTxnHeaders.LastValid)[:zb0064]
			} else {
				(*z).encodedTxnHeaders.LastValid = make([]basics.Round, zb0064)
			}
			for zb0003 := range (*z).encodedTxnHeaders.LastValid {
				bts, err = (*z).encodedTxnHeaders.LastValid[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LastValid", zb0003)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0066 []byte
				var zb0067 int
				zb0067, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLastValid")
					return
				}
				if zb0067 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0067), uint64(maxBitmaskSize))
					return
				}
				zb0066, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskLastValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLastValid")
					return
				}
				(*z).encodedTxnHeaders.BitmaskLastValid = bitmask(zb0066)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0068 int
			var zb0069 bool
			zb0068, zb0069, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0068 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0068), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0069 {
				(*z).encodedTxnHeaders.Note = nil
			} else if (*z).encodedTxnHeaders.Note != nil && cap((*z).encodedTxnHeaders.Note) >= zb0068 {
				(*z).encodedTxnHeaders.Note = ((*z).encodedTxnHeaders.Note)[:zb0068]
			} else {
				(*z).encodedTxnHeaders.Note = make([][]byte, zb0068)
			}
			for zb0004 := range (*z).encodedTxnHeaders.Note {
				var zb0070 int
				zb0070, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Note", zb0004)
					return
				}
				if zb0070 > config.MaxTxnNoteBytes {
					err = msgp.ErrOverflow(uint64(zb0070), uint64(config.MaxTxnNoteBytes))
					return
				}
				(*z).encodedTxnHeaders.Note[zb0004], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxnHeaders.Note[zb0004])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Note", zb0004)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0071 []byte
				var zb0072 int
				zb0072, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNote")
					return
				}
				if zb0072 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0072), uint64(maxBitmaskSize))
					return
				}
				zb0071, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskNote))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNote")
					return
				}
				(*z).encodedTxnHeaders.BitmaskNote = bitmask(zb0071)
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0073 []byte
				var zb0074 int
				zb0074, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisID")
					return
				}
				if zb0074 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0074), uint64(maxBitmaskSize))
					return
				}
				zb0073, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskGenesisID))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisID")
					return
				}
				(*z).encodedTxnHeaders.BitmaskGenesisID = bitmask(zb0073)
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0075 []byte
				var zb0076 int
				zb0076, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGroup")
					return
				}
				if zb0076 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0076), uint64(maxBitmaskSize))
					return
				}
				zb0075, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskGroup))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGroup")
					return
				}
				(*z).encodedTxnHeaders.BitmaskGroup = bitmask(zb0075)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0077 int
			zb0077, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
			if zb0077 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0077), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxnHeaders.Lease, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxnHeaders.Lease)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0078 []byte
				var zb0079 int
				zb0079, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLease")
					return
				}
				if zb0079 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0079), uint64(maxBitmaskSize))
					return
				}
				zb0078, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskLease))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLease")
					return
				}
				(*z).encodedTxnHeaders.BitmaskLease = bitmask(zb0078)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0080 int
			zb0080, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
			if zb0080 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0080), uint64(maxAddressBytes))
				return
			}
			(*z).encodedTxnHeaders.RekeyTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxnHeaders.RekeyTo)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0081 []byte
				var zb0082 int
				zb0082, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskRekeyTo")
					return
				}
				if zb0082 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0082), uint64(maxBitmaskSize))
					return
				}
				zb0081, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskRekeyTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskRekeyTo")
					return
				}
				(*z).encodedTxnHeaders.BitmaskRekeyTo = bitmask(zb0081)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0083 int
			zb0083, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
			if zb0083 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0083), uint64(maxAddressBytes))
				return
			}
			(*z).encodedKeyregTxnFields.VotePK, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedKeyregTxnFields.VotePK)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0084 int
			zb0084, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
			if zb0084 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0084), uint64(maxAddressBytes))
				return
			}
			(*z).encodedKeyregTxnFields.SelectionPK, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedKeyregTxnFields.SelectionPK)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0085 int
			var zb0086 bool
			zb0085, zb0086, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0085 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0085), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0086 {
				(*z).encodedKeyregTxnFields.VoteFirst = nil
			} else if (*z).encodedKeyregTxnFields.VoteFirst != nil && cap((*z).encodedKeyregTxnFields.VoteFirst) >= zb0085 {
				(*z).encodedKeyregTxnFields.VoteFirst = ((*z).encodedKeyregTxnFields.VoteFirst)[:zb0085]
			} else {
				(*z).encodedKeyregTxnFields.VoteFirst = make([]basics.Round, zb0085)
			}
			for zb0005 := range (*z).encodedKeyregTxnFields.VoteFirst {
				bts, err = (*z).encodedKeyregTxnFields.VoteFirst[zb0005].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteFirst", zb0005)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0087 []byte
				var zb0088 int
				zb0088, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteFirst")
					return
				}
				if zb0088 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0088), uint64(maxBitmaskSize))
					return
				}
				zb0087, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskVoteFirst))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteFirst")
					return
				}
				(*z).encodedKeyregTxnFields.BitmaskVoteFirst = bitmask(zb0087)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0089 int
			var zb0090 bool
			zb0089, zb0090, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0089 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0089), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0090 {
				(*z).encodedKeyregTxnFields.VoteLast = nil
			} else if (*z).encodedKeyregTxnFields.VoteLast != nil && cap((*z).encodedKeyregTxnFields.VoteLast) >= zb0089 {
				(*z).encodedKeyregTxnFields.VoteLast = ((*z).encodedKeyregTxnFields.VoteLast)[:zb0089]
			} else {
				(*z).encodedKeyregTxnFields.VoteLast = make([]basics.Round, zb0089)
			}
			for zb0006 := range (*z).encodedKeyregTxnFields.VoteLast {
				bts, err = (*z).encodedKeyregTxnFields.VoteLast[zb0006].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteLast", zb0006)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0091 []byte
				var zb0092 int
				zb0092, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteLast")
					return
				}
				if zb0092 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0092), uint64(maxBitmaskSize))
					return
				}
				zb0091, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskVoteLast))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteLast")
					return
				}
				(*z).encodedKeyregTxnFields.BitmaskVoteLast = bitmask(zb0091)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0093 int
			var zb0094 bool
			zb0093, zb0094, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0093 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0093), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0094 {
				(*z).encodedKeyregTxnFields.VoteKeyDilution = nil
			} else if (*z).encodedKeyregTxnFields.VoteKeyDilution != nil && cap((*z).encodedKeyregTxnFields.VoteKeyDilution) >= zb0093 {
				(*z).encodedKeyregTxnFields.VoteKeyDilution = ((*z).encodedKeyregTxnFields.VoteKeyDilution)[:zb0093]
			} else {
				(*z).encodedKeyregTxnFields.VoteKeyDilution = make([]uint64, zb0093)
			}
			for zb0007 := range (*z).encodedKeyregTxnFields.VoteKeyDilution {
				(*z).encodedKeyregTxnFields.VoteKeyDilution[zb0007], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution", zb0007)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0095 []byte
				var zb0096 int
				zb0096, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskKeys")
					return
				}
				if zb0096 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0096), uint64(maxBitmaskSize))
					return
				}
				zb0095, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskKeys))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskKeys")
					return
				}
				(*z).encodedKeyregTxnFields.BitmaskKeys = bitmask(zb0095)
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0097 []byte
				var zb0098 int
				zb0098, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNonparticipation")
					return
				}
				if zb0098 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0098), uint64(maxBitmaskSize))
					return
				}
				zb0097, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskNonparticipation))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNonparticipation")
					return
				}
				(*z).encodedKeyregTxnFields.BitmaskNonparticipation = bitmask(zb0097)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0099 int
			var zb0100 bool
			zb0099, zb0100, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "HasValidRoot")
				return
			}
			if zb0099 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0099), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "HasValidRoot")
				return
			}
			if zb0100 {
				(*z).encodedKeyregTxnFields.HasValidRoot = nil
			} else if (*z).encodedKeyregTxnFields.HasValidRoot != nil && cap((*z).encodedKeyregTxnFields.HasValidRoot) >= zb0099 {
				(*z).encodedKeyregTxnFields.HasValidRoot = ((*z).encodedKeyregTxnFields.HasValidRoot)[:zb0099]
			} else {
				(*z).encodedKeyregTxnFields.HasValidRoot = make([]bool, zb0099)
			}
			for zb0008 := range (*z).encodedKeyregTxnFields.HasValidRoot {
				(*z).encodedKeyregTxnFields.HasValidRoot[zb0008], bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "HasValidRoot", zb0008)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0101 int
			zb0101, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CommitmentRoot")
				return
			}
			if zb0101 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0101), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).encodedKeyregTxnFields.CommitmentRoot, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedKeyregTxnFields.CommitmentRoot)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CommitmentRoot")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0102 int
			zb0102, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
			if zb0102 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0102), uint64(maxAddressBytes))
				return
			}
			(*z).encodedPaymentTxnFields.Receiver, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedPaymentTxnFields.Receiver)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0103 []byte
				var zb0104 int
				zb0104, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReceiver")
					return
				}
				if zb0104 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0104), uint64(maxBitmaskSize))
					return
				}
				zb0103, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedPaymentTxnFields.BitmaskReceiver))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReceiver")
					return
				}
				(*z).encodedPaymentTxnFields.BitmaskReceiver = bitmask(zb0103)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0105 int
			var zb0106 bool
			zb0105, zb0106, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0105 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0105), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0106 {
				(*z).encodedPaymentTxnFields.Amount = nil
			} else if (*z).encodedPaymentTxnFields.Amount != nil && cap((*z).encodedPaymentTxnFields.Amount) >= zb0105 {
				(*z).encodedPaymentTxnFields.Amount = ((*z).encodedPaymentTxnFields.Amount)[:zb0105]
			} else {
				(*z).encodedPaymentTxnFields.Amount = make([]basics.MicroAlgos, zb0105)
			}
			for zb0009 := range (*z).encodedPaymentTxnFields.Amount {
				bts, err = (*z).encodedPaymentTxnFields.Amount[zb0009].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Amount", zb0009)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0107 []byte
				var zb0108 int
				zb0108, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAmount")
					return
				}
				if zb0108 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0108), uint64(maxBitmaskSize))
					return
				}
				zb0107, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedPaymentTxnFields.BitmaskAmount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAmount")
					return
				}
				(*z).encodedPaymentTxnFields.BitmaskAmount = bitmask(zb0107)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0109 int
			zb0109, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
			if zb0109 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0109), uint64(maxAddressBytes))
				return
			}
			(*z).encodedPaymentTxnFields.CloseRemainderTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedPaymentTxnFields.CloseRemainderTo)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0110 []byte
				var zb0111 int
				zb0111, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCloseRemainderTo")
					return
				}
				if zb0111 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0111), uint64(maxBitmaskSize))
					return
				}
				zb0110, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCloseRemainderTo")
					return
				}
				(*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo = bitmask(zb0110)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0112 int
			var zb0113 bool
			zb0112, zb0113, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ConfigAsset")
				return
			}
			if zb0112 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0112), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ConfigAsset")
				return
			}
			if zb0113 {
				(*z).encodedAssetConfigTxnFields.ConfigAsset = nil
			} else if (*z).encodedAssetConfigTxnFields.ConfigAsset != nil && cap((*z).encodedAssetConfigTxnFields.ConfigAsset) >= zb0112 {
				(*z).encodedAssetConfigTxnFields.ConfigAsset = ((*z).encodedAssetConfigTxnFields.ConfigAsset)[:zb0112]
			} else {
				(*z).encodedAssetConfigTxnFields.ConfigAsset = make([]basics.AssetIndex, zb0112)
			}
			for zb0010 := range (*z).encodedAssetConfigTxnFields.ConfigAsset {
				bts, err = (*z).encodedAssetConfigTxnFields.ConfigAsset[zb0010].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ConfigAsset", zb0010)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0114 []byte
				var zb0115 int
				zb0115, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskConfigAsset")
					return
				}
				if zb0115 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0115), uint64(maxBitmaskSize))
					return
				}
				zb0114, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.BitmaskConfigAsset))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskConfigAsset")
					return
				}
				(*z).encodedAssetConfigTxnFields.BitmaskConfigAsset = bitmask(zb0114)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0116 int
			var zb0117 bool
			zb0116, zb0117, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Total")
				return
			}
			if zb0116 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0116), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Total")
				return
			}
			if zb0117 {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.Total = nil
			} else if (*z).encodedAssetConfigTxnFields.encodedAssetParams.Total != nil && cap((*z).encodedAssetConfigTxnFields.encodedAssetParams.Total) >= zb0116 {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.Total = ((*z).encodedAssetConfigTxnFields.encodedAssetParams.Total)[:zb0116]
			} else {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.Total = make([]uint64, zb0116)
			}
			for zb0011 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.Total {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.Total[zb0011], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Total", zb0011)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0118 []byte
				var zb0119 int
				zb0119, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTotal")
					return
				}
				if zb0119 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0119), uint64(maxBitmaskSize))
					return
				}
				zb0118, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTotal")
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal = bitmask(zb0118)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0120 int
			var zb0121 bool
			zb0120, zb0121, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Decimals")
				return
			}
			if zb0120 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0120), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Decimals")
				return
			}
			if zb0121 {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals = nil
			} else if (*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals != nil && cap((*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals) >= zb0120 {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals = ((*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals)[:zb0120]
			} else {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals = make([]uint32, zb0120)
			}
			for zb0012 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals[zb0012], bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Decimals", zb0012)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0122 []byte
				var zb0123 int
				zb0123, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDecimals")
					return
				}
				if zb0123 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0123), uint64(maxBitmaskSize))
					return
				}
				zb0122, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDecimals")
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals = bitmask(zb0122)
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0124 []byte
				var zb0125 int
				zb0125, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDefaultFrozen")
					return
				}
				if zb0125 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0125), uint64(maxBitmaskSize))
					return
				}
				zb0124, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDefaultFrozen")
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen = bitmask(zb0124)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0126 int
			var zb0127 bool
			zb0126, zb0127, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UnitName")
				return
			}
			if zb0126 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0126), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "UnitName")
				return
			}
			if zb0127 {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName = nil
			} else if (*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName != nil && cap((*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName) >= zb0126 {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName = ((*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName)[:zb0126]
			} else {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName = make([]string, zb0126)
			}
			for zb0013 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName[zb0013], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "UnitName", zb0013)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0128 []byte
				var zb0129 int
				zb0129, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskUnitName")
					return
				}
				if zb0129 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0129), uint64(maxBitmaskSize))
					return
				}
				zb0128, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskUnitName")
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName = bitmask(zb0128)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0130 int
			var zb0131 bool
			zb0130, zb0131, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetName")
				return
			}
			if zb0130 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0130), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "AssetName")
				return
			}
			if zb0131 {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName = nil
			} else if (*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName != nil && cap((*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName) >= zb0130 {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName = ((*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName)[:zb0130]
			} else {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName = make([]string, zb0130)
			}
			for zb0014 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName[zb0014], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AssetName", zb0014)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0132 []byte
				var zb0133 int
				zb0133, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetName")
					return
				}
				if zb0133 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0133), uint64(maxBitmaskSize))
					return
				}
				zb0132, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetName")
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName = bitmask(zb0132)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0134 int
			var zb0135 bool
			zb0134, zb0135, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "URL")
				return
			}
			if zb0134 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0134), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "URL")
				return
			}
			if zb0135 {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.URL = nil
			} else if (*z).encodedAssetConfigTxnFields.encodedAssetParams.URL != nil && cap((*z).encodedAssetConfigTxnFields.encodedAssetParams.URL) >= zb0134 {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.URL = ((*z).encodedAssetConfigTxnFields.encodedAssetParams.URL)[:zb0134]
			} else {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.URL = make([]string, zb0134)
			}
			for zb0015 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.URL {
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.URL[zb0015], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "URL", zb0015)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0136 []byte
				var zb0137 int
				zb0137, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskURL")
					return
				}
				if zb0137 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0137), uint64(maxBitmaskSize))
					return
				}
				zb0136, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskURL")
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL = bitmask(zb0136)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0138 int
			zb0138, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MetadataHash")
				return
			}
			if zb0138 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0138), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MetadataHash")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0139 []byte
				var zb0140 int
				zb0140, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMetadataHash")
					return
				}
				if zb0140 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0140), uint64(maxBitmaskSize))
					return
				}
				zb0139, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMetadataHash")
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash = bitmask(zb0139)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0141 int
			zb0141, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Manager")
				return
			}
			if zb0141 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0141), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetConfigTxnFields.encodedAssetParams.Manager, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Manager)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Manager")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0142 []byte
				var zb0143 int
				zb0143, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskManager")
					return
				}
				if zb0143 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0143), uint64(maxBitmaskSize))
					return
				}
				zb0142, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskManager")
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager = bitmask(zb0142)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0144 int
			zb0144, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reserve")
				return
			}
			if zb0144 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0144), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetConfigTxnFields.encodedAssetParams.Reserve, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Reserve)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reserve")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0145 []byte
				var zb0146 int
				zb0146, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReserve")
					return
				}
				if zb0146 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0146), uint64(maxBitmaskSize))
					return
				}
				zb0145, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReserve")
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve = bitmask(zb0145)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0147 int
			zb0147, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Freeze")
				return
			}
			if zb0147 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0147), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetConfigTxnFields.encodedAssetParams.Freeze, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Freeze)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Freeze")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0148 []byte
				var zb0149 int
				zb0149, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreeze")
					return
				}
				if zb0149 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0149), uint64(maxBitmaskSize))
					return
				}
				zb0148, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreeze")
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze = bitmask(zb0148)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0150 int
			zb0150, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Clawback")
				return
			}
			if zb0150 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0150), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetConfigTxnFields.encodedAssetParams.Clawback, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Clawback)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Clawback")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0151 []byte
				var zb0152 int
				zb0152, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClawback")
					return
				}
				if zb0152 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0152), uint64(maxBitmaskSize))
					return
				}
				zb0151, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClawback")
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback = bitmask(zb0151)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0153 int
			var zb0154 bool
			zb0153, zb0154, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "XferAsset")
				return
			}
			if zb0153 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0153), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "XferAsset")
				return
			}
			if zb0154 {
				(*z).encodedAssetTransferTxnFields.XferAsset = nil
			} else if (*z).encodedAssetTransferTxnFields.XferAsset != nil && cap((*z).encodedAssetTransferTxnFields.XferAsset) >= zb0153 {
				(*z).encodedAssetTransferTxnFields.XferAsset = ((*z).encodedAssetTransferTxnFields.XferAsset)[:zb0153]
			} else {
				(*z).encodedAssetTransferTxnFields.XferAsset = make([]basics.AssetIndex, zb0153)
			}
			for zb0016 := range (*z).encodedAssetTransferTxnFields.XferAsset {
				bts, err = (*z).encodedAssetTransferTxnFields.XferAsset[zb0016].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "XferAsset", zb0016)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0155 []byte
				var zb0156 int
				zb0156, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskXferAsset")
					return
				}
				if zb0156 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0156), uint64(maxBitmaskSize))
					return
				}
				zb0155, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetTransferTxnFields.BitmaskXferAsset))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskXferAsset")
					return
				}
				(*z).encodedAssetTransferTxnFields.BitmaskXferAsset = bitmask(zb0155)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0157 int
			var zb0158 bool
			zb0157, zb0158, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetAmount")
				return
			}
			if zb0157 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0157), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "AssetAmount")
				return
			}
			if zb0158 {
				(*z).encodedAssetTransferTxnFields.AssetAmount = nil
			} else if (*z).encodedAssetTransferTxnFields.AssetAmount != nil && cap((*z).encodedAssetTransferTxnFields.AssetAmount) >= zb0157 {
				(*z).encodedAssetTransferTxnFields.AssetAmount = ((*z).encodedAssetTransferTxnFields.AssetAmount)[:zb0157]
			} else {
				(*z).encodedAssetTransferTxnFields.AssetAmount = make([]uint64, zb0157)
			}
			for zb0017 := range (*z).encodedAssetTransferTxnFields.AssetAmount {
				(*z).encodedAssetTransferTxnFields.AssetAmount[zb0017], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AssetAmount", zb0017)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0159 []byte
				var zb0160 int
				zb0160, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetAmount")
					return
				}
				if zb0160 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0160), uint64(maxBitmaskSize))
					return
				}
				zb0159, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetTransferTxnFields.BitmaskAssetAmount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetAmount")
					return
				}
				(*z).encodedAssetTransferTxnFields.BitmaskAssetAmount = bitmask(zb0159)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0161 int
			zb0161, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetSender")
				return
			}
			if zb0161 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0161), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetTransferTxnFields.AssetSender, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetTransferTxnFields.AssetSender)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetSender")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0162 []byte
				var zb0163 int
				zb0163, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetSender")
					return
				}
				if zb0163 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0163), uint64(maxBitmaskSize))
					return
				}
				zb0162, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetTransferTxnFields.BitmaskAssetSender))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetSender")
					return
				}
				(*z).encodedAssetTransferTxnFields.BitmaskAssetSender = bitmask(zb0162)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0164 int
			zb0164, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetReceiver")
				return
			}
			if zb0164 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0164), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetTransferTxnFields.AssetReceiver, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetTransferTxnFields.AssetReceiver)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetReceiver")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0165 []byte
				var zb0166 int
				zb0166, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetReceiver")
					return
				}
				if zb0166 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0166), uint64(maxBitmaskSize))
					return
				}
				zb0165, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetTransferTxnFields.BitmaskAssetReceiver))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetReceiver")
					return
				}
				(*z).encodedAssetTransferTxnFields.BitmaskAssetReceiver = bitmask(zb0165)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0167 int
			zb0167, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetCloseTo")
				return
			}
			if zb0167 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0167), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetTransferTxnFields.AssetCloseTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetTransferTxnFields.AssetCloseTo)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetCloseTo")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0168 []byte
				var zb0169 int
				zb0169, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetCloseTo")
					return
				}
				if zb0169 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0169), uint64(maxBitmaskSize))
					return
				}
				zb0168, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetTransferTxnFields.BitmaskAssetCloseTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetCloseTo")
					return
				}
				(*z).encodedAssetTransferTxnFields.BitmaskAssetCloseTo = bitmask(zb0168)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0170 int
			zb0170, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAccount")
				return
			}
			if zb0170 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0170), uint64(maxAddressBytes))
				return
			}
			(*z).encodedAssetFreezeTxnFields.FreezeAccount, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetFreezeTxnFields.FreezeAccount)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAccount")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0171 []byte
				var zb0172 int
				zb0172, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAccount")
					return
				}
				if zb0172 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0172), uint64(maxBitmaskSize))
					return
				}
				zb0171, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetFreezeTxnFields.BitmaskFreezeAccount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAccount")
					return
				}
				(*z).encodedAssetFreezeTxnFields.BitmaskFreezeAccount = bitmask(zb0171)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0173 int
			var zb0174 bool
			zb0173, zb0174, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAsset")
				return
			}
			if zb0173 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0173), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "FreezeAsset")
				return
			}
			if zb0174 {
				(*z).encodedAssetFreezeTxnFields.FreezeAsset = nil
			} else if (*z).encodedAssetFreezeTxnFields.FreezeAsset != nil && cap((*z).encodedAssetFreezeTxnFields.FreezeAsset) >= zb0173 {
				(*z).encodedAssetFreezeTxnFields.FreezeAsset = ((*z).encodedAssetFreezeTxnFields.FreezeAsset)[:zb0173]
			} else {
				(*z).encodedAssetFreezeTxnFields.FreezeAsset = make([]basics.AssetIndex, zb0173)
			}
			for zb0018 := range (*z).encodedAssetFreezeTxnFields.FreezeAsset {
				bts, err = (*z).encodedAssetFreezeTxnFields.FreezeAsset[zb0018].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "FreezeAsset", zb0018)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0175 []byte
				var zb0176 int
				zb0176, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAsset")
					return
				}
				if zb0176 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0176), uint64(maxBitmaskSize))
					return
				}
				zb0175, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetFreezeTxnFields.BitmaskFreezeAsset))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAsset")
					return
				}
				(*z).encodedAssetFreezeTxnFields.BitmaskFreezeAsset = bitmask(zb0175)
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0177 []byte
				var zb0178 int
				zb0178, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetFrozen")
					return
				}
				if zb0178 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0178), uint64(maxBitmaskSize))
					return
				}
				zb0177, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetFreezeTxnFields.BitmaskAssetFrozen))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetFrozen")
					return
				}
				(*z).encodedAssetFreezeTxnFields.BitmaskAssetFrozen = bitmask(zb0177)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0179 int
			var zb0180 bool
			zb0179, zb0180, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ApplicationID")
				return
			}
			if zb0179 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0179), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ApplicationID")
				return
			}
			if zb0180 {
				(*z).encodedApplicationCallTxnFields.ApplicationID = nil
			} else if (*z).encodedApplicationCallTxnFields.ApplicationID != nil && cap((*z).encodedApplicationCallTxnFields.ApplicationID) >= zb0179 {
				(*z).encodedApplicationCallTxnFields.ApplicationID = ((*z).encodedApplicationCallTxnFields.ApplicationID)[:zb0179]
			} else {
				(*z).encodedApplicationCallTxnFields.ApplicationID = make([]basics.AppIndex, zb0179)
			}
			for zb0019 := range (*z).encodedApplicationCallTxnFields.ApplicationID {
				bts, err = (*z).encodedApplicationCallTxnFields.ApplicationID[zb0019].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ApplicationID", zb0019)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0181 []byte
				var zb0182 int
				zb0182, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationID")
					return
				}
				if zb0182 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0182), uint64(maxBitmaskSize))
					return
				}
				zb0181, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskApplicationID))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationID")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskApplicationID = bitmask(zb0181)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0183 int
			zb0183, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OnCompletion")
				return
			}
			if zb0183 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0183), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).encodedApplicationCallTxnFields.OnCompletion, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedApplicationCallTxnFields.OnCompletion)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OnCompletion")
				return
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0184 []byte
				var zb0185 int
				zb0185, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskOnCompletion")
					return
				}
				if zb0185 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0185), uint64(maxBitmaskSize))
					return
				}
				zb0184, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskOnCompletion))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskOnCompletion")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskOnCompletion = bitmask(zb0184)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0186 int
			var zb0187 bool
			zb0186, zb0187, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs")
				return
			}
			if zb0186 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0186), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs")
				return
			}
			if zb0187 {
				(*z).encodedApplicationCallTxnFields.ApplicationArgs = nil
			} else if (*z).encodedApplicationCallTxnFields.ApplicationArgs != nil && cap((*z).encodedApplicationCallTxnFields.ApplicationArgs) >= zb0186 {
				(*z).encodedApplicationCallTxnFields.ApplicationArgs = ((*z).encodedApplicationCallTxnFields.ApplicationArgs)[:zb0186]
			} else {
				(*z).encodedApplicationCallTxnFields.ApplicationArgs = make([]applicationArgs, zb0186)
			}
			for zb0020 := range (*z).encodedApplicationCallTxnFields.ApplicationArgs {
				var zb0188 int
				var zb0189 bool
				zb0188, zb0189, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs", zb0020)
					return
				}
				if zb0188 > transactions.EncodedMaxApplicationArgs {
					err = msgp.ErrOverflow(uint64(zb0188), uint64(transactions.EncodedMaxApplicationArgs))
					err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs", zb0020)
					return
				}
				if zb0189 {
					(*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] = nil
				} else if (*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] != nil && cap((*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020]) >= zb0188 {
					(*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] = ((*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020])[:zb0188]
				} else {
					(*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] = make(applicationArgs, zb0188)
				}
				for zb0021 := range (*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] {
					(*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020][zb0021], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020][zb0021])
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs", zb0020, zb0021)
						return
					}
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0190 []byte
				var zb0191 int
				zb0191, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationArgs")
					return
				}
				if zb0191 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0191), uint64(maxBitmaskSize))
					return
				}
				zb0190, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskApplicationArgs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationArgs")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskApplicationArgs = bitmask(zb0190)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0192 int
			var zb0193 bool
			zb0192, zb0193, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Accounts")
				return
			}
			if zb0192 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0192), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Accounts")
				return
			}
			if zb0193 {
				(*z).encodedApplicationCallTxnFields.Accounts = nil
			} else if (*z).encodedApplicationCallTxnFields.Accounts != nil && cap((*z).encodedApplicationCallTxnFields.Accounts) >= zb0192 {
				(*z).encodedApplicationCallTxnFields.Accounts = ((*z).encodedApplicationCallTxnFields.Accounts)[:zb0192]
			} else {
				(*z).encodedApplicationCallTxnFields.Accounts = make([]addresses, zb0192)
			}
			for zb0022 := range (*z).encodedApplicationCallTxnFields.Accounts {
				var zb0194 int
				var zb0195 bool
				zb0194, zb0195, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Accounts", zb0022)
					return
				}
				if zb0194 > transactions.EncodedMaxAccounts {
					err = msgp.ErrOverflow(uint64(zb0194), uint64(transactions.EncodedMaxAccounts))
					err = msgp.WrapError(err, "struct-from-array", "Accounts", zb0022)
					return
				}
				if zb0195 {
					(*z).encodedApplicationCallTxnFields.Accounts[zb0022] = nil
				} else if (*z).encodedApplicationCallTxnFields.Accounts[zb0022] != nil && cap((*z).encodedApplicationCallTxnFields.Accounts[zb0022]) >= zb0194 {
					(*z).encodedApplicationCallTxnFields.Accounts[zb0022] = ((*z).encodedApplicationCallTxnFields.Accounts[zb0022])[:zb0194]
				} else {
					(*z).encodedApplicationCallTxnFields.Accounts[zb0022] = make(addresses, zb0194)
				}
				for zb0023 := range (*z).encodedApplicationCallTxnFields.Accounts[zb0022] {
					bts, err = (*z).encodedApplicationCallTxnFields.Accounts[zb0022][zb0023].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Accounts", zb0022, zb0023)
						return
					}
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0196 []byte
				var zb0197 int
				zb0197, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAccounts")
					return
				}
				if zb0197 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0197), uint64(maxBitmaskSize))
					return
				}
				zb0196, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskAccounts))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAccounts")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskAccounts = bitmask(zb0196)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0198 int
			var zb0199 bool
			zb0198, zb0199, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ForeignApps")
				return
			}
			if zb0198 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0198), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ForeignApps")
				return
			}
			if zb0199 {
				(*z).encodedApplicationCallTxnFields.ForeignApps = nil
			} else if (*z).encodedApplicationCallTxnFields.ForeignApps != nil && cap((*z).encodedApplicationCallTxnFields.ForeignApps) >= zb0198 {
				(*z).encodedApplicationCallTxnFields.ForeignApps = ((*z).encodedApplicationCallTxnFields.ForeignApps)[:zb0198]
			} else {
				(*z).encodedApplicationCallTxnFields.ForeignApps = make([]appIndices, zb0198)
			}
			for zb0024 := range (*z).encodedApplicationCallTxnFields.ForeignApps {
				var zb0200 int
				var zb0201 bool
				zb0200, zb0201, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ForeignApps", zb0024)
					return
				}
				if zb0200 > transactions.EncodedMaxForeignApps {
					err = msgp.ErrOverflow(uint64(zb0200), uint64(transactions.EncodedMaxForeignApps))
					err = msgp.WrapError(err, "struct-from-array", "ForeignApps", zb0024)
					return
				}
				if zb0201 {
					(*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] = nil
				} else if (*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] != nil && cap((*z).encodedApplicationCallTxnFields.ForeignApps[zb0024]) >= zb0200 {
					(*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] = ((*z).encodedApplicationCallTxnFields.ForeignApps[zb0024])[:zb0200]
				} else {
					(*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] = make(appIndices, zb0200)
				}
				for zb0025 := range (*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] {
					bts, err = (*z).encodedApplicationCallTxnFields.ForeignApps[zb0024][zb0025].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ForeignApps", zb0024, zb0025)
						return
					}
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0202 []byte
				var zb0203 int
				zb0203, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignApps")
					return
				}
				if zb0203 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0203), uint64(maxBitmaskSize))
					return
				}
				zb0202, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskForeignApps))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignApps")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskForeignApps = bitmask(zb0202)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0204 int
			var zb0205 bool
			zb0204, zb0205, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ForeignAssets")
				return
			}
			if zb0204 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0204), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ForeignAssets")
				return
			}
			if zb0205 {
				(*z).encodedApplicationCallTxnFields.ForeignAssets = nil
			} else if (*z).encodedApplicationCallTxnFields.ForeignAssets != nil && cap((*z).encodedApplicationCallTxnFields.ForeignAssets) >= zb0204 {
				(*z).encodedApplicationCallTxnFields.ForeignAssets = ((*z).encodedApplicationCallTxnFields.ForeignAssets)[:zb0204]
			} else {
				(*z).encodedApplicationCallTxnFields.ForeignAssets = make([]assetIndices, zb0204)
			}
			for zb0026 := range (*z).encodedApplicationCallTxnFields.ForeignAssets {
				var zb0206 int
				var zb0207 bool
				zb0206, zb0207, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ForeignAssets", zb0026)
					return
				}
				if zb0206 > transactions.EncodedMaxForeignAssets {
					err = msgp.ErrOverflow(uint64(zb0206), uint64(transactions.EncodedMaxForeignAssets))
					err = msgp.WrapError(err, "struct-from-array", "ForeignAssets", zb0026)
					return
				}
				if zb0207 {
					(*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] = nil
				} else if (*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] != nil && cap((*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026]) >= zb0206 {
					(*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] = ((*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026])[:zb0206]
				} else {
					(*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] = make(assetIndices, zb0206)
				}
				for zb0027 := range (*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] {
					bts, err = (*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026][zb0027].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ForeignAssets", zb0026, zb0027)
						return
					}
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0208 []byte
				var zb0209 int
				zb0209, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignAssets")
					return
				}
				if zb0209 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0209), uint64(maxBitmaskSize))
					return
				}
				zb0208, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskForeignAssets))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignAssets")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskForeignAssets = bitmask(zb0208)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0210 int
			var zb0211 bool
			zb0210, zb0211, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LocalNumUint")
				return
			}
			if zb0210 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0210), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LocalNumUint")
				return
			}
			if zb0211 {
				(*z).encodedApplicationCallTxnFields.LocalNumUint = nil
			} else if (*z).encodedApplicationCallTxnFields.LocalNumUint != nil && cap((*z).encodedApplicationCallTxnFields.LocalNumUint) >= zb0210 {
				(*z).encodedApplicationCallTxnFields.LocalNumUint = ((*z).encodedApplicationCallTxnFields.LocalNumUint)[:zb0210]
			} else {
				(*z).encodedApplicationCallTxnFields.LocalNumUint = make([]uint64, zb0210)
			}
			for zb0028 := range (*z).encodedApplicationCallTxnFields.LocalNumUint {
				(*z).encodedApplicationCallTxnFields.LocalNumUint[zb0028], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LocalNumUint", zb0028)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0212 []byte
				var zb0213 int
				zb0213, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumUint")
					return
				}
				if zb0213 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0213), uint64(maxBitmaskSize))
					return
				}
				zb0212, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskLocalNumUint))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumUint")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskLocalNumUint = bitmask(zb0212)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0214 int
			var zb0215 bool
			zb0214, zb0215, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LocalNumByteSlice")
				return
			}
			if zb0214 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0214), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LocalNumByteSlice")
				return
			}
			if zb0215 {
				(*z).encodedApplicationCallTxnFields.LocalNumByteSlice = nil
			} else if (*z).encodedApplicationCallTxnFields.LocalNumByteSlice != nil && cap((*z).encodedApplicationCallTxnFields.LocalNumByteSlice) >= zb0214 {
				(*z).encodedApplicationCallTxnFields.LocalNumByteSlice = ((*z).encodedApplicationCallTxnFields.LocalNumByteSlice)[:zb0214]
			} else {
				(*z).encodedApplicationCallTxnFields.LocalNumByteSlice = make([]uint64, zb0214)
			}
			for zb0029 := range (*z).encodedApplicationCallTxnFields.LocalNumByteSlice {
				(*z).encodedApplicationCallTxnFields.LocalNumByteSlice[zb0029], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LocalNumByteSlice", zb0029)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0216 []byte
				var zb0217 int
				zb0217, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumByteSlice")
					return
				}
				if zb0217 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0217), uint64(maxBitmaskSize))
					return
				}
				zb0216, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumByteSlice")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice = bitmask(zb0216)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0218 int
			var zb0219 bool
			zb0218, zb0219, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumUint")
				return
			}
			if zb0218 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0218), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumUint")
				return
			}
			if zb0219 {
				(*z).encodedApplicationCallTxnFields.GlobalNumUint = nil
			} else if (*z).encodedApplicationCallTxnFields.GlobalNumUint != nil && cap((*z).encodedApplicationCallTxnFields.GlobalNumUint) >= zb0218 {
				(*z).encodedApplicationCallTxnFields.GlobalNumUint = ((*z).encodedApplicationCallTxnFields.GlobalNumUint)[:zb0218]
			} else {
				(*z).encodedApplicationCallTxnFields.GlobalNumUint = make([]uint64, zb0218)
			}
			for zb0030 := range (*z).encodedApplicationCallTxnFields.GlobalNumUint {
				(*z).encodedApplicationCallTxnFields.GlobalNumUint[zb0030], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "GlobalNumUint", zb0030)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0220 []byte
				var zb0221 int
				zb0221, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumUint")
					return
				}
				if zb0221 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0221), uint64(maxBitmaskSize))
					return
				}
				zb0220, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskGlobalNumUint))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumUint")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskGlobalNumUint = bitmask(zb0220)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0222 int
			var zb0223 bool
			zb0222, zb0223, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumByteSlice")
				return
			}
			if zb0222 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0222), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumByteSlice")
				return
			}
			if zb0223 {
				(*z).encodedApplicationCallTxnFields.GlobalNumByteSlice = nil
			} else if (*z).encodedApplicationCallTxnFields.GlobalNumByteSlice != nil && cap((*z).encodedApplicationCallTxnFields.GlobalNumByteSlice) >= zb0222 {
				(*z).encodedApplicationCallTxnFields.GlobalNumByteSlice = ((*z).encodedApplicationCallTxnFields.GlobalNumByteSlice)[:zb0222]
			} else {
				(*z).encodedApplicationCallTxnFields.GlobalNumByteSlice = make([]uint64, zb0222)
			}
			for zb0031 := range (*z).encodedApplicationCallTxnFields.GlobalNumByteSlice {
				(*z).encodedApplicationCallTxnFields.GlobalNumByteSlice[zb0031], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "GlobalNumByteSlice", zb0031)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0224 []byte
				var zb0225 int
				zb0225, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumByteSlice")
					return
				}
				if zb0225 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0225), uint64(maxBitmaskSize))
					return
				}
				zb0224, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumByteSlice")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice = bitmask(zb0224)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0226 int
			var zb0227 bool
			zb0226, zb0227, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram")
				return
			}
			if zb0226 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0226), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram")
				return
			}
			if zb0227 {
				(*z).encodedApplicationCallTxnFields.ApprovalProgram = nil
			} else if (*z).encodedApplicationCallTxnFields.ApprovalProgram != nil && cap((*z).encodedApplicationCallTxnFields.ApprovalProgram) >= zb0226 {
				(*z).encodedApplicationCallTxnFields.ApprovalProgram = ((*z).encodedApplicationCallTxnFields.ApprovalProgram)[:zb0226]
			} else {
				(*z).encodedApplicationCallTxnFields.ApprovalProgram = make([]program, zb0226)
			}
			for zb0032 := range (*z).encodedApplicationCallTxnFields.ApprovalProgram {
				{
					var zb0228 []byte
					var zb0229 int
					zb0229, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram", zb0032)
						return
					}
					if zb0229 > config.MaxAvailableAppProgramLen {
						err = msgp.ErrOverflow(uint64(zb0229), uint64(config.MaxAvailableAppProgramLen))
						return
					}
					zb0228, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.ApprovalProgram[zb0032]))
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram", zb0032)
						return
					}
					(*z).encodedApplicationCallTxnFields.ApprovalProgram[zb0032] = program(zb0228)
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0230 []byte
				var zb0231 int
				zb0231, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApprovalProgram")
					return
				}
				if zb0231 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0231), uint64(maxBitmaskSize))
					return
				}
				zb0230, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskApprovalProgram))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApprovalProgram")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskApprovalProgram = bitmask(zb0230)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0232 int
			var zb0233 bool
			zb0232, zb0233, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram")
				return
			}
			if zb0232 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0232), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram")
				return
			}
			if zb0233 {
				(*z).encodedApplicationCallTxnFields.ClearStateProgram = nil
			} else if (*z).encodedApplicationCallTxnFields.ClearStateProgram != nil && cap((*z).encodedApplicationCallTxnFields.ClearStateProgram) >= zb0232 {
				(*z).encodedApplicationCallTxnFields.ClearStateProgram = ((*z).encodedApplicationCallTxnFields.ClearStateProgram)[:zb0232]
			} else {
				(*z).encodedApplicationCallTxnFields.ClearStateProgram = make([]program, zb0232)
			}
			for zb0033 := range (*z).encodedApplicationCallTxnFields.ClearStateProgram {
				{
					var zb0234 []byte
					var zb0235 int
					zb0235, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram", zb0033)
						return
					}
					if zb0235 > config.MaxAvailableAppProgramLen {
						err = msgp.ErrOverflow(uint64(zb0235), uint64(config.MaxAvailableAppProgramLen))
						return
					}
					zb0234, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.ClearStateProgram[zb0033]))
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram", zb0033)
						return
					}
					(*z).encodedApplicationCallTxnFields.ClearStateProgram[zb0033] = program(zb0234)
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0236 []byte
				var zb0237 int
				zb0237, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClearStateProgram")
					return
				}
				if zb0237 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0237), uint64(maxBitmaskSize))
					return
				}
				zb0236, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskClearStateProgram))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClearStateProgram")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskClearStateProgram = bitmask(zb0236)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0238 int
			var zb0239 bool
			zb0238, zb0239, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ExtraProgramPages")
				return
			}
			if zb0238 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0238), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ExtraProgramPages")
				return
			}
			if zb0239 {
				(*z).encodedApplicationCallTxnFields.ExtraProgramPages = nil
			} else if (*z).encodedApplicationCallTxnFields.ExtraProgramPages != nil && cap((*z).encodedApplicationCallTxnFields.ExtraProgramPages) >= zb0238 {
				(*z).encodedApplicationCallTxnFields.ExtraProgramPages = ((*z).encodedApplicationCallTxnFields.ExtraProgramPages)[:zb0238]
			} else {
				(*z).encodedApplicationCallTxnFields.ExtraProgramPages = make([]uint32, zb0238)
			}
			for zb0034 := range (*z).encodedApplicationCallTxnFields.ExtraProgramPages {
				(*z).encodedApplicationCallTxnFields.ExtraProgramPages[zb0034], bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ExtraProgramPages", zb0034)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0240 []byte
				var zb0241 int
				zb0241, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskExtraProgramPages")
					return
				}
				if zb0241 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0241), uint64(maxBitmaskSize))
					return
				}
				zb0240, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskExtraProgramPages))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskExtraProgramPages")
					return
				}
				(*z).encodedApplicationCallTxnFields.BitmaskExtraProgramPages = bitmask(zb0240)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0242 int
			var zb0243 bool
			zb0242, zb0243, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CertRound")
				return
			}
			if zb0242 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0242), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "CertRound")
				return
			}
			if zb0243 {
				(*z).encodedCompactCertTxnFields.CertRound = nil
			} else if (*z).encodedCompactCertTxnFields.CertRound != nil && cap((*z).encodedCompactCertTxnFields.CertRound) >= zb0242 {
				(*z).encodedCompactCertTxnFields.CertRound = ((*z).encodedCompactCertTxnFields.CertRound)[:zb0242]
			} else {
				(*z).encodedCompactCertTxnFields.CertRound = make([]basics.Round, zb0242)
			}
			for zb0035 := range (*z).encodedCompactCertTxnFields.CertRound {
				bts, err = (*z).encodedCompactCertTxnFields.CertRound[zb0035].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CertRound", zb0035)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0244 []byte
				var zb0245 int
				zb0245, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertRound")
					return
				}
				if zb0245 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0245), uint64(maxBitmaskSize))
					return
				}
				zb0244, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.BitmaskCertRound))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertRound")
					return
				}
				(*z).encodedCompactCertTxnFields.BitmaskCertRound = bitmask(zb0244)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0246 int
			var zb0247 bool
			zb0246, zb0247, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CertType")
				return
			}
			if zb0246 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0246), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "CertType")
				return
			}
			if zb0247 {
				(*z).encodedCompactCertTxnFields.CertType = nil
			} else if (*z).encodedCompactCertTxnFields.CertType != nil && cap((*z).encodedCompactCertTxnFields.CertType) >= zb0246 {
				(*z).encodedCompactCertTxnFields.CertType = ((*z).encodedCompactCertTxnFields.CertType)[:zb0246]
			} else {
				(*z).encodedCompactCertTxnFields.CertType = make([]protocol.CompactCertType, zb0246)
			}
			for zb0036 := range (*z).encodedCompactCertTxnFields.CertType {
				bts, err = (*z).encodedCompactCertTxnFields.CertType[zb0036].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CertType", zb0036)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0248 []byte
				var zb0249 int
				zb0249, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertType")
					return
				}
				if zb0249 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0249), uint64(maxBitmaskSize))
					return
				}
				zb0248, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.BitmaskCertType))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertType")
					return
				}
				(*z).encodedCompactCertTxnFields.BitmaskCertType = bitmask(zb0248)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0250 int
			var zb0251 bool
			zb0250, zb0251, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigCommit")
				return
			}
			if zb0250 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0250), uint64(maxAddressBytes))
				err = msgp.WrapError(err, "struct-from-array", "SigCommit")
				return
			}
			if zb0251 {
				(*z).encodedCompactCertTxnFields.encodedCert.SigCommit = nil
			} else if (*z).encodedCompactCertTxnFields.encodedCert.SigCommit != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.SigCommit) >= zb0250 {
				(*z).encodedCompactCertTxnFields.encodedCert.SigCommit = ((*z).encodedCompactCertTxnFields.encodedCert.SigCommit)[:zb0250]
			} else {
				(*z).encodedCompactCertTxnFields.encodedCert.SigCommit = make([]crypto.GenericDigest, zb0250)
			}
			for zb0037 := range (*z).encodedCompactCertTxnFields.encodedCert.SigCommit {
				bts, err = (*z).encodedCompactCertTxnFields.encodedCert.SigCommit[zb0037].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigCommit", zb0037)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0252 []byte
				var zb0253 int
				zb0253, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigCommit")
					return
				}
				if zb0253 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0253), uint64(maxBitmaskSize))
					return
				}
				zb0252, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigCommit")
					return
				}
				(*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit = bitmask(zb0252)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0254 int
			var zb0255 bool
			zb0254, zb0255, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SignedWeight")
				return
			}
			if zb0254 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0254), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SignedWeight")
				return
			}
			if zb0255 {
				(*z).encodedCompactCertTxnFields.encodedCert.SignedWeight = nil
			} else if (*z).encodedCompactCertTxnFields.encodedCert.SignedWeight != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.SignedWeight) >= zb0254 {
				(*z).encodedCompactCertTxnFields.encodedCert.SignedWeight = ((*z).encodedCompactCertTxnFields.encodedCert.SignedWeight)[:zb0254]
			} else {
				(*z).encodedCompactCertTxnFields.encodedCert.SignedWeight = make([]uint64, zb0254)
			}
			for zb0038 := range (*z).encodedCompactCertTxnFields.encodedCert.SignedWeight {
				(*z).encodedCompactCertTxnFields.encodedCert.SignedWeight[zb0038], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedWeight", zb0038)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0256 []byte
				var zb0257 int
				zb0257, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSignedWeight")
					return
				}
				if zb0257 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0257), uint64(maxBitmaskSize))
					return
				}
				zb0256, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSignedWeight")
					return
				}
				(*z).encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight = bitmask(zb0256)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0258 int
			var zb0259 bool
			zb0258, zb0259, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigProofs")
				return
			}
			if zb0258 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0258), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SigProofs")
				return
			}
			if zb0259 {
				(*z).encodedCompactCertTxnFields.encodedCert.SigProofs = nil
			} else if (*z).encodedCompactCertTxnFields.encodedCert.SigProofs != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.SigProofs) >= zb0258 {
				(*z).encodedCompactCertTxnFields.encodedCert.SigProofs = ((*z).encodedCompactCertTxnFields.encodedCert.SigProofs)[:zb0258]
			} else {
				(*z).encodedCompactCertTxnFields.encodedCert.SigProofs = make([]certProofs, zb0258)
			}
			for zb0039 := range (*z).encodedCompactCertTxnFields.encodedCert.SigProofs {
				var zb0260 int
				var zb0261 bool
				zb0260, zb0261, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0039)
					return
				}
				if zb0260 > compactcert.MaxProofDigests {
					err = msgp.ErrOverflow(uint64(zb0260), uint64(compactcert.MaxProofDigests))
					err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0039)
					return
				}
				if zb0261 {
					(*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] = nil
				} else if (*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039]) >= zb0260 {
					(*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] = ((*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039])[:zb0260]
				} else {
					(*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] = make(certProofs, zb0260)
				}
				for zb0040 := range (*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] {
					bts, err = (*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039][zb0040].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0039, zb0040)
						return
					}
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0262 []byte
				var zb0263 int
				zb0263, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigProofs")
					return
				}
				if zb0263 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0263), uint64(maxBitmaskSize))
					return
				}
				zb0262, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigProofs")
					return
				}
				(*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs = bitmask(zb0262)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0264 int
			var zb0265 bool
			zb0264, zb0265, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes")
				return
			}
			if zb0264 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0264), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes")
				return
			}
			if zb0265 {
				(*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = nil
			} else if (*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) >= zb0264 {
				(*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = ((*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes)[:zb0264]
			} else {
				(*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = make([]uint64, zb0264)
			}
			for zb0041 := range (*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes {
				(*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes[zb0041], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes", zb0041)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0266 []byte
				var zb0267 int
				zb0267, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigsHash")
					return
				}
				if zb0267 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0267), uint64(maxBitmaskSize))
					return
				}
				zb0266, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigsHash")
					return
				}
				(*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash = bitmask(zb0266)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0268 int
			var zb0269 bool
			zb0268, zb0269, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PartProofs")
				return
			}
			if zb0268 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0268), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "PartProofs")
				return
			}
			if zb0269 {
				(*z).encodedCompactCertTxnFields.encodedCert.PartProofs = nil
			} else if (*z).encodedCompactCertTxnFields.encodedCert.PartProofs != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.PartProofs) >= zb0268 {
				(*z).encodedCompactCertTxnFields.encodedCert.PartProofs = ((*z).encodedCompactCertTxnFields.encodedCert.PartProofs)[:zb0268]
			} else {
				(*z).encodedCompactCertTxnFields.encodedCert.PartProofs = make([]certProofs, zb0268)
			}
			for zb0042 := range (*z).encodedCompactCertTxnFields.encodedCert.PartProofs {
				var zb0270 int
				var zb0271 bool
				zb0270, zb0271, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0042)
					return
				}
				if zb0270 > compactcert.MaxProofDigests {
					err = msgp.ErrOverflow(uint64(zb0270), uint64(compactcert.MaxProofDigests))
					err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0042)
					return
				}
				if zb0271 {
					(*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] = nil
				} else if (*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042]) >= zb0270 {
					(*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] = ((*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042])[:zb0270]
				} else {
					(*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] = make(certProofs, zb0270)
				}
				for zb0043 := range (*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] {
					bts, err = (*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042][zb0043].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0042, zb0043)
						return
					}
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0272 []byte
				var zb0273 int
				zb0273, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartProofs")
					return
				}
				if zb0273 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0273), uint64(maxBitmaskSize))
					return
				}
				zb0272, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartProofs")
					return
				}
				(*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs = bitmask(zb0272)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0274 int
			var zb0275 bool
			zb0274, zb0275, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes")
				return
			}
			if zb0274 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0274), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes")
				return
			}
			if zb0275 {
				(*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = nil
			} else if (*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) >= zb0274 {
				(*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = ((*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes)[:zb0274]
			} else {
				(*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = make([]uint64, zb0274)
			}
			for zb0044 := range (*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes {
				(*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes[zb0044], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes", zb0044)
					return
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0276 []byte
				var zb0277 int
				zb0277, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartHash")
					return
				}
				if zb0277 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0277), uint64(maxBitmaskSize))
					return
				}
				zb0276, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartHash")
					return
				}
				(*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartHash = bitmask(zb0276)
			}
		}
		if zb0048 > 0 {
			zb0048--
			var zb0278 int
			var zb0279 bool
			zb0278, zb0279, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reveals")
				return
			}
			if zb0278 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0278), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Reveals")
				return
			}
			if zb0279 {
				(*z).encodedCompactCertTxnFields.encodedCert.Reveals = nil
			} else if (*z).encodedCompactCertTxnFields.encodedCert.Reveals != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.Reveals) >= zb0278 {
				(*z).encodedCompactCertTxnFields.encodedCert.Reveals = ((*z).encodedCompactCertTxnFields.encodedCert.Reveals)[:zb0278]
			} else {
				(*z).encodedCompactCertTxnFields.encodedCert.Reveals = make([]revealMap, zb0278)
			}
			for zb0045 := range (*z).encodedCompactCertTxnFields.encodedCert.Reveals {
				var zb0280 int
				var zb0281 bool
				zb0280, zb0281, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0045)
					return
				}
				if zb0280 > compactcert.MaxReveals {
					err = msgp.ErrOverflow(uint64(zb0280), uint64(compactcert.MaxReveals))
					err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0045)
					return
				}
				if zb0281 {
					(*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045] = nil
				} else if (*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045] == nil {
					(*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045] = make(revealMap, zb0280)
				}
				for zb0280 > 0 {
					var zb0046 uint64
					var zb0047 compactcert.Reveal
					zb0280--
					zb0046, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0045)
						return
					}
					bts, err = zb0047.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0045, zb0046)
						return
					}
					(*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045][zb0046] = zb0047
				}
			}
		}
		if zb0048 > 0 {
			zb0048--
			{
				var zb0282 []byte
				var zb0283 int
				zb0283, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReveals")
					return
				}
				if zb0283 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0283), uint64(maxBitmaskSize))
					return
				}
				zb0282, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskReveals))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReveals")
					return
				}
				(*z).encodedCompactCertTxnFields.encodedCert.BitmaskReveals = bitmask(zb0282)
			}
		}
		if zb0048 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0048)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0049 {
			(*z) = encodedTxns{}
		}
		for zb0048 > 0 {
			zb0048--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "type":
				var zb0284 int
				zb0284, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
				if zb0284 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0284), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).TxType, bts, err = msgp.ReadBytesBytes(bts, (*z).TxType)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
			case "typebm":
				{
					var zb0285 []byte
					var zb0286 int
					zb0286, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTxType")
						return
					}
					if zb0286 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0286), uint64(maxBitmaskSize))
						return
					}
					zb0285, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskTxType))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTxType")
						return
					}
					(*z).BitmaskTxType = bitmask(zb0285)
				}
			case "typeo":
				(*z).TxTypeOffset, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxTypeOffset")
					return
				}
			case "snd":
				var zb0287 int
				zb0287, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				if zb0287 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0287), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxnHeaders.Sender, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxnHeaders.Sender)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "sndbm":
				{
					var zb0288 []byte
					var zb0289 int
					zb0289, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSender")
						return
					}
					if zb0289 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0289), uint64(maxBitmaskSize))
						return
					}
					zb0288, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskSender))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSender")
						return
					}
					(*z).encodedTxnHeaders.BitmaskSender = bitmask(zb0288)
				}
			case "fee":
				var zb0290 int
				var zb0291 bool
				zb0290, zb0291, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0290 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0290), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0291 {
					(*z).encodedTxnHeaders.Fee = nil
				} else if (*z).encodedTxnHeaders.Fee != nil && cap((*z).encodedTxnHeaders.Fee) >= zb0290 {
					(*z).encodedTxnHeaders.Fee = ((*z).encodedTxnHeaders.Fee)[:zb0290]
				} else {
					(*z).encodedTxnHeaders.Fee = make([]basics.MicroAlgos, zb0290)
				}
				for zb0001 := range (*z).encodedTxnHeaders.Fee {
					bts, err = (*z).encodedTxnHeaders.Fee[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Fee", zb0001)
						return
					}
				}
			case "feebm":
				{
					var zb0292 []byte
					var zb0293 int
					zb0293, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFee")
						return
					}
					if zb0293 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0293), uint64(maxBitmaskSize))
						return
					}
					zb0292, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskFee))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFee")
						return
					}
					(*z).encodedTxnHeaders.BitmaskFee = bitmask(zb0292)
				}
			case "fv":
				var zb0294 int
				var zb0295 bool
				zb0294, zb0295, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0294 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0294), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0295 {
					(*z).encodedTxnHeaders.FirstValid = nil
				} else if (*z).encodedTxnHeaders.FirstValid != nil && cap((*z).encodedTxnHeaders.FirstValid) >= zb0294 {
					(*z).encodedTxnHeaders.FirstValid = ((*z).encodedTxnHeaders.FirstValid)[:zb0294]
				} else {
					(*z).encodedTxnHeaders.FirstValid = make([]basics.Round, zb0294)
				}
				for zb0002 := range (*z).encodedTxnHeaders.FirstValid {
					bts, err = (*z).encodedTxnHeaders.FirstValid[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "FirstValid", zb0002)
						return
					}
				}
			case "fvbm":
				{
					var zb0296 []byte
					var zb0297 int
					zb0297, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFirstValid")
						return
					}
					if zb0297 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0297), uint64(maxBitmaskSize))
						return
					}
					zb0296, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskFirstValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFirstValid")
						return
					}
					(*z).encodedTxnHeaders.BitmaskFirstValid = bitmask(zb0296)
				}
			case "lv":
				var zb0298 int
				var zb0299 bool
				zb0298, zb0299, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0298 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0298), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0299 {
					(*z).encodedTxnHeaders.LastValid = nil
				} else if (*z).encodedTxnHeaders.LastValid != nil && cap((*z).encodedTxnHeaders.LastValid) >= zb0298 {
					(*z).encodedTxnHeaders.LastValid = ((*z).encodedTxnHeaders.LastValid)[:zb0298]
				} else {
					(*z).encodedTxnHeaders.LastValid = make([]basics.Round, zb0298)
				}
				for zb0003 := range (*z).encodedTxnHeaders.LastValid {
					bts, err = (*z).encodedTxnHeaders.LastValid[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastValid", zb0003)
						return
					}
				}
			case "lvbm":
				{
					var zb0300 []byte
					var zb0301 int
					zb0301, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLastValid")
						return
					}
					if zb0301 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0301), uint64(maxBitmaskSize))
						return
					}
					zb0300, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskLastValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLastValid")
						return
					}
					(*z).encodedTxnHeaders.BitmaskLastValid = bitmask(zb0300)
				}
			case "note":
				var zb0302 int
				var zb0303 bool
				zb0302, zb0303, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0302 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0302), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0303 {
					(*z).encodedTxnHeaders.Note = nil
				} else if (*z).encodedTxnHeaders.Note != nil && cap((*z).encodedTxnHeaders.Note) >= zb0302 {
					(*z).encodedTxnHeaders.Note = ((*z).encodedTxnHeaders.Note)[:zb0302]
				} else {
					(*z).encodedTxnHeaders.Note = make([][]byte, zb0302)
				}
				for zb0004 := range (*z).encodedTxnHeaders.Note {
					var zb0304 int
					zb0304, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "Note", zb0004)
						return
					}
					if zb0304 > config.MaxTxnNoteBytes {
						err = msgp.ErrOverflow(uint64(zb0304), uint64(config.MaxTxnNoteBytes))
						return
					}
					(*z).encodedTxnHeaders.Note[zb0004], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxnHeaders.Note[zb0004])
					if err != nil {
						err = msgp.WrapError(err, "Note", zb0004)
						return
					}
				}
			case "notebm":
				{
					var zb0305 []byte
					var zb0306 int
					zb0306, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNote")
						return
					}
					if zb0306 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0306), uint64(maxBitmaskSize))
						return
					}
					zb0305, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskNote))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNote")
						return
					}
					(*z).encodedTxnHeaders.BitmaskNote = bitmask(zb0305)
				}
			case "genbm":
				{
					var zb0307 []byte
					var zb0308 int
					zb0308, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisID")
						return
					}
					if zb0308 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0308), uint64(maxBitmaskSize))
						return
					}
					zb0307, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskGenesisID))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisID")
						return
					}
					(*z).encodedTxnHeaders.BitmaskGenesisID = bitmask(zb0307)
				}
			case "grpbm":
				{
					var zb0309 []byte
					var zb0310 int
					zb0310, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGroup")
						return
					}
					if zb0310 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0310), uint64(maxBitmaskSize))
						return
					}
					zb0309, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskGroup))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGroup")
						return
					}
					(*z).encodedTxnHeaders.BitmaskGroup = bitmask(zb0309)
				}
			case "lx":
				var zb0311 int
				zb0311, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
				if zb0311 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0311), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxnHeaders.Lease, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxnHeaders.Lease)
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
			case "lxbm":
				{
					var zb0312 []byte
					var zb0313 int
					zb0313, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLease")
						return
					}
					if zb0313 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0313), uint64(maxBitmaskSize))
						return
					}
					zb0312, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskLease))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLease")
						return
					}
					(*z).encodedTxnHeaders.BitmaskLease = bitmask(zb0312)
				}
			case "rekey":
				var zb0314 int
				zb0314, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
				if zb0314 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0314), uint64(maxAddressBytes))
					return
				}
				(*z).encodedTxnHeaders.RekeyTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxnHeaders.RekeyTo)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
			case "rekeybm":
				{
					var zb0315 []byte
					var zb0316 int
					zb0316, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskRekeyTo")
						return
					}
					if zb0316 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0316), uint64(maxBitmaskSize))
						return
					}
					zb0315, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskRekeyTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskRekeyTo")
						return
					}
					(*z).encodedTxnHeaders.BitmaskRekeyTo = bitmask(zb0315)
				}
			case "votekey":
				var zb0317 int
				zb0317, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
				if zb0317 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0317), uint64(maxAddressBytes))
					return
				}
				(*z).encodedKeyregTxnFields.VotePK, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedKeyregTxnFields.VotePK)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
			case "selkey":
				var zb0318 int
				zb0318, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
				if zb0318 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0318), uint64(maxAddressBytes))
					return
				}
				(*z).encodedKeyregTxnFields.SelectionPK, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedKeyregTxnFields.SelectionPK)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
			case "votefst":
				var zb0319 int
				var zb0320 bool
				zb0319, zb0320, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0319 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0319), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0320 {
					(*z).encodedKeyregTxnFields.VoteFirst = nil
				} else if (*z).encodedKeyregTxnFields.VoteFirst != nil && cap((*z).encodedKeyregTxnFields.VoteFirst) >= zb0319 {
					(*z).encodedKeyregTxnFields.VoteFirst = ((*z).encodedKeyregTxnFields.VoteFirst)[:zb0319]
				} else {
					(*z).encodedKeyregTxnFields.VoteFirst = make([]basics.Round, zb0319)
				}
				for zb0005 := range (*z).encodedKeyregTxnFields.VoteFirst {
					bts, err = (*z).encodedKeyregTxnFields.VoteFirst[zb0005].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteFirst", zb0005)
						return
					}
				}
			case "votefstbm":
				{
					var zb0321 []byte
					var zb0322 int
					zb0322, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteFirst")
						return
					}
					if zb0322 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0322), uint64(maxBitmaskSize))
						return
					}
					zb0321, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskVoteFirst))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteFirst")
						return
					}
					(*z).encodedKeyregTxnFields.BitmaskVoteFirst = bitmask(zb0321)
				}
			case "votelst":
				var zb0323 int
				var zb0324 bool
				zb0323, zb0324, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0323 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0323), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0324 {
					(*z).encodedKeyregTxnFields.VoteLast = nil
				} else if (*z).encodedKeyregTxnFields.VoteLast != nil && cap((*z).encodedKeyregTxnFields.VoteLast) >= zb0323 {
					(*z).encodedKeyregTxnFields.VoteLast = ((*z).encodedKeyregTxnFields.VoteLast)[:zb0323]
				} else {
					(*z).encodedKeyregTxnFields.VoteLast = make([]basics.Round, zb0323)
				}
				for zb0006 := range (*z).encodedKeyregTxnFields.VoteLast {
					bts, err = (*z).encodedKeyregTxnFields.VoteLast[zb0006].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteLast", zb0006)
						return
					}
				}
			case "votelstbm":
				{
					var zb0325 []byte
					var zb0326 int
					zb0326, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteLast")
						return
					}
					if zb0326 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0326), uint64(maxBitmaskSize))
						return
					}
					zb0325, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskVoteLast))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteLast")
						return
					}
					(*z).encodedKeyregTxnFields.BitmaskVoteLast = bitmask(zb0325)
				}
			case "votekd":
				var zb0327 int
				var zb0328 bool
				zb0327, zb0328, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0327 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0327), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0328 {
					(*z).encodedKeyregTxnFields.VoteKeyDilution = nil
				} else if (*z).encodedKeyregTxnFields.VoteKeyDilution != nil && cap((*z).encodedKeyregTxnFields.VoteKeyDilution) >= zb0327 {
					(*z).encodedKeyregTxnFields.VoteKeyDilution = ((*z).encodedKeyregTxnFields.VoteKeyDilution)[:zb0327]
				} else {
					(*z).encodedKeyregTxnFields.VoteKeyDilution = make([]uint64, zb0327)
				}
				for zb0007 := range (*z).encodedKeyregTxnFields.VoteKeyDilution {
					(*z).encodedKeyregTxnFields.VoteKeyDilution[zb0007], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteKeyDilution", zb0007)
						return
					}
				}
			case "votekbm":
				{
					var zb0329 []byte
					var zb0330 int
					zb0330, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskKeys")
						return
					}
					if zb0330 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0330), uint64(maxBitmaskSize))
						return
					}
					zb0329, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskKeys))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskKeys")
						return
					}
					(*z).encodedKeyregTxnFields.BitmaskKeys = bitmask(zb0329)
				}
			case "nonpartbm":
				{
					var zb0331 []byte
					var zb0332 int
					zb0332, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNonparticipation")
						return
					}
					if zb0332 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0332), uint64(maxBitmaskSize))
						return
					}
					zb0331, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskNonparticipation))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNonparticipation")
						return
					}
					(*z).encodedKeyregTxnFields.BitmaskNonparticipation = bitmask(zb0331)
				}
			case "vldrt":
				var zb0333 int
				var zb0334 bool
				zb0333, zb0334, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HasValidRoot")
					return
				}
				if zb0333 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0333), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "HasValidRoot")
					return
				}
				if zb0334 {
					(*z).encodedKeyregTxnFields.HasValidRoot = nil
				} else if (*z).encodedKeyregTxnFields.HasValidRoot != nil && cap((*z).encodedKeyregTxnFields.HasValidRoot) >= zb0333 {
					(*z).encodedKeyregTxnFields.HasValidRoot = ((*z).encodedKeyregTxnFields.HasValidRoot)[:zb0333]
				} else {
					(*z).encodedKeyregTxnFields.HasValidRoot = make([]bool, zb0333)
				}
				for zb0008 := range (*z).encodedKeyregTxnFields.HasValidRoot {
					(*z).encodedKeyregTxnFields.HasValidRoot[zb0008], bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "HasValidRoot", zb0008)
						return
					}
				}
			case "comt":
				var zb0335 int
				zb0335, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "CommitmentRoot")
					return
				}
				if zb0335 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0335), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).encodedKeyregTxnFields.CommitmentRoot, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedKeyregTxnFields.CommitmentRoot)
				if err != nil {
					err = msgp.WrapError(err, "CommitmentRoot")
					return
				}
			case "rcv":
				var zb0336 int
				zb0336, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
				if zb0336 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0336), uint64(maxAddressBytes))
					return
				}
				(*z).encodedPaymentTxnFields.Receiver, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedPaymentTxnFields.Receiver)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
			case "rcvbm":
				{
					var zb0337 []byte
					var zb0338 int
					zb0338, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReceiver")
						return
					}
					if zb0338 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0338), uint64(maxBitmaskSize))
						return
					}
					zb0337, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedPaymentTxnFields.BitmaskReceiver))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReceiver")
						return
					}
					(*z).encodedPaymentTxnFields.BitmaskReceiver = bitmask(zb0337)
				}
			case "amt":
				var zb0339 int
				var zb0340 bool
				zb0339, zb0340, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0339 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0339), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0340 {
					(*z).encodedPaymentTxnFields.Amount = nil
				} else if (*z).encodedPaymentTxnFields.Amount != nil && cap((*z).encodedPaymentTxnFields.Amount) >= zb0339 {
					(*z).encodedPaymentTxnFields.Amount = ((*z).encodedPaymentTxnFields.Amount)[:zb0339]
				} else {
					(*z).encodedPaymentTxnFields.Amount = make([]basics.MicroAlgos, zb0339)
				}
				for zb0009 := range (*z).encodedPaymentTxnFields.Amount {
					bts, err = (*z).encodedPaymentTxnFields.Amount[zb0009].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Amount", zb0009)
						return
					}
				}
			case "amtbm":
				{
					var zb0341 []byte
					var zb0342 int
					zb0342, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAmount")
						return
					}
					if zb0342 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0342), uint64(maxBitmaskSize))
						return
					}
					zb0341, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedPaymentTxnFields.BitmaskAmount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAmount")
						return
					}
					(*z).encodedPaymentTxnFields.BitmaskAmount = bitmask(zb0341)
				}
			case "close":
				var zb0343 int
				zb0343, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
				if zb0343 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0343), uint64(maxAddressBytes))
					return
				}
				(*z).encodedPaymentTxnFields.CloseRemainderTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedPaymentTxnFields.CloseRemainderTo)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
			case "closebm":
				{
					var zb0344 []byte
					var zb0345 int
					zb0345, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCloseRemainderTo")
						return
					}
					if zb0345 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0345), uint64(maxBitmaskSize))
						return
					}
					zb0344, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCloseRemainderTo")
						return
					}
					(*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo = bitmask(zb0344)
				}
			case "caid":
				var zb0346 int
				var zb0347 bool
				zb0346, zb0347, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ConfigAsset")
					return
				}
				if zb0346 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0346), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ConfigAsset")
					return
				}
				if zb0347 {
					(*z).encodedAssetConfigTxnFields.ConfigAsset = nil
				} else if (*z).encodedAssetConfigTxnFields.ConfigAsset != nil && cap((*z).encodedAssetConfigTxnFields.ConfigAsset) >= zb0346 {
					(*z).encodedAssetConfigTxnFields.ConfigAsset = ((*z).encodedAssetConfigTxnFields.ConfigAsset)[:zb0346]
				} else {
					(*z).encodedAssetConfigTxnFields.ConfigAsset = make([]basics.AssetIndex, zb0346)
				}
				for zb0010 := range (*z).encodedAssetConfigTxnFields.ConfigAsset {
					bts, err = (*z).encodedAssetConfigTxnFields.ConfigAsset[zb0010].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ConfigAsset", zb0010)
						return
					}
				}
			case "caidbm":
				{
					var zb0348 []byte
					var zb0349 int
					zb0349, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskConfigAsset")
						return
					}
					if zb0349 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0349), uint64(maxBitmaskSize))
						return
					}
					zb0348, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.BitmaskConfigAsset))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskConfigAsset")
						return
					}
					(*z).encodedAssetConfigTxnFields.BitmaskConfigAsset = bitmask(zb0348)
				}
			case "t":
				var zb0350 int
				var zb0351 bool
				zb0350, zb0351, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Total")
					return
				}
				if zb0350 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0350), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Total")
					return
				}
				if zb0351 {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.Total = nil
				} else if (*z).encodedAssetConfigTxnFields.encodedAssetParams.Total != nil && cap((*z).encodedAssetConfigTxnFields.encodedAssetParams.Total) >= zb0350 {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.Total = ((*z).encodedAssetConfigTxnFields.encodedAssetParams.Total)[:zb0350]
				} else {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.Total = make([]uint64, zb0350)
				}
				for zb0011 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.Total {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.Total[zb0011], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Total", zb0011)
						return
					}
				}
			case "tbm":
				{
					var zb0352 []byte
					var zb0353 int
					zb0353, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTotal")
						return
					}
					if zb0353 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0353), uint64(maxBitmaskSize))
						return
					}
					zb0352, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTotal")
						return
					}
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal = bitmask(zb0352)
				}
			case "dc":
				var zb0354 int
				var zb0355 bool
				zb0354, zb0355, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Decimals")
					return
				}
				if zb0354 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0354), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Decimals")
					return
				}
				if zb0355 {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals = nil
				} else if (*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals != nil && cap((*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals) >= zb0354 {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals = ((*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals)[:zb0354]
				} else {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals = make([]uint32, zb0354)
				}
				for zb0012 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals[zb0012], bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Decimals", zb0012)
						return
					}
				}
			case "dcbm":
				{
					var zb0356 []byte
					var zb0357 int
					zb0357, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDecimals")
						return
					}
					if zb0357 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0357), uint64(maxBitmaskSize))
						return
					}
					zb0356, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDecimals")
						return
					}
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals = bitmask(zb0356)
				}
			case "dfbm":
				{
					var zb0358 []byte
					var zb0359 int
					zb0359, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDefaultFrozen")
						return
					}
					if zb0359 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0359), uint64(maxBitmaskSize))
						return
					}
					zb0358, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDefaultFrozen")
						return
					}
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen = bitmask(zb0358)
				}
			case "un":
				var zb0360 int
				var zb0361 bool
				zb0360, zb0361, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UnitName")
					return
				}
				if zb0360 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0360), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "UnitName")
					return
				}
				if zb0361 {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName = nil
				} else if (*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName != nil && cap((*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName) >= zb0360 {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName = ((*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName)[:zb0360]
				} else {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName = make([]string, zb0360)
				}
				for zb0013 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName[zb0013], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "UnitName", zb0013)
						return
					}
				}
			case "unbm":
				{
					var zb0362 []byte
					var zb0363 int
					zb0363, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskUnitName")
						return
					}
					if zb0363 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0363), uint64(maxBitmaskSize))
						return
					}
					zb0362, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskUnitName")
						return
					}
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName = bitmask(zb0362)
				}
			case "an":
				var zb0364 int
				var zb0365 bool
				zb0364, zb0365, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetName")
					return
				}
				if zb0364 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0364), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "AssetName")
					return
				}
				if zb0365 {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName = nil
				} else if (*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName != nil && cap((*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName) >= zb0364 {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName = ((*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName)[:zb0364]
				} else {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName = make([]string, zb0364)
				}
				for zb0014 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName[zb0014], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AssetName", zb0014)
						return
					}
				}
			case "anbm":
				{
					var zb0366 []byte
					var zb0367 int
					zb0367, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetName")
						return
					}
					if zb0367 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0367), uint64(maxBitmaskSize))
						return
					}
					zb0366, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetName")
						return
					}
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName = bitmask(zb0366)
				}
			case "au":
				var zb0368 int
				var zb0369 bool
				zb0368, zb0369, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "URL")
					return
				}
				if zb0368 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0368), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "URL")
					return
				}
				if zb0369 {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.URL = nil
				} else if (*z).encodedAssetConfigTxnFields.encodedAssetParams.URL != nil && cap((*z).encodedAssetConfigTxnFields.encodedAssetParams.URL) >= zb0368 {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.URL = ((*z).encodedAssetConfigTxnFields.encodedAssetParams.URL)[:zb0368]
				} else {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.URL = make([]string, zb0368)
				}
				for zb0015 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.URL {
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.URL[zb0015], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "URL", zb0015)
						return
					}
				}
			case "aubm":
				{
					var zb0370 []byte
					var zb0371 int
					zb0371, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskURL")
						return
					}
					if zb0371 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0371), uint64(maxBitmaskSize))
						return
					}
					zb0370, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskURL")
						return
					}
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL = bitmask(zb0370)
				}
			case "am":
				var zb0372 int
				zb0372, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "MetadataHash")
					return
				}
				if zb0372 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0372), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash)
				if err != nil {
					err = msgp.WrapError(err, "MetadataHash")
					return
				}
			case "ambm":
				{
					var zb0373 []byte
					var zb0374 int
					zb0374, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMetadataHash")
						return
					}
					if zb0374 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0374), uint64(maxBitmaskSize))
						return
					}
					zb0373, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMetadataHash")
						return
					}
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash = bitmask(zb0373)
				}
			case "m":
				var zb0375 int
				zb0375, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Manager")
					return
				}
				if zb0375 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0375), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.Manager, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Manager)
				if err != nil {
					err = msgp.WrapError(err, "Manager")
					return
				}
			case "mbm":
				{
					var zb0376 []byte
					var zb0377 int
					zb0377, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskManager")
						return
					}
					if zb0377 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0377), uint64(maxBitmaskSize))
						return
					}
					zb0376, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskManager")
						return
					}
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager = bitmask(zb0376)
				}
			case "r":
				var zb0378 int
				zb0378, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reserve")
					return
				}
				if zb0378 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0378), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.Reserve, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Reserve)
				if err != nil {
					err = msgp.WrapError(err, "Reserve")
					return
				}
			case "rbm":
				{
					var zb0379 []byte
					var zb0380 int
					zb0380, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReserve")
						return
					}
					if zb0380 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0380), uint64(maxBitmaskSize))
						return
					}
					zb0379, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReserve")
						return
					}
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve = bitmask(zb0379)
				}
			case "f":
				var zb0381 int
				zb0381, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Freeze")
					return
				}
				if zb0381 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0381), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.Freeze, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Freeze)
				if err != nil {
					err = msgp.WrapError(err, "Freeze")
					return
				}
			case "fbm":
				{
					var zb0382 []byte
					var zb0383 int
					zb0383, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreeze")
						return
					}
					if zb0383 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0383), uint64(maxBitmaskSize))
						return
					}
					zb0382, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreeze")
						return
					}
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze = bitmask(zb0382)
				}
			case "c":
				var zb0384 int
				zb0384, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Clawback")
					return
				}
				if zb0384 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0384), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetConfigTxnFields.encodedAssetParams.Clawback, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetConfigTxnFields.encodedAssetParams.Clawback)
				if err != nil {
					err = msgp.WrapError(err, "Clawback")
					return
				}
			case "cbm":
				{
					var zb0385 []byte
					var zb0386 int
					zb0386, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClawback")
						return
					}
					if zb0386 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0386), uint64(maxBitmaskSize))
						return
					}
					zb0385, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClawback")
						return
					}
					(*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback = bitmask(zb0385)
				}
			case "xaid":
				var zb0387 int
				var zb0388 bool
				zb0387, zb0388, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "XferAsset")
					return
				}
				if zb0387 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0387), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "XferAsset")
					return
				}
				if zb0388 {
					(*z).encodedAssetTransferTxnFields.XferAsset = nil
				} else if (*z).encodedAssetTransferTxnFields.XferAsset != nil && cap((*z).encodedAssetTransferTxnFields.XferAsset) >= zb0387 {
					(*z).encodedAssetTransferTxnFields.XferAsset = ((*z).encodedAssetTransferTxnFields.XferAsset)[:zb0387]
				} else {
					(*z).encodedAssetTransferTxnFields.XferAsset = make([]basics.AssetIndex, zb0387)
				}
				for zb0016 := range (*z).encodedAssetTransferTxnFields.XferAsset {
					bts, err = (*z).encodedAssetTransferTxnFields.XferAsset[zb0016].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "XferAsset", zb0016)
						return
					}
				}
			case "xaidbm":
				{
					var zb0389 []byte
					var zb0390 int
					zb0390, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskXferAsset")
						return
					}
					if zb0390 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0390), uint64(maxBitmaskSize))
						return
					}
					zb0389, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetTransferTxnFields.BitmaskXferAsset))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskXferAsset")
						return
					}
					(*z).encodedAssetTransferTxnFields.BitmaskXferAsset = bitmask(zb0389)
				}
			case "aamt":
				var zb0391 int
				var zb0392 bool
				zb0391, zb0392, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetAmount")
					return
				}
				if zb0391 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0391), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "AssetAmount")
					return
				}
				if zb0392 {
					(*z).encodedAssetTransferTxnFields.AssetAmount = nil
				} else if (*z).encodedAssetTransferTxnFields.AssetAmount != nil && cap((*z).encodedAssetTransferTxnFields.AssetAmount) >= zb0391 {
					(*z).encodedAssetTransferTxnFields.AssetAmount = ((*z).encodedAssetTransferTxnFields.AssetAmount)[:zb0391]
				} else {
					(*z).encodedAssetTransferTxnFields.AssetAmount = make([]uint64, zb0391)
				}
				for zb0017 := range (*z).encodedAssetTransferTxnFields.AssetAmount {
					(*z).encodedAssetTransferTxnFields.AssetAmount[zb0017], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AssetAmount", zb0017)
						return
					}
				}
			case "aamtbm":
				{
					var zb0393 []byte
					var zb0394 int
					zb0394, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetAmount")
						return
					}
					if zb0394 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0394), uint64(maxBitmaskSize))
						return
					}
					zb0393, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetTransferTxnFields.BitmaskAssetAmount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetAmount")
						return
					}
					(*z).encodedAssetTransferTxnFields.BitmaskAssetAmount = bitmask(zb0393)
				}
			case "asnd":
				var zb0395 int
				zb0395, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetSender")
					return
				}
				if zb0395 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0395), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetTransferTxnFields.AssetSender, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetTransferTxnFields.AssetSender)
				if err != nil {
					err = msgp.WrapError(err, "AssetSender")
					return
				}
			case "asndbm":
				{
					var zb0396 []byte
					var zb0397 int
					zb0397, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetSender")
						return
					}
					if zb0397 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0397), uint64(maxBitmaskSize))
						return
					}
					zb0396, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetTransferTxnFields.BitmaskAssetSender))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetSender")
						return
					}
					(*z).encodedAssetTransferTxnFields.BitmaskAssetSender = bitmask(zb0396)
				}
			case "arcv":
				var zb0398 int
				zb0398, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetReceiver")
					return
				}
				if zb0398 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0398), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetTransferTxnFields.AssetReceiver, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetTransferTxnFields.AssetReceiver)
				if err != nil {
					err = msgp.WrapError(err, "AssetReceiver")
					return
				}
			case "arcvbm":
				{
					var zb0399 []byte
					var zb0400 int
					zb0400, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetReceiver")
						return
					}
					if zb0400 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0400), uint64(maxBitmaskSize))
						return
					}
					zb0399, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetTransferTxnFields.BitmaskAssetReceiver))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetReceiver")
						return
					}
					(*z).encodedAssetTransferTxnFields.BitmaskAssetReceiver = bitmask(zb0399)
				}
			case "aclose":
				var zb0401 int
				zb0401, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetCloseTo")
					return
				}
				if zb0401 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0401), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetTransferTxnFields.AssetCloseTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetTransferTxnFields.AssetCloseTo)
				if err != nil {
					err = msgp.WrapError(err, "AssetCloseTo")
					return
				}
			case "aclosebm":
				{
					var zb0402 []byte
					var zb0403 int
					zb0403, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetCloseTo")
						return
					}
					if zb0403 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0403), uint64(maxBitmaskSize))
						return
					}
					zb0402, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetTransferTxnFields.BitmaskAssetCloseTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetCloseTo")
						return
					}
					(*z).encodedAssetTransferTxnFields.BitmaskAssetCloseTo = bitmask(zb0402)
				}
			case "fadd":
				var zb0404 int
				zb0404, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAccount")
					return
				}
				if zb0404 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0404), uint64(maxAddressBytes))
					return
				}
				(*z).encodedAssetFreezeTxnFields.FreezeAccount, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedAssetFreezeTxnFields.FreezeAccount)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAccount")
					return
				}
			case "faddbm":
				{
					var zb0405 []byte
					var zb0406 int
					zb0406, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAccount")
						return
					}
					if zb0406 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0406), uint64(maxBitmaskSize))
						return
					}
					zb0405, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetFreezeTxnFields.BitmaskFreezeAccount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAccount")
						return
					}
					(*z).encodedAssetFreezeTxnFields.BitmaskFreezeAccount = bitmask(zb0405)
				}
			case "faid":
				var zb0407 int
				var zb0408 bool
				zb0407, zb0408, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAsset")
					return
				}
				if zb0407 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0407), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "FreezeAsset")
					return
				}
				if zb0408 {
					(*z).encodedAssetFreezeTxnFields.FreezeAsset = nil
				} else if (*z).encodedAssetFreezeTxnFields.FreezeAsset != nil && cap((*z).encodedAssetFreezeTxnFields.FreezeAsset) >= zb0407 {
					(*z).encodedAssetFreezeTxnFields.FreezeAsset = ((*z).encodedAssetFreezeTxnFields.FreezeAsset)[:zb0407]
				} else {
					(*z).encodedAssetFreezeTxnFields.FreezeAsset = make([]basics.AssetIndex, zb0407)
				}
				for zb0018 := range (*z).encodedAssetFreezeTxnFields.FreezeAsset {
					bts, err = (*z).encodedAssetFreezeTxnFields.FreezeAsset[zb0018].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "FreezeAsset", zb0018)
						return
					}
				}
			case "faidbm":
				{
					var zb0409 []byte
					var zb0410 int
					zb0410, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAsset")
						return
					}
					if zb0410 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0410), uint64(maxBitmaskSize))
						return
					}
					zb0409, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetFreezeTxnFields.BitmaskFreezeAsset))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAsset")
						return
					}
					(*z).encodedAssetFreezeTxnFields.BitmaskFreezeAsset = bitmask(zb0409)
				}
			case "afrzbm":
				{
					var zb0411 []byte
					var zb0412 int
					zb0412, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetFrozen")
						return
					}
					if zb0412 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0412), uint64(maxBitmaskSize))
						return
					}
					zb0411, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedAssetFreezeTxnFields.BitmaskAssetFrozen))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetFrozen")
						return
					}
					(*z).encodedAssetFreezeTxnFields.BitmaskAssetFrozen = bitmask(zb0411)
				}
			case "apid":
				var zb0413 int
				var zb0414 bool
				zb0413, zb0414, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ApplicationID")
					return
				}
				if zb0413 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0413), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ApplicationID")
					return
				}
				if zb0414 {
					(*z).encodedApplicationCallTxnFields.ApplicationID = nil
				} else if (*z).encodedApplicationCallTxnFields.ApplicationID != nil && cap((*z).encodedApplicationCallTxnFields.ApplicationID) >= zb0413 {
					(*z).encodedApplicationCallTxnFields.ApplicationID = ((*z).encodedApplicationCallTxnFields.ApplicationID)[:zb0413]
				} else {
					(*z).encodedApplicationCallTxnFields.ApplicationID = make([]basics.AppIndex, zb0413)
				}
				for zb0019 := range (*z).encodedApplicationCallTxnFields.ApplicationID {
					bts, err = (*z).encodedApplicationCallTxnFields.ApplicationID[zb0019].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ApplicationID", zb0019)
						return
					}
				}
			case "apidbm":
				{
					var zb0415 []byte
					var zb0416 int
					zb0416, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationID")
						return
					}
					if zb0416 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0416), uint64(maxBitmaskSize))
						return
					}
					zb0415, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskApplicationID))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationID")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskApplicationID = bitmask(zb0415)
				}
			case "apan":
				var zb0417 int
				zb0417, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "OnCompletion")
					return
				}
				if zb0417 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0417), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).encodedApplicationCallTxnFields.OnCompletion, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedApplicationCallTxnFields.OnCompletion)
				if err != nil {
					err = msgp.WrapError(err, "OnCompletion")
					return
				}
			case "apanbm":
				{
					var zb0418 []byte
					var zb0419 int
					zb0419, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskOnCompletion")
						return
					}
					if zb0419 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0419), uint64(maxBitmaskSize))
						return
					}
					zb0418, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskOnCompletion))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskOnCompletion")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskOnCompletion = bitmask(zb0418)
				}
			case "apaa":
				var zb0420 int
				var zb0421 bool
				zb0420, zb0421, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ApplicationArgs")
					return
				}
				if zb0420 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0420), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ApplicationArgs")
					return
				}
				if zb0421 {
					(*z).encodedApplicationCallTxnFields.ApplicationArgs = nil
				} else if (*z).encodedApplicationCallTxnFields.ApplicationArgs != nil && cap((*z).encodedApplicationCallTxnFields.ApplicationArgs) >= zb0420 {
					(*z).encodedApplicationCallTxnFields.ApplicationArgs = ((*z).encodedApplicationCallTxnFields.ApplicationArgs)[:zb0420]
				} else {
					(*z).encodedApplicationCallTxnFields.ApplicationArgs = make([]applicationArgs, zb0420)
				}
				for zb0020 := range (*z).encodedApplicationCallTxnFields.ApplicationArgs {
					var zb0422 int
					var zb0423 bool
					zb0422, zb0423, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ApplicationArgs", zb0020)
						return
					}
					if zb0422 > transactions.EncodedMaxApplicationArgs {
						err = msgp.ErrOverflow(uint64(zb0422), uint64(transactions.EncodedMaxApplicationArgs))
						err = msgp.WrapError(err, "ApplicationArgs", zb0020)
						return
					}
					if zb0423 {
						(*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] = nil
					} else if (*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] != nil && cap((*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020]) >= zb0422 {
						(*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] = ((*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020])[:zb0422]
					} else {
						(*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] = make(applicationArgs, zb0422)
					}
					for zb0021 := range (*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] {
						(*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020][zb0021], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020][zb0021])
						if err != nil {
							err = msgp.WrapError(err, "ApplicationArgs", zb0020, zb0021)
							return
						}
					}
				}
			case "apaabm":
				{
					var zb0424 []byte
					var zb0425 int
					zb0425, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationArgs")
						return
					}
					if zb0425 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0425), uint64(maxBitmaskSize))
						return
					}
					zb0424, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskApplicationArgs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationArgs")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskApplicationArgs = bitmask(zb0424)
				}
			case "apat":
				var zb0426 int
				var zb0427 bool
				zb0426, zb0427, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Accounts")
					return
				}
				if zb0426 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0426), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Accounts")
					return
				}
				if zb0427 {
					(*z).encodedApplicationCallTxnFields.Accounts = nil
				} else if (*z).encodedApplicationCallTxnFields.Accounts != nil && cap((*z).encodedApplicationCallTxnFields.Accounts) >= zb0426 {
					(*z).encodedApplicationCallTxnFields.Accounts = ((*z).encodedApplicationCallTxnFields.Accounts)[:zb0426]
				} else {
					(*z).encodedApplicationCallTxnFields.Accounts = make([]addresses, zb0426)
				}
				for zb0022 := range (*z).encodedApplicationCallTxnFields.Accounts {
					var zb0428 int
					var zb0429 bool
					zb0428, zb0429, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Accounts", zb0022)
						return
					}
					if zb0428 > transactions.EncodedMaxAccounts {
						err = msgp.ErrOverflow(uint64(zb0428), uint64(transactions.EncodedMaxAccounts))
						err = msgp.WrapError(err, "Accounts", zb0022)
						return
					}
					if zb0429 {
						(*z).encodedApplicationCallTxnFields.Accounts[zb0022] = nil
					} else if (*z).encodedApplicationCallTxnFields.Accounts[zb0022] != nil && cap((*z).encodedApplicationCallTxnFields.Accounts[zb0022]) >= zb0428 {
						(*z).encodedApplicationCallTxnFields.Accounts[zb0022] = ((*z).encodedApplicationCallTxnFields.Accounts[zb0022])[:zb0428]
					} else {
						(*z).encodedApplicationCallTxnFields.Accounts[zb0022] = make(addresses, zb0428)
					}
					for zb0023 := range (*z).encodedApplicationCallTxnFields.Accounts[zb0022] {
						bts, err = (*z).encodedApplicationCallTxnFields.Accounts[zb0022][zb0023].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Accounts", zb0022, zb0023)
							return
						}
					}
				}
			case "apatbm":
				{
					var zb0430 []byte
					var zb0431 int
					zb0431, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAccounts")
						return
					}
					if zb0431 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0431), uint64(maxBitmaskSize))
						return
					}
					zb0430, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskAccounts))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAccounts")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskAccounts = bitmask(zb0430)
				}
			case "apfa":
				var zb0432 int
				var zb0433 bool
				zb0432, zb0433, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ForeignApps")
					return
				}
				if zb0432 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0432), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ForeignApps")
					return
				}
				if zb0433 {
					(*z).encodedApplicationCallTxnFields.ForeignApps = nil
				} else if (*z).encodedApplicationCallTxnFields.ForeignApps != nil && cap((*z).encodedApplicationCallTxnFields.ForeignApps) >= zb0432 {
					(*z).encodedApplicationCallTxnFields.ForeignApps = ((*z).encodedApplicationCallTxnFields.ForeignApps)[:zb0432]
				} else {
					(*z).encodedApplicationCallTxnFields.ForeignApps = make([]appIndices, zb0432)
				}
				for zb0024 := range (*z).encodedApplicationCallTxnFields.ForeignApps {
					var zb0434 int
					var zb0435 bool
					zb0434, zb0435, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ForeignApps", zb0024)
						return
					}
					if zb0434 > transactions.EncodedMaxForeignApps {
						err = msgp.ErrOverflow(uint64(zb0434), uint64(transactions.EncodedMaxForeignApps))
						err = msgp.WrapError(err, "ForeignApps", zb0024)
						return
					}
					if zb0435 {
						(*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] = nil
					} else if (*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] != nil && cap((*z).encodedApplicationCallTxnFields.ForeignApps[zb0024]) >= zb0434 {
						(*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] = ((*z).encodedApplicationCallTxnFields.ForeignApps[zb0024])[:zb0434]
					} else {
						(*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] = make(appIndices, zb0434)
					}
					for zb0025 := range (*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] {
						bts, err = (*z).encodedApplicationCallTxnFields.ForeignApps[zb0024][zb0025].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "ForeignApps", zb0024, zb0025)
							return
						}
					}
				}
			case "apfabm":
				{
					var zb0436 []byte
					var zb0437 int
					zb0437, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignApps")
						return
					}
					if zb0437 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0437), uint64(maxBitmaskSize))
						return
					}
					zb0436, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskForeignApps))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignApps")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskForeignApps = bitmask(zb0436)
				}
			case "apas":
				var zb0438 int
				var zb0439 bool
				zb0438, zb0439, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ForeignAssets")
					return
				}
				if zb0438 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0438), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ForeignAssets")
					return
				}
				if zb0439 {
					(*z).encodedApplicationCallTxnFields.ForeignAssets = nil
				} else if (*z).encodedApplicationCallTxnFields.ForeignAssets != nil && cap((*z).encodedApplicationCallTxnFields.ForeignAssets) >= zb0438 {
					(*z).encodedApplicationCallTxnFields.ForeignAssets = ((*z).encodedApplicationCallTxnFields.ForeignAssets)[:zb0438]
				} else {
					(*z).encodedApplicationCallTxnFields.ForeignAssets = make([]assetIndices, zb0438)
				}
				for zb0026 := range (*z).encodedApplicationCallTxnFields.ForeignAssets {
					var zb0440 int
					var zb0441 bool
					zb0440, zb0441, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ForeignAssets", zb0026)
						return
					}
					if zb0440 > transactions.EncodedMaxForeignAssets {
						err = msgp.ErrOverflow(uint64(zb0440), uint64(transactions.EncodedMaxForeignAssets))
						err = msgp.WrapError(err, "ForeignAssets", zb0026)
						return
					}
					if zb0441 {
						(*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] = nil
					} else if (*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] != nil && cap((*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026]) >= zb0440 {
						(*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] = ((*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026])[:zb0440]
					} else {
						(*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] = make(assetIndices, zb0440)
					}
					for zb0027 := range (*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] {
						bts, err = (*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026][zb0027].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "ForeignAssets", zb0026, zb0027)
							return
						}
					}
				}
			case "apasbm":
				{
					var zb0442 []byte
					var zb0443 int
					zb0443, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignAssets")
						return
					}
					if zb0443 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0443), uint64(maxBitmaskSize))
						return
					}
					zb0442, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskForeignAssets))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignAssets")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskForeignAssets = bitmask(zb0442)
				}
			case "lnui":
				var zb0444 int
				var zb0445 bool
				zb0444, zb0445, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LocalNumUint")
					return
				}
				if zb0444 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0444), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LocalNumUint")
					return
				}
				if zb0445 {
					(*z).encodedApplicationCallTxnFields.LocalNumUint = nil
				} else if (*z).encodedApplicationCallTxnFields.LocalNumUint != nil && cap((*z).encodedApplicationCallTxnFields.LocalNumUint) >= zb0444 {
					(*z).encodedApplicationCallTxnFields.LocalNumUint = ((*z).encodedApplicationCallTxnFields.LocalNumUint)[:zb0444]
				} else {
					(*z).encodedApplicationCallTxnFields.LocalNumUint = make([]uint64, zb0444)
				}
				for zb0028 := range (*z).encodedApplicationCallTxnFields.LocalNumUint {
					(*z).encodedApplicationCallTxnFields.LocalNumUint[zb0028], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LocalNumUint", zb0028)
						return
					}
				}
			case "lnuibm":
				{
					var zb0446 []byte
					var zb0447 int
					zb0447, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumUint")
						return
					}
					if zb0447 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0447), uint64(maxBitmaskSize))
						return
					}
					zb0446, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskLocalNumUint))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumUint")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskLocalNumUint = bitmask(zb0446)
				}
			case "lnbs":
				var zb0448 int
				var zb0449 bool
				zb0448, zb0449, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LocalNumByteSlice")
					return
				}
				if zb0448 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0448), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LocalNumByteSlice")
					return
				}
				if zb0449 {
					(*z).encodedApplicationCallTxnFields.LocalNumByteSlice = nil
				} else if (*z).encodedApplicationCallTxnFields.LocalNumByteSlice != nil && cap((*z).encodedApplicationCallTxnFields.LocalNumByteSlice) >= zb0448 {
					(*z).encodedApplicationCallTxnFields.LocalNumByteSlice = ((*z).encodedApplicationCallTxnFields.LocalNumByteSlice)[:zb0448]
				} else {
					(*z).encodedApplicationCallTxnFields.LocalNumByteSlice = make([]uint64, zb0448)
				}
				for zb0029 := range (*z).encodedApplicationCallTxnFields.LocalNumByteSlice {
					(*z).encodedApplicationCallTxnFields.LocalNumByteSlice[zb0029], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LocalNumByteSlice", zb0029)
						return
					}
				}
			case "lnbsbm":
				{
					var zb0450 []byte
					var zb0451 int
					zb0451, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumByteSlice")
						return
					}
					if zb0451 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0451), uint64(maxBitmaskSize))
						return
					}
					zb0450, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumByteSlice")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice = bitmask(zb0450)
				}
			case "gnui":
				var zb0452 int
				var zb0453 bool
				zb0452, zb0453, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GlobalNumUint")
					return
				}
				if zb0452 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0452), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "GlobalNumUint")
					return
				}
				if zb0453 {
					(*z).encodedApplicationCallTxnFields.GlobalNumUint = nil
				} else if (*z).encodedApplicationCallTxnFields.GlobalNumUint != nil && cap((*z).encodedApplicationCallTxnFields.GlobalNumUint) >= zb0452 {
					(*z).encodedApplicationCallTxnFields.GlobalNumUint = ((*z).encodedApplicationCallTxnFields.GlobalNumUint)[:zb0452]
				} else {
					(*z).encodedApplicationCallTxnFields.GlobalNumUint = make([]uint64, zb0452)
				}
				for zb0030 := range (*z).encodedApplicationCallTxnFields.GlobalNumUint {
					(*z).encodedApplicationCallTxnFields.GlobalNumUint[zb0030], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "GlobalNumUint", zb0030)
						return
					}
				}
			case "gnuibm":
				{
					var zb0454 []byte
					var zb0455 int
					zb0455, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumUint")
						return
					}
					if zb0455 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0455), uint64(maxBitmaskSize))
						return
					}
					zb0454, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskGlobalNumUint))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumUint")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskGlobalNumUint = bitmask(zb0454)
				}
			case "gnbs":
				var zb0456 int
				var zb0457 bool
				zb0456, zb0457, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GlobalNumByteSlice")
					return
				}
				if zb0456 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0456), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "GlobalNumByteSlice")
					return
				}
				if zb0457 {
					(*z).encodedApplicationCallTxnFields.GlobalNumByteSlice = nil
				} else if (*z).encodedApplicationCallTxnFields.GlobalNumByteSlice != nil && cap((*z).encodedApplicationCallTxnFields.GlobalNumByteSlice) >= zb0456 {
					(*z).encodedApplicationCallTxnFields.GlobalNumByteSlice = ((*z).encodedApplicationCallTxnFields.GlobalNumByteSlice)[:zb0456]
				} else {
					(*z).encodedApplicationCallTxnFields.GlobalNumByteSlice = make([]uint64, zb0456)
				}
				for zb0031 := range (*z).encodedApplicationCallTxnFields.GlobalNumByteSlice {
					(*z).encodedApplicationCallTxnFields.GlobalNumByteSlice[zb0031], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "GlobalNumByteSlice", zb0031)
						return
					}
				}
			case "gnbsbm":
				{
					var zb0458 []byte
					var zb0459 int
					zb0459, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumByteSlice")
						return
					}
					if zb0459 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0459), uint64(maxBitmaskSize))
						return
					}
					zb0458, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumByteSlice")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice = bitmask(zb0458)
				}
			case "apap":
				var zb0460 int
				var zb0461 bool
				zb0460, zb0461, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ApprovalProgram")
					return
				}
				if zb0460 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0460), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ApprovalProgram")
					return
				}
				if zb0461 {
					(*z).encodedApplicationCallTxnFields.ApprovalProgram = nil
				} else if (*z).encodedApplicationCallTxnFields.ApprovalProgram != nil && cap((*z).encodedApplicationCallTxnFields.ApprovalProgram) >= zb0460 {
					(*z).encodedApplicationCallTxnFields.ApprovalProgram = ((*z).encodedApplicationCallTxnFields.ApprovalProgram)[:zb0460]
				} else {
					(*z).encodedApplicationCallTxnFields.ApprovalProgram = make([]program, zb0460)
				}
				for zb0032 := range (*z).encodedApplicationCallTxnFields.ApprovalProgram {
					{
						var zb0462 []byte
						var zb0463 int
						zb0463, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "ApprovalProgram", zb0032)
							return
						}
						if zb0463 > config.MaxAvailableAppProgramLen {
							err = msgp.ErrOverflow(uint64(zb0463), uint64(config.MaxAvailableAppProgramLen))
							return
						}
						zb0462, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.ApprovalProgram[zb0032]))
						if err != nil {
							err = msgp.WrapError(err, "ApprovalProgram", zb0032)
							return
						}
						(*z).encodedApplicationCallTxnFields.ApprovalProgram[zb0032] = program(zb0462)
					}
				}
			case "apapbm":
				{
					var zb0464 []byte
					var zb0465 int
					zb0465, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApprovalProgram")
						return
					}
					if zb0465 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0465), uint64(maxBitmaskSize))
						return
					}
					zb0464, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskApprovalProgram))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApprovalProgram")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskApprovalProgram = bitmask(zb0464)
				}
			case "apsu":
				var zb0466 int
				var zb0467 bool
				zb0466, zb0467, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ClearStateProgram")
					return
				}
				if zb0466 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0466), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ClearStateProgram")
					return
				}
				if zb0467 {
					(*z).encodedApplicationCallTxnFields.ClearStateProgram = nil
				} else if (*z).encodedApplicationCallTxnFields.ClearStateProgram != nil && cap((*z).encodedApplicationCallTxnFields.ClearStateProgram) >= zb0466 {
					(*z).encodedApplicationCallTxnFields.ClearStateProgram = ((*z).encodedApplicationCallTxnFields.ClearStateProgram)[:zb0466]
				} else {
					(*z).encodedApplicationCallTxnFields.ClearStateProgram = make([]program, zb0466)
				}
				for zb0033 := range (*z).encodedApplicationCallTxnFields.ClearStateProgram {
					{
						var zb0468 []byte
						var zb0469 int
						zb0469, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "ClearStateProgram", zb0033)
							return
						}
						if zb0469 > config.MaxAvailableAppProgramLen {
							err = msgp.ErrOverflow(uint64(zb0469), uint64(config.MaxAvailableAppProgramLen))
							return
						}
						zb0468, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.ClearStateProgram[zb0033]))
						if err != nil {
							err = msgp.WrapError(err, "ClearStateProgram", zb0033)
							return
						}
						(*z).encodedApplicationCallTxnFields.ClearStateProgram[zb0033] = program(zb0468)
					}
				}
			case "apsubm":
				{
					var zb0470 []byte
					var zb0471 int
					zb0471, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClearStateProgram")
						return
					}
					if zb0471 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0471), uint64(maxBitmaskSize))
						return
					}
					zb0470, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskClearStateProgram))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClearStateProgram")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskClearStateProgram = bitmask(zb0470)
				}
			case "apep":
				var zb0472 int
				var zb0473 bool
				zb0472, zb0473, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExtraProgramPages")
					return
				}
				if zb0472 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0472), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ExtraProgramPages")
					return
				}
				if zb0473 {
					(*z).encodedApplicationCallTxnFields.ExtraProgramPages = nil
				} else if (*z).encodedApplicationCallTxnFields.ExtraProgramPages != nil && cap((*z).encodedApplicationCallTxnFields.ExtraProgramPages) >= zb0472 {
					(*z).encodedApplicationCallTxnFields.ExtraProgramPages = ((*z).encodedApplicationCallTxnFields.ExtraProgramPages)[:zb0472]
				} else {
					(*z).encodedApplicationCallTxnFields.ExtraProgramPages = make([]uint32, zb0472)
				}
				for zb0034 := range (*z).encodedApplicationCallTxnFields.ExtraProgramPages {
					(*z).encodedApplicationCallTxnFields.ExtraProgramPages[zb0034], bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ExtraProgramPages", zb0034)
						return
					}
				}
			case "apepbm":
				{
					var zb0474 []byte
					var zb0475 int
					zb0475, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskExtraProgramPages")
						return
					}
					if zb0475 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0475), uint64(maxBitmaskSize))
						return
					}
					zb0474, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedApplicationCallTxnFields.BitmaskExtraProgramPages))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskExtraProgramPages")
						return
					}
					(*z).encodedApplicationCallTxnFields.BitmaskExtraProgramPages = bitmask(zb0474)
				}
			case "certrnd":
				var zb0476 int
				var zb0477 bool
				zb0476, zb0477, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CertRound")
					return
				}
				if zb0476 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0476), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "CertRound")
					return
				}
				if zb0477 {
					(*z).encodedCompactCertTxnFields.CertRound = nil
				} else if (*z).encodedCompactCertTxnFields.CertRound != nil && cap((*z).encodedCompactCertTxnFields.CertRound) >= zb0476 {
					(*z).encodedCompactCertTxnFields.CertRound = ((*z).encodedCompactCertTxnFields.CertRound)[:zb0476]
				} else {
					(*z).encodedCompactCertTxnFields.CertRound = make([]basics.Round, zb0476)
				}
				for zb0035 := range (*z).encodedCompactCertTxnFields.CertRound {
					bts, err = (*z).encodedCompactCertTxnFields.CertRound[zb0035].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CertRound", zb0035)
						return
					}
				}
			case "certrndbm":
				{
					var zb0478 []byte
					var zb0479 int
					zb0479, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertRound")
						return
					}
					if zb0479 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0479), uint64(maxBitmaskSize))
						return
					}
					zb0478, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.BitmaskCertRound))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertRound")
						return
					}
					(*z).encodedCompactCertTxnFields.BitmaskCertRound = bitmask(zb0478)
				}
			case "certtype":
				var zb0480 int
				var zb0481 bool
				zb0480, zb0481, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CertType")
					return
				}
				if zb0480 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0480), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "CertType")
					return
				}
				if zb0481 {
					(*z).encodedCompactCertTxnFields.CertType = nil
				} else if (*z).encodedCompactCertTxnFields.CertType != nil && cap((*z).encodedCompactCertTxnFields.CertType) >= zb0480 {
					(*z).encodedCompactCertTxnFields.CertType = ((*z).encodedCompactCertTxnFields.CertType)[:zb0480]
				} else {
					(*z).encodedCompactCertTxnFields.CertType = make([]protocol.CompactCertType, zb0480)
				}
				for zb0036 := range (*z).encodedCompactCertTxnFields.CertType {
					bts, err = (*z).encodedCompactCertTxnFields.CertType[zb0036].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CertType", zb0036)
						return
					}
				}
			case "certtypebm":
				{
					var zb0482 []byte
					var zb0483 int
					zb0483, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertType")
						return
					}
					if zb0483 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0483), uint64(maxBitmaskSize))
						return
					}
					zb0482, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.BitmaskCertType))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertType")
						return
					}
					(*z).encodedCompactCertTxnFields.BitmaskCertType = bitmask(zb0482)
				}
			case "certc":
				var zb0484 int
				var zb0485 bool
				zb0484, zb0485, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigCommit")
					return
				}
				if zb0484 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0484), uint64(maxAddressBytes))
					err = msgp.WrapError(err, "SigCommit")
					return
				}
				if zb0485 {
					(*z).encodedCompactCertTxnFields.encodedCert.SigCommit = nil
				} else if (*z).encodedCompactCertTxnFields.encodedCert.SigCommit != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.SigCommit) >= zb0484 {
					(*z).encodedCompactCertTxnFields.encodedCert.SigCommit = ((*z).encodedCompactCertTxnFields.encodedCert.SigCommit)[:zb0484]
				} else {
					(*z).encodedCompactCertTxnFields.encodedCert.SigCommit = make([]crypto.GenericDigest, zb0484)
				}
				for zb0037 := range (*z).encodedCompactCertTxnFields.encodedCert.SigCommit {
					bts, err = (*z).encodedCompactCertTxnFields.encodedCert.SigCommit[zb0037].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigCommit", zb0037)
						return
					}
				}
			case "certcbm":
				{
					var zb0486 []byte
					var zb0487 int
					zb0487, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigCommit")
						return
					}
					if zb0487 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0487), uint64(maxBitmaskSize))
						return
					}
					zb0486, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigCommit")
						return
					}
					(*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit = bitmask(zb0486)
				}
			case "certw":
				var zb0488 int
				var zb0489 bool
				zb0488, zb0489, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SignedWeight")
					return
				}
				if zb0488 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0488), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SignedWeight")
					return
				}
				if zb0489 {
					(*z).encodedCompactCertTxnFields.encodedCert.SignedWeight = nil
				} else if (*z).encodedCompactCertTxnFields.encodedCert.SignedWeight != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.SignedWeight) >= zb0488 {
					(*z).encodedCompactCertTxnFields.encodedCert.SignedWeight = ((*z).encodedCompactCertTxnFields.encodedCert.SignedWeight)[:zb0488]
				} else {
					(*z).encodedCompactCertTxnFields.encodedCert.SignedWeight = make([]uint64, zb0488)
				}
				for zb0038 := range (*z).encodedCompactCertTxnFields.encodedCert.SignedWeight {
					(*z).encodedCompactCertTxnFields.encodedCert.SignedWeight[zb0038], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedWeight", zb0038)
						return
					}
				}
			case "certwbm":
				{
					var zb0490 []byte
					var zb0491 int
					zb0491, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSignedWeight")
						return
					}
					if zb0491 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0491), uint64(maxBitmaskSize))
						return
					}
					zb0490, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSignedWeight")
						return
					}
					(*z).encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight = bitmask(zb0490)
				}
			case "certS":
				var zb0492 int
				var zb0493 bool
				zb0492, zb0493, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigProofs")
					return
				}
				if zb0492 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0492), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SigProofs")
					return
				}
				if zb0493 {
					(*z).encodedCompactCertTxnFields.encodedCert.SigProofs = nil
				} else if (*z).encodedCompactCertTxnFields.encodedCert.SigProofs != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.SigProofs) >= zb0492 {
					(*z).encodedCompactCertTxnFields.encodedCert.SigProofs = ((*z).encodedCompactCertTxnFields.encodedCert.SigProofs)[:zb0492]
				} else {
					(*z).encodedCompactCertTxnFields.encodedCert.SigProofs = make([]certProofs, zb0492)
				}
				for zb0039 := range (*z).encodedCompactCertTxnFields.encodedCert.SigProofs {
					var zb0494 int
					var zb0495 bool
					zb0494, zb0495, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigProofs", zb0039)
						return
					}
					if zb0494 > compactcert.MaxProofDigests {
						err = msgp.ErrOverflow(uint64(zb0494), uint64(compactcert.MaxProofDigests))
						err = msgp.WrapError(err, "SigProofs", zb0039)
						return
					}
					if zb0495 {
						(*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] = nil
					} else if (*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039]) >= zb0494 {
						(*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] = ((*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039])[:zb0494]
					} else {
						(*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] = make(certProofs, zb0494)
					}
					for zb0040 := range (*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] {
						bts, err = (*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039][zb0040].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SigProofs", zb0039, zb0040)
							return
						}
					}
				}
			case "certSbm":
				{
					var zb0496 []byte
					var zb0497 int
					zb0497, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigProofs")
						return
					}
					if zb0497 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0497), uint64(maxBitmaskSize))
						return
					}
					zb0496, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigProofs")
						return
					}
					(*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs = bitmask(zb0496)
				}
			case "certSH":
				var zb0498 int
				var zb0499 bool
				zb0498, zb0499, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigProofHashTypes")
					return
				}
				if zb0498 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0498), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SigProofHashTypes")
					return
				}
				if zb0499 {
					(*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = nil
				} else if (*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) >= zb0498 {
					(*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = ((*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes)[:zb0498]
				} else {
					(*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = make([]uint64, zb0498)
				}
				for zb0041 := range (*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes {
					(*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes[zb0041], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigProofHashTypes", zb0041)
						return
					}
				}
			case "certSHbm":
				{
					var zb0500 []byte
					var zb0501 int
					zb0501, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigsHash")
						return
					}
					if zb0501 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0501), uint64(maxBitmaskSize))
						return
					}
					zb0500, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigsHash")
						return
					}
					(*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash = bitmask(zb0500)
				}
			case "certP":
				var zb0502 int
				var zb0503 bool
				zb0502, zb0503, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PartProofs")
					return
				}
				if zb0502 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0502), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "PartProofs")
					return
				}
				if zb0503 {
					(*z).encodedCompactCertTxnFields.encodedCert.PartProofs = nil
				} else if (*z).encodedCompactCertTxnFields.encodedCert.PartProofs != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.PartProofs) >= zb0502 {
					(*z).encodedCompactCertTxnFields.encodedCert.PartProofs = ((*z).encodedCompactCertTxnFields.encodedCert.PartProofs)[:zb0502]
				} else {
					(*z).encodedCompactCertTxnFields.encodedCert.PartProofs = make([]certProofs, zb0502)
				}
				for zb0042 := range (*z).encodedCompactCertTxnFields.encodedCert.PartProofs {
					var zb0504 int
					var zb0505 bool
					zb0504, zb0505, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PartProofs", zb0042)
						return
					}
					if zb0504 > compactcert.MaxProofDigests {
						err = msgp.ErrOverflow(uint64(zb0504), uint64(compactcert.MaxProofDigests))
						err = msgp.WrapError(err, "PartProofs", zb0042)
						return
					}
					if zb0505 {
						(*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] = nil
					} else if (*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042]) >= zb0504 {
						(*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] = ((*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042])[:zb0504]
					} else {
						(*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] = make(certProofs, zb0504)
					}
					for zb0043 := range (*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] {
						bts, err = (*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042][zb0043].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "PartProofs", zb0042, zb0043)
							return
						}
					}
				}
			case "certPbm":
				{
					var zb0506 []byte
					var zb0507 int
					zb0507, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartProofs")
						return
					}
					if zb0507 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0507), uint64(maxBitmaskSize))
						return
					}
					zb0506, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartProofs")
						return
					}
					(*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs = bitmask(zb0506)
				}
			case "certPH":
				var zb0508 int
				var zb0509 bool
				zb0508, zb0509, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PartProofHashTypes")
					return
				}
				if zb0508 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0508), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "PartProofHashTypes")
					return
				}
				if zb0509 {
					(*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = nil
				} else if (*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) >= zb0508 {
					(*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = ((*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes)[:zb0508]
				} else {
					(*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = make([]uint64, zb0508)
				}
				for zb0044 := range (*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes {
					(*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes[zb0044], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PartProofHashTypes", zb0044)
						return
					}
				}
			case "certPHbm":
				{
					var zb0510 []byte
					var zb0511 int
					zb0511, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartHash")
						return
					}
					if zb0511 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0511), uint64(maxBitmaskSize))
						return
					}
					zb0510, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartHash")
						return
					}
					(*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartHash = bitmask(zb0510)
				}
			case "certr":
				var zb0512 int
				var zb0513 bool
				zb0512, zb0513, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reveals")
					return
				}
				if zb0512 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0512), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Reveals")
					return
				}
				if zb0513 {
					(*z).encodedCompactCertTxnFields.encodedCert.Reveals = nil
				} else if (*z).encodedCompactCertTxnFields.encodedCert.Reveals != nil && cap((*z).encodedCompactCertTxnFields.encodedCert.Reveals) >= zb0512 {
					(*z).encodedCompactCertTxnFields.encodedCert.Reveals = ((*z).encodedCompactCertTxnFields.encodedCert.Reveals)[:zb0512]
				} else {
					(*z).encodedCompactCertTxnFields.encodedCert.Reveals = make([]revealMap, zb0512)
				}
				for zb0045 := range (*z).encodedCompactCertTxnFields.encodedCert.Reveals {
					var zb0514 int
					var zb0515 bool
					zb0514, zb0515, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Reveals", zb0045)
						return
					}
					if zb0514 > compactcert.MaxReveals {
						err = msgp.ErrOverflow(uint64(zb0514), uint64(compactcert.MaxReveals))
						err = msgp.WrapError(err, "Reveals", zb0045)
						return
					}
					if zb0515 {
						(*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045] = nil
					} else if (*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045] == nil {
						(*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045] = make(revealMap, zb0514)
					}
					for zb0514 > 0 {
						var zb0046 uint64
						var zb0047 compactcert.Reveal
						zb0514--
						zb0046, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Reveals", zb0045)
							return
						}
						bts, err = zb0047.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Reveals", zb0045, zb0046)
							return
						}
						(*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045][zb0046] = zb0047
					}
				}
			case "certrbm":
				{
					var zb0516 []byte
					var zb0517 int
					zb0517, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReveals")
						return
					}
					if zb0517 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0517), uint64(maxBitmaskSize))
						return
					}
					zb0516, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskReveals))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReveals")
						return
					}
					(*z).encodedCompactCertTxnFields.encodedCert.BitmaskReveals = bitmask(zb0516)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedTxns) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedTxns)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedTxns) Msgsize() (s int) {
	s = 3 + 5 + msgp.BytesPrefixSize + len((*z).TxType) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskTxType)) + 6 + msgp.ByteSize + 4 + msgp.BytesPrefixSize + len((*z).encodedTxnHeaders.Sender) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskSender)) + 4 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).encodedTxnHeaders.Fee {
		s += (*z).encodedTxnHeaders.Fee[zb0001].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskFee)) + 3 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).encodedTxnHeaders.FirstValid {
		s += (*z).encodedTxnHeaders.FirstValid[zb0002].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskFirstValid)) + 3 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).encodedTxnHeaders.LastValid {
		s += (*z).encodedTxnHeaders.LastValid[zb0003].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskLastValid)) + 5 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).encodedTxnHeaders.Note {
		s += msgp.BytesPrefixSize + len((*z).encodedTxnHeaders.Note[zb0004])
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskNote)) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskGenesisID)) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskGroup)) + 3 + msgp.BytesPrefixSize + len((*z).encodedTxnHeaders.Lease) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskLease)) + 6 + msgp.BytesPrefixSize + len((*z).encodedTxnHeaders.RekeyTo) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskRekeyTo)) + 8 + msgp.BytesPrefixSize + len((*z).encodedKeyregTxnFields.VotePK) + 7 + msgp.BytesPrefixSize + len((*z).encodedKeyregTxnFields.SelectionPK) + 8 + msgp.ArrayHeaderSize
	for zb0005 := range (*z).encodedKeyregTxnFields.VoteFirst {
		s += (*z).encodedKeyregTxnFields.VoteFirst[zb0005].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedKeyregTxnFields.BitmaskVoteFirst)) + 8 + msgp.ArrayHeaderSize
	for zb0006 := range (*z).encodedKeyregTxnFields.VoteLast {
		s += (*z).encodedKeyregTxnFields.VoteLast[zb0006].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedKeyregTxnFields.BitmaskVoteLast)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedKeyregTxnFields.VoteKeyDilution) * (msgp.Uint64Size)) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedKeyregTxnFields.BitmaskKeys)) + 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedKeyregTxnFields.BitmaskNonparticipation)) + 6 + msgp.ArrayHeaderSize + (len((*z).encodedKeyregTxnFields.HasValidRoot) * (msgp.BoolSize)) + 5 + msgp.BytesPrefixSize + len((*z).encodedKeyregTxnFields.CommitmentRoot) + 4 + msgp.BytesPrefixSize + len((*z).encodedPaymentTxnFields.Receiver) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedPaymentTxnFields.BitmaskReceiver)) + 4 + msgp.ArrayHeaderSize
	for zb0009 := range (*z).encodedPaymentTxnFields.Amount {
		s += (*z).encodedPaymentTxnFields.Amount[zb0009].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedPaymentTxnFields.BitmaskAmount)) + 6 + msgp.BytesPrefixSize + len((*z).encodedPaymentTxnFields.CloseRemainderTo) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo)) + 5 + msgp.ArrayHeaderSize
	for zb0010 := range (*z).encodedAssetConfigTxnFields.ConfigAsset {
		s += (*z).encodedAssetConfigTxnFields.ConfigAsset[zb0010].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetConfigTxnFields.BitmaskConfigAsset)) + 2 + msgp.ArrayHeaderSize + (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Total) * (msgp.Uint64Size)) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal)) + 3 + msgp.ArrayHeaderSize + (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals) * (msgp.Uint32Size)) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals)) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen)) + 3 + msgp.ArrayHeaderSize
	for zb0013 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName {
		s += msgp.StringPrefixSize + len((*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName[zb0013])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName)) + 3 + msgp.ArrayHeaderSize
	for zb0014 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName {
		s += msgp.StringPrefixSize + len((*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName[zb0014])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName)) + 3 + msgp.ArrayHeaderSize
	for zb0015 := range (*z).encodedAssetConfigTxnFields.encodedAssetParams.URL {
		s += msgp.StringPrefixSize + len((*z).encodedAssetConfigTxnFields.encodedAssetParams.URL[zb0015])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL)) + 3 + msgp.BytesPrefixSize + len((*z).encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash)) + 2 + msgp.BytesPrefixSize + len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Manager) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager)) + 2 + msgp.BytesPrefixSize + len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Reserve) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve)) + 2 + msgp.BytesPrefixSize + len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Freeze) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze)) + 2 + msgp.BytesPrefixSize + len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Clawback) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback)) + 5 + msgp.ArrayHeaderSize
	for zb0016 := range (*z).encodedAssetTransferTxnFields.XferAsset {
		s += (*z).encodedAssetTransferTxnFields.XferAsset[zb0016].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetTransferTxnFields.BitmaskXferAsset)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedAssetTransferTxnFields.AssetAmount) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetTransferTxnFields.BitmaskAssetAmount)) + 5 + msgp.BytesPrefixSize + len((*z).encodedAssetTransferTxnFields.AssetSender) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetTransferTxnFields.BitmaskAssetSender)) + 5 + msgp.BytesPrefixSize + len((*z).encodedAssetTransferTxnFields.AssetReceiver) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetTransferTxnFields.BitmaskAssetReceiver)) + 7 + msgp.BytesPrefixSize + len((*z).encodedAssetTransferTxnFields.AssetCloseTo) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetTransferTxnFields.BitmaskAssetCloseTo)) + 5 + msgp.BytesPrefixSize + len((*z).encodedAssetFreezeTxnFields.FreezeAccount) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetFreezeTxnFields.BitmaskFreezeAccount)) + 5 + msgp.ArrayHeaderSize
	for zb0018 := range (*z).encodedAssetFreezeTxnFields.FreezeAsset {
		s += (*z).encodedAssetFreezeTxnFields.FreezeAsset[zb0018].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetFreezeTxnFields.BitmaskFreezeAsset)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedAssetFreezeTxnFields.BitmaskAssetFrozen)) + 5 + msgp.ArrayHeaderSize
	for zb0019 := range (*z).encodedApplicationCallTxnFields.ApplicationID {
		s += (*z).encodedApplicationCallTxnFields.ApplicationID[zb0019].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskApplicationID)) + 5 + msgp.BytesPrefixSize + len((*z).encodedApplicationCallTxnFields.OnCompletion) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskOnCompletion)) + 5 + msgp.ArrayHeaderSize
	for zb0020 := range (*z).encodedApplicationCallTxnFields.ApplicationArgs {
		s += msgp.ArrayHeaderSize
		for zb0021 := range (*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020] {
			s += msgp.BytesPrefixSize + len((*z).encodedApplicationCallTxnFields.ApplicationArgs[zb0020][zb0021])
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskApplicationArgs)) + 5 + msgp.ArrayHeaderSize
	for zb0022 := range (*z).encodedApplicationCallTxnFields.Accounts {
		s += msgp.ArrayHeaderSize
		for zb0023 := range (*z).encodedApplicationCallTxnFields.Accounts[zb0022] {
			s += (*z).encodedApplicationCallTxnFields.Accounts[zb0022][zb0023].Msgsize()
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskAccounts)) + 5 + msgp.ArrayHeaderSize
	for zb0024 := range (*z).encodedApplicationCallTxnFields.ForeignApps {
		s += msgp.ArrayHeaderSize
		for zb0025 := range (*z).encodedApplicationCallTxnFields.ForeignApps[zb0024] {
			s += (*z).encodedApplicationCallTxnFields.ForeignApps[zb0024][zb0025].Msgsize()
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskForeignApps)) + 5 + msgp.ArrayHeaderSize
	for zb0026 := range (*z).encodedApplicationCallTxnFields.ForeignAssets {
		s += msgp.ArrayHeaderSize
		for zb0027 := range (*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026] {
			s += (*z).encodedApplicationCallTxnFields.ForeignAssets[zb0026][zb0027].Msgsize()
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskForeignAssets)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedApplicationCallTxnFields.LocalNumUint) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskLocalNumUint)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedApplicationCallTxnFields.LocalNumByteSlice) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedApplicationCallTxnFields.GlobalNumUint) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskGlobalNumUint)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedApplicationCallTxnFields.GlobalNumByteSlice) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice)) + 5 + msgp.ArrayHeaderSize
	for zb0032 := range (*z).encodedApplicationCallTxnFields.ApprovalProgram {
		s += msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.ApprovalProgram[zb0032]))
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskApprovalProgram)) + 5 + msgp.ArrayHeaderSize
	for zb0033 := range (*z).encodedApplicationCallTxnFields.ClearStateProgram {
		s += msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.ClearStateProgram[zb0033]))
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskClearStateProgram)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedApplicationCallTxnFields.ExtraProgramPages) * (msgp.Uint32Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedApplicationCallTxnFields.BitmaskExtraProgramPages)) + 8 + msgp.ArrayHeaderSize
	for zb0035 := range (*z).encodedCompactCertTxnFields.CertRound {
		s += (*z).encodedCompactCertTxnFields.CertRound[zb0035].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedCompactCertTxnFields.BitmaskCertRound)) + 9 + msgp.ArrayHeaderSize
	for zb0036 := range (*z).encodedCompactCertTxnFields.CertType {
		s += (*z).encodedCompactCertTxnFields.CertType[zb0036].Msgsize()
	}
	s += 11 + msgp.BytesPrefixSize + len([]byte((*z).encodedCompactCertTxnFields.BitmaskCertType)) + 6 + msgp.ArrayHeaderSize
	for zb0037 := range (*z).encodedCompactCertTxnFields.encodedCert.SigCommit {
		s += (*z).encodedCompactCertTxnFields.encodedCert.SigCommit[zb0037].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit)) + 6 + msgp.ArrayHeaderSize + (len((*z).encodedCompactCertTxnFields.encodedCert.SignedWeight) * (msgp.Uint64Size)) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight)) + 6 + msgp.ArrayHeaderSize
	for zb0039 := range (*z).encodedCompactCertTxnFields.encodedCert.SigProofs {
		s += msgp.ArrayHeaderSize
		for zb0040 := range (*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039] {
			s += (*z).encodedCompactCertTxnFields.encodedCert.SigProofs[zb0039][zb0040].Msgsize()
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash)) + 6 + msgp.ArrayHeaderSize
	for zb0042 := range (*z).encodedCompactCertTxnFields.encodedCert.PartProofs {
		s += msgp.ArrayHeaderSize
		for zb0043 := range (*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042] {
			s += (*z).encodedCompactCertTxnFields.encodedCert.PartProofs[zb0042][zb0043].Msgsize()
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartHash)) + 6 + msgp.ArrayHeaderSize
	for zb0045 := range (*z).encodedCompactCertTxnFields.encodedCert.Reveals {
		s += msgp.MapHeaderSize
		if (*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045] != nil {
			for zb0046, zb0047 := range (*z).encodedCompactCertTxnFields.encodedCert.Reveals[zb0045] {
				_ = zb0046
				_ = zb0047
				s += 0 + msgp.Uint64Size + zb0047.Msgsize()
			}
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedCompactCertTxnFields.encodedCert.BitmaskReveals))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedTxns) MsgIsZero() bool {
	return (len((*z).TxType) == 0) && (len((*z).BitmaskTxType) == 0) && ((*z).TxTypeOffset == 0) && (len((*z).encodedTxnHeaders.Sender) == 0) && (len((*z).encodedTxnHeaders.BitmaskSender) == 0) && (len((*z).encodedTxnHeaders.Fee) == 0) && (len((*z).encodedTxnHeaders.BitmaskFee) == 0) && (len((*z).encodedTxnHeaders.FirstValid) == 0) && (len((*z).encodedTxnHeaders.BitmaskFirstValid) == 0) && (len((*z).encodedTxnHeaders.LastValid) == 0) && (len((*z).encodedTxnHeaders.BitmaskLastValid) == 0) && (len((*z).encodedTxnHeaders.Note) == 0) && (len((*z).encodedTxnHeaders.BitmaskNote) == 0) && (len((*z).encodedTxnHeaders.BitmaskGenesisID) == 0) && (len((*z).encodedTxnHeaders.BitmaskGroup) == 0) && (len((*z).encodedTxnHeaders.Lease) == 0) && (len((*z).encodedTxnHeaders.BitmaskLease) == 0) && (len((*z).encodedTxnHeaders.RekeyTo) == 0) && (len((*z).encodedTxnHeaders.BitmaskRekeyTo) == 0) && (len((*z).encodedKeyregTxnFields.VotePK) == 0) && (len((*z).encodedKeyregTxnFields.SelectionPK) == 0) && (len((*z).encodedKeyregTxnFields.VoteFirst) == 0) && (len((*z).encodedKeyregTxnFields.BitmaskVoteFirst) == 0) && (len((*z).encodedKeyregTxnFields.VoteLast) == 0) && (len((*z).encodedKeyregTxnFields.BitmaskVoteLast) == 0) && (len((*z).encodedKeyregTxnFields.VoteKeyDilution) == 0) && (len((*z).encodedKeyregTxnFields.BitmaskKeys) == 0) && (len((*z).encodedKeyregTxnFields.BitmaskNonparticipation) == 0) && (len((*z).encodedKeyregTxnFields.HasValidRoot) == 0) && (len((*z).encodedKeyregTxnFields.CommitmentRoot) == 0) && (len((*z).encodedPaymentTxnFields.Receiver) == 0) && (len((*z).encodedPaymentTxnFields.BitmaskReceiver) == 0) && (len((*z).encodedPaymentTxnFields.Amount) == 0) && (len((*z).encodedPaymentTxnFields.BitmaskAmount) == 0) && (len((*z).encodedPaymentTxnFields.CloseRemainderTo) == 0) && (len((*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo) == 0) && (len((*z).encodedAssetConfigTxnFields.ConfigAsset) == 0) && (len((*z).encodedAssetConfigTxnFields.BitmaskConfigAsset) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Total) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Decimals) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.UnitName) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.AssetName) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.URL) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Manager) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Reserve) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Freeze) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.Clawback) == 0) && (len((*z).encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback) == 0) && (len((*z).encodedAssetTransferTxnFields.XferAsset) == 0) && (len((*z).encodedAssetTransferTxnFields.BitmaskXferAsset) == 0) && (len((*z).encodedAssetTransferTxnFields.AssetAmount) == 0) && (len((*z).encodedAssetTransferTxnFields.BitmaskAssetAmount) == 0) && (len((*z).encodedAssetTransferTxnFields.AssetSender) == 0) && (len((*z).encodedAssetTransferTxnFields.BitmaskAssetSender) == 0) && (len((*z).encodedAssetTransferTxnFields.AssetReceiver) == 0) && (len((*z).encodedAssetTransferTxnFields.BitmaskAssetReceiver) == 0) && (len((*z).encodedAssetTransferTxnFields.AssetCloseTo) == 0) && (len((*z).encodedAssetTransferTxnFields.BitmaskAssetCloseTo) == 0) && (len((*z).encodedAssetFreezeTxnFields.FreezeAccount) == 0) && (len((*z).encodedAssetFreezeTxnFields.BitmaskFreezeAccount) == 0) && (len((*z).encodedAssetFreezeTxnFields.FreezeAsset) == 0) && (len((*z).encodedAssetFreezeTxnFields.BitmaskFreezeAsset) == 0) && (len((*z).encodedAssetFreezeTxnFields.BitmaskAssetFrozen) == 0) && (len((*z).encodedApplicationCallTxnFields.ApplicationID) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskApplicationID) == 0) && (len((*z).encodedApplicationCallTxnFields.OnCompletion) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskOnCompletion) == 0) && (len((*z).encodedApplicationCallTxnFields.ApplicationArgs) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskApplicationArgs) == 0) && (len((*z).encodedApplicationCallTxnFields.Accounts) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskAccounts) == 0) && (len((*z).encodedApplicationCallTxnFields.ForeignApps) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskForeignApps) == 0) && (len((*z).encodedApplicationCallTxnFields.ForeignAssets) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskForeignAssets) == 0) && (len((*z).encodedApplicationCallTxnFields.LocalNumUint) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskLocalNumUint) == 0) && (len((*z).encodedApplicationCallTxnFields.LocalNumByteSlice) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice) == 0) && (len((*z).encodedApplicationCallTxnFields.GlobalNumUint) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskGlobalNumUint) == 0) && (len((*z).encodedApplicationCallTxnFields.GlobalNumByteSlice) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice) == 0) && (len((*z).encodedApplicationCallTxnFields.ApprovalProgram) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskApprovalProgram) == 0) && (len((*z).encodedApplicationCallTxnFields.ClearStateProgram) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskClearStateProgram) == 0) && (len((*z).encodedApplicationCallTxnFields.ExtraProgramPages) == 0) && (len((*z).encodedApplicationCallTxnFields.BitmaskExtraProgramPages) == 0) && (len((*z).encodedCompactCertTxnFields.CertRound) == 0) && (len((*z).encodedCompactCertTxnFields.BitmaskCertRound) == 0) && (len((*z).encodedCompactCertTxnFields.CertType) == 0) && (len((*z).encodedCompactCertTxnFields.BitmaskCertType) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.SigCommit) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.SignedWeight) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.SigProofs) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.PartProofs) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskPartHash) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.Reveals) == 0) && (len((*z).encodedCompactCertTxnFields.encodedCert.BitmaskReveals) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *packedTransactionGroups) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).CompressionFormat == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if len((*z).Bytes) == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).LenDecompressedBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "c"
			o = append(o, 0xa1, 0x63)
			o = msgp.AppendByte(o, (*z).CompressionFormat)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "g"
			o = append(o, 0xa1, 0x67)
			o = msgp.AppendBytes(o, (*z).Bytes)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "l"
			o = append(o, 0xa1, 0x6c)
			o = msgp.AppendUint64(o, (*z).LenDecompressedBytes)
		}
	}
	return
}

func (_ *packedTransactionGroups) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*packedTransactionGroups)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *packedTransactionGroups) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			var zb0003 int
			zb0003, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Bytes")
				return
			}
			if zb0003 > maxEncodedTransactionGroupBytes {
				err = msgp.ErrOverflow(uint64(zb0003), uint64(maxEncodedTransactionGroupBytes))
				return
			}
			(*z).Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).Bytes)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Bytes")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).CompressionFormat, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CompressionFormat")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).LenDecompressedBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LenDecompressedBytes")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = packedTransactionGroups{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "g":
				var zb0004 int
				zb0004, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bytes")
					return
				}
				if zb0004 > maxEncodedTransactionGroupBytes {
					err = msgp.ErrOverflow(uint64(zb0004), uint64(maxEncodedTransactionGroupBytes))
					return
				}
				(*z).Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).Bytes)
				if err != nil {
					err = msgp.WrapError(err, "Bytes")
					return
				}
			case "c":
				(*z).CompressionFormat, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CompressionFormat")
					return
				}
			case "l":
				(*z).LenDecompressedBytes, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LenDecompressedBytes")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *packedTransactionGroups) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*packedTransactionGroups)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *packedTransactionGroups) Msgsize() (s int) {
	s = 1 + 2 + msgp.BytesPrefixSize + len((*z).Bytes) + 2 + msgp.ByteSize + 2 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *packedTransactionGroups) MsgIsZero() bool {
	return (len((*z).Bytes) == 0) && ((*z).CompressionFormat == 0) && ((*z).LenDecompressedBytes == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z program) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, []byte(z))
	return
}

func (_ program) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(program)
	if !ok {
		_, ok = (z).(*program)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *program) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 []byte
		var zb0002 int
		zb0002, err = msgp.ReadBytesBytesHeader(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > config.MaxAvailableAppProgramLen {
			err = msgp.ErrOverflow(uint64(zb0002), uint64(config.MaxAvailableAppProgramLen))
			return
		}
		zb0001, bts, err = msgp.ReadBytesBytes(bts, []byte((*z)))
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = program(zb0001)
	}
	o = bts
	return
}

func (_ *program) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*program)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z program) Msgsize() (s int) {
	s = msgp.BytesPrefixSize + len([]byte(z))
	return
}

// MsgIsZero returns whether this is a zero value
func (z program) MsgIsZero() bool {
	return len(z) == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *relayedProposal) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if len((*z).RawBytes) == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Content == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).ExcludeProposal.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "b"
			o = append(o, 0xa1, 0x62)
			o = msgp.AppendBytes(o, (*z).RawBytes)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "c"
			o = append(o, 0xa1, 0x63)
			o = msgp.AppendByte(o, (*z).Content)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "e"
			o = append(o, 0xa1, 0x65)
			o = (*z).ExcludeProposal.MarshalMsg(o)
		}
	}
	return
}

func (_ *relayedProposal) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*relayedProposal)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *relayedProposal) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			var zb0003 int
			zb0003, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RawBytes")
				return
			}
			if zb0003 > maxProposalSize {
				err = msgp.ErrOverflow(uint64(zb0003), uint64(maxProposalSize))
				return
			}
			(*z).RawBytes, bts, err = msgp.ReadBytesBytes(bts, (*z).RawBytes)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RawBytes")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).ExcludeProposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ExcludeProposal")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Content, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Content")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = relayedProposal{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "b":
				var zb0004 int
				zb0004, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "RawBytes")
					return
				}
				if zb0004 > maxProposalSize {
					err = msgp.ErrOverflow(uint64(zb0004), uint64(maxProposalSize))
					return
				}
				(*z).RawBytes, bts, err = msgp.ReadBytesBytes(bts, (*z).RawBytes)
				if err != nil {
					err = msgp.WrapError(err, "RawBytes")
					return
				}
			case "e":
				bts, err = (*z).ExcludeProposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExcludeProposal")
					return
				}
			case "c":
				(*z).Content, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Content")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *relayedProposal) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*relayedProposal)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *relayedProposal) Msgsize() (s int) {
	s = 1 + 2 + msgp.BytesPrefixSize + len((*z).RawBytes) + 2 + (*z).ExcludeProposal.Msgsize() + 2 + msgp.ByteSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *relayedProposal) MsgIsZero() bool {
	return (len((*z).RawBytes) == 0) && ((*z).ExcludeProposal.MsgIsZero()) && ((*z).Content == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *requestParams) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 3 bits */
	if (*z).Modulator == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Offset == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "m"
			o = append(o, 0xa1, 0x6d)
			o = msgp.AppendByte(o, (*z).Modulator)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "o"
			o = append(o, 0xa1, 0x6f)
			o = msgp.AppendByte(o, (*z).Offset)
		}
	}
	return
}

func (_ *requestParams) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*requestParams)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *requestParams) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Offset, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Offset")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Modulator, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Modulator")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = requestParams{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "o":
				(*z).Offset, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Offset")
					return
				}
			case "m":
				(*z).Modulator, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Modulator")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *requestParams) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*requestParams)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *requestParams) Msgsize() (s int) {
	s = 1 + 2 + msgp.ByteSize + 2 + msgp.ByteSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *requestParams) MsgIsZero() bool {
	return ((*z).Offset == 0) && ((*z).Modulator == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z revealMap) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	if z == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendMapHeader(o, uint32(len(z)))
	}
	za0002_keys := make([]uint64, 0, len(z))
	for za0002 := range z {
		za0002_keys = append(za0002_keys, za0002)
	}
	sort.Sort(SortUint64(za0002_keys))
	for _, za0002 := range za0002_keys {
		za0003 := z[za0002]
		_ = za0003
		o = msgp.AppendUint64(o, za0002)
		o = za0003.MarshalMsg(o)
	}
	return
}

func (_ revealMap) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(revealMap)
	if !ok {
		_, ok = (z).(*revealMap)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *revealMap) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0003 > compactcert.MaxReveals {
		err = msgp.ErrOverflow(uint64(zb0003), uint64(compactcert.MaxReveals))
		err = msgp.WrapError(err)
		return
	}
	if zb0004 {
		(*z) = nil
	} else if (*z) == nil {
		(*z) = make(revealMap, zb0003)
	}
	for zb0003 > 0 {
		var zb0001 uint64
		var zb0002 compactcert.Reveal
		zb0003--
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		bts, err = zb0002.UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		(*z)[zb0001] = zb0002
	}
	o = bts
	return
}

func (_ *revealMap) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*revealMap)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z revealMap) Msgsize() (s int) {
	s = msgp.MapHeaderSize
	if z != nil {
		for za0002, za0003 := range z {
			_ = za0002
			_ = za0003
			s += 0 + msgp.Uint64Size + za0003.Msgsize()
		}
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z revealMap) MsgIsZero() bool {
	return len(z) == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *timingParams) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(4)
	var zb0002Mask uint8 /* 5 bits */
	if len((*z).AcceptedMsgSeq) == 0 {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	if (*z).NextMsgMinDelay == 0 {
		zb0002Len--
		zb0002Mask |= 0x4
	}
	if (*z).ResponseElapsedTime == 0 {
		zb0002Len--
		zb0002Mask |= 0x8
	}
	if (*z).RefTxnBlockMsgSeq == 0 {
		zb0002Len--
		zb0002Mask |= 0x10
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "a"
			o = append(o, 0xa1, 0x61)
			if (*z).AcceptedMsgSeq == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).AcceptedMsgSeq)))
			}
			for zb0001 := range (*z).AcceptedMsgSeq {
				o = msgp.AppendUint64(o, (*z).AcceptedMsgSeq[zb0001])
			}
		}
		if (zb0002Mask & 0x4) == 0 { // if not empty
			// string "m"
			o = append(o, 0xa1, 0x6d)
			o = msgp.AppendUint64(o, (*z).NextMsgMinDelay)
		}
		if (zb0002Mask & 0x8) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = msgp.AppendUint64(o, (*z).ResponseElapsedTime)
		}
		if (zb0002Mask & 0x10) == 0 { // if not empty
			// string "s"
			o = append(o, 0xa1, 0x73)
			o = msgp.AppendUint64(o, (*z).RefTxnBlockMsgSeq)
		}
	}
	return
}

func (_ *timingParams) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*timingParams)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *timingParams) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			(*z).RefTxnBlockMsgSeq, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RefTxnBlockMsgSeq")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).ResponseElapsedTime, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ResponseElapsedTime")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AcceptedMsgSeq")
				return
			}
			if zb0004 > maxAcceptedMsgSeq {
				err = msgp.ErrOverflow(uint64(zb0004), uint64(maxAcceptedMsgSeq))
				err = msgp.WrapError(err, "struct-from-array", "AcceptedMsgSeq")
				return
			}
			if zb0005 {
				(*z).AcceptedMsgSeq = nil
			} else if (*z).AcceptedMsgSeq != nil && cap((*z).AcceptedMsgSeq) >= zb0004 {
				(*z).AcceptedMsgSeq = ((*z).AcceptedMsgSeq)[:zb0004]
			} else {
				(*z).AcceptedMsgSeq = make([]uint64, zb0004)
			}
			for zb0001 := range (*z).AcceptedMsgSeq {
				(*z).AcceptedMsgSeq[zb0001], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AcceptedMsgSeq", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).NextMsgMinDelay, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextMsgMinDelay")
				return
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = timingParams{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "s":
				(*z).RefTxnBlockMsgSeq, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RefTxnBlockMsgSeq")
					return
				}
			case "r":
				(*z).ResponseElapsedTime, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ResponseElapsedTime")
					return
				}
			case "a":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AcceptedMsgSeq")
					return
				}
				if zb0006 > maxAcceptedMsgSeq {
					err = msgp.ErrOverflow(uint64(zb0006), uint64(maxAcceptedMsgSeq))
					err = msgp.WrapError(err, "AcceptedMsgSeq")
					return
				}
				if zb0007 {
					(*z).AcceptedMsgSeq = nil
				} else if (*z).AcceptedMsgSeq != nil && cap((*z).AcceptedMsgSeq) >= zb0006 {
					(*z).AcceptedMsgSeq = ((*z).AcceptedMsgSeq)[:zb0006]
				} else {
					(*z).AcceptedMsgSeq = make([]uint64, zb0006)
				}
				for zb0001 := range (*z).AcceptedMsgSeq {
					(*z).AcceptedMsgSeq[zb0001], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AcceptedMsgSeq", zb0001)
						return
					}
				}
			case "m":
				(*z).NextMsgMinDelay, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextMsgMinDelay")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *timingParams) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*timingParams)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *timingParams) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint64Size + 2 + msgp.Uint64Size + 2 + msgp.ArrayHeaderSize + (len((*z).AcceptedMsgSeq) * (msgp.Uint64Size)) + 2 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *timingParams) MsgIsZero() bool {
	return ((*z).RefTxnBlockMsgSeq == 0) && ((*z).ResponseElapsedTime == 0) && (len((*z).AcceptedMsgSeq) == 0) && ((*z).NextMsgMinDelay == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *transactionBlockMessage) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 8 bits */
	if (*z).TxnBloomFilter.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).TransactionGroups.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if ((*z).UpdatedRequestParams.Offset == 0) && ((*z).UpdatedRequestParams.Modulator == 0) {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).RelayedProposal.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).MsgSync.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if (*z).Version == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "b"
			o = append(o, 0xa1, 0x62)
			o = (*z).TxnBloomFilter.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "g"
			o = append(o, 0xa1, 0x67)
			o = (*z).TransactionGroups.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "p"
			o = append(o, 0xa1, 0x70)
			// omitempty: check for empty values
			zb0002Len := uint32(2)
			var zb0002Mask uint8 /* 3 bits */
			if (*z).UpdatedRequestParams.Modulator == 0 {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			if (*z).UpdatedRequestParams.Offset == 0 {
				zb0002Len--
				zb0002Mask |= 0x4
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x2) == 0 { // if not empty
				// string "m"
				o = append(o, 0xa1, 0x6d)
				o = msgp.AppendByte(o, (*z).UpdatedRequestParams.Modulator)
			}
			if (zb0002Mask & 0x4) == 0 { // if not empty
				// string "o"
				o = append(o, 0xa1, 0x6f)
				o = msgp.AppendByte(o, (*z).UpdatedRequestParams.Offset)
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "rp"
			o = append(o, 0xa2, 0x72, 0x70)
			o = (*z).RelayedProposal.MarshalMsg(o)
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			o = (*z).MsgSync.MarshalMsg(o)
		}
		if (zb0001Mask & 0x80) == 0 { // if not empty
			// string "v"
			o = append(o, 0xa1, 0x76)
			o = msgp.AppendInt32(o, (*z).Version)
		}
	}
	return
}

func (_ *transactionBlockMessage) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*transactionBlockMessage)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *transactionBlockMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Version, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Version")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).TxnBloomFilter.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnBloomFilter")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0003 int
			var zb0004 bool
			zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams")
					return
				}
				if zb0003 > 0 {
					zb0003--
					(*z).UpdatedRequestParams.Offset, bts, err = msgp.ReadByteBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "struct-from-array", "Offset")
						return
					}
				}
				if zb0003 > 0 {
					zb0003--
					(*z).UpdatedRequestParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "struct-from-array", "Modulator")
						return
					}
				}
				if zb0003 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0003)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams")
					return
				}
				if zb0004 {
					(*z).UpdatedRequestParams = requestParams{}
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams")
						return
					}
					switch string(field) {
					case "o":
						(*z).UpdatedRequestParams.Offset, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "Offset")
							return
						}
					case "m":
						(*z).UpdatedRequestParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "Modulator")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).TransactionGroups.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TransactionGroups")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).MsgSync.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MsgSync")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).RelayedProposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RelayedProposal")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = transactionBlockMessage{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "v":
				(*z).Version, bts, err = msgp.ReadInt32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Version")
					return
				}
			case "r":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "b":
				bts, err = (*z).TxnBloomFilter.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnBloomFilter")
					return
				}
			case "p":
				var zb0005 int
				var zb0006 bool
				zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "UpdatedRequestParams")
						return
					}
					if zb0005 > 0 {
						zb0005--
						(*z).UpdatedRequestParams.Offset, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "UpdatedRequestParams", "struct-from-array", "Offset")
							return
						}
					}
					if zb0005 > 0 {
						zb0005--
						(*z).UpdatedRequestParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "UpdatedRequestParams", "struct-from-array", "Modulator")
							return
						}
					}
					if zb0005 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0005)
						if err != nil {
							err = msgp.WrapError(err, "UpdatedRequestParams", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "UpdatedRequestParams")
						return
					}
					if zb0006 {
						(*z).UpdatedRequestParams = requestParams{}
					}
					for zb0005 > 0 {
						zb0005--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "UpdatedRequestParams")
							return
						}
						switch string(field) {
						case "o":
							(*z).UpdatedRequestParams.Offset, bts, err = msgp.ReadByteBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "UpdatedRequestParams", "Offset")
								return
							}
						case "m":
							(*z).UpdatedRequestParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "UpdatedRequestParams", "Modulator")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "UpdatedRequestParams")
								return
							}
						}
					}
				}
			case "g":
				bts, err = (*z).TransactionGroups.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TransactionGroups")
					return
				}
			case "t":
				bts, err = (*z).MsgSync.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "MsgSync")
					return
				}
			case "rp":
				bts, err = (*z).RelayedProposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RelayedProposal")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *transactionBlockMessage) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*transactionBlockMessage)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *transactionBlockMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.Int32Size + 2 + (*z).Round.Msgsize() + 2 + (*z).TxnBloomFilter.Msgsize() + 2 + 1 + 2 + msgp.ByteSize + 2 + msgp.ByteSize + 2 + (*z).TransactionGroups.Msgsize() + 2 + (*z).MsgSync.Msgsize() + 3 + (*z).RelayedProposal.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *transactionBlockMessage) MsgIsZero() bool {
	return ((*z).Version == 0) && ((*z).Round.MsgIsZero()) && ((*z).TxnBloomFilter.MsgIsZero()) && (((*z).UpdatedRequestParams.Offset == 0) && ((*z).UpdatedRequestParams.Modulator == 0)) && ((*z).TransactionGroups.MsgIsZero()) && ((*z).MsgSync.MsgIsZero()) && ((*z).RelayedProposal.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *txGroupsEncodingStub) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0053Len := uint32(135)
	var zb0053Mask [3]uint64 /* 150 bits */
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x8000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x10000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x20000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x40000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x80000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x100000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x200000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x400000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x800000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x1000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x2000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x4000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x8000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.OnCompletion) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x10000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x20000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x40000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x80000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x100000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x200000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x400000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x800000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x1000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x2000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x4000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x8000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x10000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x20000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x40000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x80000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetReceiver) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x100000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x200000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetSender) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x400000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x800000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x1000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x2000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x4000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x8000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x10000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x20000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x40000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x80000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x100000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x200000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x400000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x800000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x1000000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x2000000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x4000000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit) == 0 {
		zb0053Len--
		zb0053Mask[0] |= 0x8000000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x1
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x2
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x4
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x8
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x10
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertType) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x20
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x40
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x80
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x100
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x200
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.CommitmentRoot) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x400
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x800
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x1000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x2000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x4000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x8000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x10000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x20000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x40000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x80000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x100000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x200000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x400000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x800000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x1000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x2000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x4000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x8000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x10000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGroup) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x20000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x40000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x80000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x100000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x200000000
	}
	if len((*z).encodedSignedTxns.encodedLsigs.LogicArgs) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x400000000
	}
	if len((*z).encodedSignedTxns.encodedLsigs.BitmaskLogicArgs) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x800000000
	}
	if len((*z).encodedSignedTxns.encodedLsigs.Logic) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x1000000000
	}
	if len((*z).encodedSignedTxns.encodedLsigs.BitmaskLogic) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x2000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x4000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x8000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x10000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x20000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x40000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x80000000000
	}
	if len((*z).encodedSignedTxns.encodedMsigs.Threshold) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x100000000000
	}
	if len((*z).encodedSignedTxns.encodedMsigs.BitmaskThreshold) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x200000000000
	}
	if len((*z).encodedSignedTxns.encodedMsigs.Version) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x400000000000
	}
	if len((*z).encodedSignedTxns.encodedMsigs.BitmaskVersion) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x800000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x1000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x2000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x4000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x8000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x10000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x20000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x40000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x80000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x100000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x200000000000000
	}
	if len((*z).encodedSignedTxns.AuthAddr) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x400000000000000
	}
	if len((*z).encodedSignedTxns.BitmaskAuthAddr) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x800000000000000
	}
	if len((*z).encodedSignedTxns.Sig) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x1000000000000000
	}
	if len((*z).encodedSignedTxns.BitmaskSig) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x2000000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x4000000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender) == 0 {
		zb0053Len--
		zb0053Mask[1] |= 0x8000000000000000
	}
	if len((*z).encodedSignedTxns.encodedMsigs.Subsigs) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x1
	}
	if len((*z).encodedSignedTxns.encodedMsigs.BitmaskSubsigs) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x2
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x4
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x8
	}
	if (*z).TransactionGroupCount == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x10
	}
	if len((*z).TransactionGroupSizes) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x20
	}
	if (*z).TotalTransactionsCount == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x40
	}
	if len((*z).encodedSignedTxns.encodedTxns.TxType) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x80
	}
	if len((*z).encodedSignedTxns.encodedTxns.BitmaskTxType) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x100
	}
	if (*z).encodedSignedTxns.encodedTxns.TxTypeOffset == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x200
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x400
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x800
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x1000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x2000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x4000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskKeys) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x8000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x10000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x20000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x40000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x80000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x100000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset) == 0 {
		zb0053Len--
		zb0053Mask[2] |= 0x200000
	}
	// variable map header, size zb0053Len
	o = msgp.AppendMapHeader(o, zb0053Len)
	if zb0053Len != 0 {
		if (zb0053Mask[0] & 0x8000) == 0 { // if not empty
			// string "aamt"
			o = append(o, 0xa4, 0x61, 0x61, 0x6d, 0x74)
			if (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount)))
			}
			for zb0022 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount {
				o = msgp.AppendUint64(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount[zb0022])
			}
		}
		if (zb0053Mask[0] & 0x10000) == 0 { // if not empty
			// string "aamtbm"
			o = append(o, 0xa6, 0x61, 0x61, 0x6d, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount))
		}
		if (zb0053Mask[0] & 0x20000) == 0 { // if not empty
			// string "aclose"
			o = append(o, 0xa6, 0x61, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo)
		}
		if (zb0053Mask[0] & 0x40000) == 0 { // if not empty
			// string "aclosebm"
			o = append(o, 0xa8, 0x61, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo))
		}
		if (zb0053Mask[0] & 0x80000) == 0 { // if not empty
			// string "afrzbm"
			o = append(o, 0xa6, 0x61, 0x66, 0x72, 0x7a, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen))
		}
		if (zb0053Mask[0] & 0x100000) == 0 { // if not empty
			// string "am"
			o = append(o, 0xa2, 0x61, 0x6d)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash)
		}
		if (zb0053Mask[0] & 0x200000) == 0 { // if not empty
			// string "ambm"
			o = append(o, 0xa4, 0x61, 0x6d, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash))
		}
		if (zb0053Mask[0] & 0x400000) == 0 { // if not empty
			// string "amt"
			o = append(o, 0xa3, 0x61, 0x6d, 0x74)
			if (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount)))
			}
			for zb0014 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount {
				o = (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount[zb0014].MarshalMsg(o)
			}
		}
		if (zb0053Mask[0] & 0x800000) == 0 { // if not empty
			// string "amtbm"
			o = append(o, 0xa5, 0x61, 0x6d, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount))
		}
		if (zb0053Mask[0] & 0x1000000) == 0 { // if not empty
			// string "an"
			o = append(o, 0xa2, 0x61, 0x6e)
			if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName)))
			}
			for zb0019 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName {
				o = msgp.AppendString(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName[zb0019])
			}
		}
		if (zb0053Mask[0] & 0x2000000) == 0 { // if not empty
			// string "anbm"
			o = append(o, 0xa4, 0x61, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName))
		}
		if (zb0053Mask[0] & 0x4000000) == 0 { // if not empty
			// string "apaa"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x61)
			if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs)))
			}
			for zb0025 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs {
				if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025])))
				}
				for zb0026 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] {
					o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025][zb0026])
				}
			}
		}
		if (zb0053Mask[0] & 0x8000000) == 0 { // if not empty
			// string "apaabm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x61, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs))
		}
		if (zb0053Mask[0] & 0x10000000) == 0 { // if not empty
			// string "apan"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x6e)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.OnCompletion)
		}
		if (zb0053Mask[0] & 0x20000000) == 0 { // if not empty
			// string "apanbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion))
		}
		if (zb0053Mask[0] & 0x40000000) == 0 { // if not empty
			// string "apap"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x70)
			if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram)))
			}
			for zb0037 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram {
				o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram[zb0037]))
			}
		}
		if (zb0053Mask[0] & 0x80000000) == 0 { // if not empty
			// string "apapbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x70, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram))
		}
		if (zb0053Mask[0] & 0x100000000) == 0 { // if not empty
			// string "apas"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x73)
			if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets)))
			}
			for zb0031 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets {
				if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031])))
				}
				for zb0032 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] {
					o = (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031][zb0032].MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[0] & 0x200000000) == 0 { // if not empty
			// string "apasbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets))
		}
		if (zb0053Mask[0] & 0x400000000) == 0 { // if not empty
			// string "apat"
			o = append(o, 0xa4, 0x61, 0x70, 0x61, 0x74)
			if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts)))
			}
			for zb0027 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts {
				if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027])))
				}
				for zb0028 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] {
					o = (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027][zb0028].MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[0] & 0x800000000) == 0 { // if not empty
			// string "apatbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x61, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts))
		}
		if (zb0053Mask[0] & 0x1000000000) == 0 { // if not empty
			// string "apep"
			o = append(o, 0xa4, 0x61, 0x70, 0x65, 0x70)
			if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages)))
			}
			for zb0039 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages {
				o = msgp.AppendUint32(o, (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages[zb0039])
			}
		}
		if (zb0053Mask[0] & 0x2000000000) == 0 { // if not empty
			// string "apepbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x65, 0x70, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages))
		}
		if (zb0053Mask[0] & 0x4000000000) == 0 { // if not empty
			// string "apfa"
			o = append(o, 0xa4, 0x61, 0x70, 0x66, 0x61)
			if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps)))
			}
			for zb0029 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps {
				if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029])))
				}
				for zb0030 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] {
					o = (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029][zb0030].MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[0] & 0x8000000000) == 0 { // if not empty
			// string "apfabm"
			o = append(o, 0xa6, 0x61, 0x70, 0x66, 0x61, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps))
		}
		if (zb0053Mask[0] & 0x10000000000) == 0 { // if not empty
			// string "apid"
			o = append(o, 0xa4, 0x61, 0x70, 0x69, 0x64)
			if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID)))
			}
			for zb0024 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID {
				o = (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID[zb0024].MarshalMsg(o)
			}
		}
		if (zb0053Mask[0] & 0x20000000000) == 0 { // if not empty
			// string "apidbm"
			o = append(o, 0xa6, 0x61, 0x70, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID))
		}
		if (zb0053Mask[0] & 0x40000000000) == 0 { // if not empty
			// string "apsu"
			o = append(o, 0xa4, 0x61, 0x70, 0x73, 0x75)
			if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram)))
			}
			for zb0038 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram {
				o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram[zb0038]))
			}
		}
		if (zb0053Mask[0] & 0x80000000000) == 0 { // if not empty
			// string "apsubm"
			o = append(o, 0xa6, 0x61, 0x70, 0x73, 0x75, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram))
		}
		if (zb0053Mask[0] & 0x100000000000) == 0 { // if not empty
			// string "arcv"
			o = append(o, 0xa4, 0x61, 0x72, 0x63, 0x76)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetReceiver)
		}
		if (zb0053Mask[0] & 0x200000000000) == 0 { // if not empty
			// string "arcvbm"
			o = append(o, 0xa6, 0x61, 0x72, 0x63, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver))
		}
		if (zb0053Mask[0] & 0x400000000000) == 0 { // if not empty
			// string "asnd"
			o = append(o, 0xa4, 0x61, 0x73, 0x6e, 0x64)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetSender)
		}
		if (zb0053Mask[0] & 0x800000000000) == 0 { // if not empty
			// string "asndbm"
			o = append(o, 0xa6, 0x61, 0x73, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender))
		}
		if (zb0053Mask[0] & 0x1000000000000) == 0 { // if not empty
			// string "au"
			o = append(o, 0xa2, 0x61, 0x75)
			if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL)))
			}
			for zb0020 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL {
				o = msgp.AppendString(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL[zb0020])
			}
		}
		if (zb0053Mask[0] & 0x2000000000000) == 0 { // if not empty
			// string "aubm"
			o = append(o, 0xa4, 0x61, 0x75, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL))
		}
		if (zb0053Mask[0] & 0x4000000000000) == 0 { // if not empty
			// string "c"
			o = append(o, 0xa1, 0x63)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback)
		}
		if (zb0053Mask[0] & 0x8000000000000) == 0 { // if not empty
			// string "caid"
			o = append(o, 0xa4, 0x63, 0x61, 0x69, 0x64)
			if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset)))
			}
			for zb0015 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset {
				o = (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset[zb0015].MarshalMsg(o)
			}
		}
		if (zb0053Mask[0] & 0x10000000000000) == 0 { // if not empty
			// string "caidbm"
			o = append(o, 0xa6, 0x63, 0x61, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset))
		}
		if (zb0053Mask[0] & 0x20000000000000) == 0 { // if not empty
			// string "cbm"
			o = append(o, 0xa3, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback))
		}
		if (zb0053Mask[0] & 0x40000000000000) == 0 { // if not empty
			// string "certP"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x50)
			if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs)))
			}
			for zb0047 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs {
				if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047])))
				}
				for zb0048 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] {
					o = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047][zb0048].MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[0] & 0x80000000000000) == 0 { // if not empty
			// string "certPH"
			o = append(o, 0xa6, 0x63, 0x65, 0x72, 0x74, 0x50, 0x48)
			if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes)))
			}
			for zb0049 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes {
				o = msgp.AppendUint64(o, (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes[zb0049])
			}
		}
		if (zb0053Mask[0] & 0x100000000000000) == 0 { // if not empty
			// string "certPHbm"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x50, 0x48, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash))
		}
		if (zb0053Mask[0] & 0x200000000000000) == 0 { // if not empty
			// string "certPbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x50, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs))
		}
		if (zb0053Mask[0] & 0x400000000000000) == 0 { // if not empty
			// string "certS"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x53)
			if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs)))
			}
			for zb0044 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs {
				if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044])))
				}
				for zb0045 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] {
					o = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044][zb0045].MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[0] & 0x800000000000000) == 0 { // if not empty
			// string "certSH"
			o = append(o, 0xa6, 0x63, 0x65, 0x72, 0x74, 0x53, 0x48)
			if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes)))
			}
			for zb0046 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes {
				o = msgp.AppendUint64(o, (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes[zb0046])
			}
		}
		if (zb0053Mask[0] & 0x1000000000000000) == 0 { // if not empty
			// string "certSHbm"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x53, 0x48, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash))
		}
		if (zb0053Mask[0] & 0x2000000000000000) == 0 { // if not empty
			// string "certSbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x53, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs))
		}
		if (zb0053Mask[0] & 0x4000000000000000) == 0 { // if not empty
			// string "certc"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x63)
			if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit)))
			}
			for zb0042 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit {
				o = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit[zb0042].MarshalMsg(o)
			}
		}
		if (zb0053Mask[0] & 0x8000000000000000) == 0 { // if not empty
			// string "certcbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit))
		}
		if (zb0053Mask[1] & 0x1) == 0 { // if not empty
			// string "certr"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x72)
			if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals)))
			}
			for zb0050 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals {
				if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendMapHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050])))
				}
				zb0051_keys := make([]uint64, 0, len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050]))
				for zb0051 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] {
					zb0051_keys = append(zb0051_keys, zb0051)
				}
				sort.Sort(SortUint64(zb0051_keys))
				for _, zb0051 := range zb0051_keys {
					zb0052 := (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050][zb0051]
					_ = zb0052
					o = msgp.AppendUint64(o, zb0051)
					o = zb0052.MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[1] & 0x2) == 0 { // if not empty
			// string "certrbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals))
		}
		if (zb0053Mask[1] & 0x4) == 0 { // if not empty
			// string "certrnd"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x72, 0x6e, 0x64)
			if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound)))
			}
			for zb0040 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound {
				o = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound[zb0040].MarshalMsg(o)
			}
		}
		if (zb0053Mask[1] & 0x8) == 0 { // if not empty
			// string "certrndbm"
			o = append(o, 0xa9, 0x63, 0x65, 0x72, 0x74, 0x72, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound))
		}
		if (zb0053Mask[1] & 0x10) == 0 { // if not empty
			// string "certtype"
			o = append(o, 0xa8, 0x63, 0x65, 0x72, 0x74, 0x74, 0x79, 0x70, 0x65)
			if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType)))
			}
			for zb0041 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType {
				o = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType[zb0041].MarshalMsg(o)
			}
		}
		if (zb0053Mask[1] & 0x20) == 0 { // if not empty
			// string "certtypebm"
			o = append(o, 0xaa, 0x63, 0x65, 0x72, 0x74, 0x74, 0x79, 0x70, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertType))
		}
		if (zb0053Mask[1] & 0x40) == 0 { // if not empty
			// string "certw"
			o = append(o, 0xa5, 0x63, 0x65, 0x72, 0x74, 0x77)
			if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight)))
			}
			for zb0043 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight {
				o = msgp.AppendUint64(o, (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight[zb0043])
			}
		}
		if (zb0053Mask[1] & 0x80) == 0 { // if not empty
			// string "certwbm"
			o = append(o, 0xa7, 0x63, 0x65, 0x72, 0x74, 0x77, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight))
		}
		if (zb0053Mask[1] & 0x100) == 0 { // if not empty
			// string "close"
			o = append(o, 0xa5, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo)
		}
		if (zb0053Mask[1] & 0x200) == 0 { // if not empty
			// string "closebm"
			o = append(o, 0xa7, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
		}
		if (zb0053Mask[1] & 0x400) == 0 { // if not empty
			// string "comt"
			o = append(o, 0xa4, 0x63, 0x6f, 0x6d, 0x74)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.CommitmentRoot)
		}
		if (zb0053Mask[1] & 0x800) == 0 { // if not empty
			// string "dc"
			o = append(o, 0xa2, 0x64, 0x63)
			if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals)))
			}
			for zb0017 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals {
				o = msgp.AppendUint32(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals[zb0017])
			}
		}
		if (zb0053Mask[1] & 0x1000) == 0 { // if not empty
			// string "dcbm"
			o = append(o, 0xa4, 0x64, 0x63, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals))
		}
		if (zb0053Mask[1] & 0x2000) == 0 { // if not empty
			// string "dfbm"
			o = append(o, 0xa4, 0x64, 0x66, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen))
		}
		if (zb0053Mask[1] & 0x4000) == 0 { // if not empty
			// string "f"
			o = append(o, 0xa1, 0x66)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze)
		}
		if (zb0053Mask[1] & 0x8000) == 0 { // if not empty
			// string "fadd"
			o = append(o, 0xa4, 0x66, 0x61, 0x64, 0x64)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount)
		}
		if (zb0053Mask[1] & 0x10000) == 0 { // if not empty
			// string "faddbm"
			o = append(o, 0xa6, 0x66, 0x61, 0x64, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount))
		}
		if (zb0053Mask[1] & 0x20000) == 0 { // if not empty
			// string "faid"
			o = append(o, 0xa4, 0x66, 0x61, 0x69, 0x64)
			if (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset)))
			}
			for zb0023 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset {
				o = (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset[zb0023].MarshalMsg(o)
			}
		}
		if (zb0053Mask[1] & 0x40000) == 0 { // if not empty
			// string "faidbm"
			o = append(o, 0xa6, 0x66, 0x61, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset))
		}
		if (zb0053Mask[1] & 0x80000) == 0 { // if not empty
			// string "fbm"
			o = append(o, 0xa3, 0x66, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze))
		}
		if (zb0053Mask[1] & 0x100000) == 0 { // if not empty
			// string "fee"
			o = append(o, 0xa3, 0x66, 0x65, 0x65)
			if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee)))
			}
			for zb0006 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee {
				o = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee[zb0006].MarshalMsg(o)
			}
		}
		if (zb0053Mask[1] & 0x200000) == 0 { // if not empty
			// string "feebm"
			o = append(o, 0xa5, 0x66, 0x65, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee))
		}
		if (zb0053Mask[1] & 0x400000) == 0 { // if not empty
			// string "fv"
			o = append(o, 0xa2, 0x66, 0x76)
			if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid)))
			}
			for zb0007 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid {
				o = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid[zb0007].MarshalMsg(o)
			}
		}
		if (zb0053Mask[1] & 0x800000) == 0 { // if not empty
			// string "fvbm"
			o = append(o, 0xa4, 0x66, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid))
		}
		if (zb0053Mask[1] & 0x1000000) == 0 { // if not empty
			// string "genbm"
			o = append(o, 0xa5, 0x67, 0x65, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID))
		}
		if (zb0053Mask[1] & 0x2000000) == 0 { // if not empty
			// string "gnbs"
			o = append(o, 0xa4, 0x67, 0x6e, 0x62, 0x73)
			if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice)))
			}
			for zb0036 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice {
				o = msgp.AppendUint64(o, (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice[zb0036])
			}
		}
		if (zb0053Mask[1] & 0x4000000) == 0 { // if not empty
			// string "gnbsbm"
			o = append(o, 0xa6, 0x67, 0x6e, 0x62, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice))
		}
		if (zb0053Mask[1] & 0x8000000) == 0 { // if not empty
			// string "gnui"
			o = append(o, 0xa4, 0x67, 0x6e, 0x75, 0x69)
			if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint)))
			}
			for zb0035 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint {
				o = msgp.AppendUint64(o, (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint[zb0035])
			}
		}
		if (zb0053Mask[1] & 0x10000000) == 0 { // if not empty
			// string "gnuibm"
			o = append(o, 0xa6, 0x67, 0x6e, 0x75, 0x69, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint))
		}
		if (zb0053Mask[1] & 0x20000000) == 0 { // if not empty
			// string "grpbm"
			o = append(o, 0xa5, 0x67, 0x72, 0x70, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGroup))
		}
		if (zb0053Mask[1] & 0x40000000) == 0 { // if not empty
			// string "lnbs"
			o = append(o, 0xa4, 0x6c, 0x6e, 0x62, 0x73)
			if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice)))
			}
			for zb0034 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice {
				o = msgp.AppendUint64(o, (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice[zb0034])
			}
		}
		if (zb0053Mask[1] & 0x80000000) == 0 { // if not empty
			// string "lnbsbm"
			o = append(o, 0xa6, 0x6c, 0x6e, 0x62, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice))
		}
		if (zb0053Mask[1] & 0x100000000) == 0 { // if not empty
			// string "lnui"
			o = append(o, 0xa4, 0x6c, 0x6e, 0x75, 0x69)
			if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint)))
			}
			for zb0033 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint {
				o = msgp.AppendUint64(o, (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint[zb0033])
			}
		}
		if (zb0053Mask[1] & 0x200000000) == 0 { // if not empty
			// string "lnuibm"
			o = append(o, 0xa6, 0x6c, 0x6e, 0x75, 0x69, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint))
		}
		if (zb0053Mask[1] & 0x400000000) == 0 { // if not empty
			// string "lsigarg"
			o = append(o, 0xa7, 0x6c, 0x73, 0x69, 0x67, 0x61, 0x72, 0x67)
			if (*z).encodedSignedTxns.encodedLsigs.LogicArgs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedLsigs.LogicArgs)))
			}
			for zb0004 := range (*z).encodedSignedTxns.encodedLsigs.LogicArgs {
				if (*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004])))
				}
				for zb0005 := range (*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] {
					o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004][zb0005])
				}
			}
		}
		if (zb0053Mask[1] & 0x800000000) == 0 { // if not empty
			// string "lsigargbm"
			o = append(o, 0xa9, 0x6c, 0x73, 0x69, 0x67, 0x61, 0x72, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedLsigs.BitmaskLogicArgs))
		}
		if (zb0053Mask[1] & 0x1000000000) == 0 { // if not empty
			// string "lsigl"
			o = append(o, 0xa5, 0x6c, 0x73, 0x69, 0x67, 0x6c)
			if (*z).encodedSignedTxns.encodedLsigs.Logic == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedLsigs.Logic)))
			}
			for zb0003 := range (*z).encodedSignedTxns.encodedLsigs.Logic {
				o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedLsigs.Logic[zb0003])
			}
		}
		if (zb0053Mask[1] & 0x2000000000) == 0 { // if not empty
			// string "lsiglbm"
			o = append(o, 0xa7, 0x6c, 0x73, 0x69, 0x67, 0x6c, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedLsigs.BitmaskLogic))
		}
		if (zb0053Mask[1] & 0x4000000000) == 0 { // if not empty
			// string "lv"
			o = append(o, 0xa2, 0x6c, 0x76)
			if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid)))
			}
			for zb0008 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid {
				o = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid[zb0008].MarshalMsg(o)
			}
		}
		if (zb0053Mask[1] & 0x8000000000) == 0 { // if not empty
			// string "lvbm"
			o = append(o, 0xa4, 0x6c, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid))
		}
		if (zb0053Mask[1] & 0x10000000000) == 0 { // if not empty
			// string "lx"
			o = append(o, 0xa2, 0x6c, 0x78)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease)
		}
		if (zb0053Mask[1] & 0x20000000000) == 0 { // if not empty
			// string "lxbm"
			o = append(o, 0xa4, 0x6c, 0x78, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease))
		}
		if (zb0053Mask[1] & 0x40000000000) == 0 { // if not empty
			// string "m"
			o = append(o, 0xa1, 0x6d)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager)
		}
		if (zb0053Mask[1] & 0x80000000000) == 0 { // if not empty
			// string "mbm"
			o = append(o, 0xa3, 0x6d, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager))
		}
		if (zb0053Mask[1] & 0x100000000000) == 0 { // if not empty
			// string "msigthr"
			o = append(o, 0xa7, 0x6d, 0x73, 0x69, 0x67, 0x74, 0x68, 0x72)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedMsigs.Threshold)
		}
		if (zb0053Mask[1] & 0x200000000000) == 0 { // if not empty
			// string "msigthrbm"
			o = append(o, 0xa9, 0x6d, 0x73, 0x69, 0x67, 0x74, 0x68, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedMsigs.BitmaskThreshold))
		}
		if (zb0053Mask[1] & 0x400000000000) == 0 { // if not empty
			// string "msigv"
			o = append(o, 0xa5, 0x6d, 0x73, 0x69, 0x67, 0x76)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedMsigs.Version)
		}
		if (zb0053Mask[1] & 0x800000000000) == 0 { // if not empty
			// string "msigvbm"
			o = append(o, 0xa7, 0x6d, 0x73, 0x69, 0x67, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedMsigs.BitmaskVersion))
		}
		if (zb0053Mask[1] & 0x1000000000000) == 0 { // if not empty
			// string "nonpartbm"
			o = append(o, 0xa9, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation))
		}
		if (zb0053Mask[1] & 0x2000000000000) == 0 { // if not empty
			// string "note"
			o = append(o, 0xa4, 0x6e, 0x6f, 0x74, 0x65)
			if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note)))
			}
			for zb0009 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note {
				o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note[zb0009])
			}
		}
		if (zb0053Mask[1] & 0x4000000000000) == 0 { // if not empty
			// string "notebm"
			o = append(o, 0xa6, 0x6e, 0x6f, 0x74, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote))
		}
		if (zb0053Mask[1] & 0x8000000000000) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve)
		}
		if (zb0053Mask[1] & 0x10000000000000) == 0 { // if not empty
			// string "rbm"
			o = append(o, 0xa3, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve))
		}
		if (zb0053Mask[1] & 0x20000000000000) == 0 { // if not empty
			// string "rcv"
			o = append(o, 0xa3, 0x72, 0x63, 0x76)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver)
		}
		if (zb0053Mask[1] & 0x40000000000000) == 0 { // if not empty
			// string "rcvbm"
			o = append(o, 0xa5, 0x72, 0x63, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver))
		}
		if (zb0053Mask[1] & 0x80000000000000) == 0 { // if not empty
			// string "rekey"
			o = append(o, 0xa5, 0x72, 0x65, 0x6b, 0x65, 0x79)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo)
		}
		if (zb0053Mask[1] & 0x100000000000000) == 0 { // if not empty
			// string "rekeybm"
			o = append(o, 0xa7, 0x72, 0x65, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo))
		}
		if (zb0053Mask[1] & 0x200000000000000) == 0 { // if not empty
			// string "selkey"
			o = append(o, 0xa6, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK)
		}
		if (zb0053Mask[1] & 0x400000000000000) == 0 { // if not empty
			// string "sgnr"
			o = append(o, 0xa4, 0x73, 0x67, 0x6e, 0x72)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.AuthAddr)
		}
		if (zb0053Mask[1] & 0x800000000000000) == 0 { // if not empty
			// string "sgnrbm"
			o = append(o, 0xa6, 0x73, 0x67, 0x6e, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.BitmaskAuthAddr))
		}
		if (zb0053Mask[1] & 0x1000000000000000) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.Sig)
		}
		if (zb0053Mask[1] & 0x2000000000000000) == 0 { // if not empty
			// string "sigbm"
			o = append(o, 0xa5, 0x73, 0x69, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.BitmaskSig))
		}
		if (zb0053Mask[1] & 0x4000000000000000) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender)
		}
		if (zb0053Mask[1] & 0x8000000000000000) == 0 { // if not empty
			// string "sndbm"
			o = append(o, 0xa5, 0x73, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender))
		}
		if (zb0053Mask[2] & 0x1) == 0 { // if not empty
			// string "subsig"
			o = append(o, 0xa6, 0x73, 0x75, 0x62, 0x73, 0x69, 0x67)
			if (*z).encodedSignedTxns.encodedMsigs.Subsigs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedMsigs.Subsigs)))
			}
			for zb0001 := range (*z).encodedSignedTxns.encodedMsigs.Subsigs {
				if (*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001])))
				}
				for zb0002 := range (*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] {
					o = (*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001][zb0002].MarshalMsg(o)
				}
			}
		}
		if (zb0053Mask[2] & 0x2) == 0 { // if not empty
			// string "subsigsbm"
			o = append(o, 0xa9, 0x73, 0x75, 0x62, 0x73, 0x69, 0x67, 0x73, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedMsigs.BitmaskSubsigs))
		}
		if (zb0053Mask[2] & 0x4) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total)))
			}
			for zb0016 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total {
				o = msgp.AppendUint64(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total[zb0016])
			}
		}
		if (zb0053Mask[2] & 0x8) == 0 { // if not empty
			// string "tbm"
			o = append(o, 0xa3, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal))
		}
		if (zb0053Mask[2] & 0x10) == 0 { // if not empty
			// string "tgc"
			o = append(o, 0xa3, 0x74, 0x67, 0x63)
			o = msgp.AppendUint64(o, (*z).TransactionGroupCount)
		}
		if (zb0053Mask[2] & 0x20) == 0 { // if not empty
			// string "tgs"
			o = append(o, 0xa3, 0x74, 0x67, 0x73)
			o = msgp.AppendBytes(o, (*z).TransactionGroupSizes)
		}
		if (zb0053Mask[2] & 0x40) == 0 { // if not empty
			// string "ttc"
			o = append(o, 0xa3, 0x74, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).TotalTransactionsCount)
		}
		if (zb0053Mask[2] & 0x80) == 0 { // if not empty
			// string "type"
			o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.TxType)
		}
		if (zb0053Mask[2] & 0x100) == 0 { // if not empty
			// string "typebm"
			o = append(o, 0xa6, 0x74, 0x79, 0x70, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.BitmaskTxType))
		}
		if (zb0053Mask[2] & 0x200) == 0 { // if not empty
			// string "typeo"
			o = append(o, 0xa5, 0x74, 0x79, 0x70, 0x65, 0x6f)
			o = msgp.AppendByte(o, (*z).encodedSignedTxns.encodedTxns.TxTypeOffset)
		}
		if (zb0053Mask[2] & 0x400) == 0 { // if not empty
			// string "un"
			o = append(o, 0xa2, 0x75, 0x6e)
			if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName)))
			}
			for zb0018 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName {
				o = msgp.AppendString(o, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName[zb0018])
			}
		}
		if (zb0053Mask[2] & 0x800) == 0 { // if not empty
			// string "unbm"
			o = append(o, 0xa4, 0x75, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName))
		}
		if (zb0053Mask[2] & 0x1000) == 0 { // if not empty
			// string "vldrt"
			o = append(o, 0xa5, 0x76, 0x6c, 0x64, 0x72, 0x74)
			if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot)))
			}
			for zb0013 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot {
				o = msgp.AppendBool(o, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot[zb0013])
			}
		}
		if (zb0053Mask[2] & 0x2000) == 0 { // if not empty
			// string "votefst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74)
			if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst)))
			}
			for zb0010 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst {
				o = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0010].MarshalMsg(o)
			}
		}
		if (zb0053Mask[2] & 0x4000) == 0 { // if not empty
			// string "votefstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst))
		}
		if (zb0053Mask[2] & 0x8000) == 0 { // if not empty
			// string "votekbm"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskKeys))
		}
		if (zb0053Mask[2] & 0x10000) == 0 { // if not empty
			// string "votekd"
			o = append(o, 0xa6, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64)
			if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution)))
			}
			for zb0012 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution {
				o = msgp.AppendUint64(o, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution[zb0012])
			}
		}
		if (zb0053Mask[2] & 0x20000) == 0 { // if not empty
			// string "votekey"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK)
		}
		if (zb0053Mask[2] & 0x40000) == 0 { // if not empty
			// string "votelst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74)
			if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast)))
			}
			for zb0011 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast {
				o = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast[zb0011].MarshalMsg(o)
			}
		}
		if (zb0053Mask[2] & 0x80000) == 0 { // if not empty
			// string "votelstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast))
		}
		if (zb0053Mask[2] & 0x100000) == 0 { // if not empty
			// string "xaid"
			o = append(o, 0xa4, 0x78, 0x61, 0x69, 0x64)
			if (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset)))
			}
			for zb0021 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset {
				o = (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset[zb0021].MarshalMsg(o)
			}
		}
		if (zb0053Mask[2] & 0x200000) == 0 { // if not empty
			// string "xaidbm"
			o = append(o, 0xa6, 0x78, 0x61, 0x69, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset))
		}
	}
	return
}

func (_ *txGroupsEncodingStub) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*txGroupsEncodingStub)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *txGroupsEncodingStub) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0053 int
	var zb0054 bool
	zb0053, zb0054, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0053, zb0054, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0053 > 0 {
			zb0053--
			(*z).TotalTransactionsCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TotalTransactionsCount")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			(*z).TransactionGroupCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TransactionGroupCount")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0055 int
			zb0055, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TransactionGroupSizes")
				return
			}
			if zb0055 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0055), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).TransactionGroupSizes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroupSizes)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TransactionGroupSizes")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0056 int
			zb0056, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
			if zb0056 > maxSignatureBytes {
				err = msgp.ErrOverflow(uint64(zb0056), uint64(maxSignatureBytes))
				return
			}
			(*z).encodedSignedTxns.Sig, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.Sig)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0057 []byte
				var zb0058 int
				zb0058, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSig")
					return
				}
				if zb0058 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0058), uint64(maxBitmaskSize))
					return
				}
				zb0057, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskSig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSig")
					return
				}
				(*z).encodedSignedTxns.BitmaskSig = bitmask(zb0057)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0059 int
			zb0059, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Version")
				return
			}
			if zb0059 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0059), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).encodedSignedTxns.encodedMsigs.Version, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedMsigs.Version)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Version")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0060 []byte
				var zb0061 int
				zb0061, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVersion")
					return
				}
				if zb0061 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0061), uint64(maxBitmaskSize))
					return
				}
				zb0060, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedMsigs.BitmaskVersion))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVersion")
					return
				}
				(*z).encodedSignedTxns.encodedMsigs.BitmaskVersion = bitmask(zb0060)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0062 int
			zb0062, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Threshold")
				return
			}
			if zb0062 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0062), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).encodedSignedTxns.encodedMsigs.Threshold, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedMsigs.Threshold)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Threshold")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0063 []byte
				var zb0064 int
				zb0064, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskThreshold")
					return
				}
				if zb0064 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0064), uint64(maxBitmaskSize))
					return
				}
				zb0063, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedMsigs.BitmaskThreshold))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskThreshold")
					return
				}
				(*z).encodedSignedTxns.encodedMsigs.BitmaskThreshold = bitmask(zb0063)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0065 int
			var zb0066 bool
			zb0065, zb0066, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Subsigs")
				return
			}
			if zb0065 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0065), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Subsigs")
				return
			}
			if zb0066 {
				(*z).encodedSignedTxns.encodedMsigs.Subsigs = nil
			} else if (*z).encodedSignedTxns.encodedMsigs.Subsigs != nil && cap((*z).encodedSignedTxns.encodedMsigs.Subsigs) >= zb0065 {
				(*z).encodedSignedTxns.encodedMsigs.Subsigs = ((*z).encodedSignedTxns.encodedMsigs.Subsigs)[:zb0065]
			} else {
				(*z).encodedSignedTxns.encodedMsigs.Subsigs = make([][]crypto.MultisigSubsig, zb0065)
			}
			for zb0001 := range (*z).encodedSignedTxns.encodedMsigs.Subsigs {
				var zb0067 int
				var zb0068 bool
				zb0067, zb0068, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Subsigs", zb0001)
					return
				}
				if zb0067 > crypto.MaxMultisig {
					err = msgp.ErrOverflow(uint64(zb0067), uint64(crypto.MaxMultisig))
					err = msgp.WrapError(err, "struct-from-array", "Subsigs", zb0001)
					return
				}
				if zb0068 {
					(*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] = nil
				} else if (*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] != nil && cap((*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001]) >= zb0067 {
					(*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] = ((*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001])[:zb0067]
				} else {
					(*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] = make([]crypto.MultisigSubsig, zb0067)
				}
				for zb0002 := range (*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] {
					bts, err = (*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001][zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Subsigs", zb0001, zb0002)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0069 []byte
				var zb0070 int
				zb0070, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSubsigs")
					return
				}
				if zb0070 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0070), uint64(maxBitmaskSize))
					return
				}
				zb0069, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedMsigs.BitmaskSubsigs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSubsigs")
					return
				}
				(*z).encodedSignedTxns.encodedMsigs.BitmaskSubsigs = bitmask(zb0069)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0071 int
			var zb0072 bool
			zb0071, zb0072, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Logic")
				return
			}
			if zb0071 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0071), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Logic")
				return
			}
			if zb0072 {
				(*z).encodedSignedTxns.encodedLsigs.Logic = nil
			} else if (*z).encodedSignedTxns.encodedLsigs.Logic != nil && cap((*z).encodedSignedTxns.encodedLsigs.Logic) >= zb0071 {
				(*z).encodedSignedTxns.encodedLsigs.Logic = ((*z).encodedSignedTxns.encodedLsigs.Logic)[:zb0071]
			} else {
				(*z).encodedSignedTxns.encodedLsigs.Logic = make([][]byte, zb0071)
			}
			for zb0003 := range (*z).encodedSignedTxns.encodedLsigs.Logic {
				var zb0073 int
				zb0073, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Logic", zb0003)
					return
				}
				if zb0073 > config.MaxLogicSigMaxSize {
					err = msgp.ErrOverflow(uint64(zb0073), uint64(config.MaxLogicSigMaxSize))
					return
				}
				(*z).encodedSignedTxns.encodedLsigs.Logic[zb0003], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedLsigs.Logic[zb0003])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Logic", zb0003)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0074 []byte
				var zb0075 int
				zb0075, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLogic")
					return
				}
				if zb0075 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0075), uint64(maxBitmaskSize))
					return
				}
				zb0074, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedLsigs.BitmaskLogic))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLogic")
					return
				}
				(*z).encodedSignedTxns.encodedLsigs.BitmaskLogic = bitmask(zb0074)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0076 int
			var zb0077 bool
			zb0076, zb0077, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LogicArgs")
				return
			}
			if zb0076 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0076), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LogicArgs")
				return
			}
			if zb0077 {
				(*z).encodedSignedTxns.encodedLsigs.LogicArgs = nil
			} else if (*z).encodedSignedTxns.encodedLsigs.LogicArgs != nil && cap((*z).encodedSignedTxns.encodedLsigs.LogicArgs) >= zb0076 {
				(*z).encodedSignedTxns.encodedLsigs.LogicArgs = ((*z).encodedSignedTxns.encodedLsigs.LogicArgs)[:zb0076]
			} else {
				(*z).encodedSignedTxns.encodedLsigs.LogicArgs = make([][][]byte, zb0076)
			}
			for zb0004 := range (*z).encodedSignedTxns.encodedLsigs.LogicArgs {
				var zb0078 int
				var zb0079 bool
				zb0078, zb0079, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LogicArgs", zb0004)
					return
				}
				if zb0078 > transactions.EvalMaxArgs {
					err = msgp.ErrOverflow(uint64(zb0078), uint64(transactions.EvalMaxArgs))
					err = msgp.WrapError(err, "struct-from-array", "LogicArgs", zb0004)
					return
				}
				if zb0079 {
					(*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] = nil
				} else if (*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] != nil && cap((*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004]) >= zb0078 {
					(*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] = ((*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004])[:zb0078]
				} else {
					(*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] = make([][]byte, zb0078)
				}
				for zb0005 := range (*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] {
					var zb0080 int
					zb0080, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "LogicArgs", zb0004, zb0005)
						return
					}
					if zb0080 > config.MaxLogicSigMaxSize {
						err = msgp.ErrOverflow(uint64(zb0080), uint64(config.MaxLogicSigMaxSize))
						return
					}
					(*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004][zb0005], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004][zb0005])
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "LogicArgs", zb0004, zb0005)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0081 []byte
				var zb0082 int
				zb0082, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLogicArgs")
					return
				}
				if zb0082 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0082), uint64(maxBitmaskSize))
					return
				}
				zb0081, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedLsigs.BitmaskLogicArgs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLogicArgs")
					return
				}
				(*z).encodedSignedTxns.encodedLsigs.BitmaskLogicArgs = bitmask(zb0081)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0083 int
			zb0083, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
			if zb0083 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0083), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.AuthAddr, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.AuthAddr)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0084 []byte
				var zb0085 int
				zb0085, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAuthAddr")
					return
				}
				if zb0085 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0085), uint64(maxBitmaskSize))
					return
				}
				zb0084, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskAuthAddr))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAuthAddr")
					return
				}
				(*z).encodedSignedTxns.BitmaskAuthAddr = bitmask(zb0084)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0086 int
			zb0086, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
			if zb0086 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0086), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.TxType, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.TxType)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0087 []byte
				var zb0088 int
				zb0088, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTxType")
					return
				}
				if zb0088 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0088), uint64(maxBitmaskSize))
					return
				}
				zb0087, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.BitmaskTxType))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTxType")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.BitmaskTxType = bitmask(zb0087)
			}
		}
		if zb0053 > 0 {
			zb0053--
			(*z).encodedSignedTxns.encodedTxns.TxTypeOffset, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxTypeOffset")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0089 int
			zb0089, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
			if zb0089 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0089), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0090 []byte
				var zb0091 int
				zb0091, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSender")
					return
				}
				if zb0091 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0091), uint64(maxBitmaskSize))
					return
				}
				zb0090, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSender")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender = bitmask(zb0090)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0092 int
			var zb0093 bool
			zb0092, zb0093, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0092 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0092), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0093 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee) >= zb0092 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee)[:zb0092]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee = make([]basics.MicroAlgos, zb0092)
			}
			for zb0006 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee[zb0006].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Fee", zb0006)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0094 []byte
				var zb0095 int
				zb0095, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFee")
					return
				}
				if zb0095 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0095), uint64(maxBitmaskSize))
					return
				}
				zb0094, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFee")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee = bitmask(zb0094)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0096 int
			var zb0097 bool
			zb0096, zb0097, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0096 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0096), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0097 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid) >= zb0096 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid)[:zb0096]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid = make([]basics.Round, zb0096)
			}
			for zb0007 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid[zb0007].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "FirstValid", zb0007)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0098 []byte
				var zb0099 int
				zb0099, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFirstValid")
					return
				}
				if zb0099 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0099), uint64(maxBitmaskSize))
					return
				}
				zb0098, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFirstValid")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid = bitmask(zb0098)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0100 int
			var zb0101 bool
			zb0100, zb0101, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0100 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0100), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0101 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid) >= zb0100 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid)[:zb0100]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid = make([]basics.Round, zb0100)
			}
			for zb0008 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid[zb0008].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LastValid", zb0008)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0102 []byte
				var zb0103 int
				zb0103, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLastValid")
					return
				}
				if zb0103 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0103), uint64(maxBitmaskSize))
					return
				}
				zb0102, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLastValid")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid = bitmask(zb0102)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0104 int
			var zb0105 bool
			zb0104, zb0105, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0104 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0104), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0105 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note) >= zb0104 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note)[:zb0104]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note = make([][]byte, zb0104)
			}
			for zb0009 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note {
				var zb0106 int
				zb0106, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Note", zb0009)
					return
				}
				if zb0106 > config.MaxTxnNoteBytes {
					err = msgp.ErrOverflow(uint64(zb0106), uint64(config.MaxTxnNoteBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note[zb0009], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note[zb0009])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Note", zb0009)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0107 []byte
				var zb0108 int
				zb0108, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNote")
					return
				}
				if zb0108 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0108), uint64(maxBitmaskSize))
					return
				}
				zb0107, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNote")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote = bitmask(zb0107)
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0109 []byte
				var zb0110 int
				zb0110, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisID")
					return
				}
				if zb0110 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0110), uint64(maxBitmaskSize))
					return
				}
				zb0109, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisID")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID = bitmask(zb0109)
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0111 []byte
				var zb0112 int
				zb0112, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGroup")
					return
				}
				if zb0112 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0112), uint64(maxBitmaskSize))
					return
				}
				zb0111, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGroup))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGroup")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGroup = bitmask(zb0111)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0113 int
			zb0113, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
			if zb0113 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0113), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0114 []byte
				var zb0115 int
				zb0115, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLease")
					return
				}
				if zb0115 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0115), uint64(maxBitmaskSize))
					return
				}
				zb0114, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLease")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease = bitmask(zb0114)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0116 int
			zb0116, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
			if zb0116 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0116), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0117 []byte
				var zb0118 int
				zb0118, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskRekeyTo")
					return
				}
				if zb0118 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0118), uint64(maxBitmaskSize))
					return
				}
				zb0117, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskRekeyTo")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo = bitmask(zb0117)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0119 int
			zb0119, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
			if zb0119 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0119), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0120 int
			zb0120, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
			if zb0120 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0120), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0121 int
			var zb0122 bool
			zb0121, zb0122, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0121 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0121), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0122 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst) >= zb0121 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst)[:zb0121]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst = make([]basics.Round, zb0121)
			}
			for zb0010 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0010].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteFirst", zb0010)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0123 []byte
				var zb0124 int
				zb0124, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteFirst")
					return
				}
				if zb0124 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0124), uint64(maxBitmaskSize))
					return
				}
				zb0123, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteFirst")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst = bitmask(zb0123)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0125 int
			var zb0126 bool
			zb0125, zb0126, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0125 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0125), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0126 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast) >= zb0125 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast)[:zb0125]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast = make([]basics.Round, zb0125)
			}
			for zb0011 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast[zb0011].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteLast", zb0011)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0127 []byte
				var zb0128 int
				zb0128, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteLast")
					return
				}
				if zb0128 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0128), uint64(maxBitmaskSize))
					return
				}
				zb0127, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteLast")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast = bitmask(zb0127)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0129 int
			var zb0130 bool
			zb0129, zb0130, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0129 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0129), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0130 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) >= zb0129 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution)[:zb0129]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = make([]uint64, zb0129)
			}
			for zb0012 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution[zb0012], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution", zb0012)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0131 []byte
				var zb0132 int
				zb0132, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskKeys")
					return
				}
				if zb0132 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0132), uint64(maxBitmaskSize))
					return
				}
				zb0131, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskKeys))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskKeys")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskKeys = bitmask(zb0131)
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0133 []byte
				var zb0134 int
				zb0134, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNonparticipation")
					return
				}
				if zb0134 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0134), uint64(maxBitmaskSize))
					return
				}
				zb0133, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNonparticipation")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation = bitmask(zb0133)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0135 int
			var zb0136 bool
			zb0135, zb0136, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "HasValidRoot")
				return
			}
			if zb0135 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0135), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "HasValidRoot")
				return
			}
			if zb0136 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot) >= zb0135 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot)[:zb0135]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot = make([]bool, zb0135)
			}
			for zb0013 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot[zb0013], bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "HasValidRoot", zb0013)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0137 int
			zb0137, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CommitmentRoot")
				return
			}
			if zb0137 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0137), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.CommitmentRoot, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.CommitmentRoot)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CommitmentRoot")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0138 int
			zb0138, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
			if zb0138 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0138), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0139 []byte
				var zb0140 int
				zb0140, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReceiver")
					return
				}
				if zb0140 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0140), uint64(maxBitmaskSize))
					return
				}
				zb0139, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReceiver")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver = bitmask(zb0139)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0141 int
			var zb0142 bool
			zb0141, zb0142, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0141 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0141), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0142 {
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount) >= zb0141 {
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount = ((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount)[:zb0141]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount = make([]basics.MicroAlgos, zb0141)
			}
			for zb0014 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount[zb0014].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Amount", zb0014)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0143 []byte
				var zb0144 int
				zb0144, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAmount")
					return
				}
				if zb0144 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0144), uint64(maxBitmaskSize))
					return
				}
				zb0143, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAmount")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount = bitmask(zb0143)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0145 int
			zb0145, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
			if zb0145 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0145), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0146 []byte
				var zb0147 int
				zb0147, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCloseRemainderTo")
					return
				}
				if zb0147 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0147), uint64(maxBitmaskSize))
					return
				}
				zb0146, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCloseRemainderTo")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo = bitmask(zb0146)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0148 int
			var zb0149 bool
			zb0148, zb0149, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ConfigAsset")
				return
			}
			if zb0148 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0148), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ConfigAsset")
				return
			}
			if zb0149 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset) >= zb0148 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset = ((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset)[:zb0148]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset = make([]basics.AssetIndex, zb0148)
			}
			for zb0015 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset[zb0015].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ConfigAsset", zb0015)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0150 []byte
				var zb0151 int
				zb0151, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskConfigAsset")
					return
				}
				if zb0151 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0151), uint64(maxBitmaskSize))
					return
				}
				zb0150, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskConfigAsset")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset = bitmask(zb0150)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0152 int
			var zb0153 bool
			zb0152, zb0153, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Total")
				return
			}
			if zb0152 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0152), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Total")
				return
			}
			if zb0153 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total) >= zb0152 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total = ((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total)[:zb0152]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total = make([]uint64, zb0152)
			}
			for zb0016 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total[zb0016], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Total", zb0016)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0154 []byte
				var zb0155 int
				zb0155, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTotal")
					return
				}
				if zb0155 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0155), uint64(maxBitmaskSize))
					return
				}
				zb0154, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTotal")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal = bitmask(zb0154)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0156 int
			var zb0157 bool
			zb0156, zb0157, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Decimals")
				return
			}
			if zb0156 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0156), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Decimals")
				return
			}
			if zb0157 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals) >= zb0156 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals = ((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals)[:zb0156]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals = make([]uint32, zb0156)
			}
			for zb0017 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals[zb0017], bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Decimals", zb0017)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0158 []byte
				var zb0159 int
				zb0159, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDecimals")
					return
				}
				if zb0159 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0159), uint64(maxBitmaskSize))
					return
				}
				zb0158, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDecimals")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals = bitmask(zb0158)
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0160 []byte
				var zb0161 int
				zb0161, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDefaultFrozen")
					return
				}
				if zb0161 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0161), uint64(maxBitmaskSize))
					return
				}
				zb0160, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskDefaultFrozen")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen = bitmask(zb0160)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0162 int
			var zb0163 bool
			zb0162, zb0163, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UnitName")
				return
			}
			if zb0162 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0162), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "UnitName")
				return
			}
			if zb0163 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName) >= zb0162 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName = ((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName)[:zb0162]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName = make([]string, zb0162)
			}
			for zb0018 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName[zb0018], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "UnitName", zb0018)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0164 []byte
				var zb0165 int
				zb0165, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskUnitName")
					return
				}
				if zb0165 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0165), uint64(maxBitmaskSize))
					return
				}
				zb0164, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskUnitName")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName = bitmask(zb0164)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0166 int
			var zb0167 bool
			zb0166, zb0167, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetName")
				return
			}
			if zb0166 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0166), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "AssetName")
				return
			}
			if zb0167 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName) >= zb0166 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName = ((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName)[:zb0166]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName = make([]string, zb0166)
			}
			for zb0019 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName[zb0019], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AssetName", zb0019)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0168 []byte
				var zb0169 int
				zb0169, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetName")
					return
				}
				if zb0169 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0169), uint64(maxBitmaskSize))
					return
				}
				zb0168, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetName")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName = bitmask(zb0168)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0170 int
			var zb0171 bool
			zb0170, zb0171, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "URL")
				return
			}
			if zb0170 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0170), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "URL")
				return
			}
			if zb0171 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL) >= zb0170 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL = ((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL)[:zb0170]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL = make([]string, zb0170)
			}
			for zb0020 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL[zb0020], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "URL", zb0020)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0172 []byte
				var zb0173 int
				zb0173, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskURL")
					return
				}
				if zb0173 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0173), uint64(maxBitmaskSize))
					return
				}
				zb0172, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskURL")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL = bitmask(zb0172)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0174 int
			zb0174, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MetadataHash")
				return
			}
			if zb0174 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0174), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MetadataHash")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0175 []byte
				var zb0176 int
				zb0176, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMetadataHash")
					return
				}
				if zb0176 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0176), uint64(maxBitmaskSize))
					return
				}
				zb0175, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMetadataHash")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash = bitmask(zb0175)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0177 int
			zb0177, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Manager")
				return
			}
			if zb0177 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0177), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Manager")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0178 []byte
				var zb0179 int
				zb0179, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskManager")
					return
				}
				if zb0179 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0179), uint64(maxBitmaskSize))
					return
				}
				zb0178, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskManager")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager = bitmask(zb0178)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0180 int
			zb0180, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reserve")
				return
			}
			if zb0180 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0180), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reserve")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0181 []byte
				var zb0182 int
				zb0182, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReserve")
					return
				}
				if zb0182 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0182), uint64(maxBitmaskSize))
					return
				}
				zb0181, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReserve")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve = bitmask(zb0181)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0183 int
			zb0183, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Freeze")
				return
			}
			if zb0183 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0183), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Freeze")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0184 []byte
				var zb0185 int
				zb0185, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreeze")
					return
				}
				if zb0185 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0185), uint64(maxBitmaskSize))
					return
				}
				zb0184, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreeze")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze = bitmask(zb0184)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0186 int
			zb0186, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Clawback")
				return
			}
			if zb0186 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0186), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Clawback")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0187 []byte
				var zb0188 int
				zb0188, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClawback")
					return
				}
				if zb0188 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0188), uint64(maxBitmaskSize))
					return
				}
				zb0187, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClawback")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback = bitmask(zb0187)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0189 int
			var zb0190 bool
			zb0189, zb0190, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "XferAsset")
				return
			}
			if zb0189 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0189), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "XferAsset")
				return
			}
			if zb0190 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset) >= zb0189 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset = ((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset)[:zb0189]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset = make([]basics.AssetIndex, zb0189)
			}
			for zb0021 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset[zb0021].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "XferAsset", zb0021)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0191 []byte
				var zb0192 int
				zb0192, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskXferAsset")
					return
				}
				if zb0192 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0192), uint64(maxBitmaskSize))
					return
				}
				zb0191, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskXferAsset")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset = bitmask(zb0191)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0193 int
			var zb0194 bool
			zb0193, zb0194, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetAmount")
				return
			}
			if zb0193 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0193), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "AssetAmount")
				return
			}
			if zb0194 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount) >= zb0193 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount = ((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount)[:zb0193]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount = make([]uint64, zb0193)
			}
			for zb0022 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount[zb0022], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AssetAmount", zb0022)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0195 []byte
				var zb0196 int
				zb0196, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetAmount")
					return
				}
				if zb0196 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0196), uint64(maxBitmaskSize))
					return
				}
				zb0195, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetAmount")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount = bitmask(zb0195)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0197 int
			zb0197, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetSender")
				return
			}
			if zb0197 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0197), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetSender, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetSender)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetSender")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0198 []byte
				var zb0199 int
				zb0199, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetSender")
					return
				}
				if zb0199 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0199), uint64(maxBitmaskSize))
					return
				}
				zb0198, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetSender")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender = bitmask(zb0198)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0200 int
			zb0200, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetReceiver")
				return
			}
			if zb0200 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0200), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetReceiver, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetReceiver)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetReceiver")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0201 []byte
				var zb0202 int
				zb0202, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetReceiver")
					return
				}
				if zb0202 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0202), uint64(maxBitmaskSize))
					return
				}
				zb0201, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetReceiver")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver = bitmask(zb0201)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0203 int
			zb0203, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetCloseTo")
				return
			}
			if zb0203 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0203), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AssetCloseTo")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0204 []byte
				var zb0205 int
				zb0205, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetCloseTo")
					return
				}
				if zb0205 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0205), uint64(maxBitmaskSize))
					return
				}
				zb0204, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetCloseTo")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo = bitmask(zb0204)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0206 int
			zb0206, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAccount")
				return
			}
			if zb0206 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0206), uint64(maxAddressBytes))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAccount")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0207 []byte
				var zb0208 int
				zb0208, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAccount")
					return
				}
				if zb0208 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0208), uint64(maxBitmaskSize))
					return
				}
				zb0207, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAccount")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount = bitmask(zb0207)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0209 int
			var zb0210 bool
			zb0209, zb0210, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FreezeAsset")
				return
			}
			if zb0209 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0209), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "FreezeAsset")
				return
			}
			if zb0210 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset) >= zb0209 {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset = ((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset)[:zb0209]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset = make([]basics.AssetIndex, zb0209)
			}
			for zb0023 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset[zb0023].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "FreezeAsset", zb0023)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0211 []byte
				var zb0212 int
				zb0212, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAsset")
					return
				}
				if zb0212 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0212), uint64(maxBitmaskSize))
					return
				}
				zb0211, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFreezeAsset")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset = bitmask(zb0211)
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0213 []byte
				var zb0214 int
				zb0214, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetFrozen")
					return
				}
				if zb0214 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0214), uint64(maxBitmaskSize))
					return
				}
				zb0213, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAssetFrozen")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen = bitmask(zb0213)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0215 int
			var zb0216 bool
			zb0215, zb0216, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ApplicationID")
				return
			}
			if zb0215 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0215), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ApplicationID")
				return
			}
			if zb0216 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID) >= zb0215 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID)[:zb0215]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID = make([]basics.AppIndex, zb0215)
			}
			for zb0024 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID[zb0024].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ApplicationID", zb0024)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0217 []byte
				var zb0218 int
				zb0218, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationID")
					return
				}
				if zb0218 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0218), uint64(maxBitmaskSize))
					return
				}
				zb0217, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationID")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID = bitmask(zb0217)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0219 int
			zb0219, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OnCompletion")
				return
			}
			if zb0219 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0219), uint64(maxEncodedTransactionGroups))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.OnCompletion, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.OnCompletion)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OnCompletion")
				return
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0220 []byte
				var zb0221 int
				zb0221, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskOnCompletion")
					return
				}
				if zb0221 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0221), uint64(maxBitmaskSize))
					return
				}
				zb0220, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskOnCompletion")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion = bitmask(zb0220)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0222 int
			var zb0223 bool
			zb0222, zb0223, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs")
				return
			}
			if zb0222 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0222), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs")
				return
			}
			if zb0223 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs) >= zb0222 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs)[:zb0222]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs = make([]applicationArgs, zb0222)
			}
			for zb0025 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs {
				var zb0224 int
				var zb0225 bool
				zb0224, zb0225, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs", zb0025)
					return
				}
				if zb0224 > transactions.EncodedMaxApplicationArgs {
					err = msgp.ErrOverflow(uint64(zb0224), uint64(transactions.EncodedMaxApplicationArgs))
					err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs", zb0025)
					return
				}
				if zb0225 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025]) >= zb0224 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025])[:zb0224]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] = make(applicationArgs, zb0224)
				}
				for zb0026 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025][zb0026], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025][zb0026])
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ApplicationArgs", zb0025, zb0026)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0226 []byte
				var zb0227 int
				zb0227, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationArgs")
					return
				}
				if zb0227 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0227), uint64(maxBitmaskSize))
					return
				}
				zb0226, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApplicationArgs")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs = bitmask(zb0226)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0228 int
			var zb0229 bool
			zb0228, zb0229, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Accounts")
				return
			}
			if zb0228 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0228), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Accounts")
				return
			}
			if zb0229 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts) >= zb0228 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts)[:zb0228]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts = make([]addresses, zb0228)
			}
			for zb0027 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts {
				var zb0230 int
				var zb0231 bool
				zb0230, zb0231, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Accounts", zb0027)
					return
				}
				if zb0230 > transactions.EncodedMaxAccounts {
					err = msgp.ErrOverflow(uint64(zb0230), uint64(transactions.EncodedMaxAccounts))
					err = msgp.WrapError(err, "struct-from-array", "Accounts", zb0027)
					return
				}
				if zb0231 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027]) >= zb0230 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027])[:zb0230]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] = make(addresses, zb0230)
				}
				for zb0028 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027][zb0028].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Accounts", zb0027, zb0028)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0232 []byte
				var zb0233 int
				zb0233, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAccounts")
					return
				}
				if zb0233 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0233), uint64(maxBitmaskSize))
					return
				}
				zb0232, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAccounts")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts = bitmask(zb0232)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0234 int
			var zb0235 bool
			zb0234, zb0235, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ForeignApps")
				return
			}
			if zb0234 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0234), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ForeignApps")
				return
			}
			if zb0235 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps) >= zb0234 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps)[:zb0234]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps = make([]appIndices, zb0234)
			}
			for zb0029 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps {
				var zb0236 int
				var zb0237 bool
				zb0236, zb0237, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ForeignApps", zb0029)
					return
				}
				if zb0236 > transactions.EncodedMaxForeignApps {
					err = msgp.ErrOverflow(uint64(zb0236), uint64(transactions.EncodedMaxForeignApps))
					err = msgp.WrapError(err, "struct-from-array", "ForeignApps", zb0029)
					return
				}
				if zb0237 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029]) >= zb0236 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029])[:zb0236]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] = make(appIndices, zb0236)
				}
				for zb0030 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029][zb0030].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ForeignApps", zb0029, zb0030)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0238 []byte
				var zb0239 int
				zb0239, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignApps")
					return
				}
				if zb0239 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0239), uint64(maxBitmaskSize))
					return
				}
				zb0238, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignApps")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps = bitmask(zb0238)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0240 int
			var zb0241 bool
			zb0240, zb0241, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ForeignAssets")
				return
			}
			if zb0240 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0240), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ForeignAssets")
				return
			}
			if zb0241 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets) >= zb0240 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets)[:zb0240]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets = make([]assetIndices, zb0240)
			}
			for zb0031 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets {
				var zb0242 int
				var zb0243 bool
				zb0242, zb0243, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ForeignAssets", zb0031)
					return
				}
				if zb0242 > transactions.EncodedMaxForeignAssets {
					err = msgp.ErrOverflow(uint64(zb0242), uint64(transactions.EncodedMaxForeignAssets))
					err = msgp.WrapError(err, "struct-from-array", "ForeignAssets", zb0031)
					return
				}
				if zb0243 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031]) >= zb0242 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031])[:zb0242]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] = make(assetIndices, zb0242)
				}
				for zb0032 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031][zb0032].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ForeignAssets", zb0031, zb0032)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0244 []byte
				var zb0245 int
				zb0245, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignAssets")
					return
				}
				if zb0245 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0245), uint64(maxBitmaskSize))
					return
				}
				zb0244, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskForeignAssets")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets = bitmask(zb0244)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0246 int
			var zb0247 bool
			zb0246, zb0247, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LocalNumUint")
				return
			}
			if zb0246 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0246), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LocalNumUint")
				return
			}
			if zb0247 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint) >= zb0246 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint)[:zb0246]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint = make([]uint64, zb0246)
			}
			for zb0033 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint[zb0033], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LocalNumUint", zb0033)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0248 []byte
				var zb0249 int
				zb0249, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumUint")
					return
				}
				if zb0249 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0249), uint64(maxBitmaskSize))
					return
				}
				zb0248, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumUint")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint = bitmask(zb0248)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0250 int
			var zb0251 bool
			zb0250, zb0251, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LocalNumByteSlice")
				return
			}
			if zb0250 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0250), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "LocalNumByteSlice")
				return
			}
			if zb0251 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice) >= zb0250 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice)[:zb0250]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice = make([]uint64, zb0250)
			}
			for zb0034 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice[zb0034], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LocalNumByteSlice", zb0034)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0252 []byte
				var zb0253 int
				zb0253, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumByteSlice")
					return
				}
				if zb0253 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0253), uint64(maxBitmaskSize))
					return
				}
				zb0252, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLocalNumByteSlice")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice = bitmask(zb0252)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0254 int
			var zb0255 bool
			zb0254, zb0255, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumUint")
				return
			}
			if zb0254 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0254), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumUint")
				return
			}
			if zb0255 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint) >= zb0254 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint)[:zb0254]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint = make([]uint64, zb0254)
			}
			for zb0035 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint[zb0035], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "GlobalNumUint", zb0035)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0256 []byte
				var zb0257 int
				zb0257, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumUint")
					return
				}
				if zb0257 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0257), uint64(maxBitmaskSize))
					return
				}
				zb0256, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumUint")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint = bitmask(zb0256)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0258 int
			var zb0259 bool
			zb0258, zb0259, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumByteSlice")
				return
			}
			if zb0258 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0258), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "GlobalNumByteSlice")
				return
			}
			if zb0259 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice) >= zb0258 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice)[:zb0258]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice = make([]uint64, zb0258)
			}
			for zb0036 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice[zb0036], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "GlobalNumByteSlice", zb0036)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0260 []byte
				var zb0261 int
				zb0261, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumByteSlice")
					return
				}
				if zb0261 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0261), uint64(maxBitmaskSize))
					return
				}
				zb0260, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGlobalNumByteSlice")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice = bitmask(zb0260)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0262 int
			var zb0263 bool
			zb0262, zb0263, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram")
				return
			}
			if zb0262 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0262), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram")
				return
			}
			if zb0263 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram) >= zb0262 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram)[:zb0262]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram = make([]program, zb0262)
			}
			for zb0037 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram {
				{
					var zb0264 []byte
					var zb0265 int
					zb0265, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram", zb0037)
						return
					}
					if zb0265 > config.MaxAvailableAppProgramLen {
						err = msgp.ErrOverflow(uint64(zb0265), uint64(config.MaxAvailableAppProgramLen))
						return
					}
					zb0264, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram[zb0037]))
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ApprovalProgram", zb0037)
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram[zb0037] = program(zb0264)
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0266 []byte
				var zb0267 int
				zb0267, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApprovalProgram")
					return
				}
				if zb0267 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0267), uint64(maxBitmaskSize))
					return
				}
				zb0266, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskApprovalProgram")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram = bitmask(zb0266)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0268 int
			var zb0269 bool
			zb0268, zb0269, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram")
				return
			}
			if zb0268 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0268), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram")
				return
			}
			if zb0269 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram) >= zb0268 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram)[:zb0268]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram = make([]program, zb0268)
			}
			for zb0038 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram {
				{
					var zb0270 []byte
					var zb0271 int
					zb0271, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram", zb0038)
						return
					}
					if zb0271 > config.MaxAvailableAppProgramLen {
						err = msgp.ErrOverflow(uint64(zb0271), uint64(config.MaxAvailableAppProgramLen))
						return
					}
					zb0270, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram[zb0038]))
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ClearStateProgram", zb0038)
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram[zb0038] = program(zb0270)
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0272 []byte
				var zb0273 int
				zb0273, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClearStateProgram")
					return
				}
				if zb0273 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0273), uint64(maxBitmaskSize))
					return
				}
				zb0272, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskClearStateProgram")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram = bitmask(zb0272)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0274 int
			var zb0275 bool
			zb0274, zb0275, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ExtraProgramPages")
				return
			}
			if zb0274 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0274), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "ExtraProgramPages")
				return
			}
			if zb0275 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages) >= zb0274 {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages)[:zb0274]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages = make([]uint32, zb0274)
			}
			for zb0039 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages {
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages[zb0039], bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ExtraProgramPages", zb0039)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0276 []byte
				var zb0277 int
				zb0277, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskExtraProgramPages")
					return
				}
				if zb0277 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0277), uint64(maxBitmaskSize))
					return
				}
				zb0276, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskExtraProgramPages")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages = bitmask(zb0276)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0278 int
			var zb0279 bool
			zb0278, zb0279, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CertRound")
				return
			}
			if zb0278 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0278), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "CertRound")
				return
			}
			if zb0279 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound) >= zb0278 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound)[:zb0278]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound = make([]basics.Round, zb0278)
			}
			for zb0040 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound[zb0040].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CertRound", zb0040)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0280 []byte
				var zb0281 int
				zb0281, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertRound")
					return
				}
				if zb0281 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0281), uint64(maxBitmaskSize))
					return
				}
				zb0280, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertRound")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound = bitmask(zb0280)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0282 int
			var zb0283 bool
			zb0282, zb0283, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CertType")
				return
			}
			if zb0282 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0282), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "CertType")
				return
			}
			if zb0283 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType) >= zb0282 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType)[:zb0282]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType = make([]protocol.CompactCertType, zb0282)
			}
			for zb0041 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType[zb0041].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CertType", zb0041)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0284 []byte
				var zb0285 int
				zb0285, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertType")
					return
				}
				if zb0285 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0285), uint64(maxBitmaskSize))
					return
				}
				zb0284, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertType))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCertType")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertType = bitmask(zb0284)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0286 int
			var zb0287 bool
			zb0286, zb0287, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigCommit")
				return
			}
			if zb0286 > maxAddressBytes {
				err = msgp.ErrOverflow(uint64(zb0286), uint64(maxAddressBytes))
				err = msgp.WrapError(err, "struct-from-array", "SigCommit")
				return
			}
			if zb0287 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit) >= zb0286 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit)[:zb0286]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit = make([]crypto.GenericDigest, zb0286)
			}
			for zb0042 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit[zb0042].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigCommit", zb0042)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0288 []byte
				var zb0289 int
				zb0289, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigCommit")
					return
				}
				if zb0289 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0289), uint64(maxBitmaskSize))
					return
				}
				zb0288, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigCommit")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit = bitmask(zb0288)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0290 int
			var zb0291 bool
			zb0290, zb0291, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SignedWeight")
				return
			}
			if zb0290 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0290), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SignedWeight")
				return
			}
			if zb0291 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight) >= zb0290 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight)[:zb0290]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight = make([]uint64, zb0290)
			}
			for zb0043 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight[zb0043], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedWeight", zb0043)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0292 []byte
				var zb0293 int
				zb0293, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSignedWeight")
					return
				}
				if zb0293 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0293), uint64(maxBitmaskSize))
					return
				}
				zb0292, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSignedWeight")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight = bitmask(zb0292)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0294 int
			var zb0295 bool
			zb0294, zb0295, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigProofs")
				return
			}
			if zb0294 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0294), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SigProofs")
				return
			}
			if zb0295 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs) >= zb0294 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs)[:zb0294]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs = make([]certProofs, zb0294)
			}
			for zb0044 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs {
				var zb0296 int
				var zb0297 bool
				zb0296, zb0297, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0044)
					return
				}
				if zb0296 > compactcert.MaxProofDigests {
					err = msgp.ErrOverflow(uint64(zb0296), uint64(compactcert.MaxProofDigests))
					err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0044)
					return
				}
				if zb0297 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044]) >= zb0296 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044])[:zb0296]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] = make(certProofs, zb0296)
				}
				for zb0045 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044][zb0045].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SigProofs", zb0044, zb0045)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0298 []byte
				var zb0299 int
				zb0299, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigProofs")
					return
				}
				if zb0299 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0299), uint64(maxBitmaskSize))
					return
				}
				zb0298, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigProofs")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs = bitmask(zb0298)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0300 int
			var zb0301 bool
			zb0300, zb0301, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes")
				return
			}
			if zb0300 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0300), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes")
				return
			}
			if zb0301 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) >= zb0300 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes)[:zb0300]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = make([]uint64, zb0300)
			}
			for zb0046 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes[zb0046], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SigProofHashTypes", zb0046)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0302 []byte
				var zb0303 int
				zb0303, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigsHash")
					return
				}
				if zb0303 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0303), uint64(maxBitmaskSize))
					return
				}
				zb0302, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSigsHash")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash = bitmask(zb0302)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0304 int
			var zb0305 bool
			zb0304, zb0305, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PartProofs")
				return
			}
			if zb0304 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0304), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "PartProofs")
				return
			}
			if zb0305 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs) >= zb0304 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs)[:zb0304]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs = make([]certProofs, zb0304)
			}
			for zb0047 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs {
				var zb0306 int
				var zb0307 bool
				zb0306, zb0307, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0047)
					return
				}
				if zb0306 > compactcert.MaxProofDigests {
					err = msgp.ErrOverflow(uint64(zb0306), uint64(compactcert.MaxProofDigests))
					err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0047)
					return
				}
				if zb0307 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047]) >= zb0306 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047])[:zb0306]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] = make(certProofs, zb0306)
				}
				for zb0048 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047][zb0048].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "PartProofs", zb0047, zb0048)
						return
					}
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0308 []byte
				var zb0309 int
				zb0309, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartProofs")
					return
				}
				if zb0309 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0309), uint64(maxBitmaskSize))
					return
				}
				zb0308, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartProofs")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs = bitmask(zb0308)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0310 int
			var zb0311 bool
			zb0310, zb0311, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes")
				return
			}
			if zb0310 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0310), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes")
				return
			}
			if zb0311 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) >= zb0310 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes)[:zb0310]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = make([]uint64, zb0310)
			}
			for zb0049 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes[zb0049], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PartProofHashTypes", zb0049)
					return
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0312 []byte
				var zb0313 int
				zb0313, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartHash")
					return
				}
				if zb0313 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0313), uint64(maxBitmaskSize))
					return
				}
				zb0312, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskPartHash")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash = bitmask(zb0312)
			}
		}
		if zb0053 > 0 {
			zb0053--
			var zb0314 int
			var zb0315 bool
			zb0314, zb0315, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Reveals")
				return
			}
			if zb0314 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0314), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "Reveals")
				return
			}
			if zb0315 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals) >= zb0314 {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals)[:zb0314]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals = make([]revealMap, zb0314)
			}
			for zb0050 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals {
				var zb0316 int
				var zb0317 bool
				zb0316, zb0317, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0050)
					return
				}
				if zb0316 > compactcert.MaxReveals {
					err = msgp.ErrOverflow(uint64(zb0316), uint64(compactcert.MaxReveals))
					err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0050)
					return
				}
				if zb0317 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] == nil {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] = make(revealMap, zb0316)
				}
				for zb0316 > 0 {
					var zb0051 uint64
					var zb0052 compactcert.Reveal
					zb0316--
					zb0051, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0050)
						return
					}
					bts, err = zb0052.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Reveals", zb0050, zb0051)
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050][zb0051] = zb0052
				}
			}
		}
		if zb0053 > 0 {
			zb0053--
			{
				var zb0318 []byte
				var zb0319 int
				zb0319, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReveals")
					return
				}
				if zb0319 > maxBitmaskSize {
					err = msgp.ErrOverflow(uint64(zb0319), uint64(maxBitmaskSize))
					return
				}
				zb0318, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReveals")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals = bitmask(zb0318)
			}
		}
		if zb0053 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0053)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0054 {
			(*z) = txGroupsEncodingStub{}
		}
		for zb0053 > 0 {
			zb0053--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "ttc":
				(*z).TotalTransactionsCount, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TotalTransactionsCount")
					return
				}
			case "tgc":
				(*z).TransactionGroupCount, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TransactionGroupCount")
					return
				}
			case "tgs":
				var zb0320 int
				zb0320, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "TransactionGroupSizes")
					return
				}
				if zb0320 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0320), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).TransactionGroupSizes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroupSizes)
				if err != nil {
					err = msgp.WrapError(err, "TransactionGroupSizes")
					return
				}
			case "sig":
				var zb0321 int
				zb0321, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
				if zb0321 > maxSignatureBytes {
					err = msgp.ErrOverflow(uint64(zb0321), uint64(maxSignatureBytes))
					return
				}
				(*z).encodedSignedTxns.Sig, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.Sig)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			case "sigbm":
				{
					var zb0322 []byte
					var zb0323 int
					zb0323, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSig")
						return
					}
					if zb0323 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0323), uint64(maxBitmaskSize))
						return
					}
					zb0322, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskSig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSig")
						return
					}
					(*z).encodedSignedTxns.BitmaskSig = bitmask(zb0322)
				}
			case "msigv":
				var zb0324 int
				zb0324, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Version")
					return
				}
				if zb0324 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0324), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).encodedSignedTxns.encodedMsigs.Version, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedMsigs.Version)
				if err != nil {
					err = msgp.WrapError(err, "Version")
					return
				}
			case "msigvbm":
				{
					var zb0325 []byte
					var zb0326 int
					zb0326, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVersion")
						return
					}
					if zb0326 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0326), uint64(maxBitmaskSize))
						return
					}
					zb0325, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedMsigs.BitmaskVersion))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVersion")
						return
					}
					(*z).encodedSignedTxns.encodedMsigs.BitmaskVersion = bitmask(zb0325)
				}
			case "msigthr":
				var zb0327 int
				zb0327, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Threshold")
					return
				}
				if zb0327 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0327), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).encodedSignedTxns.encodedMsigs.Threshold, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedMsigs.Threshold)
				if err != nil {
					err = msgp.WrapError(err, "Threshold")
					return
				}
			case "msigthrbm":
				{
					var zb0328 []byte
					var zb0329 int
					zb0329, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskThreshold")
						return
					}
					if zb0329 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0329), uint64(maxBitmaskSize))
						return
					}
					zb0328, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedMsigs.BitmaskThreshold))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskThreshold")
						return
					}
					(*z).encodedSignedTxns.encodedMsigs.BitmaskThreshold = bitmask(zb0328)
				}
			case "subsig":
				var zb0330 int
				var zb0331 bool
				zb0330, zb0331, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Subsigs")
					return
				}
				if zb0330 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0330), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Subsigs")
					return
				}
				if zb0331 {
					(*z).encodedSignedTxns.encodedMsigs.Subsigs = nil
				} else if (*z).encodedSignedTxns.encodedMsigs.Subsigs != nil && cap((*z).encodedSignedTxns.encodedMsigs.Subsigs) >= zb0330 {
					(*z).encodedSignedTxns.encodedMsigs.Subsigs = ((*z).encodedSignedTxns.encodedMsigs.Subsigs)[:zb0330]
				} else {
					(*z).encodedSignedTxns.encodedMsigs.Subsigs = make([][]crypto.MultisigSubsig, zb0330)
				}
				for zb0001 := range (*z).encodedSignedTxns.encodedMsigs.Subsigs {
					var zb0332 int
					var zb0333 bool
					zb0332, zb0333, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Subsigs", zb0001)
						return
					}
					if zb0332 > crypto.MaxMultisig {
						err = msgp.ErrOverflow(uint64(zb0332), uint64(crypto.MaxMultisig))
						err = msgp.WrapError(err, "Subsigs", zb0001)
						return
					}
					if zb0333 {
						(*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] = nil
					} else if (*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] != nil && cap((*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001]) >= zb0332 {
						(*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] = ((*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001])[:zb0332]
					} else {
						(*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] = make([]crypto.MultisigSubsig, zb0332)
					}
					for zb0002 := range (*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] {
						bts, err = (*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001][zb0002].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Subsigs", zb0001, zb0002)
							return
						}
					}
				}
			case "subsigsbm":
				{
					var zb0334 []byte
					var zb0335 int
					zb0335, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSubsigs")
						return
					}
					if zb0335 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0335), uint64(maxBitmaskSize))
						return
					}
					zb0334, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedMsigs.BitmaskSubsigs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSubsigs")
						return
					}
					(*z).encodedSignedTxns.encodedMsigs.BitmaskSubsigs = bitmask(zb0334)
				}
			case "lsigl":
				var zb0336 int
				var zb0337 bool
				zb0336, zb0337, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Logic")
					return
				}
				if zb0336 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0336), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Logic")
					return
				}
				if zb0337 {
					(*z).encodedSignedTxns.encodedLsigs.Logic = nil
				} else if (*z).encodedSignedTxns.encodedLsigs.Logic != nil && cap((*z).encodedSignedTxns.encodedLsigs.Logic) >= zb0336 {
					(*z).encodedSignedTxns.encodedLsigs.Logic = ((*z).encodedSignedTxns.encodedLsigs.Logic)[:zb0336]
				} else {
					(*z).encodedSignedTxns.encodedLsigs.Logic = make([][]byte, zb0336)
				}
				for zb0003 := range (*z).encodedSignedTxns.encodedLsigs.Logic {
					var zb0338 int
					zb0338, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "Logic", zb0003)
						return
					}
					if zb0338 > config.MaxLogicSigMaxSize {
						err = msgp.ErrOverflow(uint64(zb0338), uint64(config.MaxLogicSigMaxSize))
						return
					}
					(*z).encodedSignedTxns.encodedLsigs.Logic[zb0003], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedLsigs.Logic[zb0003])
					if err != nil {
						err = msgp.WrapError(err, "Logic", zb0003)
						return
					}
				}
			case "lsiglbm":
				{
					var zb0339 []byte
					var zb0340 int
					zb0340, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLogic")
						return
					}
					if zb0340 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0340), uint64(maxBitmaskSize))
						return
					}
					zb0339, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedLsigs.BitmaskLogic))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLogic")
						return
					}
					(*z).encodedSignedTxns.encodedLsigs.BitmaskLogic = bitmask(zb0339)
				}
			case "lsigarg":
				var zb0341 int
				var zb0342 bool
				zb0341, zb0342, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LogicArgs")
					return
				}
				if zb0341 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0341), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LogicArgs")
					return
				}
				if zb0342 {
					(*z).encodedSignedTxns.encodedLsigs.LogicArgs = nil
				} else if (*z).encodedSignedTxns.encodedLsigs.LogicArgs != nil && cap((*z).encodedSignedTxns.encodedLsigs.LogicArgs) >= zb0341 {
					(*z).encodedSignedTxns.encodedLsigs.LogicArgs = ((*z).encodedSignedTxns.encodedLsigs.LogicArgs)[:zb0341]
				} else {
					(*z).encodedSignedTxns.encodedLsigs.LogicArgs = make([][][]byte, zb0341)
				}
				for zb0004 := range (*z).encodedSignedTxns.encodedLsigs.LogicArgs {
					var zb0343 int
					var zb0344 bool
					zb0343, zb0344, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LogicArgs", zb0004)
						return
					}
					if zb0343 > transactions.EvalMaxArgs {
						err = msgp.ErrOverflow(uint64(zb0343), uint64(transactions.EvalMaxArgs))
						err = msgp.WrapError(err, "LogicArgs", zb0004)
						return
					}
					if zb0344 {
						(*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] = nil
					} else if (*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] != nil && cap((*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004]) >= zb0343 {
						(*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] = ((*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004])[:zb0343]
					} else {
						(*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] = make([][]byte, zb0343)
					}
					for zb0005 := range (*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] {
						var zb0345 int
						zb0345, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "LogicArgs", zb0004, zb0005)
							return
						}
						if zb0345 > config.MaxLogicSigMaxSize {
							err = msgp.ErrOverflow(uint64(zb0345), uint64(config.MaxLogicSigMaxSize))
							return
						}
						(*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004][zb0005], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004][zb0005])
						if err != nil {
							err = msgp.WrapError(err, "LogicArgs", zb0004, zb0005)
							return
						}
					}
				}
			case "lsigargbm":
				{
					var zb0346 []byte
					var zb0347 int
					zb0347, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLogicArgs")
						return
					}
					if zb0347 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0347), uint64(maxBitmaskSize))
						return
					}
					zb0346, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedLsigs.BitmaskLogicArgs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLogicArgs")
						return
					}
					(*z).encodedSignedTxns.encodedLsigs.BitmaskLogicArgs = bitmask(zb0346)
				}
			case "sgnr":
				var zb0348 int
				zb0348, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
				if zb0348 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0348), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.AuthAddr, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.AuthAddr)
				if err != nil {
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
			case "sgnrbm":
				{
					var zb0349 []byte
					var zb0350 int
					zb0350, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAuthAddr")
						return
					}
					if zb0350 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0350), uint64(maxBitmaskSize))
						return
					}
					zb0349, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskAuthAddr))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAuthAddr")
						return
					}
					(*z).encodedSignedTxns.BitmaskAuthAddr = bitmask(zb0349)
				}
			case "type":
				var zb0351 int
				zb0351, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
				if zb0351 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0351), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.TxType, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.TxType)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
			case "typebm":
				{
					var zb0352 []byte
					var zb0353 int
					zb0353, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTxType")
						return
					}
					if zb0353 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0353), uint64(maxBitmaskSize))
						return
					}
					zb0352, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.BitmaskTxType))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTxType")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.BitmaskTxType = bitmask(zb0352)
				}
			case "typeo":
				(*z).encodedSignedTxns.encodedTxns.TxTypeOffset, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxTypeOffset")
					return
				}
			case "snd":
				var zb0354 int
				zb0354, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				if zb0354 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0354), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "sndbm":
				{
					var zb0355 []byte
					var zb0356 int
					zb0356, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSender")
						return
					}
					if zb0356 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0356), uint64(maxBitmaskSize))
						return
					}
					zb0355, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSender")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender = bitmask(zb0355)
				}
			case "fee":
				var zb0357 int
				var zb0358 bool
				zb0357, zb0358, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0357 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0357), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0358 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee) >= zb0357 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee)[:zb0357]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee = make([]basics.MicroAlgos, zb0357)
				}
				for zb0006 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee[zb0006].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Fee", zb0006)
						return
					}
				}
			case "feebm":
				{
					var zb0359 []byte
					var zb0360 int
					zb0360, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFee")
						return
					}
					if zb0360 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0360), uint64(maxBitmaskSize))
						return
					}
					zb0359, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFee")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee = bitmask(zb0359)
				}
			case "fv":
				var zb0361 int
				var zb0362 bool
				zb0361, zb0362, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0361 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0361), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0362 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid) >= zb0361 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid)[:zb0361]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid = make([]basics.Round, zb0361)
				}
				for zb0007 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid[zb0007].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "FirstValid", zb0007)
						return
					}
				}
			case "fvbm":
				{
					var zb0363 []byte
					var zb0364 int
					zb0364, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFirstValid")
						return
					}
					if zb0364 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0364), uint64(maxBitmaskSize))
						return
					}
					zb0363, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFirstValid")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid = bitmask(zb0363)
				}
			case "lv":
				var zb0365 int
				var zb0366 bool
				zb0365, zb0366, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0365 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0365), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0366 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid) >= zb0365 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid)[:zb0365]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid = make([]basics.Round, zb0365)
				}
				for zb0008 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid[zb0008].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastValid", zb0008)
						return
					}
				}
			case "lvbm":
				{
					var zb0367 []byte
					var zb0368 int
					zb0368, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLastValid")
						return
					}
					if zb0368 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0368), uint64(maxBitmaskSize))
						return
					}
					zb0367, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLastValid")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid = bitmask(zb0367)
				}
			case "note":
				var zb0369 int
				var zb0370 bool
				zb0369, zb0370, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0369 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0369), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0370 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note) >= zb0369 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note)[:zb0369]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note = make([][]byte, zb0369)
				}
				for zb0009 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note {
					var zb0371 int
					zb0371, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "Note", zb0009)
						return
					}
					if zb0371 > config.MaxTxnNoteBytes {
						err = msgp.ErrOverflow(uint64(zb0371), uint64(config.MaxTxnNoteBytes))
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note[zb0009], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note[zb0009])
					if err != nil {
						err = msgp.WrapError(err, "Note", zb0009)
						return
					}
				}
			case "notebm":
				{
					var zb0372 []byte
					var zb0373 int
					zb0373, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNote")
						return
					}
					if zb0373 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0373), uint64(maxBitmaskSize))
						return
					}
					zb0372, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNote")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote = bitmask(zb0372)
				}
			case "genbm":
				{
					var zb0374 []byte
					var zb0375 int
					zb0375, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisID")
						return
					}
					if zb0375 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0375), uint64(maxBitmaskSize))
						return
					}
					zb0374, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisID")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID = bitmask(zb0374)
				}
			case "grpbm":
				{
					var zb0376 []byte
					var zb0377 int
					zb0377, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGroup")
						return
					}
					if zb0377 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0377), uint64(maxBitmaskSize))
						return
					}
					zb0376, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGroup))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGroup")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGroup = bitmask(zb0376)
				}
			case "lx":
				var zb0378 int
				zb0378, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
				if zb0378 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0378), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease)
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
			case "lxbm":
				{
					var zb0379 []byte
					var zb0380 int
					zb0380, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLease")
						return
					}
					if zb0380 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0380), uint64(maxBitmaskSize))
						return
					}
					zb0379, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLease")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease = bitmask(zb0379)
				}
			case "rekey":
				var zb0381 int
				zb0381, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
				if zb0381 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0381), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
			case "rekeybm":
				{
					var zb0382 []byte
					var zb0383 int
					zb0383, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskRekeyTo")
						return
					}
					if zb0383 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0383), uint64(maxBitmaskSize))
						return
					}
					zb0382, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskRekeyTo")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo = bitmask(zb0382)
				}
			case "votekey":
				var zb0384 int
				zb0384, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
				if zb0384 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0384), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
			case "selkey":
				var zb0385 int
				zb0385, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
				if zb0385 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0385), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
			case "votefst":
				var zb0386 int
				var zb0387 bool
				zb0386, zb0387, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0386 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0386), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0387 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst) >= zb0386 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst)[:zb0386]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst = make([]basics.Round, zb0386)
				}
				for zb0010 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0010].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteFirst", zb0010)
						return
					}
				}
			case "votefstbm":
				{
					var zb0388 []byte
					var zb0389 int
					zb0389, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteFirst")
						return
					}
					if zb0389 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0389), uint64(maxBitmaskSize))
						return
					}
					zb0388, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteFirst")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst = bitmask(zb0388)
				}
			case "votelst":
				var zb0390 int
				var zb0391 bool
				zb0390, zb0391, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0390 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0390), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0391 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast) >= zb0390 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast)[:zb0390]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast = make([]basics.Round, zb0390)
				}
				for zb0011 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast[zb0011].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteLast", zb0011)
						return
					}
				}
			case "votelstbm":
				{
					var zb0392 []byte
					var zb0393 int
					zb0393, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteLast")
						return
					}
					if zb0393 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0393), uint64(maxBitmaskSize))
						return
					}
					zb0392, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteLast")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast = bitmask(zb0392)
				}
			case "votekd":
				var zb0394 int
				var zb0395 bool
				zb0394, zb0395, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0394 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0394), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0395 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) >= zb0394 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution)[:zb0394]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = make([]uint64, zb0394)
				}
				for zb0012 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution[zb0012], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteKeyDilution", zb0012)
						return
					}
				}
			case "votekbm":
				{
					var zb0396 []byte
					var zb0397 int
					zb0397, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskKeys")
						return
					}
					if zb0397 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0397), uint64(maxBitmaskSize))
						return
					}
					zb0396, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskKeys))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskKeys")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskKeys = bitmask(zb0396)
				}
			case "nonpartbm":
				{
					var zb0398 []byte
					var zb0399 int
					zb0399, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNonparticipation")
						return
					}
					if zb0399 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0399), uint64(maxBitmaskSize))
						return
					}
					zb0398, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNonparticipation")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation = bitmask(zb0398)
				}
			case "vldrt":
				var zb0400 int
				var zb0401 bool
				zb0400, zb0401, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HasValidRoot")
					return
				}
				if zb0400 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0400), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "HasValidRoot")
					return
				}
				if zb0401 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot) >= zb0400 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot)[:zb0400]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot = make([]bool, zb0400)
				}
				for zb0013 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot[zb0013], bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "HasValidRoot", zb0013)
						return
					}
				}
			case "comt":
				var zb0402 int
				zb0402, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "CommitmentRoot")
					return
				}
				if zb0402 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0402), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.CommitmentRoot, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.CommitmentRoot)
				if err != nil {
					err = msgp.WrapError(err, "CommitmentRoot")
					return
				}
			case "rcv":
				var zb0403 int
				zb0403, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
				if zb0403 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0403), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
			case "rcvbm":
				{
					var zb0404 []byte
					var zb0405 int
					zb0405, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReceiver")
						return
					}
					if zb0405 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0405), uint64(maxBitmaskSize))
						return
					}
					zb0404, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReceiver")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver = bitmask(zb0404)
				}
			case "amt":
				var zb0406 int
				var zb0407 bool
				zb0406, zb0407, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0406 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0406), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0407 {
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount) >= zb0406 {
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount = ((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount)[:zb0406]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount = make([]basics.MicroAlgos, zb0406)
				}
				for zb0014 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount[zb0014].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Amount", zb0014)
						return
					}
				}
			case "amtbm":
				{
					var zb0408 []byte
					var zb0409 int
					zb0409, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAmount")
						return
					}
					if zb0409 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0409), uint64(maxBitmaskSize))
						return
					}
					zb0408, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAmount")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount = bitmask(zb0408)
				}
			case "close":
				var zb0410 int
				zb0410, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
				if zb0410 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0410), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
			case "closebm":
				{
					var zb0411 []byte
					var zb0412 int
					zb0412, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCloseRemainderTo")
						return
					}
					if zb0412 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0412), uint64(maxBitmaskSize))
						return
					}
					zb0411, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCloseRemainderTo")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo = bitmask(zb0411)
				}
			case "caid":
				var zb0413 int
				var zb0414 bool
				zb0413, zb0414, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ConfigAsset")
					return
				}
				if zb0413 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0413), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ConfigAsset")
					return
				}
				if zb0414 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset) >= zb0413 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset = ((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset)[:zb0413]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset = make([]basics.AssetIndex, zb0413)
				}
				for zb0015 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset[zb0015].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ConfigAsset", zb0015)
						return
					}
				}
			case "caidbm":
				{
					var zb0415 []byte
					var zb0416 int
					zb0416, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskConfigAsset")
						return
					}
					if zb0416 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0416), uint64(maxBitmaskSize))
						return
					}
					zb0415, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskConfigAsset")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset = bitmask(zb0415)
				}
			case "t":
				var zb0417 int
				var zb0418 bool
				zb0417, zb0418, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Total")
					return
				}
				if zb0417 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0417), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Total")
					return
				}
				if zb0418 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total) >= zb0417 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total = ((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total)[:zb0417]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total = make([]uint64, zb0417)
				}
				for zb0016 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total[zb0016], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Total", zb0016)
						return
					}
				}
			case "tbm":
				{
					var zb0419 []byte
					var zb0420 int
					zb0420, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTotal")
						return
					}
					if zb0420 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0420), uint64(maxBitmaskSize))
						return
					}
					zb0419, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTotal")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal = bitmask(zb0419)
				}
			case "dc":
				var zb0421 int
				var zb0422 bool
				zb0421, zb0422, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Decimals")
					return
				}
				if zb0421 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0421), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Decimals")
					return
				}
				if zb0422 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals) >= zb0421 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals = ((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals)[:zb0421]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals = make([]uint32, zb0421)
				}
				for zb0017 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals[zb0017], bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Decimals", zb0017)
						return
					}
				}
			case "dcbm":
				{
					var zb0423 []byte
					var zb0424 int
					zb0424, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDecimals")
						return
					}
					if zb0424 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0424), uint64(maxBitmaskSize))
						return
					}
					zb0423, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDecimals")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals = bitmask(zb0423)
				}
			case "dfbm":
				{
					var zb0425 []byte
					var zb0426 int
					zb0426, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDefaultFrozen")
						return
					}
					if zb0426 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0426), uint64(maxBitmaskSize))
						return
					}
					zb0425, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskDefaultFrozen")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen = bitmask(zb0425)
				}
			case "un":
				var zb0427 int
				var zb0428 bool
				zb0427, zb0428, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UnitName")
					return
				}
				if zb0427 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0427), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "UnitName")
					return
				}
				if zb0428 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName) >= zb0427 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName = ((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName)[:zb0427]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName = make([]string, zb0427)
				}
				for zb0018 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName[zb0018], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "UnitName", zb0018)
						return
					}
				}
			case "unbm":
				{
					var zb0429 []byte
					var zb0430 int
					zb0430, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskUnitName")
						return
					}
					if zb0430 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0430), uint64(maxBitmaskSize))
						return
					}
					zb0429, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskUnitName")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName = bitmask(zb0429)
				}
			case "an":
				var zb0431 int
				var zb0432 bool
				zb0431, zb0432, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetName")
					return
				}
				if zb0431 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0431), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "AssetName")
					return
				}
				if zb0432 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName) >= zb0431 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName = ((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName)[:zb0431]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName = make([]string, zb0431)
				}
				for zb0019 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName[zb0019], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AssetName", zb0019)
						return
					}
				}
			case "anbm":
				{
					var zb0433 []byte
					var zb0434 int
					zb0434, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetName")
						return
					}
					if zb0434 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0434), uint64(maxBitmaskSize))
						return
					}
					zb0433, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetName")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName = bitmask(zb0433)
				}
			case "au":
				var zb0435 int
				var zb0436 bool
				zb0435, zb0436, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "URL")
					return
				}
				if zb0435 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0435), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "URL")
					return
				}
				if zb0436 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL) >= zb0435 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL = ((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL)[:zb0435]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL = make([]string, zb0435)
				}
				for zb0020 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL[zb0020], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "URL", zb0020)
						return
					}
				}
			case "aubm":
				{
					var zb0437 []byte
					var zb0438 int
					zb0438, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskURL")
						return
					}
					if zb0438 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0438), uint64(maxBitmaskSize))
						return
					}
					zb0437, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskURL")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL = bitmask(zb0437)
				}
			case "am":
				var zb0439 int
				zb0439, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "MetadataHash")
					return
				}
				if zb0439 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0439), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash)
				if err != nil {
					err = msgp.WrapError(err, "MetadataHash")
					return
				}
			case "ambm":
				{
					var zb0440 []byte
					var zb0441 int
					zb0441, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMetadataHash")
						return
					}
					if zb0441 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0441), uint64(maxBitmaskSize))
						return
					}
					zb0440, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMetadataHash")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash = bitmask(zb0440)
				}
			case "m":
				var zb0442 int
				zb0442, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Manager")
					return
				}
				if zb0442 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0442), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager)
				if err != nil {
					err = msgp.WrapError(err, "Manager")
					return
				}
			case "mbm":
				{
					var zb0443 []byte
					var zb0444 int
					zb0444, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskManager")
						return
					}
					if zb0444 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0444), uint64(maxBitmaskSize))
						return
					}
					zb0443, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskManager")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager = bitmask(zb0443)
				}
			case "r":
				var zb0445 int
				zb0445, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reserve")
					return
				}
				if zb0445 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0445), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve)
				if err != nil {
					err = msgp.WrapError(err, "Reserve")
					return
				}
			case "rbm":
				{
					var zb0446 []byte
					var zb0447 int
					zb0447, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReserve")
						return
					}
					if zb0447 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0447), uint64(maxBitmaskSize))
						return
					}
					zb0446, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReserve")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve = bitmask(zb0446)
				}
			case "f":
				var zb0448 int
				zb0448, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Freeze")
					return
				}
				if zb0448 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0448), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze)
				if err != nil {
					err = msgp.WrapError(err, "Freeze")
					return
				}
			case "fbm":
				{
					var zb0449 []byte
					var zb0450 int
					zb0450, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreeze")
						return
					}
					if zb0450 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0450), uint64(maxBitmaskSize))
						return
					}
					zb0449, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreeze")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze = bitmask(zb0449)
				}
			case "c":
				var zb0451 int
				zb0451, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Clawback")
					return
				}
				if zb0451 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0451), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback)
				if err != nil {
					err = msgp.WrapError(err, "Clawback")
					return
				}
			case "cbm":
				{
					var zb0452 []byte
					var zb0453 int
					zb0453, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClawback")
						return
					}
					if zb0453 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0453), uint64(maxBitmaskSize))
						return
					}
					zb0452, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClawback")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback = bitmask(zb0452)
				}
			case "xaid":
				var zb0454 int
				var zb0455 bool
				zb0454, zb0455, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "XferAsset")
					return
				}
				if zb0454 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0454), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "XferAsset")
					return
				}
				if zb0455 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset) >= zb0454 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset = ((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset)[:zb0454]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset = make([]basics.AssetIndex, zb0454)
				}
				for zb0021 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset[zb0021].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "XferAsset", zb0021)
						return
					}
				}
			case "xaidbm":
				{
					var zb0456 []byte
					var zb0457 int
					zb0457, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskXferAsset")
						return
					}
					if zb0457 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0457), uint64(maxBitmaskSize))
						return
					}
					zb0456, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskXferAsset")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset = bitmask(zb0456)
				}
			case "aamt":
				var zb0458 int
				var zb0459 bool
				zb0458, zb0459, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetAmount")
					return
				}
				if zb0458 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0458), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "AssetAmount")
					return
				}
				if zb0459 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount) >= zb0458 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount = ((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount)[:zb0458]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount = make([]uint64, zb0458)
				}
				for zb0022 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount[zb0022], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AssetAmount", zb0022)
						return
					}
				}
			case "aamtbm":
				{
					var zb0460 []byte
					var zb0461 int
					zb0461, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetAmount")
						return
					}
					if zb0461 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0461), uint64(maxBitmaskSize))
						return
					}
					zb0460, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetAmount")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount = bitmask(zb0460)
				}
			case "asnd":
				var zb0462 int
				zb0462, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetSender")
					return
				}
				if zb0462 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0462), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetSender, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetSender)
				if err != nil {
					err = msgp.WrapError(err, "AssetSender")
					return
				}
			case "asndbm":
				{
					var zb0463 []byte
					var zb0464 int
					zb0464, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetSender")
						return
					}
					if zb0464 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0464), uint64(maxBitmaskSize))
						return
					}
					zb0463, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetSender")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender = bitmask(zb0463)
				}
			case "arcv":
				var zb0465 int
				zb0465, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetReceiver")
					return
				}
				if zb0465 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0465), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetReceiver, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetReceiver)
				if err != nil {
					err = msgp.WrapError(err, "AssetReceiver")
					return
				}
			case "arcvbm":
				{
					var zb0466 []byte
					var zb0467 int
					zb0467, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetReceiver")
						return
					}
					if zb0467 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0467), uint64(maxBitmaskSize))
						return
					}
					zb0466, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetReceiver")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver = bitmask(zb0466)
				}
			case "aclose":
				var zb0468 int
				zb0468, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "AssetCloseTo")
					return
				}
				if zb0468 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0468), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo)
				if err != nil {
					err = msgp.WrapError(err, "AssetCloseTo")
					return
				}
			case "aclosebm":
				{
					var zb0469 []byte
					var zb0470 int
					zb0470, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetCloseTo")
						return
					}
					if zb0470 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0470), uint64(maxBitmaskSize))
						return
					}
					zb0469, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetCloseTo")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo = bitmask(zb0469)
				}
			case "fadd":
				var zb0471 int
				zb0471, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAccount")
					return
				}
				if zb0471 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0471), uint64(maxAddressBytes))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAccount")
					return
				}
			case "faddbm":
				{
					var zb0472 []byte
					var zb0473 int
					zb0473, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAccount")
						return
					}
					if zb0473 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0473), uint64(maxBitmaskSize))
						return
					}
					zb0472, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAccount")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount = bitmask(zb0472)
				}
			case "faid":
				var zb0474 int
				var zb0475 bool
				zb0474, zb0475, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FreezeAsset")
					return
				}
				if zb0474 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0474), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "FreezeAsset")
					return
				}
				if zb0475 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset) >= zb0474 {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset = ((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset)[:zb0474]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset = make([]basics.AssetIndex, zb0474)
				}
				for zb0023 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset[zb0023].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "FreezeAsset", zb0023)
						return
					}
				}
			case "faidbm":
				{
					var zb0476 []byte
					var zb0477 int
					zb0477, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAsset")
						return
					}
					if zb0477 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0477), uint64(maxBitmaskSize))
						return
					}
					zb0476, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFreezeAsset")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset = bitmask(zb0476)
				}
			case "afrzbm":
				{
					var zb0478 []byte
					var zb0479 int
					zb0479, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetFrozen")
						return
					}
					if zb0479 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0479), uint64(maxBitmaskSize))
						return
					}
					zb0478, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAssetFrozen")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen = bitmask(zb0478)
				}
			case "apid":
				var zb0480 int
				var zb0481 bool
				zb0480, zb0481, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ApplicationID")
					return
				}
				if zb0480 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0480), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ApplicationID")
					return
				}
				if zb0481 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID) >= zb0480 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID)[:zb0480]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID = make([]basics.AppIndex, zb0480)
				}
				for zb0024 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID[zb0024].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ApplicationID", zb0024)
						return
					}
				}
			case "apidbm":
				{
					var zb0482 []byte
					var zb0483 int
					zb0483, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationID")
						return
					}
					if zb0483 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0483), uint64(maxBitmaskSize))
						return
					}
					zb0482, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationID")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID = bitmask(zb0482)
				}
			case "apan":
				var zb0484 int
				zb0484, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "OnCompletion")
					return
				}
				if zb0484 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0484), uint64(maxEncodedTransactionGroups))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.OnCompletion, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.OnCompletion)
				if err != nil {
					err = msgp.WrapError(err, "OnCompletion")
					return
				}
			case "apanbm":
				{
					var zb0485 []byte
					var zb0486 int
					zb0486, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskOnCompletion")
						return
					}
					if zb0486 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0486), uint64(maxBitmaskSize))
						return
					}
					zb0485, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskOnCompletion")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion = bitmask(zb0485)
				}
			case "apaa":
				var zb0487 int
				var zb0488 bool
				zb0487, zb0488, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ApplicationArgs")
					return
				}
				if zb0487 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0487), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ApplicationArgs")
					return
				}
				if zb0488 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs) >= zb0487 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs)[:zb0487]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs = make([]applicationArgs, zb0487)
				}
				for zb0025 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs {
					var zb0489 int
					var zb0490 bool
					zb0489, zb0490, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ApplicationArgs", zb0025)
						return
					}
					if zb0489 > transactions.EncodedMaxApplicationArgs {
						err = msgp.ErrOverflow(uint64(zb0489), uint64(transactions.EncodedMaxApplicationArgs))
						err = msgp.WrapError(err, "ApplicationArgs", zb0025)
						return
					}
					if zb0490 {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] = nil
					} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025]) >= zb0489 {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025])[:zb0489]
					} else {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] = make(applicationArgs, zb0489)
					}
					for zb0026 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025][zb0026], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025][zb0026])
						if err != nil {
							err = msgp.WrapError(err, "ApplicationArgs", zb0025, zb0026)
							return
						}
					}
				}
			case "apaabm":
				{
					var zb0491 []byte
					var zb0492 int
					zb0492, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationArgs")
						return
					}
					if zb0492 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0492), uint64(maxBitmaskSize))
						return
					}
					zb0491, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApplicationArgs")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs = bitmask(zb0491)
				}
			case "apat":
				var zb0493 int
				var zb0494 bool
				zb0493, zb0494, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Accounts")
					return
				}
				if zb0493 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0493), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Accounts")
					return
				}
				if zb0494 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts) >= zb0493 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts)[:zb0493]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts = make([]addresses, zb0493)
				}
				for zb0027 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts {
					var zb0495 int
					var zb0496 bool
					zb0495, zb0496, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Accounts", zb0027)
						return
					}
					if zb0495 > transactions.EncodedMaxAccounts {
						err = msgp.ErrOverflow(uint64(zb0495), uint64(transactions.EncodedMaxAccounts))
						err = msgp.WrapError(err, "Accounts", zb0027)
						return
					}
					if zb0496 {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] = nil
					} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027]) >= zb0495 {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027])[:zb0495]
					} else {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] = make(addresses, zb0495)
					}
					for zb0028 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] {
						bts, err = (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027][zb0028].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Accounts", zb0027, zb0028)
							return
						}
					}
				}
			case "apatbm":
				{
					var zb0497 []byte
					var zb0498 int
					zb0498, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAccounts")
						return
					}
					if zb0498 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0498), uint64(maxBitmaskSize))
						return
					}
					zb0497, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAccounts")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts = bitmask(zb0497)
				}
			case "apfa":
				var zb0499 int
				var zb0500 bool
				zb0499, zb0500, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ForeignApps")
					return
				}
				if zb0499 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0499), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ForeignApps")
					return
				}
				if zb0500 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps) >= zb0499 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps)[:zb0499]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps = make([]appIndices, zb0499)
				}
				for zb0029 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps {
					var zb0501 int
					var zb0502 bool
					zb0501, zb0502, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ForeignApps", zb0029)
						return
					}
					if zb0501 > transactions.EncodedMaxForeignApps {
						err = msgp.ErrOverflow(uint64(zb0501), uint64(transactions.EncodedMaxForeignApps))
						err = msgp.WrapError(err, "ForeignApps", zb0029)
						return
					}
					if zb0502 {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] = nil
					} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029]) >= zb0501 {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029])[:zb0501]
					} else {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] = make(appIndices, zb0501)
					}
					for zb0030 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] {
						bts, err = (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029][zb0030].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "ForeignApps", zb0029, zb0030)
							return
						}
					}
				}
			case "apfabm":
				{
					var zb0503 []byte
					var zb0504 int
					zb0504, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignApps")
						return
					}
					if zb0504 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0504), uint64(maxBitmaskSize))
						return
					}
					zb0503, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignApps")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps = bitmask(zb0503)
				}
			case "apas":
				var zb0505 int
				var zb0506 bool
				zb0505, zb0506, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ForeignAssets")
					return
				}
				if zb0505 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0505), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ForeignAssets")
					return
				}
				if zb0506 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets) >= zb0505 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets)[:zb0505]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets = make([]assetIndices, zb0505)
				}
				for zb0031 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets {
					var zb0507 int
					var zb0508 bool
					zb0507, zb0508, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ForeignAssets", zb0031)
						return
					}
					if zb0507 > transactions.EncodedMaxForeignAssets {
						err = msgp.ErrOverflow(uint64(zb0507), uint64(transactions.EncodedMaxForeignAssets))
						err = msgp.WrapError(err, "ForeignAssets", zb0031)
						return
					}
					if zb0508 {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] = nil
					} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031]) >= zb0507 {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031])[:zb0507]
					} else {
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] = make(assetIndices, zb0507)
					}
					for zb0032 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] {
						bts, err = (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031][zb0032].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "ForeignAssets", zb0031, zb0032)
							return
						}
					}
				}
			case "apasbm":
				{
					var zb0509 []byte
					var zb0510 int
					zb0510, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignAssets")
						return
					}
					if zb0510 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0510), uint64(maxBitmaskSize))
						return
					}
					zb0509, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskForeignAssets")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets = bitmask(zb0509)
				}
			case "lnui":
				var zb0511 int
				var zb0512 bool
				zb0511, zb0512, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LocalNumUint")
					return
				}
				if zb0511 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0511), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LocalNumUint")
					return
				}
				if zb0512 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint) >= zb0511 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint)[:zb0511]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint = make([]uint64, zb0511)
				}
				for zb0033 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint[zb0033], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LocalNumUint", zb0033)
						return
					}
				}
			case "lnuibm":
				{
					var zb0513 []byte
					var zb0514 int
					zb0514, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumUint")
						return
					}
					if zb0514 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0514), uint64(maxBitmaskSize))
						return
					}
					zb0513, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumUint")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint = bitmask(zb0513)
				}
			case "lnbs":
				var zb0515 int
				var zb0516 bool
				zb0515, zb0516, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LocalNumByteSlice")
					return
				}
				if zb0515 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0515), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "LocalNumByteSlice")
					return
				}
				if zb0516 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice) >= zb0515 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice)[:zb0515]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice = make([]uint64, zb0515)
				}
				for zb0034 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice[zb0034], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LocalNumByteSlice", zb0034)
						return
					}
				}
			case "lnbsbm":
				{
					var zb0517 []byte
					var zb0518 int
					zb0518, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumByteSlice")
						return
					}
					if zb0518 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0518), uint64(maxBitmaskSize))
						return
					}
					zb0517, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLocalNumByteSlice")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice = bitmask(zb0517)
				}
			case "gnui":
				var zb0519 int
				var zb0520 bool
				zb0519, zb0520, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GlobalNumUint")
					return
				}
				if zb0519 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0519), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "GlobalNumUint")
					return
				}
				if zb0520 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint) >= zb0519 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint)[:zb0519]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint = make([]uint64, zb0519)
				}
				for zb0035 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint[zb0035], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "GlobalNumUint", zb0035)
						return
					}
				}
			case "gnuibm":
				{
					var zb0521 []byte
					var zb0522 int
					zb0522, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumUint")
						return
					}
					if zb0522 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0522), uint64(maxBitmaskSize))
						return
					}
					zb0521, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumUint")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint = bitmask(zb0521)
				}
			case "gnbs":
				var zb0523 int
				var zb0524 bool
				zb0523, zb0524, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GlobalNumByteSlice")
					return
				}
				if zb0523 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0523), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "GlobalNumByteSlice")
					return
				}
				if zb0524 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice) >= zb0523 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice)[:zb0523]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice = make([]uint64, zb0523)
				}
				for zb0036 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice[zb0036], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "GlobalNumByteSlice", zb0036)
						return
					}
				}
			case "gnbsbm":
				{
					var zb0525 []byte
					var zb0526 int
					zb0526, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumByteSlice")
						return
					}
					if zb0526 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0526), uint64(maxBitmaskSize))
						return
					}
					zb0525, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGlobalNumByteSlice")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice = bitmask(zb0525)
				}
			case "apap":
				var zb0527 int
				var zb0528 bool
				zb0527, zb0528, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ApprovalProgram")
					return
				}
				if zb0527 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0527), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ApprovalProgram")
					return
				}
				if zb0528 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram) >= zb0527 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram)[:zb0527]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram = make([]program, zb0527)
				}
				for zb0037 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram {
					{
						var zb0529 []byte
						var zb0530 int
						zb0530, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "ApprovalProgram", zb0037)
							return
						}
						if zb0530 > config.MaxAvailableAppProgramLen {
							err = msgp.ErrOverflow(uint64(zb0530), uint64(config.MaxAvailableAppProgramLen))
							return
						}
						zb0529, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram[zb0037]))
						if err != nil {
							err = msgp.WrapError(err, "ApprovalProgram", zb0037)
							return
						}
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram[zb0037] = program(zb0529)
					}
				}
			case "apapbm":
				{
					var zb0531 []byte
					var zb0532 int
					zb0532, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApprovalProgram")
						return
					}
					if zb0532 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0532), uint64(maxBitmaskSize))
						return
					}
					zb0531, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskApprovalProgram")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram = bitmask(zb0531)
				}
			case "apsu":
				var zb0533 int
				var zb0534 bool
				zb0533, zb0534, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ClearStateProgram")
					return
				}
				if zb0533 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0533), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ClearStateProgram")
					return
				}
				if zb0534 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram) >= zb0533 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram)[:zb0533]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram = make([]program, zb0533)
				}
				for zb0038 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram {
					{
						var zb0535 []byte
						var zb0536 int
						zb0536, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "ClearStateProgram", zb0038)
							return
						}
						if zb0536 > config.MaxAvailableAppProgramLen {
							err = msgp.ErrOverflow(uint64(zb0536), uint64(config.MaxAvailableAppProgramLen))
							return
						}
						zb0535, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram[zb0038]))
						if err != nil {
							err = msgp.WrapError(err, "ClearStateProgram", zb0038)
							return
						}
						(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram[zb0038] = program(zb0535)
					}
				}
			case "apsubm":
				{
					var zb0537 []byte
					var zb0538 int
					zb0538, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClearStateProgram")
						return
					}
					if zb0538 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0538), uint64(maxBitmaskSize))
						return
					}
					zb0537, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskClearStateProgram")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram = bitmask(zb0537)
				}
			case "apep":
				var zb0539 int
				var zb0540 bool
				zb0539, zb0540, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExtraProgramPages")
					return
				}
				if zb0539 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0539), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "ExtraProgramPages")
					return
				}
				if zb0540 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages) >= zb0539 {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages = ((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages)[:zb0539]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages = make([]uint32, zb0539)
				}
				for zb0039 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages {
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages[zb0039], bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ExtraProgramPages", zb0039)
						return
					}
				}
			case "apepbm":
				{
					var zb0541 []byte
					var zb0542 int
					zb0542, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskExtraProgramPages")
						return
					}
					if zb0542 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0542), uint64(maxBitmaskSize))
						return
					}
					zb0541, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskExtraProgramPages")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages = bitmask(zb0541)
				}
			case "certrnd":
				var zb0543 int
				var zb0544 bool
				zb0543, zb0544, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CertRound")
					return
				}
				if zb0543 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0543), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "CertRound")
					return
				}
				if zb0544 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound) >= zb0543 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound)[:zb0543]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound = make([]basics.Round, zb0543)
				}
				for zb0040 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound[zb0040].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CertRound", zb0040)
						return
					}
				}
			case "certrndbm":
				{
					var zb0545 []byte
					var zb0546 int
					zb0546, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertRound")
						return
					}
					if zb0546 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0546), uint64(maxBitmaskSize))
						return
					}
					zb0545, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertRound")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound = bitmask(zb0545)
				}
			case "certtype":
				var zb0547 int
				var zb0548 bool
				zb0547, zb0548, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CertType")
					return
				}
				if zb0547 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0547), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "CertType")
					return
				}
				if zb0548 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType) >= zb0547 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType)[:zb0547]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType = make([]protocol.CompactCertType, zb0547)
				}
				for zb0041 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType[zb0041].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CertType", zb0041)
						return
					}
				}
			case "certtypebm":
				{
					var zb0549 []byte
					var zb0550 int
					zb0550, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertType")
						return
					}
					if zb0550 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0550), uint64(maxBitmaskSize))
						return
					}
					zb0549, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertType))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCertType")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertType = bitmask(zb0549)
				}
			case "certc":
				var zb0551 int
				var zb0552 bool
				zb0551, zb0552, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigCommit")
					return
				}
				if zb0551 > maxAddressBytes {
					err = msgp.ErrOverflow(uint64(zb0551), uint64(maxAddressBytes))
					err = msgp.WrapError(err, "SigCommit")
					return
				}
				if zb0552 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit) >= zb0551 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit)[:zb0551]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit = make([]crypto.GenericDigest, zb0551)
				}
				for zb0042 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit[zb0042].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigCommit", zb0042)
						return
					}
				}
			case "certcbm":
				{
					var zb0553 []byte
					var zb0554 int
					zb0554, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigCommit")
						return
					}
					if zb0554 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0554), uint64(maxBitmaskSize))
						return
					}
					zb0553, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigCommit")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit = bitmask(zb0553)
				}
			case "certw":
				var zb0555 int
				var zb0556 bool
				zb0555, zb0556, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SignedWeight")
					return
				}
				if zb0555 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0555), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SignedWeight")
					return
				}
				if zb0556 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight) >= zb0555 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight)[:zb0555]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight = make([]uint64, zb0555)
				}
				for zb0043 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight[zb0043], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedWeight", zb0043)
						return
					}
				}
			case "certwbm":
				{
					var zb0557 []byte
					var zb0558 int
					zb0558, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSignedWeight")
						return
					}
					if zb0558 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0558), uint64(maxBitmaskSize))
						return
					}
					zb0557, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSignedWeight")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight = bitmask(zb0557)
				}
			case "certS":
				var zb0559 int
				var zb0560 bool
				zb0559, zb0560, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigProofs")
					return
				}
				if zb0559 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0559), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SigProofs")
					return
				}
				if zb0560 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs) >= zb0559 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs)[:zb0559]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs = make([]certProofs, zb0559)
				}
				for zb0044 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs {
					var zb0561 int
					var zb0562 bool
					zb0561, zb0562, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigProofs", zb0044)
						return
					}
					if zb0561 > compactcert.MaxProofDigests {
						err = msgp.ErrOverflow(uint64(zb0561), uint64(compactcert.MaxProofDigests))
						err = msgp.WrapError(err, "SigProofs", zb0044)
						return
					}
					if zb0562 {
						(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] = nil
					} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044]) >= zb0561 {
						(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044])[:zb0561]
					} else {
						(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] = make(certProofs, zb0561)
					}
					for zb0045 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] {
						bts, err = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044][zb0045].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SigProofs", zb0044, zb0045)
							return
						}
					}
				}
			case "certSbm":
				{
					var zb0563 []byte
					var zb0564 int
					zb0564, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigProofs")
						return
					}
					if zb0564 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0564), uint64(maxBitmaskSize))
						return
					}
					zb0563, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigProofs")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs = bitmask(zb0563)
				}
			case "certSH":
				var zb0565 int
				var zb0566 bool
				zb0565, zb0566, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SigProofHashTypes")
					return
				}
				if zb0565 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0565), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "SigProofHashTypes")
					return
				}
				if zb0566 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) >= zb0565 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes)[:zb0565]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes = make([]uint64, zb0565)
				}
				for zb0046 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes[zb0046], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SigProofHashTypes", zb0046)
						return
					}
				}
			case "certSHbm":
				{
					var zb0567 []byte
					var zb0568 int
					zb0568, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigsHash")
						return
					}
					if zb0568 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0568), uint64(maxBitmaskSize))
						return
					}
					zb0567, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSigsHash")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash = bitmask(zb0567)
				}
			case "certP":
				var zb0569 int
				var zb0570 bool
				zb0569, zb0570, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PartProofs")
					return
				}
				if zb0569 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0569), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "PartProofs")
					return
				}
				if zb0570 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs) >= zb0569 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs)[:zb0569]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs = make([]certProofs, zb0569)
				}
				for zb0047 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs {
					var zb0571 int
					var zb0572 bool
					zb0571, zb0572, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PartProofs", zb0047)
						return
					}
					if zb0571 > compactcert.MaxProofDigests {
						err = msgp.ErrOverflow(uint64(zb0571), uint64(compactcert.MaxProofDigests))
						err = msgp.WrapError(err, "PartProofs", zb0047)
						return
					}
					if zb0572 {
						(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] = nil
					} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047]) >= zb0571 {
						(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047])[:zb0571]
					} else {
						(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] = make(certProofs, zb0571)
					}
					for zb0048 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] {
						bts, err = (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047][zb0048].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "PartProofs", zb0047, zb0048)
							return
						}
					}
				}
			case "certPbm":
				{
					var zb0573 []byte
					var zb0574 int
					zb0574, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartProofs")
						return
					}
					if zb0574 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0574), uint64(maxBitmaskSize))
						return
					}
					zb0573, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartProofs")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs = bitmask(zb0573)
				}
			case "certPH":
				var zb0575 int
				var zb0576 bool
				zb0575, zb0576, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PartProofHashTypes")
					return
				}
				if zb0575 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0575), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "PartProofHashTypes")
					return
				}
				if zb0576 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) >= zb0575 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes)[:zb0575]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes = make([]uint64, zb0575)
				}
				for zb0049 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes[zb0049], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PartProofHashTypes", zb0049)
						return
					}
				}
			case "certPHbm":
				{
					var zb0577 []byte
					var zb0578 int
					zb0578, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartHash")
						return
					}
					if zb0578 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0578), uint64(maxBitmaskSize))
						return
					}
					zb0577, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskPartHash")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash = bitmask(zb0577)
				}
			case "certr":
				var zb0579 int
				var zb0580 bool
				zb0579, zb0580, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reveals")
					return
				}
				if zb0579 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0579), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "Reveals")
					return
				}
				if zb0580 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals) >= zb0579 {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals = ((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals)[:zb0579]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals = make([]revealMap, zb0579)
				}
				for zb0050 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals {
					var zb0581 int
					var zb0582 bool
					zb0581, zb0582, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Reveals", zb0050)
						return
					}
					if zb0581 > compactcert.MaxReveals {
						err = msgp.ErrOverflow(uint64(zb0581), uint64(compactcert.MaxReveals))
						err = msgp.WrapError(err, "Reveals", zb0050)
						return
					}
					if zb0582 {
						(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] = nil
					} else if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] == nil {
						(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] = make(revealMap, zb0581)
					}
					for zb0581 > 0 {
						var zb0051 uint64
						var zb0052 compactcert.Reveal
						zb0581--
						zb0051, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Reveals", zb0050)
							return
						}
						bts, err = zb0052.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Reveals", zb0050, zb0051)
							return
						}
						(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050][zb0051] = zb0052
					}
				}
			case "certrbm":
				{
					var zb0583 []byte
					var zb0584 int
					zb0584, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReveals")
						return
					}
					if zb0584 > maxBitmaskSize {
						err = msgp.ErrOverflow(uint64(zb0584), uint64(maxBitmaskSize))
						return
					}
					zb0583, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReveals")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals = bitmask(zb0583)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *txGroupsEncodingStub) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*txGroupsEncodingStub)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *txGroupsEncodingStub) Msgsize() (s int) {
	s = 3 + 4 + msgp.Uint64Size + 4 + msgp.Uint64Size + 4 + msgp.BytesPrefixSize + len((*z).TransactionGroupSizes) + 4 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.Sig) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.BitmaskSig)) + 6 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedMsigs.Version) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedMsigs.BitmaskVersion)) + 8 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedMsigs.Threshold) + 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedMsigs.BitmaskThreshold)) + 7 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).encodedSignedTxns.encodedMsigs.Subsigs {
		s += msgp.ArrayHeaderSize
		for zb0002 := range (*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001] {
			s += (*z).encodedSignedTxns.encodedMsigs.Subsigs[zb0001][zb0002].Msgsize()
		}
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedMsigs.BitmaskSubsigs)) + 6 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).encodedSignedTxns.encodedLsigs.Logic {
		s += msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedLsigs.Logic[zb0003])
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedLsigs.BitmaskLogic)) + 8 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).encodedSignedTxns.encodedLsigs.LogicArgs {
		s += msgp.ArrayHeaderSize
		for zb0005 := range (*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004] {
			s += msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedLsigs.LogicArgs[zb0004][zb0005])
		}
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedLsigs.BitmaskLogicArgs)) + 5 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.AuthAddr) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.BitmaskAuthAddr)) + 5 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.TxType) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.BitmaskTxType)) + 6 + msgp.ByteSize + 4 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender)) + 4 + msgp.ArrayHeaderSize
	for zb0006 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee {
		s += (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee[zb0006].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee)) + 3 + msgp.ArrayHeaderSize
	for zb0007 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid {
		s += (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid[zb0007].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid)) + 3 + msgp.ArrayHeaderSize
	for zb0008 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid {
		s += (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid[zb0008].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid)) + 5 + msgp.ArrayHeaderSize
	for zb0009 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note {
		s += msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note[zb0009])
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote)) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID)) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGroup)) + 3 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease)) + 6 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo)) + 8 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK) + 7 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK) + 8 + msgp.ArrayHeaderSize
	for zb0010 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst {
		s += (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0010].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst)) + 8 + msgp.ArrayHeaderSize
	for zb0011 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast {
		s += (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast[zb0011].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) * (msgp.Uint64Size)) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskKeys)) + 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation)) + 6 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot) * (msgp.BoolSize)) + 5 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.CommitmentRoot) + 4 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver)) + 4 + msgp.ArrayHeaderSize
	for zb0014 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount {
		s += (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount[zb0014].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount)) + 6 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo)) + 5 + msgp.ArrayHeaderSize
	for zb0015 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset {
		s += (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset[zb0015].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset)) + 2 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total) * (msgp.Uint64Size)) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal)) + 3 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals) * (msgp.Uint32Size)) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals)) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen)) + 3 + msgp.ArrayHeaderSize
	for zb0018 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName {
		s += msgp.StringPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName[zb0018])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName)) + 3 + msgp.ArrayHeaderSize
	for zb0019 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName {
		s += msgp.StringPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName[zb0019])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName)) + 3 + msgp.ArrayHeaderSize
	for zb0020 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL {
		s += msgp.StringPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL[zb0020])
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL)) + 3 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash)) + 2 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager)) + 2 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve)) + 2 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze)) + 2 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback) + 4 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback)) + 5 + msgp.ArrayHeaderSize
	for zb0021 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset {
		s += (*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset[zb0021].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount)) + 5 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetSender) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender)) + 5 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetReceiver) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver)) + 7 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo)) + 5 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount)) + 5 + msgp.ArrayHeaderSize
	for zb0023 := range (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset {
		s += (*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset[zb0023].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen)) + 5 + msgp.ArrayHeaderSize
	for zb0024 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID {
		s += (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID[zb0024].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID)) + 5 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.OnCompletion) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion)) + 5 + msgp.ArrayHeaderSize
	for zb0025 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs {
		s += msgp.ArrayHeaderSize
		for zb0026 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025] {
			s += msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs[zb0025][zb0026])
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs)) + 5 + msgp.ArrayHeaderSize
	for zb0027 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts {
		s += msgp.ArrayHeaderSize
		for zb0028 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027] {
			s += (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts[zb0027][zb0028].Msgsize()
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts)) + 5 + msgp.ArrayHeaderSize
	for zb0029 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps {
		s += msgp.ArrayHeaderSize
		for zb0030 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029] {
			s += (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps[zb0029][zb0030].Msgsize()
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps)) + 5 + msgp.ArrayHeaderSize
	for zb0031 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets {
		s += msgp.ArrayHeaderSize
		for zb0032 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031] {
			s += (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets[zb0031][zb0032].Msgsize()
		}
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice) * (msgp.Uint64Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice)) + 5 + msgp.ArrayHeaderSize
	for zb0037 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram {
		s += msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram[zb0037]))
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram)) + 5 + msgp.ArrayHeaderSize
	for zb0038 := range (*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram {
		s += msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram[zb0038]))
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram)) + 5 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages) * (msgp.Uint32Size)) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages)) + 8 + msgp.ArrayHeaderSize
	for zb0040 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound {
		s += (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound[zb0040].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound)) + 9 + msgp.ArrayHeaderSize
	for zb0041 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType {
		s += (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType[zb0041].Msgsize()
	}
	s += 11 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertType)) + 6 + msgp.ArrayHeaderSize
	for zb0042 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit {
		s += (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit[zb0042].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit)) + 6 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight) * (msgp.Uint64Size)) + 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight)) + 6 + msgp.ArrayHeaderSize
	for zb0044 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs {
		s += msgp.ArrayHeaderSize
		for zb0045 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044] {
			s += (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs[zb0044][zb0045].Msgsize()
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash)) + 6 + msgp.ArrayHeaderSize
	for zb0047 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs {
		s += msgp.ArrayHeaderSize
		for zb0048 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047] {
			s += (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs[zb0047][zb0048].Msgsize()
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash)) + 6 + msgp.ArrayHeaderSize
	for zb0050 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals {
		s += msgp.MapHeaderSize
		if (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] != nil {
			for zb0051, zb0052 := range (*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals[zb0050] {
				_ = zb0051
				_ = zb0052
				s += 0 + msgp.Uint64Size + zb0052.Msgsize()
			}
		}
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *txGroupsEncodingStub) MsgIsZero() bool {
	return ((*z).TotalTransactionsCount == 0) && ((*z).TransactionGroupCount == 0) && (len((*z).TransactionGroupSizes) == 0) && (len((*z).encodedSignedTxns.Sig) == 0) && (len((*z).encodedSignedTxns.BitmaskSig) == 0) && (len((*z).encodedSignedTxns.encodedMsigs.Version) == 0) && (len((*z).encodedSignedTxns.encodedMsigs.BitmaskVersion) == 0) && (len((*z).encodedSignedTxns.encodedMsigs.Threshold) == 0) && (len((*z).encodedSignedTxns.encodedMsigs.BitmaskThreshold) == 0) && (len((*z).encodedSignedTxns.encodedMsigs.Subsigs) == 0) && (len((*z).encodedSignedTxns.encodedMsigs.BitmaskSubsigs) == 0) && (len((*z).encodedSignedTxns.encodedLsigs.Logic) == 0) && (len((*z).encodedSignedTxns.encodedLsigs.BitmaskLogic) == 0) && (len((*z).encodedSignedTxns.encodedLsigs.LogicArgs) == 0) && (len((*z).encodedSignedTxns.encodedLsigs.BitmaskLogicArgs) == 0) && (len((*z).encodedSignedTxns.AuthAddr) == 0) && (len((*z).encodedSignedTxns.BitmaskAuthAddr) == 0) && (len((*z).encodedSignedTxns.encodedTxns.TxType) == 0) && (len((*z).encodedSignedTxns.encodedTxns.BitmaskTxType) == 0) && ((*z).encodedSignedTxns.encodedTxns.TxTypeOffset == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGroup) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskKeys) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.HasValidRoot) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.CommitmentRoot) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.ConfigAsset) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.BitmaskConfigAsset) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Total) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskTotal) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Decimals) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDecimals) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskDefaultFrozen) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.UnitName) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskUnitName) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.AssetName) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskAssetName) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.URL) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskURL) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.MetadataHash) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskMetadataHash) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Manager) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskManager) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Reserve) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskReserve) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Freeze) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskFreeze) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.Clawback) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetConfigTxnFields.encodedAssetParams.BitmaskClawback) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.XferAsset) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskXferAsset) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetAmount) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetAmount) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetSender) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetSender) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetReceiver) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetReceiver) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.AssetCloseTo) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetTransferTxnFields.BitmaskAssetCloseTo) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAccount) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAccount) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.FreezeAsset) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskFreezeAsset) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedAssetFreezeTxnFields.BitmaskAssetFrozen) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationID) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationID) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.OnCompletion) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskOnCompletion) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApplicationArgs) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApplicationArgs) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.Accounts) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskAccounts) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignApps) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignApps) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ForeignAssets) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskForeignAssets) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumUint) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumUint) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.LocalNumByteSlice) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskLocalNumByteSlice) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumUint) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumUint) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.GlobalNumByteSlice) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskGlobalNumByteSlice) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ApprovalProgram) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskApprovalProgram) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ClearStateProgram) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskClearStateProgram) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.ExtraProgramPages) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedApplicationCallTxnFields.BitmaskExtraProgramPages) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertRound) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertRound) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.CertType) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.BitmaskCertType) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigCommit) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigCommit) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SignedWeight) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSignedWeight) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofs) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigProofs) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.SigProofHashTypes) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskSigsHash) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofs) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartProofs) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.PartProofHashTypes) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskPartHash) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.Reveals) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedCompactCertTxnFields.encodedCert.BitmaskReveals) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *txGroupsEncodingStubOld) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(1)
	var zb0002Mask uint8 /* 2 bits */
	if len((*z).TxnGroups) == 0 {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			if (*z).TxnGroups == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).TxnGroups)))
			}
			for zb0001 := range (*z).TxnGroups {
				o = (*z).TxnGroups[zb0001].MarshalMsg(o)
			}
		}
	}
	return
}

func (_ *txGroupsEncodingStubOld) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*txGroupsEncodingStubOld)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *txGroupsEncodingStubOld) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnGroups")
				return
			}
			if zb0004 > maxEncodedTransactionGroups {
				err = msgp.ErrOverflow(uint64(zb0004), uint64(maxEncodedTransactionGroups))
				err = msgp.WrapError(err, "struct-from-array", "TxnGroups")
				return
			}
			if zb0005 {
				(*z).TxnGroups = nil
			} else if (*z).TxnGroups != nil && cap((*z).TxnGroups) >= zb0004 {
				(*z).TxnGroups = ((*z).TxnGroups)[:zb0004]
			} else {
				(*z).TxnGroups = make([]txnGroups, zb0004)
			}
			for zb0001 := range (*z).TxnGroups {
				bts, err = (*z).TxnGroups[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "TxnGroups", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = txGroupsEncodingStubOld{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "t":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnGroups")
					return
				}
				if zb0006 > maxEncodedTransactionGroups {
					err = msgp.ErrOverflow(uint64(zb0006), uint64(maxEncodedTransactionGroups))
					err = msgp.WrapError(err, "TxnGroups")
					return
				}
				if zb0007 {
					(*z).TxnGroups = nil
				} else if (*z).TxnGroups != nil && cap((*z).TxnGroups) >= zb0006 {
					(*z).TxnGroups = ((*z).TxnGroups)[:zb0006]
				} else {
					(*z).TxnGroups = make([]txnGroups, zb0006)
				}
				for zb0001 := range (*z).TxnGroups {
					bts, err = (*z).TxnGroups[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "TxnGroups", zb0001)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *txGroupsEncodingStubOld) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*txGroupsEncodingStubOld)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *txGroupsEncodingStubOld) Msgsize() (s int) {
	s = 1 + 2 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).TxnGroups {
		s += (*z).TxnGroups[zb0001].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *txGroupsEncodingStubOld) MsgIsZero() bool {
	return (len((*z).TxnGroups) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *txnGroups) MarshalMsg(b []byte) []byte {
	return ((*(pooldata.SignedTxnSlice))(z)).MarshalMsg(b)
}
func (_ *txnGroups) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*txnGroups)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *txnGroups) UnmarshalMsg(bts []byte) ([]byte, error) {
	return ((*(pooldata.SignedTxnSlice))(z)).UnmarshalMsg(bts)
}
func (_ *txnGroups) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*txnGroups)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *txnGroups) Msgsize() int {
	return ((*(pooldata.SignedTxnSlice))(z)).Msgsize()
}

// MsgIsZero returns whether this is a zero value
func (z *txnGroups) MsgIsZero() bool {
	return ((*(pooldata.SignedTxnSlice))(z)).MsgIsZero()
}
