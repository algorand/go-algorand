package txnsync

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	"github.com/algorand/go-algorand/crypto"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/algorand/go-algorand/data/transactions"
	"github.com/algorand/msgp/msgp"
)

// The following msgp objects are implemented in this file:
// bitmask
//    |-----> MarshalMsg
//    |-----> CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> Msgsize
//    |-----> MsgIsZero
//
// encodedApplicationCallTxnFields
//                |-----> (*) MarshalMsg
//                |-----> (*) CanMarshalMsg
//                |-----> (*) UnmarshalMsg
//                |-----> (*) CanUnmarshalMsg
//                |-----> (*) Msgsize
//                |-----> (*) MsgIsZero
//
// encodedAssetConfigTxnFields
//              |-----> (*) MarshalMsg
//              |-----> (*) CanMarshalMsg
//              |-----> (*) UnmarshalMsg
//              |-----> (*) CanUnmarshalMsg
//              |-----> (*) Msgsize
//              |-----> (*) MsgIsZero
//
// encodedAssetFreezeTxnFields
//              |-----> (*) MarshalMsg
//              |-----> (*) CanMarshalMsg
//              |-----> (*) UnmarshalMsg
//              |-----> (*) CanUnmarshalMsg
//              |-----> (*) Msgsize
//              |-----> (*) MsgIsZero
//
// encodedAssetTransferTxnFields
//               |-----> (*) MarshalMsg
//               |-----> (*) CanMarshalMsg
//               |-----> (*) UnmarshalMsg
//               |-----> (*) CanUnmarshalMsg
//               |-----> (*) Msgsize
//               |-----> (*) MsgIsZero
//
// encodedBloomFilter
//          |-----> (*) MarshalMsg
//          |-----> (*) CanMarshalMsg
//          |-----> (*) UnmarshalMsg
//          |-----> (*) CanUnmarshalMsg
//          |-----> (*) Msgsize
//          |-----> (*) MsgIsZero
//
// encodedCompactCertTxnFields
//              |-----> (*) MarshalMsg
//              |-----> (*) CanMarshalMsg
//              |-----> (*) UnmarshalMsg
//              |-----> (*) CanUnmarshalMsg
//              |-----> (*) Msgsize
//              |-----> (*) MsgIsZero
//
// encodedKeyregTxnFields
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// encodedPaymentTxnFields
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// encodedSignedTxns
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//
// encodedTxnHeaders
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//
// encodedTxns
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//
// packedTransactionGroups
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// requestParams
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// timingParams
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// transactionBlockMessage
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// txGroupsEncodingStub
//           |-----> (*) MarshalMsg
//           |-----> (*) CanMarshalMsg
//           |-----> (*) UnmarshalMsg
//           |-----> (*) CanUnmarshalMsg
//           |-----> (*) Msgsize
//           |-----> (*) MsgIsZero
//
// txnGroups
//     |-----> MarshalMsg
//     |-----> CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> Msgsize
//     |-----> MsgIsZero
//

// MarshalMsg implements msgp.Marshaler
func (z bitmask) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, []byte(z))
	return
}

func (_ bitmask) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(bitmask)
	if !ok {
		_, ok = (z).(*bitmask)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *bitmask) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 []byte
		zb0001, bts, err = msgp.ReadBytesBytes(bts, []byte((*z)))
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = bitmask(zb0001)
	}
	o = bts
	return
}

func (_ *bitmask) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*bitmask)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z bitmask) Msgsize() (s int) {
	s = msgp.BytesPrefixSize + len([]byte(z))
	return
}

// MsgIsZero returns whether this is a zero value
func (z bitmask) MsgIsZero() bool {
	return len(z) == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedApplicationCallTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(0)
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
	}
	return
}

func (_ *encodedApplicationCallTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedApplicationCallTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedApplicationCallTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = encodedApplicationCallTxnFields{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedApplicationCallTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedApplicationCallTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedApplicationCallTxnFields) Msgsize() (s int) {
	s = 1
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedApplicationCallTxnFields) MsgIsZero() bool {
	return true
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedAssetConfigTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(0)
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
	}
	return
}

func (_ *encodedAssetConfigTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetConfigTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedAssetConfigTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = encodedAssetConfigTxnFields{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedAssetConfigTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetConfigTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedAssetConfigTxnFields) Msgsize() (s int) {
	s = 1
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedAssetConfigTxnFields) MsgIsZero() bool {
	return true
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedAssetFreezeTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(0)
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
	}
	return
}

func (_ *encodedAssetFreezeTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetFreezeTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedAssetFreezeTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = encodedAssetFreezeTxnFields{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedAssetFreezeTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetFreezeTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedAssetFreezeTxnFields) Msgsize() (s int) {
	s = 1
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedAssetFreezeTxnFields) MsgIsZero() bool {
	return true
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedAssetTransferTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(0)
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
	}
	return
}

func (_ *encodedAssetTransferTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetTransferTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedAssetTransferTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = encodedAssetTransferTxnFields{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedAssetTransferTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedAssetTransferTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedAssetTransferTxnFields) Msgsize() (s int) {
	s = 1
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedAssetTransferTxnFields) MsgIsZero() bool {
	return true
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedBloomFilter) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 5 bits */
	if len((*z).BloomFilter) == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if ((*z).EncodingParams.Offset == 0) && ((*z).EncodingParams.Modulator == 0) {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Shuffler == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).BloomFilterType == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "f"
			o = append(o, 0xa1, 0x66)
			o = msgp.AppendBytes(o, (*z).BloomFilter)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "p"
			o = append(o, 0xa1, 0x70)
			// omitempty: check for empty values
			zb0002Len := uint32(2)
			var zb0002Mask uint8 /* 3 bits */
			if (*z).EncodingParams.Modulator == 0 {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			if (*z).EncodingParams.Offset == 0 {
				zb0002Len--
				zb0002Mask |= 0x4
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x2) == 0 { // if not empty
				// string "m"
				o = append(o, 0xa1, 0x6d)
				o = msgp.AppendByte(o, (*z).EncodingParams.Modulator)
			}
			if (zb0002Mask & 0x4) == 0 { // if not empty
				// string "o"
				o = append(o, 0xa1, 0x6f)
				o = msgp.AppendByte(o, (*z).EncodingParams.Offset)
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "s"
			o = append(o, 0xa1, 0x73)
			o = msgp.AppendByte(o, (*z).Shuffler)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			o = msgp.AppendByte(o, (*z).BloomFilterType)
		}
	}
	return
}

func (_ *encodedBloomFilter) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedBloomFilter)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedBloomFilter) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).BloomFilterType, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BloomFilterType")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0003 int
			var zb0004 bool
			zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EncodingParams")
					return
				}
				if zb0003 > 0 {
					zb0003--
					(*z).EncodingParams.Offset, bts, err = msgp.ReadByteBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "struct-from-array", "Offset")
						return
					}
				}
				if zb0003 > 0 {
					zb0003--
					(*z).EncodingParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "struct-from-array", "Modulator")
						return
					}
				}
				if zb0003 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0003)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EncodingParams")
					return
				}
				if zb0004 {
					(*z).EncodingParams = requestParams{}
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "EncodingParams")
						return
					}
					switch string(field) {
					case "o":
						(*z).EncodingParams.Offset, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "Offset")
							return
						}
					case "m":
						(*z).EncodingParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "Modulator")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "EncodingParams")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Shuffler, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Shuffler")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0005 int
			zb0005, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BloomFilter")
				return
			}
			if zb0005 > maxBloomFilterSize {
				err = msgp.ErrOverflow(uint64(zb0005), uint64(maxBloomFilterSize))
				return
			}
			(*z).BloomFilter, bts, err = msgp.ReadBytesBytes(bts, (*z).BloomFilter)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BloomFilter")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = encodedBloomFilter{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "t":
				(*z).BloomFilterType, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BloomFilterType")
					return
				}
			case "p":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "EncodingParams")
						return
					}
					if zb0006 > 0 {
						zb0006--
						(*z).EncodingParams.Offset, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "EncodingParams", "struct-from-array", "Offset")
							return
						}
					}
					if zb0006 > 0 {
						zb0006--
						(*z).EncodingParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "EncodingParams", "struct-from-array", "Modulator")
							return
						}
					}
					if zb0006 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0006)
						if err != nil {
							err = msgp.WrapError(err, "EncodingParams", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "EncodingParams")
						return
					}
					if zb0007 {
						(*z).EncodingParams = requestParams{}
					}
					for zb0006 > 0 {
						zb0006--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "EncodingParams")
							return
						}
						switch string(field) {
						case "o":
							(*z).EncodingParams.Offset, bts, err = msgp.ReadByteBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "EncodingParams", "Offset")
								return
							}
						case "m":
							(*z).EncodingParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "EncodingParams", "Modulator")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "EncodingParams")
								return
							}
						}
					}
				}
			case "s":
				(*z).Shuffler, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Shuffler")
					return
				}
			case "f":
				var zb0008 int
				zb0008, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "BloomFilter")
					return
				}
				if zb0008 > maxBloomFilterSize {
					err = msgp.ErrOverflow(uint64(zb0008), uint64(maxBloomFilterSize))
					return
				}
				(*z).BloomFilter, bts, err = msgp.ReadBytesBytes(bts, (*z).BloomFilter)
				if err != nil {
					err = msgp.WrapError(err, "BloomFilter")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedBloomFilter) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedBloomFilter)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedBloomFilter) Msgsize() (s int) {
	s = 1 + 2 + msgp.ByteSize + 2 + 1 + 2 + msgp.ByteSize + 2 + msgp.ByteSize + 2 + msgp.ByteSize + 2 + msgp.BytesPrefixSize + len((*z).BloomFilter)
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedBloomFilter) MsgIsZero() bool {
	return ((*z).BloomFilterType == 0) && (((*z).EncodingParams.Offset == 0) && ((*z).EncodingParams.Modulator == 0)) && ((*z).Shuffler == 0) && (len((*z).BloomFilter) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedCompactCertTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(0)
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
	}
	return
}

func (_ *encodedCompactCertTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedCompactCertTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedCompactCertTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = encodedCompactCertTxnFields{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedCompactCertTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedCompactCertTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedCompactCertTxnFields) Msgsize() (s int) {
	s = 1
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedCompactCertTxnFields) MsgIsZero() bool {
	return true
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedKeyregTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0007Len := uint32(12)
	var zb0007Mask uint16 /* 13 bits */
	if len((*z).Nonparticipation) == 0 {
		zb0007Len--
		zb0007Mask |= 0x2
	}
	if len((*z).BitmaskNonparticipation) == 0 {
		zb0007Len--
		zb0007Mask |= 0x4
	}
	if len((*z).SelectionPK) == 0 {
		zb0007Len--
		zb0007Mask |= 0x8
	}
	if len((*z).BitmaskSelectionPK) == 0 {
		zb0007Len--
		zb0007Mask |= 0x10
	}
	if len((*z).VoteFirst) == 0 {
		zb0007Len--
		zb0007Mask |= 0x20
	}
	if len((*z).BitmaskVoteFirst) == 0 {
		zb0007Len--
		zb0007Mask |= 0x40
	}
	if len((*z).VoteKeyDilution) == 0 {
		zb0007Len--
		zb0007Mask |= 0x80
	}
	if len((*z).BitmaskVoteKeyDilution) == 0 {
		zb0007Len--
		zb0007Mask |= 0x100
	}
	if len((*z).VotePK) == 0 {
		zb0007Len--
		zb0007Mask |= 0x200
	}
	if len((*z).BitmaskVotePK) == 0 {
		zb0007Len--
		zb0007Mask |= 0x400
	}
	if len((*z).VoteLast) == 0 {
		zb0007Len--
		zb0007Mask |= 0x800
	}
	if len((*z).BitmaskVoteLast) == 0 {
		zb0007Len--
		zb0007Mask |= 0x1000
	}
	// variable map header, size zb0007Len
	o = append(o, 0x80|uint8(zb0007Len))
	if zb0007Len != 0 {
		if (zb0007Mask & 0x2) == 0 { // if not empty
			// string "nonpart"
			o = append(o, 0xa7, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74)
			if (*z).Nonparticipation == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Nonparticipation)))
			}
			for zb0006 := range (*z).Nonparticipation {
				o = msgp.AppendBool(o, (*z).Nonparticipation[zb0006])
			}
		}
		if (zb0007Mask & 0x4) == 0 { // if not empty
			// string "nonpartbm"
			o = append(o, 0xa9, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskNonparticipation))
		}
		if (zb0007Mask & 0x8) == 0 { // if not empty
			// string "selkey"
			o = append(o, 0xa6, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79)
			if (*z).SelectionPK == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).SelectionPK)))
			}
			for zb0002 := range (*z).SelectionPK {
				o = (*z).SelectionPK[zb0002].MarshalMsg(o)
			}
		}
		if (zb0007Mask & 0x10) == 0 { // if not empty
			// string "selkeybm"
			o = append(o, 0xa8, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskSelectionPK))
		}
		if (zb0007Mask & 0x20) == 0 { // if not empty
			// string "votefst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74)
			if (*z).VoteFirst == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).VoteFirst)))
			}
			for zb0003 := range (*z).VoteFirst {
				o = (*z).VoteFirst[zb0003].MarshalMsg(o)
			}
		}
		if (zb0007Mask & 0x40) == 0 { // if not empty
			// string "votefstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskVoteFirst))
		}
		if (zb0007Mask & 0x80) == 0 { // if not empty
			// string "votekd"
			o = append(o, 0xa6, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64)
			if (*z).VoteKeyDilution == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).VoteKeyDilution)))
			}
			for zb0005 := range (*z).VoteKeyDilution {
				o = msgp.AppendUint64(o, (*z).VoteKeyDilution[zb0005])
			}
		}
		if (zb0007Mask & 0x100) == 0 { // if not empty
			// string "votekdbm"
			o = append(o, 0xa8, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskVoteKeyDilution))
		}
		if (zb0007Mask & 0x200) == 0 { // if not empty
			// string "votekey"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79)
			if (*z).VotePK == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).VotePK)))
			}
			for zb0001 := range (*z).VotePK {
				o = (*z).VotePK[zb0001].MarshalMsg(o)
			}
		}
		if (zb0007Mask & 0x400) == 0 { // if not empty
			// string "votekeybm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskVotePK))
		}
		if (zb0007Mask & 0x800) == 0 { // if not empty
			// string "votelst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74)
			if (*z).VoteLast == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).VoteLast)))
			}
			for zb0004 := range (*z).VoteLast {
				o = (*z).VoteLast[zb0004].MarshalMsg(o)
			}
		}
		if (zb0007Mask & 0x1000) == 0 { // if not empty
			// string "votelstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskVoteLast))
		}
	}
	return
}

func (_ *encodedKeyregTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedKeyregTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedKeyregTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0007 int
	var zb0008 bool
	zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0007 > 0 {
			zb0007--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
			if zb0009 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
			if zb0010 {
				(*z).VotePK = nil
			} else if (*z).VotePK != nil && cap((*z).VotePK) >= zb0009 {
				(*z).VotePK = ((*z).VotePK)[:zb0009]
			} else {
				(*z).VotePK = make([]crypto.OneTimeSignatureVerifier, zb0009)
			}
			for zb0001 := range (*z).VotePK {
				bts, err = (*z).VotePK[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VotePK", zb0001)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0011 []byte
				zb0011, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVotePK))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVotePK")
					return
				}
				(*z).BitmaskVotePK = bitmask(zb0011)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0012 int
			var zb0013 bool
			zb0012, zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
			if zb0012 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0012), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
			if zb0013 {
				(*z).SelectionPK = nil
			} else if (*z).SelectionPK != nil && cap((*z).SelectionPK) >= zb0012 {
				(*z).SelectionPK = ((*z).SelectionPK)[:zb0012]
			} else {
				(*z).SelectionPK = make([]crypto.VRFVerifier, zb0012)
			}
			for zb0002 := range (*z).SelectionPK {
				bts, err = (*z).SelectionPK[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SelectionPK", zb0002)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0014 []byte
				zb0014, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSelectionPK))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSelectionPK")
					return
				}
				(*z).BitmaskSelectionPK = bitmask(zb0014)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0015 int
			var zb0016 bool
			zb0015, zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0015 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0015), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0016 {
				(*z).VoteFirst = nil
			} else if (*z).VoteFirst != nil && cap((*z).VoteFirst) >= zb0015 {
				(*z).VoteFirst = ((*z).VoteFirst)[:zb0015]
			} else {
				(*z).VoteFirst = make([]basics.Round, zb0015)
			}
			for zb0003 := range (*z).VoteFirst {
				bts, err = (*z).VoteFirst[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteFirst", zb0003)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0017 []byte
				zb0017, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVoteFirst))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteFirst")
					return
				}
				(*z).BitmaskVoteFirst = bitmask(zb0017)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0018 int
			var zb0019 bool
			zb0018, zb0019, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0018 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0018), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0019 {
				(*z).VoteLast = nil
			} else if (*z).VoteLast != nil && cap((*z).VoteLast) >= zb0018 {
				(*z).VoteLast = ((*z).VoteLast)[:zb0018]
			} else {
				(*z).VoteLast = make([]basics.Round, zb0018)
			}
			for zb0004 := range (*z).VoteLast {
				bts, err = (*z).VoteLast[zb0004].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteLast", zb0004)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0020 []byte
				zb0020, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVoteLast))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteLast")
					return
				}
				(*z).BitmaskVoteLast = bitmask(zb0020)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0021 int
			var zb0022 bool
			zb0021, zb0022, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0021 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0021), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0022 {
				(*z).VoteKeyDilution = nil
			} else if (*z).VoteKeyDilution != nil && cap((*z).VoteKeyDilution) >= zb0021 {
				(*z).VoteKeyDilution = ((*z).VoteKeyDilution)[:zb0021]
			} else {
				(*z).VoteKeyDilution = make([]uint64, zb0021)
			}
			for zb0005 := range (*z).VoteKeyDilution {
				(*z).VoteKeyDilution[zb0005], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution", zb0005)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0023 []byte
				zb0023, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVoteKeyDilution))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteKeyDilution")
					return
				}
				(*z).BitmaskVoteKeyDilution = bitmask(zb0023)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0024 int
			var zb0025 bool
			zb0024, zb0025, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Nonparticipation")
				return
			}
			if zb0024 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0024), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Nonparticipation")
				return
			}
			if zb0025 {
				(*z).Nonparticipation = nil
			} else if (*z).Nonparticipation != nil && cap((*z).Nonparticipation) >= zb0024 {
				(*z).Nonparticipation = ((*z).Nonparticipation)[:zb0024]
			} else {
				(*z).Nonparticipation = make([]bool, zb0024)
			}
			for zb0006 := range (*z).Nonparticipation {
				(*z).Nonparticipation[zb0006], bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Nonparticipation", zb0006)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0026 []byte
				zb0026, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskNonparticipation))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNonparticipation")
					return
				}
				(*z).BitmaskNonparticipation = bitmask(zb0026)
			}
		}
		if zb0007 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0007)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0008 {
			(*z) = encodedKeyregTxnFields{}
		}
		for zb0007 > 0 {
			zb0007--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "votekey":
				var zb0027 int
				var zb0028 bool
				zb0027, zb0028, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
				if zb0027 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0027), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VotePK")
					return
				}
				if zb0028 {
					(*z).VotePK = nil
				} else if (*z).VotePK != nil && cap((*z).VotePK) >= zb0027 {
					(*z).VotePK = ((*z).VotePK)[:zb0027]
				} else {
					(*z).VotePK = make([]crypto.OneTimeSignatureVerifier, zb0027)
				}
				for zb0001 := range (*z).VotePK {
					bts, err = (*z).VotePK[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VotePK", zb0001)
						return
					}
				}
			case "votekeybm":
				{
					var zb0029 []byte
					zb0029, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVotePK))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVotePK")
						return
					}
					(*z).BitmaskVotePK = bitmask(zb0029)
				}
			case "selkey":
				var zb0030 int
				var zb0031 bool
				zb0030, zb0031, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
				if zb0030 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0030), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
				if zb0031 {
					(*z).SelectionPK = nil
				} else if (*z).SelectionPK != nil && cap((*z).SelectionPK) >= zb0030 {
					(*z).SelectionPK = ((*z).SelectionPK)[:zb0030]
				} else {
					(*z).SelectionPK = make([]crypto.VRFVerifier, zb0030)
				}
				for zb0002 := range (*z).SelectionPK {
					bts, err = (*z).SelectionPK[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "SelectionPK", zb0002)
						return
					}
				}
			case "selkeybm":
				{
					var zb0032 []byte
					zb0032, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSelectionPK))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSelectionPK")
						return
					}
					(*z).BitmaskSelectionPK = bitmask(zb0032)
				}
			case "votefst":
				var zb0033 int
				var zb0034 bool
				zb0033, zb0034, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0033 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0033), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0034 {
					(*z).VoteFirst = nil
				} else if (*z).VoteFirst != nil && cap((*z).VoteFirst) >= zb0033 {
					(*z).VoteFirst = ((*z).VoteFirst)[:zb0033]
				} else {
					(*z).VoteFirst = make([]basics.Round, zb0033)
				}
				for zb0003 := range (*z).VoteFirst {
					bts, err = (*z).VoteFirst[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteFirst", zb0003)
						return
					}
				}
			case "votefstbm":
				{
					var zb0035 []byte
					zb0035, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVoteFirst))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteFirst")
						return
					}
					(*z).BitmaskVoteFirst = bitmask(zb0035)
				}
			case "votelst":
				var zb0036 int
				var zb0037 bool
				zb0036, zb0037, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0036 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0036), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0037 {
					(*z).VoteLast = nil
				} else if (*z).VoteLast != nil && cap((*z).VoteLast) >= zb0036 {
					(*z).VoteLast = ((*z).VoteLast)[:zb0036]
				} else {
					(*z).VoteLast = make([]basics.Round, zb0036)
				}
				for zb0004 := range (*z).VoteLast {
					bts, err = (*z).VoteLast[zb0004].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteLast", zb0004)
						return
					}
				}
			case "votelstbm":
				{
					var zb0038 []byte
					zb0038, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVoteLast))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteLast")
						return
					}
					(*z).BitmaskVoteLast = bitmask(zb0038)
				}
			case "votekd":
				var zb0039 int
				var zb0040 bool
				zb0039, zb0040, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0039 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0039), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0040 {
					(*z).VoteKeyDilution = nil
				} else if (*z).VoteKeyDilution != nil && cap((*z).VoteKeyDilution) >= zb0039 {
					(*z).VoteKeyDilution = ((*z).VoteKeyDilution)[:zb0039]
				} else {
					(*z).VoteKeyDilution = make([]uint64, zb0039)
				}
				for zb0005 := range (*z).VoteKeyDilution {
					(*z).VoteKeyDilution[zb0005], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteKeyDilution", zb0005)
						return
					}
				}
			case "votekdbm":
				{
					var zb0041 []byte
					zb0041, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskVoteKeyDilution))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteKeyDilution")
						return
					}
					(*z).BitmaskVoteKeyDilution = bitmask(zb0041)
				}
			case "nonpart":
				var zb0042 int
				var zb0043 bool
				zb0042, zb0043, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Nonparticipation")
					return
				}
				if zb0042 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0042), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Nonparticipation")
					return
				}
				if zb0043 {
					(*z).Nonparticipation = nil
				} else if (*z).Nonparticipation != nil && cap((*z).Nonparticipation) >= zb0042 {
					(*z).Nonparticipation = ((*z).Nonparticipation)[:zb0042]
				} else {
					(*z).Nonparticipation = make([]bool, zb0042)
				}
				for zb0006 := range (*z).Nonparticipation {
					(*z).Nonparticipation[zb0006], bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Nonparticipation", zb0006)
						return
					}
				}
			case "nonpartbm":
				{
					var zb0044 []byte
					zb0044, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskNonparticipation))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNonparticipation")
						return
					}
					(*z).BitmaskNonparticipation = bitmask(zb0044)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedKeyregTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedKeyregTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedKeyregTxnFields) Msgsize() (s int) {
	s = 1 + 8 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).VotePK {
		s += (*z).VotePK[zb0001].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskVotePK)) + 7 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).SelectionPK {
		s += (*z).SelectionPK[zb0002].Msgsize()
	}
	s += 9 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskSelectionPK)) + 8 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).VoteFirst {
		s += (*z).VoteFirst[zb0003].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskVoteFirst)) + 8 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).VoteLast {
		s += (*z).VoteLast[zb0004].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskVoteLast)) + 7 + msgp.ArrayHeaderSize + (len((*z).VoteKeyDilution) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskVoteKeyDilution)) + 8 + msgp.ArrayHeaderSize + (len((*z).Nonparticipation) * (msgp.BoolSize)) + 10 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskNonparticipation))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedKeyregTxnFields) MsgIsZero() bool {
	return (len((*z).VotePK) == 0) && (len((*z).BitmaskVotePK) == 0) && (len((*z).SelectionPK) == 0) && (len((*z).BitmaskSelectionPK) == 0) && (len((*z).VoteFirst) == 0) && (len((*z).BitmaskVoteFirst) == 0) && (len((*z).VoteLast) == 0) && (len((*z).BitmaskVoteLast) == 0) && (len((*z).VoteKeyDilution) == 0) && (len((*z).BitmaskVoteKeyDilution) == 0) && (len((*z).Nonparticipation) == 0) && (len((*z).BitmaskNonparticipation) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedPaymentTxnFields) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0004Len := uint32(6)
	var zb0004Mask uint8 /* 7 bits */
	if len((*z).Amount) == 0 {
		zb0004Len--
		zb0004Mask |= 0x2
	}
	if len((*z).BitmaskAmount) == 0 {
		zb0004Len--
		zb0004Mask |= 0x4
	}
	if len((*z).CloseRemainderTo) == 0 {
		zb0004Len--
		zb0004Mask |= 0x8
	}
	if len((*z).BitmaskCloseRemainderTo) == 0 {
		zb0004Len--
		zb0004Mask |= 0x10
	}
	if len((*z).Receiver) == 0 {
		zb0004Len--
		zb0004Mask |= 0x20
	}
	if len((*z).BitmaskReceiver) == 0 {
		zb0004Len--
		zb0004Mask |= 0x40
	}
	// variable map header, size zb0004Len
	o = append(o, 0x80|uint8(zb0004Len))
	if zb0004Len != 0 {
		if (zb0004Mask & 0x2) == 0 { // if not empty
			// string "amt"
			o = append(o, 0xa3, 0x61, 0x6d, 0x74)
			if (*z).Amount == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Amount)))
			}
			for zb0002 := range (*z).Amount {
				o = (*z).Amount[zb0002].MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x4) == 0 { // if not empty
			// string "amtbm"
			o = append(o, 0xa5, 0x61, 0x6d, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskAmount))
		}
		if (zb0004Mask & 0x8) == 0 { // if not empty
			// string "close"
			o = append(o, 0xa5, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			if (*z).CloseRemainderTo == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).CloseRemainderTo)))
			}
			for zb0003 := range (*z).CloseRemainderTo {
				o = (*z).CloseRemainderTo[zb0003].MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x10) == 0 { // if not empty
			// string "closebm"
			o = append(o, 0xa7, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskCloseRemainderTo))
		}
		if (zb0004Mask & 0x20) == 0 { // if not empty
			// string "rcv"
			o = append(o, 0xa3, 0x72, 0x63, 0x76)
			if (*z).Receiver == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Receiver)))
			}
			for zb0001 := range (*z).Receiver {
				o = (*z).Receiver[zb0001].MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x40) == 0 { // if not empty
			// string "rcvbm"
			o = append(o, 0xa5, 0x72, 0x63, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskReceiver))
		}
	}
	return
}

func (_ *encodedPaymentTxnFields) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedPaymentTxnFields)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedPaymentTxnFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0004 int
	var zb0005 bool
	zb0004, zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 > 0 {
			zb0004--
			var zb0006 int
			var zb0007 bool
			zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
			if zb0006 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0006), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
			if zb0007 {
				(*z).Receiver = nil
			} else if (*z).Receiver != nil && cap((*z).Receiver) >= zb0006 {
				(*z).Receiver = ((*z).Receiver)[:zb0006]
			} else {
				(*z).Receiver = make([]basics.Address, zb0006)
			}
			for zb0001 := range (*z).Receiver {
				bts, err = (*z).Receiver[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Receiver", zb0001)
					return
				}
			}
		}
		if zb0004 > 0 {
			zb0004--
			{
				var zb0008 []byte
				zb0008, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskReceiver))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReceiver")
					return
				}
				(*z).BitmaskReceiver = bitmask(zb0008)
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0009 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0010 {
				(*z).Amount = nil
			} else if (*z).Amount != nil && cap((*z).Amount) >= zb0009 {
				(*z).Amount = ((*z).Amount)[:zb0009]
			} else {
				(*z).Amount = make([]basics.MicroAlgos, zb0009)
			}
			for zb0002 := range (*z).Amount {
				bts, err = (*z).Amount[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Amount", zb0002)
					return
				}
			}
		}
		if zb0004 > 0 {
			zb0004--
			{
				var zb0011 []byte
				zb0011, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAmount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAmount")
					return
				}
				(*z).BitmaskAmount = bitmask(zb0011)
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0012 int
			var zb0013 bool
			zb0012, zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
			if zb0012 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0012), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
			if zb0013 {
				(*z).CloseRemainderTo = nil
			} else if (*z).CloseRemainderTo != nil && cap((*z).CloseRemainderTo) >= zb0012 {
				(*z).CloseRemainderTo = ((*z).CloseRemainderTo)[:zb0012]
			} else {
				(*z).CloseRemainderTo = make([]basics.Address, zb0012)
			}
			for zb0003 := range (*z).CloseRemainderTo {
				bts, err = (*z).CloseRemainderTo[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo", zb0003)
					return
				}
			}
		}
		if zb0004 > 0 {
			zb0004--
			{
				var zb0014 []byte
				zb0014, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskCloseRemainderTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCloseRemainderTo")
					return
				}
				(*z).BitmaskCloseRemainderTo = bitmask(zb0014)
			}
		}
		if zb0004 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0004)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0005 {
			(*z) = encodedPaymentTxnFields{}
		}
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rcv":
				var zb0015 int
				var zb0016 bool
				zb0015, zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
				if zb0015 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0015), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Receiver")
					return
				}
				if zb0016 {
					(*z).Receiver = nil
				} else if (*z).Receiver != nil && cap((*z).Receiver) >= zb0015 {
					(*z).Receiver = ((*z).Receiver)[:zb0015]
				} else {
					(*z).Receiver = make([]basics.Address, zb0015)
				}
				for zb0001 := range (*z).Receiver {
					bts, err = (*z).Receiver[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Receiver", zb0001)
						return
					}
				}
			case "rcvbm":
				{
					var zb0017 []byte
					zb0017, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskReceiver))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReceiver")
						return
					}
					(*z).BitmaskReceiver = bitmask(zb0017)
				}
			case "amt":
				var zb0018 int
				var zb0019 bool
				zb0018, zb0019, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0018 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0018), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0019 {
					(*z).Amount = nil
				} else if (*z).Amount != nil && cap((*z).Amount) >= zb0018 {
					(*z).Amount = ((*z).Amount)[:zb0018]
				} else {
					(*z).Amount = make([]basics.MicroAlgos, zb0018)
				}
				for zb0002 := range (*z).Amount {
					bts, err = (*z).Amount[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Amount", zb0002)
						return
					}
				}
			case "amtbm":
				{
					var zb0020 []byte
					zb0020, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAmount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAmount")
						return
					}
					(*z).BitmaskAmount = bitmask(zb0020)
				}
			case "close":
				var zb0021 int
				var zb0022 bool
				zb0021, zb0022, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
				if zb0021 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0021), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
				if zb0022 {
					(*z).CloseRemainderTo = nil
				} else if (*z).CloseRemainderTo != nil && cap((*z).CloseRemainderTo) >= zb0021 {
					(*z).CloseRemainderTo = ((*z).CloseRemainderTo)[:zb0021]
				} else {
					(*z).CloseRemainderTo = make([]basics.Address, zb0021)
				}
				for zb0003 := range (*z).CloseRemainderTo {
					bts, err = (*z).CloseRemainderTo[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CloseRemainderTo", zb0003)
						return
					}
				}
			case "closebm":
				{
					var zb0023 []byte
					zb0023, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskCloseRemainderTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCloseRemainderTo")
						return
					}
					(*z).BitmaskCloseRemainderTo = bitmask(zb0023)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedPaymentTxnFields) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedPaymentTxnFields)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedPaymentTxnFields) Msgsize() (s int) {
	s = 1 + 4 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Receiver {
		s += (*z).Receiver[zb0001].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskReceiver)) + 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Amount {
		s += (*z).Amount[zb0002].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskAmount)) + 6 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).CloseRemainderTo {
		s += (*z).CloseRemainderTo[zb0003].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskCloseRemainderTo))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedPaymentTxnFields) MsgIsZero() bool {
	return (len((*z).Receiver) == 0) && (len((*z).BitmaskReceiver) == 0) && (len((*z).Amount) == 0) && (len((*z).BitmaskAmount) == 0) && (len((*z).CloseRemainderTo) == 0) && (len((*z).BitmaskCloseRemainderTo) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedSignedTxns) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0022Len := uint32(46)
	var zb0022Mask uint64 /* 56 bits */
	if len((*z).encodedTxns.encodedPaymentTxnFields.Amount) == 0 {
		zb0022Len--
		zb0022Mask |= 0x400
	}
	if len((*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount) == 0 {
		zb0022Len--
		zb0022Mask |= 0x800
	}
	if len((*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) == 0 {
		zb0022Len--
		zb0022Mask |= 0x1000
	}
	if len((*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo) == 0 {
		zb0022Len--
		zb0022Mask |= 0x2000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.Fee) == 0 {
		zb0022Len--
		zb0022Mask |= 0x4000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskFee) == 0 {
		zb0022Len--
		zb0022Mask |= 0x8000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.FirstValid) == 0 {
		zb0022Len--
		zb0022Mask |= 0x10000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid) == 0 {
		zb0022Len--
		zb0022Mask |= 0x20000
	}
	if (*z).encodedTxns.encodedTxnHeaders.GenesisID == "" {
		zb0022Len--
		zb0022Mask |= 0x40000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID) == 0 {
		zb0022Len--
		zb0022Mask |= 0x80000
	}
	if (*z).encodedTxns.encodedTxnHeaders.GenesisHash.MsgIsZero() {
		zb0022Len--
		zb0022Mask |= 0x100000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisHash) == 0 {
		zb0022Len--
		zb0022Mask |= 0x200000
	}
	if len((*z).Lsig) == 0 {
		zb0022Len--
		zb0022Mask |= 0x400000
	}
	if len((*z).BitmaskLsig) == 0 {
		zb0022Len--
		zb0022Mask |= 0x800000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.LastValid) == 0 {
		zb0022Len--
		zb0022Mask |= 0x1000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid) == 0 {
		zb0022Len--
		zb0022Mask |= 0x2000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.Lease) == 0 {
		zb0022Len--
		zb0022Mask |= 0x4000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskLease) == 0 {
		zb0022Len--
		zb0022Mask |= 0x8000000
	}
	if len((*z).Msig) == 0 {
		zb0022Len--
		zb0022Mask |= 0x10000000
	}
	if len((*z).BitmaskMsig) == 0 {
		zb0022Len--
		zb0022Mask |= 0x20000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation) == 0 {
		zb0022Len--
		zb0022Mask |= 0x40000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation) == 0 {
		zb0022Len--
		zb0022Mask |= 0x80000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.Note) == 0 {
		zb0022Len--
		zb0022Mask |= 0x100000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskNote) == 0 {
		zb0022Len--
		zb0022Mask |= 0x200000000
	}
	if len((*z).encodedTxns.encodedPaymentTxnFields.Receiver) == 0 {
		zb0022Len--
		zb0022Mask |= 0x400000000
	}
	if len((*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver) == 0 {
		zb0022Len--
		zb0022Mask |= 0x800000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.RekeyTo) == 0 {
		zb0022Len--
		zb0022Mask |= 0x1000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo) == 0 {
		zb0022Len--
		zb0022Mask |= 0x2000000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.SelectionPK) == 0 {
		zb0022Len--
		zb0022Mask |= 0x4000000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK) == 0 {
		zb0022Len--
		zb0022Mask |= 0x8000000000
	}
	if len((*z).AuthAddr) == 0 {
		zb0022Len--
		zb0022Mask |= 0x10000000000
	}
	if len((*z).BitmaskAuthAddr) == 0 {
		zb0022Len--
		zb0022Mask |= 0x20000000000
	}
	if len((*z).Sig) == 0 {
		zb0022Len--
		zb0022Mask |= 0x40000000000
	}
	if len((*z).BitmaskSig) == 0 {
		zb0022Len--
		zb0022Mask |= 0x80000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.Sender) == 0 {
		zb0022Len--
		zb0022Mask |= 0x100000000000
	}
	if len((*z).encodedTxns.encodedTxnHeaders.BitmaskSender) == 0 {
		zb0022Len--
		zb0022Mask |= 0x200000000000
	}
	if len((*z).encodedTxns.TxType) == 0 {
		zb0022Len--
		zb0022Mask |= 0x400000000000
	}
	if len((*z).encodedTxns.BitmaskTxType) == 0 {
		zb0022Len--
		zb0022Mask |= 0x800000000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst) == 0 {
		zb0022Len--
		zb0022Mask |= 0x1000000000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst) == 0 {
		zb0022Len--
		zb0022Mask |= 0x2000000000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) == 0 {
		zb0022Len--
		zb0022Mask |= 0x4000000000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution) == 0 {
		zb0022Len--
		zb0022Mask |= 0x8000000000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.VotePK) == 0 {
		zb0022Len--
		zb0022Mask |= 0x10000000000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVotePK) == 0 {
		zb0022Len--
		zb0022Mask |= 0x20000000000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.VoteLast) == 0 {
		zb0022Len--
		zb0022Mask |= 0x40000000000000
	}
	if len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast) == 0 {
		zb0022Len--
		zb0022Mask |= 0x80000000000000
	}
	// variable map header, size zb0022Len
	o = msgp.AppendMapHeader(o, zb0022Len)
	if zb0022Len != 0 {
		if (zb0022Mask & 0x400) == 0 { // if not empty
			// string "amt"
			o = append(o, 0xa3, 0x61, 0x6d, 0x74)
			if (*z).encodedTxns.encodedPaymentTxnFields.Amount == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedPaymentTxnFields.Amount)))
			}
			for zb0020 := range (*z).encodedTxns.encodedPaymentTxnFields.Amount {
				o = (*z).encodedTxns.encodedPaymentTxnFields.Amount[zb0020].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x800) == 0 { // if not empty
			// string "amtbm"
			o = append(o, 0xa5, 0x61, 0x6d, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount))
		}
		if (zb0022Mask & 0x1000) == 0 { // if not empty
			// string "close"
			o = append(o, 0xa5, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			if (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo)))
			}
			for zb0021 := range (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo {
				o = (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo[zb0021].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x2000) == 0 { // if not empty
			// string "closebm"
			o = append(o, 0xa7, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
		}
		if (zb0022Mask & 0x4000) == 0 { // if not empty
			// string "fee"
			o = append(o, 0xa3, 0x66, 0x65, 0x65)
			if (*z).encodedTxns.encodedTxnHeaders.Fee == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedTxnHeaders.Fee)))
			}
			for zb0006 := range (*z).encodedTxns.encodedTxnHeaders.Fee {
				o = (*z).encodedTxns.encodedTxnHeaders.Fee[zb0006].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x8000) == 0 { // if not empty
			// string "feebm"
			o = append(o, 0xa5, 0x66, 0x65, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFee))
		}
		if (zb0022Mask & 0x10000) == 0 { // if not empty
			// string "fv"
			o = append(o, 0xa2, 0x66, 0x76)
			if (*z).encodedTxns.encodedTxnHeaders.FirstValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedTxnHeaders.FirstValid)))
			}
			for zb0007 := range (*z).encodedTxns.encodedTxnHeaders.FirstValid {
				o = (*z).encodedTxns.encodedTxnHeaders.FirstValid[zb0007].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x20000) == 0 { // if not empty
			// string "fvbm"
			o = append(o, 0xa4, 0x66, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid))
		}
		if (zb0022Mask & 0x40000) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).encodedTxns.encodedTxnHeaders.GenesisID)
		}
		if (zb0022Mask & 0x80000) == 0 { // if not empty
			// string "genbm"
			o = append(o, 0xa5, 0x67, 0x65, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID))
		}
		if (zb0022Mask & 0x100000) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o = (*z).encodedTxns.encodedTxnHeaders.GenesisHash.MarshalMsg(o)
		}
		if (zb0022Mask & 0x200000) == 0 { // if not empty
			// string "ghbm"
			o = append(o, 0xa4, 0x67, 0x68, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisHash))
		}
		if (zb0022Mask & 0x400000) == 0 { // if not empty
			// string "lsig"
			o = append(o, 0xa4, 0x6c, 0x73, 0x69, 0x67)
			if (*z).Lsig == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Lsig)))
			}
			for zb0003 := range (*z).Lsig {
				o = (*z).Lsig[zb0003].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x800000) == 0 { // if not empty
			// string "lsigbm"
			o = append(o, 0xa6, 0x6c, 0x73, 0x69, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskLsig))
		}
		if (zb0022Mask & 0x1000000) == 0 { // if not empty
			// string "lv"
			o = append(o, 0xa2, 0x6c, 0x76)
			if (*z).encodedTxns.encodedTxnHeaders.LastValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedTxnHeaders.LastValid)))
			}
			for zb0008 := range (*z).encodedTxns.encodedTxnHeaders.LastValid {
				o = (*z).encodedTxns.encodedTxnHeaders.LastValid[zb0008].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x2000000) == 0 { // if not empty
			// string "lvbm"
			o = append(o, 0xa4, 0x6c, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid))
		}
		if (zb0022Mask & 0x4000000) == 0 { // if not empty
			// string "lx"
			o = append(o, 0xa2, 0x6c, 0x78)
			if (*z).encodedTxns.encodedTxnHeaders.Lease == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedTxnHeaders.Lease)))
			}
			for zb0010 := range (*z).encodedTxns.encodedTxnHeaders.Lease {
				o = msgp.AppendBytes(o, ((*z).encodedTxns.encodedTxnHeaders.Lease[zb0010])[:])
			}
		}
		if (zb0022Mask & 0x8000000) == 0 { // if not empty
			// string "lxbm"
			o = append(o, 0xa4, 0x6c, 0x78, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLease))
		}
		if (zb0022Mask & 0x10000000) == 0 { // if not empty
			// string "msig"
			o = append(o, 0xa4, 0x6d, 0x73, 0x69, 0x67)
			if (*z).Msig == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Msig)))
			}
			for zb0002 := range (*z).Msig {
				o = (*z).Msig[zb0002].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x20000000) == 0 { // if not empty
			// string "msigbm"
			o = append(o, 0xa6, 0x6d, 0x73, 0x69, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskMsig))
		}
		if (zb0022Mask & 0x40000000) == 0 { // if not empty
			// string "nonpart"
			o = append(o, 0xa7, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74)
			if (*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation)))
			}
			for zb0018 := range (*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation {
				o = msgp.AppendBool(o, (*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation[zb0018])
			}
		}
		if (zb0022Mask & 0x80000000) == 0 { // if not empty
			// string "nonpartbm"
			o = append(o, 0xa9, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation))
		}
		if (zb0022Mask & 0x100000000) == 0 { // if not empty
			// string "note"
			o = append(o, 0xa4, 0x6e, 0x6f, 0x74, 0x65)
			if (*z).encodedTxns.encodedTxnHeaders.Note == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedTxnHeaders.Note)))
			}
			for zb0009 := range (*z).encodedTxns.encodedTxnHeaders.Note {
				o = msgp.AppendBytes(o, (*z).encodedTxns.encodedTxnHeaders.Note[zb0009])
			}
		}
		if (zb0022Mask & 0x200000000) == 0 { // if not empty
			// string "notebm"
			o = append(o, 0xa6, 0x6e, 0x6f, 0x74, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskNote))
		}
		if (zb0022Mask & 0x400000000) == 0 { // if not empty
			// string "rcv"
			o = append(o, 0xa3, 0x72, 0x63, 0x76)
			if (*z).encodedTxns.encodedPaymentTxnFields.Receiver == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedPaymentTxnFields.Receiver)))
			}
			for zb0019 := range (*z).encodedTxns.encodedPaymentTxnFields.Receiver {
				o = (*z).encodedTxns.encodedPaymentTxnFields.Receiver[zb0019].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x800000000) == 0 { // if not empty
			// string "rcvbm"
			o = append(o, 0xa5, 0x72, 0x63, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver))
		}
		if (zb0022Mask & 0x1000000000) == 0 { // if not empty
			// string "rekey"
			o = append(o, 0xa5, 0x72, 0x65, 0x6b, 0x65, 0x79)
			if (*z).encodedTxns.encodedTxnHeaders.RekeyTo == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedTxnHeaders.RekeyTo)))
			}
			for zb0012 := range (*z).encodedTxns.encodedTxnHeaders.RekeyTo {
				o = (*z).encodedTxns.encodedTxnHeaders.RekeyTo[zb0012].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x2000000000) == 0 { // if not empty
			// string "rekeybm"
			o = append(o, 0xa7, 0x72, 0x65, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo))
		}
		if (zb0022Mask & 0x4000000000) == 0 { // if not empty
			// string "selkey"
			o = append(o, 0xa6, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79)
			if (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedKeyregTxnFields.SelectionPK)))
			}
			for zb0014 := range (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK {
				o = (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK[zb0014].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x8000000000) == 0 { // if not empty
			// string "selkeybm"
			o = append(o, 0xa8, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK))
		}
		if (zb0022Mask & 0x10000000000) == 0 { // if not empty
			// string "sgnr"
			o = append(o, 0xa4, 0x73, 0x67, 0x6e, 0x72)
			if (*z).AuthAddr == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).AuthAddr)))
			}
			for zb0004 := range (*z).AuthAddr {
				o = (*z).AuthAddr[zb0004].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x20000000000) == 0 { // if not empty
			// string "sgnrbm"
			o = append(o, 0xa6, 0x73, 0x67, 0x6e, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskAuthAddr))
		}
		if (zb0022Mask & 0x40000000000) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			if (*z).Sig == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Sig)))
			}
			for zb0001 := range (*z).Sig {
				o = (*z).Sig[zb0001].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x80000000000) == 0 { // if not empty
			// string "sigbm"
			o = append(o, 0xa5, 0x73, 0x69, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskSig))
		}
		if (zb0022Mask & 0x100000000000) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			if (*z).encodedTxns.encodedTxnHeaders.Sender == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedTxnHeaders.Sender)))
			}
			for zb0005 := range (*z).encodedTxns.encodedTxnHeaders.Sender {
				o = (*z).encodedTxns.encodedTxnHeaders.Sender[zb0005].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x200000000000) == 0 { // if not empty
			// string "sndbm"
			o = append(o, 0xa5, 0x73, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskSender))
		}
		if (zb0022Mask & 0x400000000000) == 0 { // if not empty
			// string "type"
			o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
			o = msgp.AppendBytes(o, (*z).encodedTxns.TxType)
		}
		if (zb0022Mask & 0x800000000000) == 0 { // if not empty
			// string "typebm"
			o = append(o, 0xa6, 0x74, 0x79, 0x70, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.BitmaskTxType))
		}
		if (zb0022Mask & 0x1000000000000) == 0 { // if not empty
			// string "votefst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74)
			if (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst)))
			}
			for zb0015 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst {
				o = (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0015].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x2000000000000) == 0 { // if not empty
			// string "votefstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst))
		}
		if (zb0022Mask & 0x4000000000000) == 0 { // if not empty
			// string "votekd"
			o = append(o, 0xa6, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64)
			if (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution)))
			}
			for zb0017 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution {
				o = msgp.AppendUint64(o, (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution[zb0017])
			}
		}
		if (zb0022Mask & 0x8000000000000) == 0 { // if not empty
			// string "votekdbm"
			o = append(o, 0xa8, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution))
		}
		if (zb0022Mask & 0x10000000000000) == 0 { // if not empty
			// string "votekey"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79)
			if (*z).encodedTxns.encodedKeyregTxnFields.VotePK == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedKeyregTxnFields.VotePK)))
			}
			for zb0013 := range (*z).encodedTxns.encodedKeyregTxnFields.VotePK {
				o = (*z).encodedTxns.encodedKeyregTxnFields.VotePK[zb0013].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x20000000000000) == 0 { // if not empty
			// string "votekeybm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVotePK))
		}
		if (zb0022Mask & 0x40000000000000) == 0 { // if not empty
			// string "votelst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74)
			if (*z).encodedTxns.encodedKeyregTxnFields.VoteLast == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.encodedKeyregTxnFields.VoteLast)))
			}
			for zb0016 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteLast {
				o = (*z).encodedTxns.encodedKeyregTxnFields.VoteLast[zb0016].MarshalMsg(o)
			}
		}
		if (zb0022Mask & 0x80000000000000) == 0 { // if not empty
			// string "votelstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast))
		}
	}
	return
}

func (_ *encodedSignedTxns) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedSignedTxns)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedSignedTxns) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0022 int
	var zb0023 bool
	zb0022, zb0023, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0022, zb0023, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0022 > 0 {
			zb0022--
			var zb0024 int
			var zb0025 bool
			zb0024, zb0025, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
			if zb0024 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0024), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
			if zb0025 {
				(*z).Sig = nil
			} else if (*z).Sig != nil && cap((*z).Sig) >= zb0024 {
				(*z).Sig = ((*z).Sig)[:zb0024]
			} else {
				(*z).Sig = make([]crypto.Signature, zb0024)
			}
			for zb0001 := range (*z).Sig {
				bts, err = (*z).Sig[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sig", zb0001)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0026 []byte
				zb0026, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSig")
					return
				}
				(*z).BitmaskSig = bitmask(zb0026)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0027 int
			var zb0028 bool
			zb0027, zb0028, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Msig")
				return
			}
			if zb0027 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0027), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Msig")
				return
			}
			if zb0028 {
				(*z).Msig = nil
			} else if (*z).Msig != nil && cap((*z).Msig) >= zb0027 {
				(*z).Msig = ((*z).Msig)[:zb0027]
			} else {
				(*z).Msig = make([]crypto.MultisigSig, zb0027)
			}
			for zb0002 := range (*z).Msig {
				bts, err = (*z).Msig[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Msig", zb0002)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0029 []byte
				zb0029, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskMsig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMsig")
					return
				}
				(*z).BitmaskMsig = bitmask(zb0029)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0030 int
			var zb0031 bool
			zb0030, zb0031, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lsig")
				return
			}
			if zb0030 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0030), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Lsig")
				return
			}
			if zb0031 {
				(*z).Lsig = nil
			} else if (*z).Lsig != nil && cap((*z).Lsig) >= zb0030 {
				(*z).Lsig = ((*z).Lsig)[:zb0030]
			} else {
				(*z).Lsig = make([]transactions.LogicSig, zb0030)
			}
			for zb0003 := range (*z).Lsig {
				bts, err = (*z).Lsig[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Lsig", zb0003)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0032 []byte
				zb0032, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLsig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLsig")
					return
				}
				(*z).BitmaskLsig = bitmask(zb0032)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0033 int
			var zb0034 bool
			zb0033, zb0034, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
			if zb0033 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0033), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
			if zb0034 {
				(*z).AuthAddr = nil
			} else if (*z).AuthAddr != nil && cap((*z).AuthAddr) >= zb0033 {
				(*z).AuthAddr = ((*z).AuthAddr)[:zb0033]
			} else {
				(*z).AuthAddr = make([]basics.Address, zb0033)
			}
			for zb0004 := range (*z).AuthAddr {
				bts, err = (*z).AuthAddr[zb0004].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AuthAddr", zb0004)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0035 []byte
				zb0035, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAuthAddr))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAuthAddr")
					return
				}
				(*z).BitmaskAuthAddr = bitmask(zb0035)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0036 int
			zb0036, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
			if zb0036 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0036), uint64(maxEncodedTransactionGroup))
				return
			}
			(*z).encodedTxns.TxType, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.TxType)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0037 []byte
				zb0037, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.BitmaskTxType))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTxType")
					return
				}
				(*z).encodedTxns.BitmaskTxType = bitmask(zb0037)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0038 int
			var zb0039 bool
			zb0038, zb0039, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
			if zb0038 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0038), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
			if zb0039 {
				(*z).encodedTxns.encodedTxnHeaders.Sender = nil
			} else if (*z).encodedTxns.encodedTxnHeaders.Sender != nil && cap((*z).encodedTxns.encodedTxnHeaders.Sender) >= zb0038 {
				(*z).encodedTxns.encodedTxnHeaders.Sender = ((*z).encodedTxns.encodedTxnHeaders.Sender)[:zb0038]
			} else {
				(*z).encodedTxns.encodedTxnHeaders.Sender = make([]basics.Address, zb0038)
			}
			for zb0005 := range (*z).encodedTxns.encodedTxnHeaders.Sender {
				bts, err = (*z).encodedTxns.encodedTxnHeaders.Sender[zb0005].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sender", zb0005)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0040 []byte
				zb0040, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskSender))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSender")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskSender = bitmask(zb0040)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0041 int
			var zb0042 bool
			zb0041, zb0042, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0041 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0041), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0042 {
				(*z).encodedTxns.encodedTxnHeaders.Fee = nil
			} else if (*z).encodedTxns.encodedTxnHeaders.Fee != nil && cap((*z).encodedTxns.encodedTxnHeaders.Fee) >= zb0041 {
				(*z).encodedTxns.encodedTxnHeaders.Fee = ((*z).encodedTxns.encodedTxnHeaders.Fee)[:zb0041]
			} else {
				(*z).encodedTxns.encodedTxnHeaders.Fee = make([]basics.MicroAlgos, zb0041)
			}
			for zb0006 := range (*z).encodedTxns.encodedTxnHeaders.Fee {
				bts, err = (*z).encodedTxns.encodedTxnHeaders.Fee[zb0006].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Fee", zb0006)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0043 []byte
				zb0043, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFee))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFee")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskFee = bitmask(zb0043)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0044 int
			var zb0045 bool
			zb0044, zb0045, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0044 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0044), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0045 {
				(*z).encodedTxns.encodedTxnHeaders.FirstValid = nil
			} else if (*z).encodedTxns.encodedTxnHeaders.FirstValid != nil && cap((*z).encodedTxns.encodedTxnHeaders.FirstValid) >= zb0044 {
				(*z).encodedTxns.encodedTxnHeaders.FirstValid = ((*z).encodedTxns.encodedTxnHeaders.FirstValid)[:zb0044]
			} else {
				(*z).encodedTxns.encodedTxnHeaders.FirstValid = make([]basics.Round, zb0044)
			}
			for zb0007 := range (*z).encodedTxns.encodedTxnHeaders.FirstValid {
				bts, err = (*z).encodedTxns.encodedTxnHeaders.FirstValid[zb0007].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "FirstValid", zb0007)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0046 []byte
				zb0046, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFirstValid")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid = bitmask(zb0046)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0047 int
			var zb0048 bool
			zb0047, zb0048, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0047 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0047), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0048 {
				(*z).encodedTxns.encodedTxnHeaders.LastValid = nil
			} else if (*z).encodedTxns.encodedTxnHeaders.LastValid != nil && cap((*z).encodedTxns.encodedTxnHeaders.LastValid) >= zb0047 {
				(*z).encodedTxns.encodedTxnHeaders.LastValid = ((*z).encodedTxns.encodedTxnHeaders.LastValid)[:zb0047]
			} else {
				(*z).encodedTxns.encodedTxnHeaders.LastValid = make([]basics.Round, zb0047)
			}
			for zb0008 := range (*z).encodedTxns.encodedTxnHeaders.LastValid {
				bts, err = (*z).encodedTxns.encodedTxnHeaders.LastValid[zb0008].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LastValid", zb0008)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0049 []byte
				zb0049, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLastValid")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid = bitmask(zb0049)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0050 int
			var zb0051 bool
			zb0050, zb0051, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0050 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0050), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0051 {
				(*z).encodedTxns.encodedTxnHeaders.Note = nil
			} else if (*z).encodedTxns.encodedTxnHeaders.Note != nil && cap((*z).encodedTxns.encodedTxnHeaders.Note) >= zb0050 {
				(*z).encodedTxns.encodedTxnHeaders.Note = ((*z).encodedTxns.encodedTxnHeaders.Note)[:zb0050]
			} else {
				(*z).encodedTxns.encodedTxnHeaders.Note = make([][]byte, zb0050)
			}
			for zb0009 := range (*z).encodedTxns.encodedTxnHeaders.Note {
				(*z).encodedTxns.encodedTxnHeaders.Note[zb0009], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedTxnHeaders.Note[zb0009])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Note", zb0009)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0052 []byte
				zb0052, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskNote))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNote")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskNote = bitmask(zb0052)
			}
		}
		if zb0022 > 0 {
			zb0022--
			(*z).encodedTxns.encodedTxnHeaders.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0053 []byte
				zb0053, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisID")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID = bitmask(zb0053)
			}
		}
		if zb0022 > 0 {
			zb0022--
			bts, err = (*z).encodedTxns.encodedTxnHeaders.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0054 []byte
				zb0054, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisHash")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisHash = bitmask(zb0054)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0055 int
			var zb0056 bool
			zb0055, zb0056, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
			if zb0055 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0055), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
			if zb0056 {
				(*z).encodedTxns.encodedTxnHeaders.Lease = nil
			} else if (*z).encodedTxns.encodedTxnHeaders.Lease != nil && cap((*z).encodedTxns.encodedTxnHeaders.Lease) >= zb0055 {
				(*z).encodedTxns.encodedTxnHeaders.Lease = ((*z).encodedTxns.encodedTxnHeaders.Lease)[:zb0055]
			} else {
				(*z).encodedTxns.encodedTxnHeaders.Lease = make([][32]byte, zb0055)
			}
			for zb0010 := range (*z).encodedTxns.encodedTxnHeaders.Lease {
				bts, err = msgp.ReadExactBytes(bts, ((*z).encodedTxns.encodedTxnHeaders.Lease[zb0010])[:])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Lease", zb0010)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0057 []byte
				zb0057, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLease))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLease")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskLease = bitmask(zb0057)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0058 int
			var zb0059 bool
			zb0058, zb0059, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
			if zb0058 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0058), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
			if zb0059 {
				(*z).encodedTxns.encodedTxnHeaders.RekeyTo = nil
			} else if (*z).encodedTxns.encodedTxnHeaders.RekeyTo != nil && cap((*z).encodedTxns.encodedTxnHeaders.RekeyTo) >= zb0058 {
				(*z).encodedTxns.encodedTxnHeaders.RekeyTo = ((*z).encodedTxns.encodedTxnHeaders.RekeyTo)[:zb0058]
			} else {
				(*z).encodedTxns.encodedTxnHeaders.RekeyTo = make([]basics.Address, zb0058)
			}
			for zb0012 := range (*z).encodedTxns.encodedTxnHeaders.RekeyTo {
				bts, err = (*z).encodedTxns.encodedTxnHeaders.RekeyTo[zb0012].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "RekeyTo", zb0012)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0060 []byte
				zb0060, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskRekeyTo")
					return
				}
				(*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo = bitmask(zb0060)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0061 int
			var zb0062 bool
			zb0061, zb0062, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
			if zb0061 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0061), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
			if zb0062 {
				(*z).encodedTxns.encodedKeyregTxnFields.VotePK = nil
			} else if (*z).encodedTxns.encodedKeyregTxnFields.VotePK != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VotePK) >= zb0061 {
				(*z).encodedTxns.encodedKeyregTxnFields.VotePK = ((*z).encodedTxns.encodedKeyregTxnFields.VotePK)[:zb0061]
			} else {
				(*z).encodedTxns.encodedKeyregTxnFields.VotePK = make([]crypto.OneTimeSignatureVerifier, zb0061)
			}
			for zb0013 := range (*z).encodedTxns.encodedKeyregTxnFields.VotePK {
				bts, err = (*z).encodedTxns.encodedKeyregTxnFields.VotePK[zb0013].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VotePK", zb0013)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0063 []byte
				zb0063, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVotePK))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVotePK")
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.BitmaskVotePK = bitmask(zb0063)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0064 int
			var zb0065 bool
			zb0064, zb0065, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
			if zb0064 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0064), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
			if zb0065 {
				(*z).encodedTxns.encodedKeyregTxnFields.SelectionPK = nil
			} else if (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.SelectionPK) >= zb0064 {
				(*z).encodedTxns.encodedKeyregTxnFields.SelectionPK = ((*z).encodedTxns.encodedKeyregTxnFields.SelectionPK)[:zb0064]
			} else {
				(*z).encodedTxns.encodedKeyregTxnFields.SelectionPK = make([]crypto.VRFVerifier, zb0064)
			}
			for zb0014 := range (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK {
				bts, err = (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK[zb0014].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SelectionPK", zb0014)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0066 []byte
				zb0066, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSelectionPK")
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK = bitmask(zb0066)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0067 int
			var zb0068 bool
			zb0067, zb0068, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0067 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0067), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0068 {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteFirst = nil
			} else if (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst) >= zb0067 {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteFirst = ((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst)[:zb0067]
			} else {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteFirst = make([]basics.Round, zb0067)
			}
			for zb0015 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst {
				bts, err = (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0015].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteFirst", zb0015)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0069 []byte
				zb0069, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteFirst")
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst = bitmask(zb0069)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0070 int
			var zb0071 bool
			zb0070, zb0071, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0070 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0070), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0071 {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteLast = nil
			} else if (*z).encodedTxns.encodedKeyregTxnFields.VoteLast != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VoteLast) >= zb0070 {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteLast = ((*z).encodedTxns.encodedKeyregTxnFields.VoteLast)[:zb0070]
			} else {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteLast = make([]basics.Round, zb0070)
			}
			for zb0016 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteLast {
				bts, err = (*z).encodedTxns.encodedKeyregTxnFields.VoteLast[zb0016].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteLast", zb0016)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0072 []byte
				zb0072, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteLast")
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast = bitmask(zb0072)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0073 int
			var zb0074 bool
			zb0073, zb0074, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0073 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0073), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0074 {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = nil
			} else if (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) >= zb0073 {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = ((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution)[:zb0073]
			} else {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = make([]uint64, zb0073)
			}
			for zb0017 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution {
				(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution[zb0017], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution", zb0017)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0075 []byte
				zb0075, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteKeyDilution")
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution = bitmask(zb0075)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0076 int
			var zb0077 bool
			zb0076, zb0077, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Nonparticipation")
				return
			}
			if zb0076 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0076), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Nonparticipation")
				return
			}
			if zb0077 {
				(*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation = nil
			} else if (*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation) >= zb0076 {
				(*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation = ((*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation)[:zb0076]
			} else {
				(*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation = make([]bool, zb0076)
			}
			for zb0018 := range (*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation {
				(*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation[zb0018], bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Nonparticipation", zb0018)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0078 []byte
				zb0078, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNonparticipation")
					return
				}
				(*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation = bitmask(zb0078)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0079 int
			var zb0080 bool
			zb0079, zb0080, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
			if zb0079 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0079), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
			if zb0080 {
				(*z).encodedTxns.encodedPaymentTxnFields.Receiver = nil
			} else if (*z).encodedTxns.encodedPaymentTxnFields.Receiver != nil && cap((*z).encodedTxns.encodedPaymentTxnFields.Receiver) >= zb0079 {
				(*z).encodedTxns.encodedPaymentTxnFields.Receiver = ((*z).encodedTxns.encodedPaymentTxnFields.Receiver)[:zb0079]
			} else {
				(*z).encodedTxns.encodedPaymentTxnFields.Receiver = make([]basics.Address, zb0079)
			}
			for zb0019 := range (*z).encodedTxns.encodedPaymentTxnFields.Receiver {
				bts, err = (*z).encodedTxns.encodedPaymentTxnFields.Receiver[zb0019].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Receiver", zb0019)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0081 []byte
				zb0081, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReceiver")
					return
				}
				(*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver = bitmask(zb0081)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0082 int
			var zb0083 bool
			zb0082, zb0083, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0082 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0082), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0083 {
				(*z).encodedTxns.encodedPaymentTxnFields.Amount = nil
			} else if (*z).encodedTxns.encodedPaymentTxnFields.Amount != nil && cap((*z).encodedTxns.encodedPaymentTxnFields.Amount) >= zb0082 {
				(*z).encodedTxns.encodedPaymentTxnFields.Amount = ((*z).encodedTxns.encodedPaymentTxnFields.Amount)[:zb0082]
			} else {
				(*z).encodedTxns.encodedPaymentTxnFields.Amount = make([]basics.MicroAlgos, zb0082)
			}
			for zb0020 := range (*z).encodedTxns.encodedPaymentTxnFields.Amount {
				bts, err = (*z).encodedTxns.encodedPaymentTxnFields.Amount[zb0020].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Amount", zb0020)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0084 []byte
				zb0084, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAmount")
					return
				}
				(*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount = bitmask(zb0084)
			}
		}
		if zb0022 > 0 {
			zb0022--
			var zb0085 int
			var zb0086 bool
			zb0085, zb0086, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
			if zb0085 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0085), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
			if zb0086 {
				(*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo = nil
			} else if (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo != nil && cap((*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) >= zb0085 {
				(*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo = ((*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo)[:zb0085]
			} else {
				(*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo = make([]basics.Address, zb0085)
			}
			for zb0021 := range (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo {
				bts, err = (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo[zb0021].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo", zb0021)
					return
				}
			}
		}
		if zb0022 > 0 {
			zb0022--
			{
				var zb0087 []byte
				zb0087, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCloseRemainderTo")
					return
				}
				(*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo = bitmask(zb0087)
			}
		}
		if zb0022 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0022)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0023 {
			(*z) = encodedSignedTxns{}
		}
		for zb0022 > 0 {
			zb0022--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "sig":
				var zb0088 int
				var zb0089 bool
				zb0088, zb0089, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
				if zb0088 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0088), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Sig")
					return
				}
				if zb0089 {
					(*z).Sig = nil
				} else if (*z).Sig != nil && cap((*z).Sig) >= zb0088 {
					(*z).Sig = ((*z).Sig)[:zb0088]
				} else {
					(*z).Sig = make([]crypto.Signature, zb0088)
				}
				for zb0001 := range (*z).Sig {
					bts, err = (*z).Sig[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sig", zb0001)
						return
					}
				}
			case "sigbm":
				{
					var zb0090 []byte
					zb0090, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSig")
						return
					}
					(*z).BitmaskSig = bitmask(zb0090)
				}
			case "msig":
				var zb0091 int
				var zb0092 bool
				zb0091, zb0092, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Msig")
					return
				}
				if zb0091 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0091), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Msig")
					return
				}
				if zb0092 {
					(*z).Msig = nil
				} else if (*z).Msig != nil && cap((*z).Msig) >= zb0091 {
					(*z).Msig = ((*z).Msig)[:zb0091]
				} else {
					(*z).Msig = make([]crypto.MultisigSig, zb0091)
				}
				for zb0002 := range (*z).Msig {
					bts, err = (*z).Msig[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Msig", zb0002)
						return
					}
				}
			case "msigbm":
				{
					var zb0093 []byte
					zb0093, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskMsig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMsig")
						return
					}
					(*z).BitmaskMsig = bitmask(zb0093)
				}
			case "lsig":
				var zb0094 int
				var zb0095 bool
				zb0094, zb0095, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lsig")
					return
				}
				if zb0094 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0094), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Lsig")
					return
				}
				if zb0095 {
					(*z).Lsig = nil
				} else if (*z).Lsig != nil && cap((*z).Lsig) >= zb0094 {
					(*z).Lsig = ((*z).Lsig)[:zb0094]
				} else {
					(*z).Lsig = make([]transactions.LogicSig, zb0094)
				}
				for zb0003 := range (*z).Lsig {
					bts, err = (*z).Lsig[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Lsig", zb0003)
						return
					}
				}
			case "lsigbm":
				{
					var zb0096 []byte
					zb0096, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLsig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLsig")
						return
					}
					(*z).BitmaskLsig = bitmask(zb0096)
				}
			case "sgnr":
				var zb0097 int
				var zb0098 bool
				zb0097, zb0098, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
				if zb0097 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0097), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
				if zb0098 {
					(*z).AuthAddr = nil
				} else if (*z).AuthAddr != nil && cap((*z).AuthAddr) >= zb0097 {
					(*z).AuthAddr = ((*z).AuthAddr)[:zb0097]
				} else {
					(*z).AuthAddr = make([]basics.Address, zb0097)
				}
				for zb0004 := range (*z).AuthAddr {
					bts, err = (*z).AuthAddr[zb0004].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "AuthAddr", zb0004)
						return
					}
				}
			case "sgnrbm":
				{
					var zb0099 []byte
					zb0099, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAuthAddr))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAuthAddr")
						return
					}
					(*z).BitmaskAuthAddr = bitmask(zb0099)
				}
			case "type":
				var zb0100 int
				zb0100, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
				if zb0100 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0100), uint64(maxEncodedTransactionGroup))
					return
				}
				(*z).encodedTxns.TxType, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.TxType)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
			case "typebm":
				{
					var zb0101 []byte
					zb0101, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.BitmaskTxType))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTxType")
						return
					}
					(*z).encodedTxns.BitmaskTxType = bitmask(zb0101)
				}
			case "snd":
				var zb0102 int
				var zb0103 bool
				zb0102, zb0103, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				if zb0102 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0102), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Sender")
					return
				}
				if zb0103 {
					(*z).encodedTxns.encodedTxnHeaders.Sender = nil
				} else if (*z).encodedTxns.encodedTxnHeaders.Sender != nil && cap((*z).encodedTxns.encodedTxnHeaders.Sender) >= zb0102 {
					(*z).encodedTxns.encodedTxnHeaders.Sender = ((*z).encodedTxns.encodedTxnHeaders.Sender)[:zb0102]
				} else {
					(*z).encodedTxns.encodedTxnHeaders.Sender = make([]basics.Address, zb0102)
				}
				for zb0005 := range (*z).encodedTxns.encodedTxnHeaders.Sender {
					bts, err = (*z).encodedTxns.encodedTxnHeaders.Sender[zb0005].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sender", zb0005)
						return
					}
				}
			case "sndbm":
				{
					var zb0104 []byte
					zb0104, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskSender))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSender")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskSender = bitmask(zb0104)
				}
			case "fee":
				var zb0105 int
				var zb0106 bool
				zb0105, zb0106, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0105 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0105), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0106 {
					(*z).encodedTxns.encodedTxnHeaders.Fee = nil
				} else if (*z).encodedTxns.encodedTxnHeaders.Fee != nil && cap((*z).encodedTxns.encodedTxnHeaders.Fee) >= zb0105 {
					(*z).encodedTxns.encodedTxnHeaders.Fee = ((*z).encodedTxns.encodedTxnHeaders.Fee)[:zb0105]
				} else {
					(*z).encodedTxns.encodedTxnHeaders.Fee = make([]basics.MicroAlgos, zb0105)
				}
				for zb0006 := range (*z).encodedTxns.encodedTxnHeaders.Fee {
					bts, err = (*z).encodedTxns.encodedTxnHeaders.Fee[zb0006].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Fee", zb0006)
						return
					}
				}
			case "feebm":
				{
					var zb0107 []byte
					zb0107, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFee))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFee")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskFee = bitmask(zb0107)
				}
			case "fv":
				var zb0108 int
				var zb0109 bool
				zb0108, zb0109, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0108 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0108), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0109 {
					(*z).encodedTxns.encodedTxnHeaders.FirstValid = nil
				} else if (*z).encodedTxns.encodedTxnHeaders.FirstValid != nil && cap((*z).encodedTxns.encodedTxnHeaders.FirstValid) >= zb0108 {
					(*z).encodedTxns.encodedTxnHeaders.FirstValid = ((*z).encodedTxns.encodedTxnHeaders.FirstValid)[:zb0108]
				} else {
					(*z).encodedTxns.encodedTxnHeaders.FirstValid = make([]basics.Round, zb0108)
				}
				for zb0007 := range (*z).encodedTxns.encodedTxnHeaders.FirstValid {
					bts, err = (*z).encodedTxns.encodedTxnHeaders.FirstValid[zb0007].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "FirstValid", zb0007)
						return
					}
				}
			case "fvbm":
				{
					var zb0110 []byte
					zb0110, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFirstValid")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid = bitmask(zb0110)
				}
			case "lv":
				var zb0111 int
				var zb0112 bool
				zb0111, zb0112, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0111 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0111), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0112 {
					(*z).encodedTxns.encodedTxnHeaders.LastValid = nil
				} else if (*z).encodedTxns.encodedTxnHeaders.LastValid != nil && cap((*z).encodedTxns.encodedTxnHeaders.LastValid) >= zb0111 {
					(*z).encodedTxns.encodedTxnHeaders.LastValid = ((*z).encodedTxns.encodedTxnHeaders.LastValid)[:zb0111]
				} else {
					(*z).encodedTxns.encodedTxnHeaders.LastValid = make([]basics.Round, zb0111)
				}
				for zb0008 := range (*z).encodedTxns.encodedTxnHeaders.LastValid {
					bts, err = (*z).encodedTxns.encodedTxnHeaders.LastValid[zb0008].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastValid", zb0008)
						return
					}
				}
			case "lvbm":
				{
					var zb0113 []byte
					zb0113, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLastValid")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid = bitmask(zb0113)
				}
			case "note":
				var zb0114 int
				var zb0115 bool
				zb0114, zb0115, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0114 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0114), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0115 {
					(*z).encodedTxns.encodedTxnHeaders.Note = nil
				} else if (*z).encodedTxns.encodedTxnHeaders.Note != nil && cap((*z).encodedTxns.encodedTxnHeaders.Note) >= zb0114 {
					(*z).encodedTxns.encodedTxnHeaders.Note = ((*z).encodedTxns.encodedTxnHeaders.Note)[:zb0114]
				} else {
					(*z).encodedTxns.encodedTxnHeaders.Note = make([][]byte, zb0114)
				}
				for zb0009 := range (*z).encodedTxns.encodedTxnHeaders.Note {
					(*z).encodedTxns.encodedTxnHeaders.Note[zb0009], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxns.encodedTxnHeaders.Note[zb0009])
					if err != nil {
						err = msgp.WrapError(err, "Note", zb0009)
						return
					}
				}
			case "notebm":
				{
					var zb0116 []byte
					zb0116, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskNote))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNote")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskNote = bitmask(zb0116)
				}
			case "gen":
				(*z).encodedTxns.encodedTxnHeaders.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "genbm":
				{
					var zb0117 []byte
					zb0117, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisID")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID = bitmask(zb0117)
				}
			case "gh":
				bts, err = (*z).encodedTxns.encodedTxnHeaders.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "ghbm":
				{
					var zb0118 []byte
					zb0118, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisHash")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisHash = bitmask(zb0118)
				}
			case "lx":
				var zb0119 int
				var zb0120 bool
				zb0119, zb0120, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
				if zb0119 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0119), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Lease")
					return
				}
				if zb0120 {
					(*z).encodedTxns.encodedTxnHeaders.Lease = nil
				} else if (*z).encodedTxns.encodedTxnHeaders.Lease != nil && cap((*z).encodedTxns.encodedTxnHeaders.Lease) >= zb0119 {
					(*z).encodedTxns.encodedTxnHeaders.Lease = ((*z).encodedTxns.encodedTxnHeaders.Lease)[:zb0119]
				} else {
					(*z).encodedTxns.encodedTxnHeaders.Lease = make([][32]byte, zb0119)
				}
				for zb0010 := range (*z).encodedTxns.encodedTxnHeaders.Lease {
					bts, err = msgp.ReadExactBytes(bts, ((*z).encodedTxns.encodedTxnHeaders.Lease[zb0010])[:])
					if err != nil {
						err = msgp.WrapError(err, "Lease", zb0010)
						return
					}
				}
			case "lxbm":
				{
					var zb0121 []byte
					zb0121, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLease))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLease")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskLease = bitmask(zb0121)
				}
			case "rekey":
				var zb0122 int
				var zb0123 bool
				zb0122, zb0123, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
				if zb0122 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0122), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
				if zb0123 {
					(*z).encodedTxns.encodedTxnHeaders.RekeyTo = nil
				} else if (*z).encodedTxns.encodedTxnHeaders.RekeyTo != nil && cap((*z).encodedTxns.encodedTxnHeaders.RekeyTo) >= zb0122 {
					(*z).encodedTxns.encodedTxnHeaders.RekeyTo = ((*z).encodedTxns.encodedTxnHeaders.RekeyTo)[:zb0122]
				} else {
					(*z).encodedTxns.encodedTxnHeaders.RekeyTo = make([]basics.Address, zb0122)
				}
				for zb0012 := range (*z).encodedTxns.encodedTxnHeaders.RekeyTo {
					bts, err = (*z).encodedTxns.encodedTxnHeaders.RekeyTo[zb0012].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "RekeyTo", zb0012)
						return
					}
				}
			case "rekeybm":
				{
					var zb0124 []byte
					zb0124, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskRekeyTo")
						return
					}
					(*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo = bitmask(zb0124)
				}
			case "votekey":
				var zb0125 int
				var zb0126 bool
				zb0125, zb0126, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
				if zb0125 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0125), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VotePK")
					return
				}
				if zb0126 {
					(*z).encodedTxns.encodedKeyregTxnFields.VotePK = nil
				} else if (*z).encodedTxns.encodedKeyregTxnFields.VotePK != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VotePK) >= zb0125 {
					(*z).encodedTxns.encodedKeyregTxnFields.VotePK = ((*z).encodedTxns.encodedKeyregTxnFields.VotePK)[:zb0125]
				} else {
					(*z).encodedTxns.encodedKeyregTxnFields.VotePK = make([]crypto.OneTimeSignatureVerifier, zb0125)
				}
				for zb0013 := range (*z).encodedTxns.encodedKeyregTxnFields.VotePK {
					bts, err = (*z).encodedTxns.encodedKeyregTxnFields.VotePK[zb0013].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VotePK", zb0013)
						return
					}
				}
			case "votekeybm":
				{
					var zb0127 []byte
					zb0127, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVotePK))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVotePK")
						return
					}
					(*z).encodedTxns.encodedKeyregTxnFields.BitmaskVotePK = bitmask(zb0127)
				}
			case "selkey":
				var zb0128 int
				var zb0129 bool
				zb0128, zb0129, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
				if zb0128 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0128), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
				if zb0129 {
					(*z).encodedTxns.encodedKeyregTxnFields.SelectionPK = nil
				} else if (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.SelectionPK) >= zb0128 {
					(*z).encodedTxns.encodedKeyregTxnFields.SelectionPK = ((*z).encodedTxns.encodedKeyregTxnFields.SelectionPK)[:zb0128]
				} else {
					(*z).encodedTxns.encodedKeyregTxnFields.SelectionPK = make([]crypto.VRFVerifier, zb0128)
				}
				for zb0014 := range (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK {
					bts, err = (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK[zb0014].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "SelectionPK", zb0014)
						return
					}
				}
			case "selkeybm":
				{
					var zb0130 []byte
					zb0130, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSelectionPK")
						return
					}
					(*z).encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK = bitmask(zb0130)
				}
			case "votefst":
				var zb0131 int
				var zb0132 bool
				zb0131, zb0132, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0131 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0131), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0132 {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteFirst = nil
				} else if (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst) >= zb0131 {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteFirst = ((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst)[:zb0131]
				} else {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteFirst = make([]basics.Round, zb0131)
				}
				for zb0015 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst {
					bts, err = (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0015].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteFirst", zb0015)
						return
					}
				}
			case "votefstbm":
				{
					var zb0133 []byte
					zb0133, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteFirst")
						return
					}
					(*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst = bitmask(zb0133)
				}
			case "votelst":
				var zb0134 int
				var zb0135 bool
				zb0134, zb0135, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0134 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0134), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0135 {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteLast = nil
				} else if (*z).encodedTxns.encodedKeyregTxnFields.VoteLast != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VoteLast) >= zb0134 {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteLast = ((*z).encodedTxns.encodedKeyregTxnFields.VoteLast)[:zb0134]
				} else {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteLast = make([]basics.Round, zb0134)
				}
				for zb0016 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteLast {
					bts, err = (*z).encodedTxns.encodedKeyregTxnFields.VoteLast[zb0016].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteLast", zb0016)
						return
					}
				}
			case "votelstbm":
				{
					var zb0136 []byte
					zb0136, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteLast")
						return
					}
					(*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast = bitmask(zb0136)
				}
			case "votekd":
				var zb0137 int
				var zb0138 bool
				zb0137, zb0138, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0137 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0137), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0138 {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = nil
				} else if (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) >= zb0137 {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = ((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution)[:zb0137]
				} else {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = make([]uint64, zb0137)
				}
				for zb0017 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution {
					(*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution[zb0017], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteKeyDilution", zb0017)
						return
					}
				}
			case "votekdbm":
				{
					var zb0139 []byte
					zb0139, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteKeyDilution")
						return
					}
					(*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution = bitmask(zb0139)
				}
			case "nonpart":
				var zb0140 int
				var zb0141 bool
				zb0140, zb0141, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Nonparticipation")
					return
				}
				if zb0140 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0140), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Nonparticipation")
					return
				}
				if zb0141 {
					(*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation = nil
				} else if (*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation != nil && cap((*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation) >= zb0140 {
					(*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation = ((*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation)[:zb0140]
				} else {
					(*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation = make([]bool, zb0140)
				}
				for zb0018 := range (*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation {
					(*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation[zb0018], bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Nonparticipation", zb0018)
						return
					}
				}
			case "nonpartbm":
				{
					var zb0142 []byte
					zb0142, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNonparticipation")
						return
					}
					(*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation = bitmask(zb0142)
				}
			case "rcv":
				var zb0143 int
				var zb0144 bool
				zb0143, zb0144, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
				if zb0143 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0143), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Receiver")
					return
				}
				if zb0144 {
					(*z).encodedTxns.encodedPaymentTxnFields.Receiver = nil
				} else if (*z).encodedTxns.encodedPaymentTxnFields.Receiver != nil && cap((*z).encodedTxns.encodedPaymentTxnFields.Receiver) >= zb0143 {
					(*z).encodedTxns.encodedPaymentTxnFields.Receiver = ((*z).encodedTxns.encodedPaymentTxnFields.Receiver)[:zb0143]
				} else {
					(*z).encodedTxns.encodedPaymentTxnFields.Receiver = make([]basics.Address, zb0143)
				}
				for zb0019 := range (*z).encodedTxns.encodedPaymentTxnFields.Receiver {
					bts, err = (*z).encodedTxns.encodedPaymentTxnFields.Receiver[zb0019].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Receiver", zb0019)
						return
					}
				}
			case "rcvbm":
				{
					var zb0145 []byte
					zb0145, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReceiver")
						return
					}
					(*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver = bitmask(zb0145)
				}
			case "amt":
				var zb0146 int
				var zb0147 bool
				zb0146, zb0147, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0146 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0146), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0147 {
					(*z).encodedTxns.encodedPaymentTxnFields.Amount = nil
				} else if (*z).encodedTxns.encodedPaymentTxnFields.Amount != nil && cap((*z).encodedTxns.encodedPaymentTxnFields.Amount) >= zb0146 {
					(*z).encodedTxns.encodedPaymentTxnFields.Amount = ((*z).encodedTxns.encodedPaymentTxnFields.Amount)[:zb0146]
				} else {
					(*z).encodedTxns.encodedPaymentTxnFields.Amount = make([]basics.MicroAlgos, zb0146)
				}
				for zb0020 := range (*z).encodedTxns.encodedPaymentTxnFields.Amount {
					bts, err = (*z).encodedTxns.encodedPaymentTxnFields.Amount[zb0020].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Amount", zb0020)
						return
					}
				}
			case "amtbm":
				{
					var zb0148 []byte
					zb0148, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAmount")
						return
					}
					(*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount = bitmask(zb0148)
				}
			case "close":
				var zb0149 int
				var zb0150 bool
				zb0149, zb0150, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
				if zb0149 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0149), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
				if zb0150 {
					(*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo = nil
				} else if (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo != nil && cap((*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) >= zb0149 {
					(*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo = ((*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo)[:zb0149]
				} else {
					(*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo = make([]basics.Address, zb0149)
				}
				for zb0021 := range (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo {
					bts, err = (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo[zb0021].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CloseRemainderTo", zb0021)
						return
					}
				}
			case "closebm":
				{
					var zb0151 []byte
					zb0151, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCloseRemainderTo")
						return
					}
					(*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo = bitmask(zb0151)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedSignedTxns) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedSignedTxns)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedSignedTxns) Msgsize() (s int) {
	s = 3 + 4 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Sig {
		s += (*z).Sig[zb0001].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskSig)) + 5 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Msig {
		s += (*z).Msig[zb0002].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskMsig)) + 5 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).Lsig {
		s += (*z).Lsig[zb0003].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskLsig)) + 5 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).AuthAddr {
		s += (*z).AuthAddr[zb0004].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskAuthAddr)) + 5 + msgp.BytesPrefixSize + len((*z).encodedTxns.TxType) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.BitmaskTxType)) + 4 + msgp.ArrayHeaderSize
	for zb0005 := range (*z).encodedTxns.encodedTxnHeaders.Sender {
		s += (*z).encodedTxns.encodedTxnHeaders.Sender[zb0005].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskSender)) + 4 + msgp.ArrayHeaderSize
	for zb0006 := range (*z).encodedTxns.encodedTxnHeaders.Fee {
		s += (*z).encodedTxns.encodedTxnHeaders.Fee[zb0006].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFee)) + 3 + msgp.ArrayHeaderSize
	for zb0007 := range (*z).encodedTxns.encodedTxnHeaders.FirstValid {
		s += (*z).encodedTxns.encodedTxnHeaders.FirstValid[zb0007].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid)) + 3 + msgp.ArrayHeaderSize
	for zb0008 := range (*z).encodedTxns.encodedTxnHeaders.LastValid {
		s += (*z).encodedTxns.encodedTxnHeaders.LastValid[zb0008].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid)) + 5 + msgp.ArrayHeaderSize
	for zb0009 := range (*z).encodedTxns.encodedTxnHeaders.Note {
		s += msgp.BytesPrefixSize + len((*z).encodedTxns.encodedTxnHeaders.Note[zb0009])
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskNote)) + 4 + msgp.StringPrefixSize + len((*z).encodedTxns.encodedTxnHeaders.GenesisID) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID)) + 3 + (*z).encodedTxns.encodedTxnHeaders.GenesisHash.Msgsize() + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisHash)) + 3 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedTxnHeaders.Lease) * (32 * (msgp.ByteSize))) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskLease)) + 6 + msgp.ArrayHeaderSize
	for zb0012 := range (*z).encodedTxns.encodedTxnHeaders.RekeyTo {
		s += (*z).encodedTxns.encodedTxnHeaders.RekeyTo[zb0012].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo)) + 8 + msgp.ArrayHeaderSize
	for zb0013 := range (*z).encodedTxns.encodedKeyregTxnFields.VotePK {
		s += (*z).encodedTxns.encodedKeyregTxnFields.VotePK[zb0013].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVotePK)) + 7 + msgp.ArrayHeaderSize
	for zb0014 := range (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK {
		s += (*z).encodedTxns.encodedKeyregTxnFields.SelectionPK[zb0014].Msgsize()
	}
	s += 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK)) + 8 + msgp.ArrayHeaderSize
	for zb0015 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst {
		s += (*z).encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0015].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst)) + 8 + msgp.ArrayHeaderSize
	for zb0016 := range (*z).encodedTxns.encodedKeyregTxnFields.VoteLast {
		s += (*z).encodedTxns.encodedKeyregTxnFields.VoteLast[zb0016].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution)) + 8 + msgp.ArrayHeaderSize + (len((*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation) * (msgp.BoolSize)) + 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation)) + 4 + msgp.ArrayHeaderSize
	for zb0019 := range (*z).encodedTxns.encodedPaymentTxnFields.Receiver {
		s += (*z).encodedTxns.encodedPaymentTxnFields.Receiver[zb0019].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver)) + 4 + msgp.ArrayHeaderSize
	for zb0020 := range (*z).encodedTxns.encodedPaymentTxnFields.Amount {
		s += (*z).encodedTxns.encodedPaymentTxnFields.Amount[zb0020].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount)) + 6 + msgp.ArrayHeaderSize
	for zb0021 := range (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo {
		s += (*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo[zb0021].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedSignedTxns) MsgIsZero() bool {
	return (len((*z).Sig) == 0) && (len((*z).BitmaskSig) == 0) && (len((*z).Msig) == 0) && (len((*z).BitmaskMsig) == 0) && (len((*z).Lsig) == 0) && (len((*z).BitmaskLsig) == 0) && (len((*z).AuthAddr) == 0) && (len((*z).BitmaskAuthAddr) == 0) && (len((*z).encodedTxns.TxType) == 0) && (len((*z).encodedTxns.BitmaskTxType) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.Sender) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskSender) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.Fee) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskFee) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.FirstValid) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskFirstValid) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.LastValid) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskLastValid) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.Note) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskNote) == 0) && ((*z).encodedTxns.encodedTxnHeaders.GenesisID == "") && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisID) == 0) && ((*z).encodedTxns.encodedTxnHeaders.GenesisHash.MsgIsZero()) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskGenesisHash) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.Lease) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskLease) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.RekeyTo) == 0) && (len((*z).encodedTxns.encodedTxnHeaders.BitmaskRekeyTo) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.VotePK) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVotePK) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.SelectionPK) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.VoteFirst) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.VoteLast) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.Nonparticipation) == 0) && (len((*z).encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation) == 0) && (len((*z).encodedTxns.encodedPaymentTxnFields.Receiver) == 0) && (len((*z).encodedTxns.encodedPaymentTxnFields.BitmaskReceiver) == 0) && (len((*z).encodedTxns.encodedPaymentTxnFields.Amount) == 0) && (len((*z).encodedTxns.encodedPaymentTxnFields.BitmaskAmount) == 0) && (len((*z).encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) == 0) && (len((*z).encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedTxnHeaders) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0009Len := uint32(18)
	var zb0009Mask uint32 /* 19 bits */
	if len((*z).Fee) == 0 {
		zb0009Len--
		zb0009Mask |= 0x2
	}
	if len((*z).BitmaskFee) == 0 {
		zb0009Len--
		zb0009Mask |= 0x4
	}
	if len((*z).FirstValid) == 0 {
		zb0009Len--
		zb0009Mask |= 0x8
	}
	if len((*z).BitmaskFirstValid) == 0 {
		zb0009Len--
		zb0009Mask |= 0x10
	}
	if (*z).GenesisID == "" {
		zb0009Len--
		zb0009Mask |= 0x20
	}
	if len((*z).BitmaskGenesisID) == 0 {
		zb0009Len--
		zb0009Mask |= 0x40
	}
	if (*z).GenesisHash.MsgIsZero() {
		zb0009Len--
		zb0009Mask |= 0x80
	}
	if len((*z).BitmaskGenesisHash) == 0 {
		zb0009Len--
		zb0009Mask |= 0x100
	}
	if len((*z).LastValid) == 0 {
		zb0009Len--
		zb0009Mask |= 0x200
	}
	if len((*z).BitmaskLastValid) == 0 {
		zb0009Len--
		zb0009Mask |= 0x400
	}
	if len((*z).Lease) == 0 {
		zb0009Len--
		zb0009Mask |= 0x800
	}
	if len((*z).BitmaskLease) == 0 {
		zb0009Len--
		zb0009Mask |= 0x1000
	}
	if len((*z).Note) == 0 {
		zb0009Len--
		zb0009Mask |= 0x2000
	}
	if len((*z).BitmaskNote) == 0 {
		zb0009Len--
		zb0009Mask |= 0x4000
	}
	if len((*z).RekeyTo) == 0 {
		zb0009Len--
		zb0009Mask |= 0x8000
	}
	if len((*z).BitmaskRekeyTo) == 0 {
		zb0009Len--
		zb0009Mask |= 0x10000
	}
	if len((*z).Sender) == 0 {
		zb0009Len--
		zb0009Mask |= 0x20000
	}
	if len((*z).BitmaskSender) == 0 {
		zb0009Len--
		zb0009Mask |= 0x40000
	}
	// variable map header, size zb0009Len
	o = msgp.AppendMapHeader(o, zb0009Len)
	if zb0009Len != 0 {
		if (zb0009Mask & 0x2) == 0 { // if not empty
			// string "fee"
			o = append(o, 0xa3, 0x66, 0x65, 0x65)
			if (*z).Fee == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Fee)))
			}
			for zb0002 := range (*z).Fee {
				o = (*z).Fee[zb0002].MarshalMsg(o)
			}
		}
		if (zb0009Mask & 0x4) == 0 { // if not empty
			// string "feebm"
			o = append(o, 0xa5, 0x66, 0x65, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskFee))
		}
		if (zb0009Mask & 0x8) == 0 { // if not empty
			// string "fv"
			o = append(o, 0xa2, 0x66, 0x76)
			if (*z).FirstValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).FirstValid)))
			}
			for zb0003 := range (*z).FirstValid {
				o = (*z).FirstValid[zb0003].MarshalMsg(o)
			}
		}
		if (zb0009Mask & 0x10) == 0 { // if not empty
			// string "fvbm"
			o = append(o, 0xa4, 0x66, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskFirstValid))
		}
		if (zb0009Mask & 0x20) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).GenesisID)
		}
		if (zb0009Mask & 0x40) == 0 { // if not empty
			// string "genbm"
			o = append(o, 0xa5, 0x67, 0x65, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskGenesisID))
		}
		if (zb0009Mask & 0x80) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o = (*z).GenesisHash.MarshalMsg(o)
		}
		if (zb0009Mask & 0x100) == 0 { // if not empty
			// string "ghbm"
			o = append(o, 0xa4, 0x67, 0x68, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskGenesisHash))
		}
		if (zb0009Mask & 0x200) == 0 { // if not empty
			// string "lv"
			o = append(o, 0xa2, 0x6c, 0x76)
			if (*z).LastValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).LastValid)))
			}
			for zb0004 := range (*z).LastValid {
				o = (*z).LastValid[zb0004].MarshalMsg(o)
			}
		}
		if (zb0009Mask & 0x400) == 0 { // if not empty
			// string "lvbm"
			o = append(o, 0xa4, 0x6c, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskLastValid))
		}
		if (zb0009Mask & 0x800) == 0 { // if not empty
			// string "lx"
			o = append(o, 0xa2, 0x6c, 0x78)
			if (*z).Lease == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Lease)))
			}
			for zb0006 := range (*z).Lease {
				o = msgp.AppendBytes(o, ((*z).Lease[zb0006])[:])
			}
		}
		if (zb0009Mask & 0x1000) == 0 { // if not empty
			// string "lxbm"
			o = append(o, 0xa4, 0x6c, 0x78, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskLease))
		}
		if (zb0009Mask & 0x2000) == 0 { // if not empty
			// string "note"
			o = append(o, 0xa4, 0x6e, 0x6f, 0x74, 0x65)
			if (*z).Note == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Note)))
			}
			for zb0005 := range (*z).Note {
				o = msgp.AppendBytes(o, (*z).Note[zb0005])
			}
		}
		if (zb0009Mask & 0x4000) == 0 { // if not empty
			// string "notebm"
			o = append(o, 0xa6, 0x6e, 0x6f, 0x74, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskNote))
		}
		if (zb0009Mask & 0x8000) == 0 { // if not empty
			// string "rekey"
			o = append(o, 0xa5, 0x72, 0x65, 0x6b, 0x65, 0x79)
			if (*z).RekeyTo == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).RekeyTo)))
			}
			for zb0008 := range (*z).RekeyTo {
				o = (*z).RekeyTo[zb0008].MarshalMsg(o)
			}
		}
		if (zb0009Mask & 0x10000) == 0 { // if not empty
			// string "rekeybm"
			o = append(o, 0xa7, 0x72, 0x65, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskRekeyTo))
		}
		if (zb0009Mask & 0x20000) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			if (*z).Sender == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Sender)))
			}
			for zb0001 := range (*z).Sender {
				o = (*z).Sender[zb0001].MarshalMsg(o)
			}
		}
		if (zb0009Mask & 0x40000) == 0 { // if not empty
			// string "sndbm"
			o = append(o, 0xa5, 0x73, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskSender))
		}
	}
	return
}

func (_ *encodedTxnHeaders) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedTxnHeaders)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedTxnHeaders) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0009 int
	var zb0010 bool
	zb0009, zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0009 > 0 {
			zb0009--
			var zb0011 int
			var zb0012 bool
			zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
			if zb0011 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0011), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
			if zb0012 {
				(*z).Sender = nil
			} else if (*z).Sender != nil && cap((*z).Sender) >= zb0011 {
				(*z).Sender = ((*z).Sender)[:zb0011]
			} else {
				(*z).Sender = make([]basics.Address, zb0011)
			}
			for zb0001 := range (*z).Sender {
				bts, err = (*z).Sender[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sender", zb0001)
					return
				}
			}
		}
		if zb0009 > 0 {
			zb0009--
			{
				var zb0013 []byte
				zb0013, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSender))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSender")
					return
				}
				(*z).BitmaskSender = bitmask(zb0013)
			}
		}
		if zb0009 > 0 {
			zb0009--
			var zb0014 int
			var zb0015 bool
			zb0014, zb0015, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0014 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0014), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0015 {
				(*z).Fee = nil
			} else if (*z).Fee != nil && cap((*z).Fee) >= zb0014 {
				(*z).Fee = ((*z).Fee)[:zb0014]
			} else {
				(*z).Fee = make([]basics.MicroAlgos, zb0014)
			}
			for zb0002 := range (*z).Fee {
				bts, err = (*z).Fee[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Fee", zb0002)
					return
				}
			}
		}
		if zb0009 > 0 {
			zb0009--
			{
				var zb0016 []byte
				zb0016, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFee))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFee")
					return
				}
				(*z).BitmaskFee = bitmask(zb0016)
			}
		}
		if zb0009 > 0 {
			zb0009--
			var zb0017 int
			var zb0018 bool
			zb0017, zb0018, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0017 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0017), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0018 {
				(*z).FirstValid = nil
			} else if (*z).FirstValid != nil && cap((*z).FirstValid) >= zb0017 {
				(*z).FirstValid = ((*z).FirstValid)[:zb0017]
			} else {
				(*z).FirstValid = make([]basics.Round, zb0017)
			}
			for zb0003 := range (*z).FirstValid {
				bts, err = (*z).FirstValid[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "FirstValid", zb0003)
					return
				}
			}
		}
		if zb0009 > 0 {
			zb0009--
			{
				var zb0019 []byte
				zb0019, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFirstValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFirstValid")
					return
				}
				(*z).BitmaskFirstValid = bitmask(zb0019)
			}
		}
		if zb0009 > 0 {
			zb0009--
			var zb0020 int
			var zb0021 bool
			zb0020, zb0021, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0020 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0020), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0021 {
				(*z).LastValid = nil
			} else if (*z).LastValid != nil && cap((*z).LastValid) >= zb0020 {
				(*z).LastValid = ((*z).LastValid)[:zb0020]
			} else {
				(*z).LastValid = make([]basics.Round, zb0020)
			}
			for zb0004 := range (*z).LastValid {
				bts, err = (*z).LastValid[zb0004].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LastValid", zb0004)
					return
				}
			}
		}
		if zb0009 > 0 {
			zb0009--
			{
				var zb0022 []byte
				zb0022, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLastValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLastValid")
					return
				}
				(*z).BitmaskLastValid = bitmask(zb0022)
			}
		}
		if zb0009 > 0 {
			zb0009--
			var zb0023 int
			var zb0024 bool
			zb0023, zb0024, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0023 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0023), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0024 {
				(*z).Note = nil
			} else if (*z).Note != nil && cap((*z).Note) >= zb0023 {
				(*z).Note = ((*z).Note)[:zb0023]
			} else {
				(*z).Note = make([][]byte, zb0023)
			}
			for zb0005 := range (*z).Note {
				(*z).Note[zb0005], bts, err = msgp.ReadBytesBytes(bts, (*z).Note[zb0005])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Note", zb0005)
					return
				}
			}
		}
		if zb0009 > 0 {
			zb0009--
			{
				var zb0025 []byte
				zb0025, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskNote))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNote")
					return
				}
				(*z).BitmaskNote = bitmask(zb0025)
			}
		}
		if zb0009 > 0 {
			zb0009--
			(*z).GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0009 > 0 {
			zb0009--
			{
				var zb0026 []byte
				zb0026, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskGenesisID))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisID")
					return
				}
				(*z).BitmaskGenesisID = bitmask(zb0026)
			}
		}
		if zb0009 > 0 {
			zb0009--
			bts, err = (*z).GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0009 > 0 {
			zb0009--
			{
				var zb0027 []byte
				zb0027, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskGenesisHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisHash")
					return
				}
				(*z).BitmaskGenesisHash = bitmask(zb0027)
			}
		}
		if zb0009 > 0 {
			zb0009--
			var zb0028 int
			var zb0029 bool
			zb0028, zb0029, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
			if zb0028 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0028), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
			if zb0029 {
				(*z).Lease = nil
			} else if (*z).Lease != nil && cap((*z).Lease) >= zb0028 {
				(*z).Lease = ((*z).Lease)[:zb0028]
			} else {
				(*z).Lease = make([][32]byte, zb0028)
			}
			for zb0006 := range (*z).Lease {
				bts, err = msgp.ReadExactBytes(bts, ((*z).Lease[zb0006])[:])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Lease", zb0006)
					return
				}
			}
		}
		if zb0009 > 0 {
			zb0009--
			{
				var zb0030 []byte
				zb0030, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLease))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLease")
					return
				}
				(*z).BitmaskLease = bitmask(zb0030)
			}
		}
		if zb0009 > 0 {
			zb0009--
			var zb0031 int
			var zb0032 bool
			zb0031, zb0032, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
			if zb0031 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0031), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
			if zb0032 {
				(*z).RekeyTo = nil
			} else if (*z).RekeyTo != nil && cap((*z).RekeyTo) >= zb0031 {
				(*z).RekeyTo = ((*z).RekeyTo)[:zb0031]
			} else {
				(*z).RekeyTo = make([]basics.Address, zb0031)
			}
			for zb0008 := range (*z).RekeyTo {
				bts, err = (*z).RekeyTo[zb0008].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "RekeyTo", zb0008)
					return
				}
			}
		}
		if zb0009 > 0 {
			zb0009--
			{
				var zb0033 []byte
				zb0033, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskRekeyTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskRekeyTo")
					return
				}
				(*z).BitmaskRekeyTo = bitmask(zb0033)
			}
		}
		if zb0009 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0009)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0010 {
			(*z) = encodedTxnHeaders{}
		}
		for zb0009 > 0 {
			zb0009--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				var zb0034 int
				var zb0035 bool
				zb0034, zb0035, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				if zb0034 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0034), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Sender")
					return
				}
				if zb0035 {
					(*z).Sender = nil
				} else if (*z).Sender != nil && cap((*z).Sender) >= zb0034 {
					(*z).Sender = ((*z).Sender)[:zb0034]
				} else {
					(*z).Sender = make([]basics.Address, zb0034)
				}
				for zb0001 := range (*z).Sender {
					bts, err = (*z).Sender[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sender", zb0001)
						return
					}
				}
			case "sndbm":
				{
					var zb0036 []byte
					zb0036, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSender))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSender")
						return
					}
					(*z).BitmaskSender = bitmask(zb0036)
				}
			case "fee":
				var zb0037 int
				var zb0038 bool
				zb0037, zb0038, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0037 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0037), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0038 {
					(*z).Fee = nil
				} else if (*z).Fee != nil && cap((*z).Fee) >= zb0037 {
					(*z).Fee = ((*z).Fee)[:zb0037]
				} else {
					(*z).Fee = make([]basics.MicroAlgos, zb0037)
				}
				for zb0002 := range (*z).Fee {
					bts, err = (*z).Fee[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Fee", zb0002)
						return
					}
				}
			case "feebm":
				{
					var zb0039 []byte
					zb0039, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFee))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFee")
						return
					}
					(*z).BitmaskFee = bitmask(zb0039)
				}
			case "fv":
				var zb0040 int
				var zb0041 bool
				zb0040, zb0041, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0040 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0040), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0041 {
					(*z).FirstValid = nil
				} else if (*z).FirstValid != nil && cap((*z).FirstValid) >= zb0040 {
					(*z).FirstValid = ((*z).FirstValid)[:zb0040]
				} else {
					(*z).FirstValid = make([]basics.Round, zb0040)
				}
				for zb0003 := range (*z).FirstValid {
					bts, err = (*z).FirstValid[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "FirstValid", zb0003)
						return
					}
				}
			case "fvbm":
				{
					var zb0042 []byte
					zb0042, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskFirstValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFirstValid")
						return
					}
					(*z).BitmaskFirstValid = bitmask(zb0042)
				}
			case "lv":
				var zb0043 int
				var zb0044 bool
				zb0043, zb0044, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0043 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0043), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0044 {
					(*z).LastValid = nil
				} else if (*z).LastValid != nil && cap((*z).LastValid) >= zb0043 {
					(*z).LastValid = ((*z).LastValid)[:zb0043]
				} else {
					(*z).LastValid = make([]basics.Round, zb0043)
				}
				for zb0004 := range (*z).LastValid {
					bts, err = (*z).LastValid[zb0004].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastValid", zb0004)
						return
					}
				}
			case "lvbm":
				{
					var zb0045 []byte
					zb0045, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLastValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLastValid")
						return
					}
					(*z).BitmaskLastValid = bitmask(zb0045)
				}
			case "note":
				var zb0046 int
				var zb0047 bool
				zb0046, zb0047, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0046 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0046), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0047 {
					(*z).Note = nil
				} else if (*z).Note != nil && cap((*z).Note) >= zb0046 {
					(*z).Note = ((*z).Note)[:zb0046]
				} else {
					(*z).Note = make([][]byte, zb0046)
				}
				for zb0005 := range (*z).Note {
					(*z).Note[zb0005], bts, err = msgp.ReadBytesBytes(bts, (*z).Note[zb0005])
					if err != nil {
						err = msgp.WrapError(err, "Note", zb0005)
						return
					}
				}
			case "notebm":
				{
					var zb0048 []byte
					zb0048, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskNote))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNote")
						return
					}
					(*z).BitmaskNote = bitmask(zb0048)
				}
			case "gen":
				(*z).GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "genbm":
				{
					var zb0049 []byte
					zb0049, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskGenesisID))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisID")
						return
					}
					(*z).BitmaskGenesisID = bitmask(zb0049)
				}
			case "gh":
				bts, err = (*z).GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "ghbm":
				{
					var zb0050 []byte
					zb0050, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskGenesisHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisHash")
						return
					}
					(*z).BitmaskGenesisHash = bitmask(zb0050)
				}
			case "lx":
				var zb0051 int
				var zb0052 bool
				zb0051, zb0052, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
				if zb0051 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0051), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Lease")
					return
				}
				if zb0052 {
					(*z).Lease = nil
				} else if (*z).Lease != nil && cap((*z).Lease) >= zb0051 {
					(*z).Lease = ((*z).Lease)[:zb0051]
				} else {
					(*z).Lease = make([][32]byte, zb0051)
				}
				for zb0006 := range (*z).Lease {
					bts, err = msgp.ReadExactBytes(bts, ((*z).Lease[zb0006])[:])
					if err != nil {
						err = msgp.WrapError(err, "Lease", zb0006)
						return
					}
				}
			case "lxbm":
				{
					var zb0053 []byte
					zb0053, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLease))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLease")
						return
					}
					(*z).BitmaskLease = bitmask(zb0053)
				}
			case "rekey":
				var zb0054 int
				var zb0055 bool
				zb0054, zb0055, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
				if zb0054 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0054), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
				if zb0055 {
					(*z).RekeyTo = nil
				} else if (*z).RekeyTo != nil && cap((*z).RekeyTo) >= zb0054 {
					(*z).RekeyTo = ((*z).RekeyTo)[:zb0054]
				} else {
					(*z).RekeyTo = make([]basics.Address, zb0054)
				}
				for zb0008 := range (*z).RekeyTo {
					bts, err = (*z).RekeyTo[zb0008].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "RekeyTo", zb0008)
						return
					}
				}
			case "rekeybm":
				{
					var zb0056 []byte
					zb0056, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskRekeyTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskRekeyTo")
						return
					}
					(*z).BitmaskRekeyTo = bitmask(zb0056)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedTxnHeaders) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedTxnHeaders)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedTxnHeaders) Msgsize() (s int) {
	s = 3 + 4 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Sender {
		s += (*z).Sender[zb0001].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskSender)) + 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Fee {
		s += (*z).Fee[zb0002].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskFee)) + 3 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).FirstValid {
		s += (*z).FirstValid[zb0003].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskFirstValid)) + 3 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).LastValid {
		s += (*z).LastValid[zb0004].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskLastValid)) + 5 + msgp.ArrayHeaderSize
	for zb0005 := range (*z).Note {
		s += msgp.BytesPrefixSize + len((*z).Note[zb0005])
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskNote)) + 4 + msgp.StringPrefixSize + len((*z).GenesisID) + 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskGenesisID)) + 3 + (*z).GenesisHash.Msgsize() + 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskGenesisHash)) + 3 + msgp.ArrayHeaderSize + (len((*z).Lease) * (32 * (msgp.ByteSize))) + 5 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskLease)) + 6 + msgp.ArrayHeaderSize
	for zb0008 := range (*z).RekeyTo {
		s += (*z).RekeyTo[zb0008].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskRekeyTo))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedTxnHeaders) MsgIsZero() bool {
	return (len((*z).Sender) == 0) && (len((*z).BitmaskSender) == 0) && (len((*z).Fee) == 0) && (len((*z).BitmaskFee) == 0) && (len((*z).FirstValid) == 0) && (len((*z).BitmaskFirstValid) == 0) && (len((*z).LastValid) == 0) && (len((*z).BitmaskLastValid) == 0) && (len((*z).Note) == 0) && (len((*z).BitmaskNote) == 0) && ((*z).GenesisID == "") && (len((*z).BitmaskGenesisID) == 0) && ((*z).GenesisHash.MsgIsZero()) && (len((*z).BitmaskGenesisHash) == 0) && (len((*z).Lease) == 0) && (len((*z).BitmaskLease) == 0) && (len((*z).RekeyTo) == 0) && (len((*z).BitmaskRekeyTo) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedTxns) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0018Len := uint32(38)
	var zb0018Mask uint64 /* 47 bits */
	if len((*z).encodedPaymentTxnFields.Amount) == 0 {
		zb0018Len--
		zb0018Mask |= 0x200
	}
	if len((*z).encodedPaymentTxnFields.BitmaskAmount) == 0 {
		zb0018Len--
		zb0018Mask |= 0x400
	}
	if len((*z).encodedPaymentTxnFields.CloseRemainderTo) == 0 {
		zb0018Len--
		zb0018Mask |= 0x800
	}
	if len((*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo) == 0 {
		zb0018Len--
		zb0018Mask |= 0x1000
	}
	if len((*z).encodedTxnHeaders.Fee) == 0 {
		zb0018Len--
		zb0018Mask |= 0x2000
	}
	if len((*z).encodedTxnHeaders.BitmaskFee) == 0 {
		zb0018Len--
		zb0018Mask |= 0x4000
	}
	if len((*z).encodedTxnHeaders.FirstValid) == 0 {
		zb0018Len--
		zb0018Mask |= 0x8000
	}
	if len((*z).encodedTxnHeaders.BitmaskFirstValid) == 0 {
		zb0018Len--
		zb0018Mask |= 0x10000
	}
	if (*z).encodedTxnHeaders.GenesisID == "" {
		zb0018Len--
		zb0018Mask |= 0x20000
	}
	if len((*z).encodedTxnHeaders.BitmaskGenesisID) == 0 {
		zb0018Len--
		zb0018Mask |= 0x40000
	}
	if (*z).encodedTxnHeaders.GenesisHash.MsgIsZero() {
		zb0018Len--
		zb0018Mask |= 0x80000
	}
	if len((*z).encodedTxnHeaders.BitmaskGenesisHash) == 0 {
		zb0018Len--
		zb0018Mask |= 0x100000
	}
	if len((*z).encodedTxnHeaders.LastValid) == 0 {
		zb0018Len--
		zb0018Mask |= 0x200000
	}
	if len((*z).encodedTxnHeaders.BitmaskLastValid) == 0 {
		zb0018Len--
		zb0018Mask |= 0x400000
	}
	if len((*z).encodedTxnHeaders.Lease) == 0 {
		zb0018Len--
		zb0018Mask |= 0x800000
	}
	if len((*z).encodedTxnHeaders.BitmaskLease) == 0 {
		zb0018Len--
		zb0018Mask |= 0x1000000
	}
	if len((*z).encodedKeyregTxnFields.Nonparticipation) == 0 {
		zb0018Len--
		zb0018Mask |= 0x2000000
	}
	if len((*z).encodedKeyregTxnFields.BitmaskNonparticipation) == 0 {
		zb0018Len--
		zb0018Mask |= 0x4000000
	}
	if len((*z).encodedTxnHeaders.Note) == 0 {
		zb0018Len--
		zb0018Mask |= 0x8000000
	}
	if len((*z).encodedTxnHeaders.BitmaskNote) == 0 {
		zb0018Len--
		zb0018Mask |= 0x10000000
	}
	if len((*z).encodedPaymentTxnFields.Receiver) == 0 {
		zb0018Len--
		zb0018Mask |= 0x20000000
	}
	if len((*z).encodedPaymentTxnFields.BitmaskReceiver) == 0 {
		zb0018Len--
		zb0018Mask |= 0x40000000
	}
	if len((*z).encodedTxnHeaders.RekeyTo) == 0 {
		zb0018Len--
		zb0018Mask |= 0x80000000
	}
	if len((*z).encodedTxnHeaders.BitmaskRekeyTo) == 0 {
		zb0018Len--
		zb0018Mask |= 0x100000000
	}
	if len((*z).encodedKeyregTxnFields.SelectionPK) == 0 {
		zb0018Len--
		zb0018Mask |= 0x200000000
	}
	if len((*z).encodedKeyregTxnFields.BitmaskSelectionPK) == 0 {
		zb0018Len--
		zb0018Mask |= 0x400000000
	}
	if len((*z).encodedTxnHeaders.Sender) == 0 {
		zb0018Len--
		zb0018Mask |= 0x800000000
	}
	if len((*z).encodedTxnHeaders.BitmaskSender) == 0 {
		zb0018Len--
		zb0018Mask |= 0x1000000000
	}
	if len((*z).TxType) == 0 {
		zb0018Len--
		zb0018Mask |= 0x2000000000
	}
	if len((*z).BitmaskTxType) == 0 {
		zb0018Len--
		zb0018Mask |= 0x4000000000
	}
	if len((*z).encodedKeyregTxnFields.VoteFirst) == 0 {
		zb0018Len--
		zb0018Mask |= 0x8000000000
	}
	if len((*z).encodedKeyregTxnFields.BitmaskVoteFirst) == 0 {
		zb0018Len--
		zb0018Mask |= 0x10000000000
	}
	if len((*z).encodedKeyregTxnFields.VoteKeyDilution) == 0 {
		zb0018Len--
		zb0018Mask |= 0x20000000000
	}
	if len((*z).encodedKeyregTxnFields.BitmaskVoteKeyDilution) == 0 {
		zb0018Len--
		zb0018Mask |= 0x40000000000
	}
	if len((*z).encodedKeyregTxnFields.VotePK) == 0 {
		zb0018Len--
		zb0018Mask |= 0x80000000000
	}
	if len((*z).encodedKeyregTxnFields.BitmaskVotePK) == 0 {
		zb0018Len--
		zb0018Mask |= 0x100000000000
	}
	if len((*z).encodedKeyregTxnFields.VoteLast) == 0 {
		zb0018Len--
		zb0018Mask |= 0x200000000000
	}
	if len((*z).encodedKeyregTxnFields.BitmaskVoteLast) == 0 {
		zb0018Len--
		zb0018Mask |= 0x400000000000
	}
	// variable map header, size zb0018Len
	o = msgp.AppendMapHeader(o, zb0018Len)
	if zb0018Len != 0 {
		if (zb0018Mask & 0x200) == 0 { // if not empty
			// string "amt"
			o = append(o, 0xa3, 0x61, 0x6d, 0x74)
			if (*z).encodedPaymentTxnFields.Amount == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedPaymentTxnFields.Amount)))
			}
			for zb0016 := range (*z).encodedPaymentTxnFields.Amount {
				o = (*z).encodedPaymentTxnFields.Amount[zb0016].MarshalMsg(o)
			}
		}
		if (zb0018Mask & 0x400) == 0 { // if not empty
			// string "amtbm"
			o = append(o, 0xa5, 0x61, 0x6d, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedPaymentTxnFields.BitmaskAmount))
		}
		if (zb0018Mask & 0x800) == 0 { // if not empty
			// string "close"
			o = append(o, 0xa5, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			if (*z).encodedPaymentTxnFields.CloseRemainderTo == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedPaymentTxnFields.CloseRemainderTo)))
			}
			for zb0017 := range (*z).encodedPaymentTxnFields.CloseRemainderTo {
				o = (*z).encodedPaymentTxnFields.CloseRemainderTo[zb0017].MarshalMsg(o)
			}
		}
		if (zb0018Mask & 0x1000) == 0 { // if not empty
			// string "closebm"
			o = append(o, 0xa7, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo))
		}
		if (zb0018Mask & 0x2000) == 0 { // if not empty
			// string "fee"
			o = append(o, 0xa3, 0x66, 0x65, 0x65)
			if (*z).encodedTxnHeaders.Fee == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxnHeaders.Fee)))
			}
			for zb0002 := range (*z).encodedTxnHeaders.Fee {
				o = (*z).encodedTxnHeaders.Fee[zb0002].MarshalMsg(o)
			}
		}
		if (zb0018Mask & 0x4000) == 0 { // if not empty
			// string "feebm"
			o = append(o, 0xa5, 0x66, 0x65, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskFee))
		}
		if (zb0018Mask & 0x8000) == 0 { // if not empty
			// string "fv"
			o = append(o, 0xa2, 0x66, 0x76)
			if (*z).encodedTxnHeaders.FirstValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxnHeaders.FirstValid)))
			}
			for zb0003 := range (*z).encodedTxnHeaders.FirstValid {
				o = (*z).encodedTxnHeaders.FirstValid[zb0003].MarshalMsg(o)
			}
		}
		if (zb0018Mask & 0x10000) == 0 { // if not empty
			// string "fvbm"
			o = append(o, 0xa4, 0x66, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskFirstValid))
		}
		if (zb0018Mask & 0x20000) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).encodedTxnHeaders.GenesisID)
		}
		if (zb0018Mask & 0x40000) == 0 { // if not empty
			// string "genbm"
			o = append(o, 0xa5, 0x67, 0x65, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskGenesisID))
		}
		if (zb0018Mask & 0x80000) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o = (*z).encodedTxnHeaders.GenesisHash.MarshalMsg(o)
		}
		if (zb0018Mask & 0x100000) == 0 { // if not empty
			// string "ghbm"
			o = append(o, 0xa4, 0x67, 0x68, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskGenesisHash))
		}
		if (zb0018Mask & 0x200000) == 0 { // if not empty
			// string "lv"
			o = append(o, 0xa2, 0x6c, 0x76)
			if (*z).encodedTxnHeaders.LastValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxnHeaders.LastValid)))
			}
			for zb0004 := range (*z).encodedTxnHeaders.LastValid {
				o = (*z).encodedTxnHeaders.LastValid[zb0004].MarshalMsg(o)
			}
		}
		if (zb0018Mask & 0x400000) == 0 { // if not empty
			// string "lvbm"
			o = append(o, 0xa4, 0x6c, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskLastValid))
		}
		if (zb0018Mask & 0x800000) == 0 { // if not empty
			// string "lx"
			o = append(o, 0xa2, 0x6c, 0x78)
			if (*z).encodedTxnHeaders.Lease == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxnHeaders.Lease)))
			}
			for zb0006 := range (*z).encodedTxnHeaders.Lease {
				o = msgp.AppendBytes(o, ((*z).encodedTxnHeaders.Lease[zb0006])[:])
			}
		}
		if (zb0018Mask & 0x1000000) == 0 { // if not empty
			// string "lxbm"
			o = append(o, 0xa4, 0x6c, 0x78, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskLease))
		}
		if (zb0018Mask & 0x2000000) == 0 { // if not empty
			// string "nonpart"
			o = append(o, 0xa7, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74)
			if (*z).encodedKeyregTxnFields.Nonparticipation == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedKeyregTxnFields.Nonparticipation)))
			}
			for zb0014 := range (*z).encodedKeyregTxnFields.Nonparticipation {
				o = msgp.AppendBool(o, (*z).encodedKeyregTxnFields.Nonparticipation[zb0014])
			}
		}
		if (zb0018Mask & 0x4000000) == 0 { // if not empty
			// string "nonpartbm"
			o = append(o, 0xa9, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedKeyregTxnFields.BitmaskNonparticipation))
		}
		if (zb0018Mask & 0x8000000) == 0 { // if not empty
			// string "note"
			o = append(o, 0xa4, 0x6e, 0x6f, 0x74, 0x65)
			if (*z).encodedTxnHeaders.Note == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxnHeaders.Note)))
			}
			for zb0005 := range (*z).encodedTxnHeaders.Note {
				o = msgp.AppendBytes(o, (*z).encodedTxnHeaders.Note[zb0005])
			}
		}
		if (zb0018Mask & 0x10000000) == 0 { // if not empty
			// string "notebm"
			o = append(o, 0xa6, 0x6e, 0x6f, 0x74, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskNote))
		}
		if (zb0018Mask & 0x20000000) == 0 { // if not empty
			// string "rcv"
			o = append(o, 0xa3, 0x72, 0x63, 0x76)
			if (*z).encodedPaymentTxnFields.Receiver == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedPaymentTxnFields.Receiver)))
			}
			for zb0015 := range (*z).encodedPaymentTxnFields.Receiver {
				o = (*z).encodedPaymentTxnFields.Receiver[zb0015].MarshalMsg(o)
			}
		}
		if (zb0018Mask & 0x40000000) == 0 { // if not empty
			// string "rcvbm"
			o = append(o, 0xa5, 0x72, 0x63, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedPaymentTxnFields.BitmaskReceiver))
		}
		if (zb0018Mask & 0x80000000) == 0 { // if not empty
			// string "rekey"
			o = append(o, 0xa5, 0x72, 0x65, 0x6b, 0x65, 0x79)
			if (*z).encodedTxnHeaders.RekeyTo == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxnHeaders.RekeyTo)))
			}
			for zb0008 := range (*z).encodedTxnHeaders.RekeyTo {
				o = (*z).encodedTxnHeaders.RekeyTo[zb0008].MarshalMsg(o)
			}
		}
		if (zb0018Mask & 0x100000000) == 0 { // if not empty
			// string "rekeybm"
			o = append(o, 0xa7, 0x72, 0x65, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskRekeyTo))
		}
		if (zb0018Mask & 0x200000000) == 0 { // if not empty
			// string "selkey"
			o = append(o, 0xa6, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79)
			if (*z).encodedKeyregTxnFields.SelectionPK == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedKeyregTxnFields.SelectionPK)))
			}
			for zb0010 := range (*z).encodedKeyregTxnFields.SelectionPK {
				o = (*z).encodedKeyregTxnFields.SelectionPK[zb0010].MarshalMsg(o)
			}
		}
		if (zb0018Mask & 0x400000000) == 0 { // if not empty
			// string "selkeybm"
			o = append(o, 0xa8, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedKeyregTxnFields.BitmaskSelectionPK))
		}
		if (zb0018Mask & 0x800000000) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			if (*z).encodedTxnHeaders.Sender == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxnHeaders.Sender)))
			}
			for zb0001 := range (*z).encodedTxnHeaders.Sender {
				o = (*z).encodedTxnHeaders.Sender[zb0001].MarshalMsg(o)
			}
		}
		if (zb0018Mask & 0x1000000000) == 0 { // if not empty
			// string "sndbm"
			o = append(o, 0xa5, 0x73, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedTxnHeaders.BitmaskSender))
		}
		if (zb0018Mask & 0x2000000000) == 0 { // if not empty
			// string "type"
			o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
			o = msgp.AppendBytes(o, (*z).TxType)
		}
		if (zb0018Mask & 0x4000000000) == 0 { // if not empty
			// string "typebm"
			o = append(o, 0xa6, 0x74, 0x79, 0x70, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskTxType))
		}
		if (zb0018Mask & 0x8000000000) == 0 { // if not empty
			// string "votefst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74)
			if (*z).encodedKeyregTxnFields.VoteFirst == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedKeyregTxnFields.VoteFirst)))
			}
			for zb0011 := range (*z).encodedKeyregTxnFields.VoteFirst {
				o = (*z).encodedKeyregTxnFields.VoteFirst[zb0011].MarshalMsg(o)
			}
		}
		if (zb0018Mask & 0x10000000000) == 0 { // if not empty
			// string "votefstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedKeyregTxnFields.BitmaskVoteFirst))
		}
		if (zb0018Mask & 0x20000000000) == 0 { // if not empty
			// string "votekd"
			o = append(o, 0xa6, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64)
			if (*z).encodedKeyregTxnFields.VoteKeyDilution == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedKeyregTxnFields.VoteKeyDilution)))
			}
			for zb0013 := range (*z).encodedKeyregTxnFields.VoteKeyDilution {
				o = msgp.AppendUint64(o, (*z).encodedKeyregTxnFields.VoteKeyDilution[zb0013])
			}
		}
		if (zb0018Mask & 0x40000000000) == 0 { // if not empty
			// string "votekdbm"
			o = append(o, 0xa8, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedKeyregTxnFields.BitmaskVoteKeyDilution))
		}
		if (zb0018Mask & 0x80000000000) == 0 { // if not empty
			// string "votekey"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79)
			if (*z).encodedKeyregTxnFields.VotePK == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedKeyregTxnFields.VotePK)))
			}
			for zb0009 := range (*z).encodedKeyregTxnFields.VotePK {
				o = (*z).encodedKeyregTxnFields.VotePK[zb0009].MarshalMsg(o)
			}
		}
		if (zb0018Mask & 0x100000000000) == 0 { // if not empty
			// string "votekeybm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedKeyregTxnFields.BitmaskVotePK))
		}
		if (zb0018Mask & 0x200000000000) == 0 { // if not empty
			// string "votelst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74)
			if (*z).encodedKeyregTxnFields.VoteLast == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedKeyregTxnFields.VoteLast)))
			}
			for zb0012 := range (*z).encodedKeyregTxnFields.VoteLast {
				o = (*z).encodedKeyregTxnFields.VoteLast[zb0012].MarshalMsg(o)
			}
		}
		if (zb0018Mask & 0x400000000000) == 0 { // if not empty
			// string "votelstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedKeyregTxnFields.BitmaskVoteLast))
		}
	}
	return
}

func (_ *encodedTxns) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedTxns)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedTxns) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0018 int
	var zb0019 bool
	zb0018, zb0019, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0018, zb0019, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0018 > 0 {
			zb0018--
			var zb0020 int
			zb0020, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
			if zb0020 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0020), uint64(maxEncodedTransactionGroup))
				return
			}
			(*z).TxType, bts, err = msgp.ReadBytesBytes(bts, (*z).TxType)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0021 []byte
				zb0021, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskTxType))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTxType")
					return
				}
				(*z).BitmaskTxType = bitmask(zb0021)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0022 int
			var zb0023 bool
			zb0022, zb0023, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
			if zb0022 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0022), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
			if zb0023 {
				(*z).encodedTxnHeaders.Sender = nil
			} else if (*z).encodedTxnHeaders.Sender != nil && cap((*z).encodedTxnHeaders.Sender) >= zb0022 {
				(*z).encodedTxnHeaders.Sender = ((*z).encodedTxnHeaders.Sender)[:zb0022]
			} else {
				(*z).encodedTxnHeaders.Sender = make([]basics.Address, zb0022)
			}
			for zb0001 := range (*z).encodedTxnHeaders.Sender {
				bts, err = (*z).encodedTxnHeaders.Sender[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sender", zb0001)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0024 []byte
				zb0024, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskSender))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSender")
					return
				}
				(*z).encodedTxnHeaders.BitmaskSender = bitmask(zb0024)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0025 int
			var zb0026 bool
			zb0025, zb0026, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0025 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0025), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0026 {
				(*z).encodedTxnHeaders.Fee = nil
			} else if (*z).encodedTxnHeaders.Fee != nil && cap((*z).encodedTxnHeaders.Fee) >= zb0025 {
				(*z).encodedTxnHeaders.Fee = ((*z).encodedTxnHeaders.Fee)[:zb0025]
			} else {
				(*z).encodedTxnHeaders.Fee = make([]basics.MicroAlgos, zb0025)
			}
			for zb0002 := range (*z).encodedTxnHeaders.Fee {
				bts, err = (*z).encodedTxnHeaders.Fee[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Fee", zb0002)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0027 []byte
				zb0027, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskFee))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFee")
					return
				}
				(*z).encodedTxnHeaders.BitmaskFee = bitmask(zb0027)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0028 int
			var zb0029 bool
			zb0028, zb0029, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0028 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0028), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0029 {
				(*z).encodedTxnHeaders.FirstValid = nil
			} else if (*z).encodedTxnHeaders.FirstValid != nil && cap((*z).encodedTxnHeaders.FirstValid) >= zb0028 {
				(*z).encodedTxnHeaders.FirstValid = ((*z).encodedTxnHeaders.FirstValid)[:zb0028]
			} else {
				(*z).encodedTxnHeaders.FirstValid = make([]basics.Round, zb0028)
			}
			for zb0003 := range (*z).encodedTxnHeaders.FirstValid {
				bts, err = (*z).encodedTxnHeaders.FirstValid[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "FirstValid", zb0003)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0030 []byte
				zb0030, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskFirstValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFirstValid")
					return
				}
				(*z).encodedTxnHeaders.BitmaskFirstValid = bitmask(zb0030)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0031 int
			var zb0032 bool
			zb0031, zb0032, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0031 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0031), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0032 {
				(*z).encodedTxnHeaders.LastValid = nil
			} else if (*z).encodedTxnHeaders.LastValid != nil && cap((*z).encodedTxnHeaders.LastValid) >= zb0031 {
				(*z).encodedTxnHeaders.LastValid = ((*z).encodedTxnHeaders.LastValid)[:zb0031]
			} else {
				(*z).encodedTxnHeaders.LastValid = make([]basics.Round, zb0031)
			}
			for zb0004 := range (*z).encodedTxnHeaders.LastValid {
				bts, err = (*z).encodedTxnHeaders.LastValid[zb0004].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LastValid", zb0004)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0033 []byte
				zb0033, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskLastValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLastValid")
					return
				}
				(*z).encodedTxnHeaders.BitmaskLastValid = bitmask(zb0033)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0034 int
			var zb0035 bool
			zb0034, zb0035, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0034 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0034), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0035 {
				(*z).encodedTxnHeaders.Note = nil
			} else if (*z).encodedTxnHeaders.Note != nil && cap((*z).encodedTxnHeaders.Note) >= zb0034 {
				(*z).encodedTxnHeaders.Note = ((*z).encodedTxnHeaders.Note)[:zb0034]
			} else {
				(*z).encodedTxnHeaders.Note = make([][]byte, zb0034)
			}
			for zb0005 := range (*z).encodedTxnHeaders.Note {
				(*z).encodedTxnHeaders.Note[zb0005], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxnHeaders.Note[zb0005])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Note", zb0005)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0036 []byte
				zb0036, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskNote))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNote")
					return
				}
				(*z).encodedTxnHeaders.BitmaskNote = bitmask(zb0036)
			}
		}
		if zb0018 > 0 {
			zb0018--
			(*z).encodedTxnHeaders.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0037 []byte
				zb0037, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskGenesisID))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisID")
					return
				}
				(*z).encodedTxnHeaders.BitmaskGenesisID = bitmask(zb0037)
			}
		}
		if zb0018 > 0 {
			zb0018--
			bts, err = (*z).encodedTxnHeaders.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0038 []byte
				zb0038, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskGenesisHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisHash")
					return
				}
				(*z).encodedTxnHeaders.BitmaskGenesisHash = bitmask(zb0038)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0039 int
			var zb0040 bool
			zb0039, zb0040, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
			if zb0039 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0039), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
			if zb0040 {
				(*z).encodedTxnHeaders.Lease = nil
			} else if (*z).encodedTxnHeaders.Lease != nil && cap((*z).encodedTxnHeaders.Lease) >= zb0039 {
				(*z).encodedTxnHeaders.Lease = ((*z).encodedTxnHeaders.Lease)[:zb0039]
			} else {
				(*z).encodedTxnHeaders.Lease = make([][32]byte, zb0039)
			}
			for zb0006 := range (*z).encodedTxnHeaders.Lease {
				bts, err = msgp.ReadExactBytes(bts, ((*z).encodedTxnHeaders.Lease[zb0006])[:])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Lease", zb0006)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0041 []byte
				zb0041, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskLease))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLease")
					return
				}
				(*z).encodedTxnHeaders.BitmaskLease = bitmask(zb0041)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0042 int
			var zb0043 bool
			zb0042, zb0043, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
			if zb0042 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0042), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
			if zb0043 {
				(*z).encodedTxnHeaders.RekeyTo = nil
			} else if (*z).encodedTxnHeaders.RekeyTo != nil && cap((*z).encodedTxnHeaders.RekeyTo) >= zb0042 {
				(*z).encodedTxnHeaders.RekeyTo = ((*z).encodedTxnHeaders.RekeyTo)[:zb0042]
			} else {
				(*z).encodedTxnHeaders.RekeyTo = make([]basics.Address, zb0042)
			}
			for zb0008 := range (*z).encodedTxnHeaders.RekeyTo {
				bts, err = (*z).encodedTxnHeaders.RekeyTo[zb0008].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "RekeyTo", zb0008)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0044 []byte
				zb0044, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskRekeyTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskRekeyTo")
					return
				}
				(*z).encodedTxnHeaders.BitmaskRekeyTo = bitmask(zb0044)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0045 int
			var zb0046 bool
			zb0045, zb0046, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
			if zb0045 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0045), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
			if zb0046 {
				(*z).encodedKeyregTxnFields.VotePK = nil
			} else if (*z).encodedKeyregTxnFields.VotePK != nil && cap((*z).encodedKeyregTxnFields.VotePK) >= zb0045 {
				(*z).encodedKeyregTxnFields.VotePK = ((*z).encodedKeyregTxnFields.VotePK)[:zb0045]
			} else {
				(*z).encodedKeyregTxnFields.VotePK = make([]crypto.OneTimeSignatureVerifier, zb0045)
			}
			for zb0009 := range (*z).encodedKeyregTxnFields.VotePK {
				bts, err = (*z).encodedKeyregTxnFields.VotePK[zb0009].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VotePK", zb0009)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0047 []byte
				zb0047, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskVotePK))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVotePK")
					return
				}
				(*z).encodedKeyregTxnFields.BitmaskVotePK = bitmask(zb0047)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0048 int
			var zb0049 bool
			zb0048, zb0049, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
			if zb0048 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0048), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
			if zb0049 {
				(*z).encodedKeyregTxnFields.SelectionPK = nil
			} else if (*z).encodedKeyregTxnFields.SelectionPK != nil && cap((*z).encodedKeyregTxnFields.SelectionPK) >= zb0048 {
				(*z).encodedKeyregTxnFields.SelectionPK = ((*z).encodedKeyregTxnFields.SelectionPK)[:zb0048]
			} else {
				(*z).encodedKeyregTxnFields.SelectionPK = make([]crypto.VRFVerifier, zb0048)
			}
			for zb0010 := range (*z).encodedKeyregTxnFields.SelectionPK {
				bts, err = (*z).encodedKeyregTxnFields.SelectionPK[zb0010].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SelectionPK", zb0010)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0050 []byte
				zb0050, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskSelectionPK))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSelectionPK")
					return
				}
				(*z).encodedKeyregTxnFields.BitmaskSelectionPK = bitmask(zb0050)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0051 int
			var zb0052 bool
			zb0051, zb0052, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0051 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0051), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0052 {
				(*z).encodedKeyregTxnFields.VoteFirst = nil
			} else if (*z).encodedKeyregTxnFields.VoteFirst != nil && cap((*z).encodedKeyregTxnFields.VoteFirst) >= zb0051 {
				(*z).encodedKeyregTxnFields.VoteFirst = ((*z).encodedKeyregTxnFields.VoteFirst)[:zb0051]
			} else {
				(*z).encodedKeyregTxnFields.VoteFirst = make([]basics.Round, zb0051)
			}
			for zb0011 := range (*z).encodedKeyregTxnFields.VoteFirst {
				bts, err = (*z).encodedKeyregTxnFields.VoteFirst[zb0011].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteFirst", zb0011)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0053 []byte
				zb0053, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskVoteFirst))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteFirst")
					return
				}
				(*z).encodedKeyregTxnFields.BitmaskVoteFirst = bitmask(zb0053)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0054 int
			var zb0055 bool
			zb0054, zb0055, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0054 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0054), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0055 {
				(*z).encodedKeyregTxnFields.VoteLast = nil
			} else if (*z).encodedKeyregTxnFields.VoteLast != nil && cap((*z).encodedKeyregTxnFields.VoteLast) >= zb0054 {
				(*z).encodedKeyregTxnFields.VoteLast = ((*z).encodedKeyregTxnFields.VoteLast)[:zb0054]
			} else {
				(*z).encodedKeyregTxnFields.VoteLast = make([]basics.Round, zb0054)
			}
			for zb0012 := range (*z).encodedKeyregTxnFields.VoteLast {
				bts, err = (*z).encodedKeyregTxnFields.VoteLast[zb0012].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteLast", zb0012)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0056 []byte
				zb0056, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskVoteLast))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteLast")
					return
				}
				(*z).encodedKeyregTxnFields.BitmaskVoteLast = bitmask(zb0056)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0057 int
			var zb0058 bool
			zb0057, zb0058, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0057 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0057), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0058 {
				(*z).encodedKeyregTxnFields.VoteKeyDilution = nil
			} else if (*z).encodedKeyregTxnFields.VoteKeyDilution != nil && cap((*z).encodedKeyregTxnFields.VoteKeyDilution) >= zb0057 {
				(*z).encodedKeyregTxnFields.VoteKeyDilution = ((*z).encodedKeyregTxnFields.VoteKeyDilution)[:zb0057]
			} else {
				(*z).encodedKeyregTxnFields.VoteKeyDilution = make([]uint64, zb0057)
			}
			for zb0013 := range (*z).encodedKeyregTxnFields.VoteKeyDilution {
				(*z).encodedKeyregTxnFields.VoteKeyDilution[zb0013], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution", zb0013)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0059 []byte
				zb0059, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskVoteKeyDilution))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteKeyDilution")
					return
				}
				(*z).encodedKeyregTxnFields.BitmaskVoteKeyDilution = bitmask(zb0059)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0060 int
			var zb0061 bool
			zb0060, zb0061, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Nonparticipation")
				return
			}
			if zb0060 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0060), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Nonparticipation")
				return
			}
			if zb0061 {
				(*z).encodedKeyregTxnFields.Nonparticipation = nil
			} else if (*z).encodedKeyregTxnFields.Nonparticipation != nil && cap((*z).encodedKeyregTxnFields.Nonparticipation) >= zb0060 {
				(*z).encodedKeyregTxnFields.Nonparticipation = ((*z).encodedKeyregTxnFields.Nonparticipation)[:zb0060]
			} else {
				(*z).encodedKeyregTxnFields.Nonparticipation = make([]bool, zb0060)
			}
			for zb0014 := range (*z).encodedKeyregTxnFields.Nonparticipation {
				(*z).encodedKeyregTxnFields.Nonparticipation[zb0014], bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Nonparticipation", zb0014)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0062 []byte
				zb0062, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskNonparticipation))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNonparticipation")
					return
				}
				(*z).encodedKeyregTxnFields.BitmaskNonparticipation = bitmask(zb0062)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0063 int
			var zb0064 bool
			zb0063, zb0064, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
			if zb0063 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0063), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
			if zb0064 {
				(*z).encodedPaymentTxnFields.Receiver = nil
			} else if (*z).encodedPaymentTxnFields.Receiver != nil && cap((*z).encodedPaymentTxnFields.Receiver) >= zb0063 {
				(*z).encodedPaymentTxnFields.Receiver = ((*z).encodedPaymentTxnFields.Receiver)[:zb0063]
			} else {
				(*z).encodedPaymentTxnFields.Receiver = make([]basics.Address, zb0063)
			}
			for zb0015 := range (*z).encodedPaymentTxnFields.Receiver {
				bts, err = (*z).encodedPaymentTxnFields.Receiver[zb0015].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Receiver", zb0015)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0065 []byte
				zb0065, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedPaymentTxnFields.BitmaskReceiver))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReceiver")
					return
				}
				(*z).encodedPaymentTxnFields.BitmaskReceiver = bitmask(zb0065)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0066 int
			var zb0067 bool
			zb0066, zb0067, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0066 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0066), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0067 {
				(*z).encodedPaymentTxnFields.Amount = nil
			} else if (*z).encodedPaymentTxnFields.Amount != nil && cap((*z).encodedPaymentTxnFields.Amount) >= zb0066 {
				(*z).encodedPaymentTxnFields.Amount = ((*z).encodedPaymentTxnFields.Amount)[:zb0066]
			} else {
				(*z).encodedPaymentTxnFields.Amount = make([]basics.MicroAlgos, zb0066)
			}
			for zb0016 := range (*z).encodedPaymentTxnFields.Amount {
				bts, err = (*z).encodedPaymentTxnFields.Amount[zb0016].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Amount", zb0016)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0068 []byte
				zb0068, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedPaymentTxnFields.BitmaskAmount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAmount")
					return
				}
				(*z).encodedPaymentTxnFields.BitmaskAmount = bitmask(zb0068)
			}
		}
		if zb0018 > 0 {
			zb0018--
			var zb0069 int
			var zb0070 bool
			zb0069, zb0070, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
			if zb0069 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0069), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
			if zb0070 {
				(*z).encodedPaymentTxnFields.CloseRemainderTo = nil
			} else if (*z).encodedPaymentTxnFields.CloseRemainderTo != nil && cap((*z).encodedPaymentTxnFields.CloseRemainderTo) >= zb0069 {
				(*z).encodedPaymentTxnFields.CloseRemainderTo = ((*z).encodedPaymentTxnFields.CloseRemainderTo)[:zb0069]
			} else {
				(*z).encodedPaymentTxnFields.CloseRemainderTo = make([]basics.Address, zb0069)
			}
			for zb0017 := range (*z).encodedPaymentTxnFields.CloseRemainderTo {
				bts, err = (*z).encodedPaymentTxnFields.CloseRemainderTo[zb0017].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo", zb0017)
					return
				}
			}
		}
		if zb0018 > 0 {
			zb0018--
			{
				var zb0071 []byte
				zb0071, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCloseRemainderTo")
					return
				}
				(*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo = bitmask(zb0071)
			}
		}
		if zb0018 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0018)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0019 {
			(*z) = encodedTxns{}
		}
		for zb0018 > 0 {
			zb0018--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "type":
				var zb0072 int
				zb0072, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
				if zb0072 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0072), uint64(maxEncodedTransactionGroup))
					return
				}
				(*z).TxType, bts, err = msgp.ReadBytesBytes(bts, (*z).TxType)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
			case "typebm":
				{
					var zb0073 []byte
					zb0073, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskTxType))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTxType")
						return
					}
					(*z).BitmaskTxType = bitmask(zb0073)
				}
			case "snd":
				var zb0074 int
				var zb0075 bool
				zb0074, zb0075, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				if zb0074 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0074), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Sender")
					return
				}
				if zb0075 {
					(*z).encodedTxnHeaders.Sender = nil
				} else if (*z).encodedTxnHeaders.Sender != nil && cap((*z).encodedTxnHeaders.Sender) >= zb0074 {
					(*z).encodedTxnHeaders.Sender = ((*z).encodedTxnHeaders.Sender)[:zb0074]
				} else {
					(*z).encodedTxnHeaders.Sender = make([]basics.Address, zb0074)
				}
				for zb0001 := range (*z).encodedTxnHeaders.Sender {
					bts, err = (*z).encodedTxnHeaders.Sender[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sender", zb0001)
						return
					}
				}
			case "sndbm":
				{
					var zb0076 []byte
					zb0076, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskSender))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSender")
						return
					}
					(*z).encodedTxnHeaders.BitmaskSender = bitmask(zb0076)
				}
			case "fee":
				var zb0077 int
				var zb0078 bool
				zb0077, zb0078, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0077 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0077), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0078 {
					(*z).encodedTxnHeaders.Fee = nil
				} else if (*z).encodedTxnHeaders.Fee != nil && cap((*z).encodedTxnHeaders.Fee) >= zb0077 {
					(*z).encodedTxnHeaders.Fee = ((*z).encodedTxnHeaders.Fee)[:zb0077]
				} else {
					(*z).encodedTxnHeaders.Fee = make([]basics.MicroAlgos, zb0077)
				}
				for zb0002 := range (*z).encodedTxnHeaders.Fee {
					bts, err = (*z).encodedTxnHeaders.Fee[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Fee", zb0002)
						return
					}
				}
			case "feebm":
				{
					var zb0079 []byte
					zb0079, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskFee))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFee")
						return
					}
					(*z).encodedTxnHeaders.BitmaskFee = bitmask(zb0079)
				}
			case "fv":
				var zb0080 int
				var zb0081 bool
				zb0080, zb0081, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0080 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0080), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0081 {
					(*z).encodedTxnHeaders.FirstValid = nil
				} else if (*z).encodedTxnHeaders.FirstValid != nil && cap((*z).encodedTxnHeaders.FirstValid) >= zb0080 {
					(*z).encodedTxnHeaders.FirstValid = ((*z).encodedTxnHeaders.FirstValid)[:zb0080]
				} else {
					(*z).encodedTxnHeaders.FirstValid = make([]basics.Round, zb0080)
				}
				for zb0003 := range (*z).encodedTxnHeaders.FirstValid {
					bts, err = (*z).encodedTxnHeaders.FirstValid[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "FirstValid", zb0003)
						return
					}
				}
			case "fvbm":
				{
					var zb0082 []byte
					zb0082, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskFirstValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFirstValid")
						return
					}
					(*z).encodedTxnHeaders.BitmaskFirstValid = bitmask(zb0082)
				}
			case "lv":
				var zb0083 int
				var zb0084 bool
				zb0083, zb0084, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0083 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0083), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0084 {
					(*z).encodedTxnHeaders.LastValid = nil
				} else if (*z).encodedTxnHeaders.LastValid != nil && cap((*z).encodedTxnHeaders.LastValid) >= zb0083 {
					(*z).encodedTxnHeaders.LastValid = ((*z).encodedTxnHeaders.LastValid)[:zb0083]
				} else {
					(*z).encodedTxnHeaders.LastValid = make([]basics.Round, zb0083)
				}
				for zb0004 := range (*z).encodedTxnHeaders.LastValid {
					bts, err = (*z).encodedTxnHeaders.LastValid[zb0004].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastValid", zb0004)
						return
					}
				}
			case "lvbm":
				{
					var zb0085 []byte
					zb0085, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskLastValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLastValid")
						return
					}
					(*z).encodedTxnHeaders.BitmaskLastValid = bitmask(zb0085)
				}
			case "note":
				var zb0086 int
				var zb0087 bool
				zb0086, zb0087, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0086 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0086), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0087 {
					(*z).encodedTxnHeaders.Note = nil
				} else if (*z).encodedTxnHeaders.Note != nil && cap((*z).encodedTxnHeaders.Note) >= zb0086 {
					(*z).encodedTxnHeaders.Note = ((*z).encodedTxnHeaders.Note)[:zb0086]
				} else {
					(*z).encodedTxnHeaders.Note = make([][]byte, zb0086)
				}
				for zb0005 := range (*z).encodedTxnHeaders.Note {
					(*z).encodedTxnHeaders.Note[zb0005], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedTxnHeaders.Note[zb0005])
					if err != nil {
						err = msgp.WrapError(err, "Note", zb0005)
						return
					}
				}
			case "notebm":
				{
					var zb0088 []byte
					zb0088, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskNote))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNote")
						return
					}
					(*z).encodedTxnHeaders.BitmaskNote = bitmask(zb0088)
				}
			case "gen":
				(*z).encodedTxnHeaders.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "genbm":
				{
					var zb0089 []byte
					zb0089, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskGenesisID))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisID")
						return
					}
					(*z).encodedTxnHeaders.BitmaskGenesisID = bitmask(zb0089)
				}
			case "gh":
				bts, err = (*z).encodedTxnHeaders.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "ghbm":
				{
					var zb0090 []byte
					zb0090, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskGenesisHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisHash")
						return
					}
					(*z).encodedTxnHeaders.BitmaskGenesisHash = bitmask(zb0090)
				}
			case "lx":
				var zb0091 int
				var zb0092 bool
				zb0091, zb0092, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
				if zb0091 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0091), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Lease")
					return
				}
				if zb0092 {
					(*z).encodedTxnHeaders.Lease = nil
				} else if (*z).encodedTxnHeaders.Lease != nil && cap((*z).encodedTxnHeaders.Lease) >= zb0091 {
					(*z).encodedTxnHeaders.Lease = ((*z).encodedTxnHeaders.Lease)[:zb0091]
				} else {
					(*z).encodedTxnHeaders.Lease = make([][32]byte, zb0091)
				}
				for zb0006 := range (*z).encodedTxnHeaders.Lease {
					bts, err = msgp.ReadExactBytes(bts, ((*z).encodedTxnHeaders.Lease[zb0006])[:])
					if err != nil {
						err = msgp.WrapError(err, "Lease", zb0006)
						return
					}
				}
			case "lxbm":
				{
					var zb0093 []byte
					zb0093, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskLease))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLease")
						return
					}
					(*z).encodedTxnHeaders.BitmaskLease = bitmask(zb0093)
				}
			case "rekey":
				var zb0094 int
				var zb0095 bool
				zb0094, zb0095, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
				if zb0094 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0094), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
				if zb0095 {
					(*z).encodedTxnHeaders.RekeyTo = nil
				} else if (*z).encodedTxnHeaders.RekeyTo != nil && cap((*z).encodedTxnHeaders.RekeyTo) >= zb0094 {
					(*z).encodedTxnHeaders.RekeyTo = ((*z).encodedTxnHeaders.RekeyTo)[:zb0094]
				} else {
					(*z).encodedTxnHeaders.RekeyTo = make([]basics.Address, zb0094)
				}
				for zb0008 := range (*z).encodedTxnHeaders.RekeyTo {
					bts, err = (*z).encodedTxnHeaders.RekeyTo[zb0008].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "RekeyTo", zb0008)
						return
					}
				}
			case "rekeybm":
				{
					var zb0096 []byte
					zb0096, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedTxnHeaders.BitmaskRekeyTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskRekeyTo")
						return
					}
					(*z).encodedTxnHeaders.BitmaskRekeyTo = bitmask(zb0096)
				}
			case "votekey":
				var zb0097 int
				var zb0098 bool
				zb0097, zb0098, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
				if zb0097 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0097), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VotePK")
					return
				}
				if zb0098 {
					(*z).encodedKeyregTxnFields.VotePK = nil
				} else if (*z).encodedKeyregTxnFields.VotePK != nil && cap((*z).encodedKeyregTxnFields.VotePK) >= zb0097 {
					(*z).encodedKeyregTxnFields.VotePK = ((*z).encodedKeyregTxnFields.VotePK)[:zb0097]
				} else {
					(*z).encodedKeyregTxnFields.VotePK = make([]crypto.OneTimeSignatureVerifier, zb0097)
				}
				for zb0009 := range (*z).encodedKeyregTxnFields.VotePK {
					bts, err = (*z).encodedKeyregTxnFields.VotePK[zb0009].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VotePK", zb0009)
						return
					}
				}
			case "votekeybm":
				{
					var zb0099 []byte
					zb0099, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskVotePK))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVotePK")
						return
					}
					(*z).encodedKeyregTxnFields.BitmaskVotePK = bitmask(zb0099)
				}
			case "selkey":
				var zb0100 int
				var zb0101 bool
				zb0100, zb0101, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
				if zb0100 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0100), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
				if zb0101 {
					(*z).encodedKeyregTxnFields.SelectionPK = nil
				} else if (*z).encodedKeyregTxnFields.SelectionPK != nil && cap((*z).encodedKeyregTxnFields.SelectionPK) >= zb0100 {
					(*z).encodedKeyregTxnFields.SelectionPK = ((*z).encodedKeyregTxnFields.SelectionPK)[:zb0100]
				} else {
					(*z).encodedKeyregTxnFields.SelectionPK = make([]crypto.VRFVerifier, zb0100)
				}
				for zb0010 := range (*z).encodedKeyregTxnFields.SelectionPK {
					bts, err = (*z).encodedKeyregTxnFields.SelectionPK[zb0010].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "SelectionPK", zb0010)
						return
					}
				}
			case "selkeybm":
				{
					var zb0102 []byte
					zb0102, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskSelectionPK))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSelectionPK")
						return
					}
					(*z).encodedKeyregTxnFields.BitmaskSelectionPK = bitmask(zb0102)
				}
			case "votefst":
				var zb0103 int
				var zb0104 bool
				zb0103, zb0104, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0103 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0103), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0104 {
					(*z).encodedKeyregTxnFields.VoteFirst = nil
				} else if (*z).encodedKeyregTxnFields.VoteFirst != nil && cap((*z).encodedKeyregTxnFields.VoteFirst) >= zb0103 {
					(*z).encodedKeyregTxnFields.VoteFirst = ((*z).encodedKeyregTxnFields.VoteFirst)[:zb0103]
				} else {
					(*z).encodedKeyregTxnFields.VoteFirst = make([]basics.Round, zb0103)
				}
				for zb0011 := range (*z).encodedKeyregTxnFields.VoteFirst {
					bts, err = (*z).encodedKeyregTxnFields.VoteFirst[zb0011].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteFirst", zb0011)
						return
					}
				}
			case "votefstbm":
				{
					var zb0105 []byte
					zb0105, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskVoteFirst))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteFirst")
						return
					}
					(*z).encodedKeyregTxnFields.BitmaskVoteFirst = bitmask(zb0105)
				}
			case "votelst":
				var zb0106 int
				var zb0107 bool
				zb0106, zb0107, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0106 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0106), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0107 {
					(*z).encodedKeyregTxnFields.VoteLast = nil
				} else if (*z).encodedKeyregTxnFields.VoteLast != nil && cap((*z).encodedKeyregTxnFields.VoteLast) >= zb0106 {
					(*z).encodedKeyregTxnFields.VoteLast = ((*z).encodedKeyregTxnFields.VoteLast)[:zb0106]
				} else {
					(*z).encodedKeyregTxnFields.VoteLast = make([]basics.Round, zb0106)
				}
				for zb0012 := range (*z).encodedKeyregTxnFields.VoteLast {
					bts, err = (*z).encodedKeyregTxnFields.VoteLast[zb0012].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteLast", zb0012)
						return
					}
				}
			case "votelstbm":
				{
					var zb0108 []byte
					zb0108, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskVoteLast))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteLast")
						return
					}
					(*z).encodedKeyregTxnFields.BitmaskVoteLast = bitmask(zb0108)
				}
			case "votekd":
				var zb0109 int
				var zb0110 bool
				zb0109, zb0110, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0109 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0109), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0110 {
					(*z).encodedKeyregTxnFields.VoteKeyDilution = nil
				} else if (*z).encodedKeyregTxnFields.VoteKeyDilution != nil && cap((*z).encodedKeyregTxnFields.VoteKeyDilution) >= zb0109 {
					(*z).encodedKeyregTxnFields.VoteKeyDilution = ((*z).encodedKeyregTxnFields.VoteKeyDilution)[:zb0109]
				} else {
					(*z).encodedKeyregTxnFields.VoteKeyDilution = make([]uint64, zb0109)
				}
				for zb0013 := range (*z).encodedKeyregTxnFields.VoteKeyDilution {
					(*z).encodedKeyregTxnFields.VoteKeyDilution[zb0013], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteKeyDilution", zb0013)
						return
					}
				}
			case "votekdbm":
				{
					var zb0111 []byte
					zb0111, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskVoteKeyDilution))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteKeyDilution")
						return
					}
					(*z).encodedKeyregTxnFields.BitmaskVoteKeyDilution = bitmask(zb0111)
				}
			case "nonpart":
				var zb0112 int
				var zb0113 bool
				zb0112, zb0113, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Nonparticipation")
					return
				}
				if zb0112 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0112), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Nonparticipation")
					return
				}
				if zb0113 {
					(*z).encodedKeyregTxnFields.Nonparticipation = nil
				} else if (*z).encodedKeyregTxnFields.Nonparticipation != nil && cap((*z).encodedKeyregTxnFields.Nonparticipation) >= zb0112 {
					(*z).encodedKeyregTxnFields.Nonparticipation = ((*z).encodedKeyregTxnFields.Nonparticipation)[:zb0112]
				} else {
					(*z).encodedKeyregTxnFields.Nonparticipation = make([]bool, zb0112)
				}
				for zb0014 := range (*z).encodedKeyregTxnFields.Nonparticipation {
					(*z).encodedKeyregTxnFields.Nonparticipation[zb0014], bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Nonparticipation", zb0014)
						return
					}
				}
			case "nonpartbm":
				{
					var zb0114 []byte
					zb0114, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedKeyregTxnFields.BitmaskNonparticipation))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNonparticipation")
						return
					}
					(*z).encodedKeyregTxnFields.BitmaskNonparticipation = bitmask(zb0114)
				}
			case "rcv":
				var zb0115 int
				var zb0116 bool
				zb0115, zb0116, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
				if zb0115 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0115), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Receiver")
					return
				}
				if zb0116 {
					(*z).encodedPaymentTxnFields.Receiver = nil
				} else if (*z).encodedPaymentTxnFields.Receiver != nil && cap((*z).encodedPaymentTxnFields.Receiver) >= zb0115 {
					(*z).encodedPaymentTxnFields.Receiver = ((*z).encodedPaymentTxnFields.Receiver)[:zb0115]
				} else {
					(*z).encodedPaymentTxnFields.Receiver = make([]basics.Address, zb0115)
				}
				for zb0015 := range (*z).encodedPaymentTxnFields.Receiver {
					bts, err = (*z).encodedPaymentTxnFields.Receiver[zb0015].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Receiver", zb0015)
						return
					}
				}
			case "rcvbm":
				{
					var zb0117 []byte
					zb0117, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedPaymentTxnFields.BitmaskReceiver))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReceiver")
						return
					}
					(*z).encodedPaymentTxnFields.BitmaskReceiver = bitmask(zb0117)
				}
			case "amt":
				var zb0118 int
				var zb0119 bool
				zb0118, zb0119, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0118 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0118), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0119 {
					(*z).encodedPaymentTxnFields.Amount = nil
				} else if (*z).encodedPaymentTxnFields.Amount != nil && cap((*z).encodedPaymentTxnFields.Amount) >= zb0118 {
					(*z).encodedPaymentTxnFields.Amount = ((*z).encodedPaymentTxnFields.Amount)[:zb0118]
				} else {
					(*z).encodedPaymentTxnFields.Amount = make([]basics.MicroAlgos, zb0118)
				}
				for zb0016 := range (*z).encodedPaymentTxnFields.Amount {
					bts, err = (*z).encodedPaymentTxnFields.Amount[zb0016].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Amount", zb0016)
						return
					}
				}
			case "amtbm":
				{
					var zb0120 []byte
					zb0120, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedPaymentTxnFields.BitmaskAmount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAmount")
						return
					}
					(*z).encodedPaymentTxnFields.BitmaskAmount = bitmask(zb0120)
				}
			case "close":
				var zb0121 int
				var zb0122 bool
				zb0121, zb0122, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
				if zb0121 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0121), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
				if zb0122 {
					(*z).encodedPaymentTxnFields.CloseRemainderTo = nil
				} else if (*z).encodedPaymentTxnFields.CloseRemainderTo != nil && cap((*z).encodedPaymentTxnFields.CloseRemainderTo) >= zb0121 {
					(*z).encodedPaymentTxnFields.CloseRemainderTo = ((*z).encodedPaymentTxnFields.CloseRemainderTo)[:zb0121]
				} else {
					(*z).encodedPaymentTxnFields.CloseRemainderTo = make([]basics.Address, zb0121)
				}
				for zb0017 := range (*z).encodedPaymentTxnFields.CloseRemainderTo {
					bts, err = (*z).encodedPaymentTxnFields.CloseRemainderTo[zb0017].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CloseRemainderTo", zb0017)
						return
					}
				}
			case "closebm":
				{
					var zb0123 []byte
					zb0123, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCloseRemainderTo")
						return
					}
					(*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo = bitmask(zb0123)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedTxns) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedTxns)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedTxns) Msgsize() (s int) {
	s = 3 + 5 + msgp.BytesPrefixSize + len((*z).TxType) + 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskTxType)) + 4 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).encodedTxnHeaders.Sender {
		s += (*z).encodedTxnHeaders.Sender[zb0001].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskSender)) + 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).encodedTxnHeaders.Fee {
		s += (*z).encodedTxnHeaders.Fee[zb0002].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskFee)) + 3 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).encodedTxnHeaders.FirstValid {
		s += (*z).encodedTxnHeaders.FirstValid[zb0003].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskFirstValid)) + 3 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).encodedTxnHeaders.LastValid {
		s += (*z).encodedTxnHeaders.LastValid[zb0004].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskLastValid)) + 5 + msgp.ArrayHeaderSize
	for zb0005 := range (*z).encodedTxnHeaders.Note {
		s += msgp.BytesPrefixSize + len((*z).encodedTxnHeaders.Note[zb0005])
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskNote)) + 4 + msgp.StringPrefixSize + len((*z).encodedTxnHeaders.GenesisID) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskGenesisID)) + 3 + (*z).encodedTxnHeaders.GenesisHash.Msgsize() + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskGenesisHash)) + 3 + msgp.ArrayHeaderSize + (len((*z).encodedTxnHeaders.Lease) * (32 * (msgp.ByteSize))) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskLease)) + 6 + msgp.ArrayHeaderSize
	for zb0008 := range (*z).encodedTxnHeaders.RekeyTo {
		s += (*z).encodedTxnHeaders.RekeyTo[zb0008].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedTxnHeaders.BitmaskRekeyTo)) + 8 + msgp.ArrayHeaderSize
	for zb0009 := range (*z).encodedKeyregTxnFields.VotePK {
		s += (*z).encodedKeyregTxnFields.VotePK[zb0009].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedKeyregTxnFields.BitmaskVotePK)) + 7 + msgp.ArrayHeaderSize
	for zb0010 := range (*z).encodedKeyregTxnFields.SelectionPK {
		s += (*z).encodedKeyregTxnFields.SelectionPK[zb0010].Msgsize()
	}
	s += 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedKeyregTxnFields.BitmaskSelectionPK)) + 8 + msgp.ArrayHeaderSize
	for zb0011 := range (*z).encodedKeyregTxnFields.VoteFirst {
		s += (*z).encodedKeyregTxnFields.VoteFirst[zb0011].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedKeyregTxnFields.BitmaskVoteFirst)) + 8 + msgp.ArrayHeaderSize
	for zb0012 := range (*z).encodedKeyregTxnFields.VoteLast {
		s += (*z).encodedKeyregTxnFields.VoteLast[zb0012].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedKeyregTxnFields.BitmaskVoteLast)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedKeyregTxnFields.VoteKeyDilution) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedKeyregTxnFields.BitmaskVoteKeyDilution)) + 8 + msgp.ArrayHeaderSize + (len((*z).encodedKeyregTxnFields.Nonparticipation) * (msgp.BoolSize)) + 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedKeyregTxnFields.BitmaskNonparticipation)) + 4 + msgp.ArrayHeaderSize
	for zb0015 := range (*z).encodedPaymentTxnFields.Receiver {
		s += (*z).encodedPaymentTxnFields.Receiver[zb0015].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedPaymentTxnFields.BitmaskReceiver)) + 4 + msgp.ArrayHeaderSize
	for zb0016 := range (*z).encodedPaymentTxnFields.Amount {
		s += (*z).encodedPaymentTxnFields.Amount[zb0016].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedPaymentTxnFields.BitmaskAmount)) + 6 + msgp.ArrayHeaderSize
	for zb0017 := range (*z).encodedPaymentTxnFields.CloseRemainderTo {
		s += (*z).encodedPaymentTxnFields.CloseRemainderTo[zb0017].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedTxns) MsgIsZero() bool {
	return (len((*z).TxType) == 0) && (len((*z).BitmaskTxType) == 0) && (len((*z).encodedTxnHeaders.Sender) == 0) && (len((*z).encodedTxnHeaders.BitmaskSender) == 0) && (len((*z).encodedTxnHeaders.Fee) == 0) && (len((*z).encodedTxnHeaders.BitmaskFee) == 0) && (len((*z).encodedTxnHeaders.FirstValid) == 0) && (len((*z).encodedTxnHeaders.BitmaskFirstValid) == 0) && (len((*z).encodedTxnHeaders.LastValid) == 0) && (len((*z).encodedTxnHeaders.BitmaskLastValid) == 0) && (len((*z).encodedTxnHeaders.Note) == 0) && (len((*z).encodedTxnHeaders.BitmaskNote) == 0) && ((*z).encodedTxnHeaders.GenesisID == "") && (len((*z).encodedTxnHeaders.BitmaskGenesisID) == 0) && ((*z).encodedTxnHeaders.GenesisHash.MsgIsZero()) && (len((*z).encodedTxnHeaders.BitmaskGenesisHash) == 0) && (len((*z).encodedTxnHeaders.Lease) == 0) && (len((*z).encodedTxnHeaders.BitmaskLease) == 0) && (len((*z).encodedTxnHeaders.RekeyTo) == 0) && (len((*z).encodedTxnHeaders.BitmaskRekeyTo) == 0) && (len((*z).encodedKeyregTxnFields.VotePK) == 0) && (len((*z).encodedKeyregTxnFields.BitmaskVotePK) == 0) && (len((*z).encodedKeyregTxnFields.SelectionPK) == 0) && (len((*z).encodedKeyregTxnFields.BitmaskSelectionPK) == 0) && (len((*z).encodedKeyregTxnFields.VoteFirst) == 0) && (len((*z).encodedKeyregTxnFields.BitmaskVoteFirst) == 0) && (len((*z).encodedKeyregTxnFields.VoteLast) == 0) && (len((*z).encodedKeyregTxnFields.BitmaskVoteLast) == 0) && (len((*z).encodedKeyregTxnFields.VoteKeyDilution) == 0) && (len((*z).encodedKeyregTxnFields.BitmaskVoteKeyDilution) == 0) && (len((*z).encodedKeyregTxnFields.Nonparticipation) == 0) && (len((*z).encodedKeyregTxnFields.BitmaskNonparticipation) == 0) && (len((*z).encodedPaymentTxnFields.Receiver) == 0) && (len((*z).encodedPaymentTxnFields.BitmaskReceiver) == 0) && (len((*z).encodedPaymentTxnFields.Amount) == 0) && (len((*z).encodedPaymentTxnFields.BitmaskAmount) == 0) && (len((*z).encodedPaymentTxnFields.CloseRemainderTo) == 0) && (len((*z).encodedPaymentTxnFields.BitmaskCloseRemainderTo) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *packedTransactionGroups) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 2 bits */
	if len((*z).Bytes) == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "g"
			o = append(o, 0xa1, 0x67)
			o = msgp.AppendBytes(o, (*z).Bytes)
		}
	}
	return
}

func (_ *packedTransactionGroups) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*packedTransactionGroups)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *packedTransactionGroups) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			var zb0003 int
			zb0003, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Bytes")
				return
			}
			if zb0003 > maxEncodedTransactionGroupBytes {
				err = msgp.ErrOverflow(uint64(zb0003), uint64(maxEncodedTransactionGroupBytes))
				return
			}
			(*z).Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).Bytes)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Bytes")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = packedTransactionGroups{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "g":
				var zb0004 int
				zb0004, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bytes")
					return
				}
				if zb0004 > maxEncodedTransactionGroupBytes {
					err = msgp.ErrOverflow(uint64(zb0004), uint64(maxEncodedTransactionGroupBytes))
					return
				}
				(*z).Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).Bytes)
				if err != nil {
					err = msgp.WrapError(err, "Bytes")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *packedTransactionGroups) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*packedTransactionGroups)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *packedTransactionGroups) Msgsize() (s int) {
	s = 1 + 2 + msgp.BytesPrefixSize + len((*z).Bytes)
	return
}

// MsgIsZero returns whether this is a zero value
func (z *packedTransactionGroups) MsgIsZero() bool {
	return (len((*z).Bytes) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *requestParams) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 3 bits */
	if (*z).Modulator == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Offset == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "m"
			o = append(o, 0xa1, 0x6d)
			o = msgp.AppendByte(o, (*z).Modulator)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "o"
			o = append(o, 0xa1, 0x6f)
			o = msgp.AppendByte(o, (*z).Offset)
		}
	}
	return
}

func (_ *requestParams) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*requestParams)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *requestParams) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Offset, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Offset")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Modulator, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Modulator")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = requestParams{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "o":
				(*z).Offset, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Offset")
					return
				}
			case "m":
				(*z).Modulator, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Modulator")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *requestParams) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*requestParams)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *requestParams) Msgsize() (s int) {
	s = 1 + 2 + msgp.ByteSize + 2 + msgp.ByteSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *requestParams) MsgIsZero() bool {
	return ((*z).Offset == 0) && ((*z).Modulator == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *timingParams) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(4)
	var zb0002Mask uint8 /* 5 bits */
	if len((*z).AcceptedMsgSeq) == 0 {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	if (*z).NextMsgMinDelay == 0 {
		zb0002Len--
		zb0002Mask |= 0x4
	}
	if (*z).ResponseElapsedTime == 0 {
		zb0002Len--
		zb0002Mask |= 0x8
	}
	if (*z).RefTxnBlockMsgSeq == 0 {
		zb0002Len--
		zb0002Mask |= 0x10
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "a"
			o = append(o, 0xa1, 0x61)
			if (*z).AcceptedMsgSeq == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).AcceptedMsgSeq)))
			}
			for zb0001 := range (*z).AcceptedMsgSeq {
				o = msgp.AppendUint32(o, (*z).AcceptedMsgSeq[zb0001])
			}
		}
		if (zb0002Mask & 0x4) == 0 { // if not empty
			// string "m"
			o = append(o, 0xa1, 0x6d)
			o = msgp.AppendUint64(o, (*z).NextMsgMinDelay)
		}
		if (zb0002Mask & 0x8) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = msgp.AppendUint64(o, (*z).ResponseElapsedTime)
		}
		if (zb0002Mask & 0x10) == 0 { // if not empty
			// string "s"
			o = append(o, 0xa1, 0x73)
			o = msgp.AppendUint64(o, (*z).RefTxnBlockMsgSeq)
		}
	}
	return
}

func (_ *timingParams) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*timingParams)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *timingParams) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			(*z).RefTxnBlockMsgSeq, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RefTxnBlockMsgSeq")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).ResponseElapsedTime, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ResponseElapsedTime")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AcceptedMsgSeq")
				return
			}
			if zb0004 > maxAcceptedMsgSeq {
				err = msgp.ErrOverflow(uint64(zb0004), uint64(maxAcceptedMsgSeq))
				err = msgp.WrapError(err, "struct-from-array", "AcceptedMsgSeq")
				return
			}
			if zb0005 {
				(*z).AcceptedMsgSeq = nil
			} else if (*z).AcceptedMsgSeq != nil && cap((*z).AcceptedMsgSeq) >= zb0004 {
				(*z).AcceptedMsgSeq = ((*z).AcceptedMsgSeq)[:zb0004]
			} else {
				(*z).AcceptedMsgSeq = make([]uint32, zb0004)
			}
			for zb0001 := range (*z).AcceptedMsgSeq {
				(*z).AcceptedMsgSeq[zb0001], bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AcceptedMsgSeq", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).NextMsgMinDelay, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextMsgMinDelay")
				return
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = timingParams{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "s":
				(*z).RefTxnBlockMsgSeq, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RefTxnBlockMsgSeq")
					return
				}
			case "r":
				(*z).ResponseElapsedTime, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ResponseElapsedTime")
					return
				}
			case "a":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AcceptedMsgSeq")
					return
				}
				if zb0006 > maxAcceptedMsgSeq {
					err = msgp.ErrOverflow(uint64(zb0006), uint64(maxAcceptedMsgSeq))
					err = msgp.WrapError(err, "AcceptedMsgSeq")
					return
				}
				if zb0007 {
					(*z).AcceptedMsgSeq = nil
				} else if (*z).AcceptedMsgSeq != nil && cap((*z).AcceptedMsgSeq) >= zb0006 {
					(*z).AcceptedMsgSeq = ((*z).AcceptedMsgSeq)[:zb0006]
				} else {
					(*z).AcceptedMsgSeq = make([]uint32, zb0006)
				}
				for zb0001 := range (*z).AcceptedMsgSeq {
					(*z).AcceptedMsgSeq[zb0001], bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AcceptedMsgSeq", zb0001)
						return
					}
				}
			case "m":
				(*z).NextMsgMinDelay, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextMsgMinDelay")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *timingParams) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*timingParams)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *timingParams) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint64Size + 2 + msgp.Uint64Size + 2 + msgp.ArrayHeaderSize + (len((*z).AcceptedMsgSeq) * (msgp.Uint32Size)) + 2 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *timingParams) MsgIsZero() bool {
	return ((*z).RefTxnBlockMsgSeq == 0) && ((*z).ResponseElapsedTime == 0) && (len((*z).AcceptedMsgSeq) == 0) && ((*z).NextMsgMinDelay == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *transactionBlockMessage) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 7 bits */
	if (*z).TxnBloomFilter.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if len((*z).TransactionGroups.Bytes) == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if ((*z).UpdatedRequestParams.Offset == 0) && ((*z).UpdatedRequestParams.Modulator == 0) {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).MsgSync.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).Version == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "b"
			o = append(o, 0xa1, 0x62)
			o = (*z).TxnBloomFilter.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "g"
			o = append(o, 0xa1, 0x67)
			// omitempty: check for empty values
			zb0002Len := uint32(1)
			var zb0002Mask uint8 /* 2 bits */
			if len((*z).TransactionGroups.Bytes) == 0 {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x2) == 0 { // if not empty
				// string "g"
				o = append(o, 0xa1, 0x67)
				o = msgp.AppendBytes(o, (*z).TransactionGroups.Bytes)
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "p"
			o = append(o, 0xa1, 0x70)
			// omitempty: check for empty values
			zb0003Len := uint32(2)
			var zb0003Mask uint8 /* 3 bits */
			if (*z).UpdatedRequestParams.Modulator == 0 {
				zb0003Len--
				zb0003Mask |= 0x2
			}
			if (*z).UpdatedRequestParams.Offset == 0 {
				zb0003Len--
				zb0003Mask |= 0x4
			}
			// variable map header, size zb0003Len
			o = append(o, 0x80|uint8(zb0003Len))
			if (zb0003Mask & 0x2) == 0 { // if not empty
				// string "m"
				o = append(o, 0xa1, 0x6d)
				o = msgp.AppendByte(o, (*z).UpdatedRequestParams.Modulator)
			}
			if (zb0003Mask & 0x4) == 0 { // if not empty
				// string "o"
				o = append(o, 0xa1, 0x6f)
				o = msgp.AppendByte(o, (*z).UpdatedRequestParams.Offset)
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			o = (*z).MsgSync.MarshalMsg(o)
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "v"
			o = append(o, 0xa1, 0x76)
			o = msgp.AppendInt32(o, (*z).Version)
		}
	}
	return
}

func (_ *transactionBlockMessage) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*transactionBlockMessage)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *transactionBlockMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Version, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Version")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).TxnBloomFilter.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnBloomFilter")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0003 int
			var zb0004 bool
			zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams")
					return
				}
				if zb0003 > 0 {
					zb0003--
					(*z).UpdatedRequestParams.Offset, bts, err = msgp.ReadByteBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "struct-from-array", "Offset")
						return
					}
				}
				if zb0003 > 0 {
					zb0003--
					(*z).UpdatedRequestParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "struct-from-array", "Modulator")
						return
					}
				}
				if zb0003 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0003)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams")
					return
				}
				if zb0004 {
					(*z).UpdatedRequestParams = requestParams{}
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams")
						return
					}
					switch string(field) {
					case "o":
						(*z).UpdatedRequestParams.Offset, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "Offset")
							return
						}
					case "m":
						(*z).UpdatedRequestParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "Modulator")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "TransactionGroups")
					return
				}
				if zb0005 > 0 {
					zb0005--
					var zb0007 int
					zb0007, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "TransactionGroups", "struct-from-array", "Bytes")
						return
					}
					if zb0007 > maxEncodedTransactionGroupBytes {
						err = msgp.ErrOverflow(uint64(zb0007), uint64(maxEncodedTransactionGroupBytes))
						return
					}
					(*z).TransactionGroups.Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroups.Bytes)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "TransactionGroups", "struct-from-array", "Bytes")
						return
					}
				}
				if zb0005 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0005)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "TransactionGroups", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "TransactionGroups")
					return
				}
				if zb0006 {
					(*z).TransactionGroups = packedTransactionGroups{}
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "TransactionGroups")
						return
					}
					switch string(field) {
					case "g":
						var zb0008 int
						zb0008, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "TransactionGroups", "Bytes")
							return
						}
						if zb0008 > maxEncodedTransactionGroupBytes {
							err = msgp.ErrOverflow(uint64(zb0008), uint64(maxEncodedTransactionGroupBytes))
							return
						}
						(*z).TransactionGroups.Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroups.Bytes)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "TransactionGroups", "Bytes")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "TransactionGroups")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).MsgSync.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MsgSync")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = transactionBlockMessage{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "v":
				(*z).Version, bts, err = msgp.ReadInt32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Version")
					return
				}
			case "r":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "b":
				bts, err = (*z).TxnBloomFilter.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnBloomFilter")
					return
				}
			case "p":
				var zb0009 int
				var zb0010 bool
				zb0009, zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "UpdatedRequestParams")
						return
					}
					if zb0009 > 0 {
						zb0009--
						(*z).UpdatedRequestParams.Offset, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "UpdatedRequestParams", "struct-from-array", "Offset")
							return
						}
					}
					if zb0009 > 0 {
						zb0009--
						(*z).UpdatedRequestParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "UpdatedRequestParams", "struct-from-array", "Modulator")
							return
						}
					}
					if zb0009 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0009)
						if err != nil {
							err = msgp.WrapError(err, "UpdatedRequestParams", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "UpdatedRequestParams")
						return
					}
					if zb0010 {
						(*z).UpdatedRequestParams = requestParams{}
					}
					for zb0009 > 0 {
						zb0009--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "UpdatedRequestParams")
							return
						}
						switch string(field) {
						case "o":
							(*z).UpdatedRequestParams.Offset, bts, err = msgp.ReadByteBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "UpdatedRequestParams", "Offset")
								return
							}
						case "m":
							(*z).UpdatedRequestParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "UpdatedRequestParams", "Modulator")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "UpdatedRequestParams")
								return
							}
						}
					}
				}
			case "g":
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "TransactionGroups")
						return
					}
					if zb0011 > 0 {
						zb0011--
						var zb0013 int
						zb0013, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "TransactionGroups", "struct-from-array", "Bytes")
							return
						}
						if zb0013 > maxEncodedTransactionGroupBytes {
							err = msgp.ErrOverflow(uint64(zb0013), uint64(maxEncodedTransactionGroupBytes))
							return
						}
						(*z).TransactionGroups.Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroups.Bytes)
						if err != nil {
							err = msgp.WrapError(err, "TransactionGroups", "struct-from-array", "Bytes")
							return
						}
					}
					if zb0011 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0011)
						if err != nil {
							err = msgp.WrapError(err, "TransactionGroups", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "TransactionGroups")
						return
					}
					if zb0012 {
						(*z).TransactionGroups = packedTransactionGroups{}
					}
					for zb0011 > 0 {
						zb0011--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "TransactionGroups")
							return
						}
						switch string(field) {
						case "g":
							var zb0014 int
							zb0014, err = msgp.ReadBytesBytesHeader(bts)
							if err != nil {
								err = msgp.WrapError(err, "TransactionGroups", "Bytes")
								return
							}
							if zb0014 > maxEncodedTransactionGroupBytes {
								err = msgp.ErrOverflow(uint64(zb0014), uint64(maxEncodedTransactionGroupBytes))
								return
							}
							(*z).TransactionGroups.Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroups.Bytes)
							if err != nil {
								err = msgp.WrapError(err, "TransactionGroups", "Bytes")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "TransactionGroups")
								return
							}
						}
					}
				}
			case "t":
				bts, err = (*z).MsgSync.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "MsgSync")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *transactionBlockMessage) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*transactionBlockMessage)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *transactionBlockMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.Int32Size + 2 + (*z).Round.Msgsize() + 2 + (*z).TxnBloomFilter.Msgsize() + 2 + 1 + 2 + msgp.ByteSize + 2 + msgp.ByteSize + 2 + 1 + 2 + msgp.BytesPrefixSize + len((*z).TransactionGroups.Bytes) + 2 + (*z).MsgSync.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *transactionBlockMessage) MsgIsZero() bool {
	return ((*z).Version == 0) && ((*z).Round.MsgIsZero()) && ((*z).TxnBloomFilter.MsgIsZero()) && (((*z).UpdatedRequestParams.Offset == 0) && ((*z).UpdatedRequestParams.Modulator == 0)) && (len((*z).TransactionGroups.Bytes) == 0) && ((*z).MsgSync.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *txGroupsEncodingStub) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0025Len := uint32(51)
	var zb0025Mask uint64 /* 62 bits */
	if len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount) == 0 {
		zb0025Len--
		zb0025Mask |= 0x800
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount) == 0 {
		zb0025Len--
		zb0025Mask |= 0x1000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) == 0 {
		zb0025Len--
		zb0025Mask |= 0x2000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo) == 0 {
		zb0025Len--
		zb0025Mask |= 0x4000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee) == 0 {
		zb0025Len--
		zb0025Mask |= 0x8000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee) == 0 {
		zb0025Len--
		zb0025Mask |= 0x10000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid) == 0 {
		zb0025Len--
		zb0025Mask |= 0x20000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid) == 0 {
		zb0025Len--
		zb0025Mask |= 0x40000
	}
	if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.GenesisID == "" {
		zb0025Len--
		zb0025Mask |= 0x80000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID) == 0 {
		zb0025Len--
		zb0025Mask |= 0x100000
	}
	if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.GenesisHash.MsgIsZero() {
		zb0025Len--
		zb0025Mask |= 0x200000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisHash) == 0 {
		zb0025Len--
		zb0025Mask |= 0x400000
	}
	if len((*z).encodedSignedTxns.Lsig) == 0 {
		zb0025Len--
		zb0025Mask |= 0x800000
	}
	if len((*z).encodedSignedTxns.BitmaskLsig) == 0 {
		zb0025Len--
		zb0025Mask |= 0x1000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid) == 0 {
		zb0025Len--
		zb0025Mask |= 0x2000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid) == 0 {
		zb0025Len--
		zb0025Mask |= 0x4000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease) == 0 {
		zb0025Len--
		zb0025Mask |= 0x8000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease) == 0 {
		zb0025Len--
		zb0025Mask |= 0x10000000
	}
	if len((*z).encodedSignedTxns.Msig) == 0 {
		zb0025Len--
		zb0025Mask |= 0x20000000
	}
	if len((*z).encodedSignedTxns.BitmaskMsig) == 0 {
		zb0025Len--
		zb0025Mask |= 0x40000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation) == 0 {
		zb0025Len--
		zb0025Mask |= 0x80000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation) == 0 {
		zb0025Len--
		zb0025Mask |= 0x100000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note) == 0 {
		zb0025Len--
		zb0025Mask |= 0x200000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote) == 0 {
		zb0025Len--
		zb0025Mask |= 0x400000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver) == 0 {
		zb0025Len--
		zb0025Mask |= 0x800000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver) == 0 {
		zb0025Len--
		zb0025Mask |= 0x1000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo) == 0 {
		zb0025Len--
		zb0025Mask |= 0x2000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo) == 0 {
		zb0025Len--
		zb0025Mask |= 0x4000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK) == 0 {
		zb0025Len--
		zb0025Mask |= 0x8000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK) == 0 {
		zb0025Len--
		zb0025Mask |= 0x10000000000
	}
	if len((*z).encodedSignedTxns.AuthAddr) == 0 {
		zb0025Len--
		zb0025Mask |= 0x20000000000
	}
	if len((*z).encodedSignedTxns.BitmaskAuthAddr) == 0 {
		zb0025Len--
		zb0025Mask |= 0x40000000000
	}
	if len((*z).encodedSignedTxns.Sig) == 0 {
		zb0025Len--
		zb0025Mask |= 0x80000000000
	}
	if len((*z).encodedSignedTxns.BitmaskSig) == 0 {
		zb0025Len--
		zb0025Mask |= 0x100000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender) == 0 {
		zb0025Len--
		zb0025Mask |= 0x200000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender) == 0 {
		zb0025Len--
		zb0025Mask |= 0x400000000000
	}
	if len((*z).SignedTxns) == 0 {
		zb0025Len--
		zb0025Mask |= 0x800000000000
	}
	if len((*z).TxnGroups) == 0 {
		zb0025Len--
		zb0025Mask |= 0x1000000000000
	}
	if (*z).TransactionGroupCount == 0 {
		zb0025Len--
		zb0025Mask |= 0x2000000000000
	}
	if len((*z).TransactionGroupSizes) == 0 {
		zb0025Len--
		zb0025Mask |= 0x4000000000000
	}
	if (*z).TotalTransactionsCount == 0 {
		zb0025Len--
		zb0025Mask |= 0x8000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.TxType) == 0 {
		zb0025Len--
		zb0025Mask |= 0x10000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.BitmaskTxType) == 0 {
		zb0025Len--
		zb0025Mask |= 0x20000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst) == 0 {
		zb0025Len--
		zb0025Mask |= 0x40000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst) == 0 {
		zb0025Len--
		zb0025Mask |= 0x80000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) == 0 {
		zb0025Len--
		zb0025Mask |= 0x100000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution) == 0 {
		zb0025Len--
		zb0025Mask |= 0x200000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK) == 0 {
		zb0025Len--
		zb0025Mask |= 0x400000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVotePK) == 0 {
		zb0025Len--
		zb0025Mask |= 0x800000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast) == 0 {
		zb0025Len--
		zb0025Mask |= 0x1000000000000000
	}
	if len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast) == 0 {
		zb0025Len--
		zb0025Mask |= 0x2000000000000000
	}
	// variable map header, size zb0025Len
	o = msgp.AppendMapHeader(o, zb0025Len)
	if zb0025Len != 0 {
		if (zb0025Mask & 0x800) == 0 { // if not empty
			// string "amt"
			o = append(o, 0xa3, 0x61, 0x6d, 0x74)
			if (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount)))
			}
			for zb0021 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount {
				o = (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount[zb0021].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x1000) == 0 { // if not empty
			// string "amtbm"
			o = append(o, 0xa5, 0x61, 0x6d, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount))
		}
		if (zb0025Mask & 0x2000) == 0 { // if not empty
			// string "close"
			o = append(o, 0xa5, 0x63, 0x6c, 0x6f, 0x73, 0x65)
			if (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo)))
			}
			for zb0022 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo {
				o = (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo[zb0022].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x4000) == 0 { // if not empty
			// string "closebm"
			o = append(o, 0xa7, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
		}
		if (zb0025Mask & 0x8000) == 0 { // if not empty
			// string "fee"
			o = append(o, 0xa3, 0x66, 0x65, 0x65)
			if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee)))
			}
			for zb0007 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee {
				o = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee[zb0007].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x10000) == 0 { // if not empty
			// string "feebm"
			o = append(o, 0xa5, 0x66, 0x65, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee))
		}
		if (zb0025Mask & 0x20000) == 0 { // if not empty
			// string "fv"
			o = append(o, 0xa2, 0x66, 0x76)
			if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid)))
			}
			for zb0008 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid {
				o = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid[zb0008].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x40000) == 0 { // if not empty
			// string "fvbm"
			o = append(o, 0xa4, 0x66, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid))
		}
		if (zb0025Mask & 0x80000) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.GenesisID)
		}
		if (zb0025Mask & 0x100000) == 0 { // if not empty
			// string "genbm"
			o = append(o, 0xa5, 0x67, 0x65, 0x6e, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID))
		}
		if (zb0025Mask & 0x200000) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.GenesisHash.MarshalMsg(o)
		}
		if (zb0025Mask & 0x400000) == 0 { // if not empty
			// string "ghbm"
			o = append(o, 0xa4, 0x67, 0x68, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisHash))
		}
		if (zb0025Mask & 0x800000) == 0 { // if not empty
			// string "lsig"
			o = append(o, 0xa4, 0x6c, 0x73, 0x69, 0x67)
			if (*z).encodedSignedTxns.Lsig == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.Lsig)))
			}
			for zb0004 := range (*z).encodedSignedTxns.Lsig {
				o = (*z).encodedSignedTxns.Lsig[zb0004].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x1000000) == 0 { // if not empty
			// string "lsigbm"
			o = append(o, 0xa6, 0x6c, 0x73, 0x69, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.BitmaskLsig))
		}
		if (zb0025Mask & 0x2000000) == 0 { // if not empty
			// string "lv"
			o = append(o, 0xa2, 0x6c, 0x76)
			if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid)))
			}
			for zb0009 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid {
				o = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid[zb0009].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x4000000) == 0 { // if not empty
			// string "lvbm"
			o = append(o, 0xa4, 0x6c, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid))
		}
		if (zb0025Mask & 0x8000000) == 0 { // if not empty
			// string "lx"
			o = append(o, 0xa2, 0x6c, 0x78)
			if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease)))
			}
			for zb0011 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease {
				o = msgp.AppendBytes(o, ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease[zb0011])[:])
			}
		}
		if (zb0025Mask & 0x10000000) == 0 { // if not empty
			// string "lxbm"
			o = append(o, 0xa4, 0x6c, 0x78, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease))
		}
		if (zb0025Mask & 0x20000000) == 0 { // if not empty
			// string "msig"
			o = append(o, 0xa4, 0x6d, 0x73, 0x69, 0x67)
			if (*z).encodedSignedTxns.Msig == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.Msig)))
			}
			for zb0003 := range (*z).encodedSignedTxns.Msig {
				o = (*z).encodedSignedTxns.Msig[zb0003].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x40000000) == 0 { // if not empty
			// string "msigbm"
			o = append(o, 0xa6, 0x6d, 0x73, 0x69, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.BitmaskMsig))
		}
		if (zb0025Mask & 0x80000000) == 0 { // if not empty
			// string "nonpart"
			o = append(o, 0xa7, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74)
			if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation)))
			}
			for zb0019 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation {
				o = msgp.AppendBool(o, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation[zb0019])
			}
		}
		if (zb0025Mask & 0x100000000) == 0 { // if not empty
			// string "nonpartbm"
			o = append(o, 0xa9, 0x6e, 0x6f, 0x6e, 0x70, 0x61, 0x72, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation))
		}
		if (zb0025Mask & 0x200000000) == 0 { // if not empty
			// string "note"
			o = append(o, 0xa4, 0x6e, 0x6f, 0x74, 0x65)
			if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note)))
			}
			for zb0010 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note {
				o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note[zb0010])
			}
		}
		if (zb0025Mask & 0x400000000) == 0 { // if not empty
			// string "notebm"
			o = append(o, 0xa6, 0x6e, 0x6f, 0x74, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote))
		}
		if (zb0025Mask & 0x800000000) == 0 { // if not empty
			// string "rcv"
			o = append(o, 0xa3, 0x72, 0x63, 0x76)
			if (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver)))
			}
			for zb0020 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver {
				o = (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver[zb0020].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x1000000000) == 0 { // if not empty
			// string "rcvbm"
			o = append(o, 0xa5, 0x72, 0x63, 0x76, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver))
		}
		if (zb0025Mask & 0x2000000000) == 0 { // if not empty
			// string "rekey"
			o = append(o, 0xa5, 0x72, 0x65, 0x6b, 0x65, 0x79)
			if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo)))
			}
			for zb0013 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo {
				o = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo[zb0013].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x4000000000) == 0 { // if not empty
			// string "rekeybm"
			o = append(o, 0xa7, 0x72, 0x65, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo))
		}
		if (zb0025Mask & 0x8000000000) == 0 { // if not empty
			// string "selkey"
			o = append(o, 0xa6, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79)
			if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK)))
			}
			for zb0015 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK {
				o = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK[zb0015].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x10000000000) == 0 { // if not empty
			// string "selkeybm"
			o = append(o, 0xa8, 0x73, 0x65, 0x6c, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK))
		}
		if (zb0025Mask & 0x20000000000) == 0 { // if not empty
			// string "sgnr"
			o = append(o, 0xa4, 0x73, 0x67, 0x6e, 0x72)
			if (*z).encodedSignedTxns.AuthAddr == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.AuthAddr)))
			}
			for zb0005 := range (*z).encodedSignedTxns.AuthAddr {
				o = (*z).encodedSignedTxns.AuthAddr[zb0005].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x40000000000) == 0 { // if not empty
			// string "sgnrbm"
			o = append(o, 0xa6, 0x73, 0x67, 0x6e, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.BitmaskAuthAddr))
		}
		if (zb0025Mask & 0x80000000000) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			if (*z).encodedSignedTxns.Sig == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.Sig)))
			}
			for zb0002 := range (*z).encodedSignedTxns.Sig {
				o = (*z).encodedSignedTxns.Sig[zb0002].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x100000000000) == 0 { // if not empty
			// string "sigbm"
			o = append(o, 0xa5, 0x73, 0x69, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.BitmaskSig))
		}
		if (zb0025Mask & 0x200000000000) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender)))
			}
			for zb0006 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender {
				o = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender[zb0006].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x400000000000) == 0 { // if not empty
			// string "sndbm"
			o = append(o, 0xa5, 0x73, 0x6e, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender))
		}
		if (zb0025Mask & 0x800000000000) == 0 { // if not empty
			// string "st"
			o = append(o, 0xa2, 0x73, 0x74)
			if (*z).SignedTxns == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).SignedTxns)))
			}
			for zb0001 := range (*z).SignedTxns {
				o = (*z).SignedTxns[zb0001].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x1000000000000) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			if (*z).TxnGroups == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).TxnGroups)))
			}
			for zb0023 := range (*z).TxnGroups {
				if (*z).TxnGroups[zb0023] == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendArrayHeader(o, uint32(len((*z).TxnGroups[zb0023])))
				}
				for zb0024 := range (*z).TxnGroups[zb0023] {
					o = (*z).TxnGroups[zb0023][zb0024].MarshalMsg(o)
				}
			}
		}
		if (zb0025Mask & 0x2000000000000) == 0 { // if not empty
			// string "tgc"
			o = append(o, 0xa3, 0x74, 0x67, 0x63)
			o = msgp.AppendUint64(o, (*z).TransactionGroupCount)
		}
		if (zb0025Mask & 0x4000000000000) == 0 { // if not empty
			// string "tgs"
			o = append(o, 0xa3, 0x74, 0x67, 0x73)
			o = msgp.AppendBytes(o, (*z).TransactionGroupSizes)
		}
		if (zb0025Mask & 0x8000000000000) == 0 { // if not empty
			// string "ttc"
			o = append(o, 0xa3, 0x74, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).TotalTransactionsCount)
		}
		if (zb0025Mask & 0x10000000000000) == 0 { // if not empty
			// string "type"
			o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
			o = msgp.AppendBytes(o, (*z).encodedSignedTxns.encodedTxns.TxType)
		}
		if (zb0025Mask & 0x20000000000000) == 0 { // if not empty
			// string "typebm"
			o = append(o, 0xa6, 0x74, 0x79, 0x70, 0x65, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.BitmaskTxType))
		}
		if (zb0025Mask & 0x40000000000000) == 0 { // if not empty
			// string "votefst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74)
			if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst)))
			}
			for zb0016 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst {
				o = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0016].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x80000000000000) == 0 { // if not empty
			// string "votefstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x66, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst))
		}
		if (zb0025Mask & 0x100000000000000) == 0 { // if not empty
			// string "votekd"
			o = append(o, 0xa6, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64)
			if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution)))
			}
			for zb0018 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution {
				o = msgp.AppendUint64(o, (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution[zb0018])
			}
		}
		if (zb0025Mask & 0x200000000000000) == 0 { // if not empty
			// string "votekdbm"
			o = append(o, 0xa8, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x64, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution))
		}
		if (zb0025Mask & 0x400000000000000) == 0 { // if not empty
			// string "votekey"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79)
			if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK)))
			}
			for zb0014 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK {
				o = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK[zb0014].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x800000000000000) == 0 { // if not empty
			// string "votekeybm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x6b, 0x65, 0x79, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVotePK))
		}
		if (zb0025Mask & 0x1000000000000000) == 0 { // if not empty
			// string "votelst"
			o = append(o, 0xa7, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74)
			if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast)))
			}
			for zb0017 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast {
				o = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast[zb0017].MarshalMsg(o)
			}
		}
		if (zb0025Mask & 0x2000000000000000) == 0 { // if not empty
			// string "votelstbm"
			o = append(o, 0xa9, 0x76, 0x6f, 0x74, 0x65, 0x6c, 0x73, 0x74, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast))
		}
	}
	return
}

func (_ *txGroupsEncodingStub) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*txGroupsEncodingStub)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *txGroupsEncodingStub) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0025 int
	var zb0026 bool
	zb0025, zb0026, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0025, zb0026, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0025 > 0 {
			zb0025--
			(*z).TotalTransactionsCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TotalTransactionsCount")
				return
			}
		}
		if zb0025 > 0 {
			zb0025--
			(*z).TransactionGroupCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TransactionGroupCount")
				return
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0027 int
			zb0027, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TransactionGroupSizes")
				return
			}
			if zb0027 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0027), uint64(maxEncodedTransactionGroup))
				return
			}
			(*z).TransactionGroupSizes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroupSizes)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TransactionGroupSizes")
				return
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0028 int
			var zb0029 bool
			zb0028, zb0029, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SignedTxns")
				return
			}
			if zb0028 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0028), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "SignedTxns")
				return
			}
			if zb0029 {
				(*z).SignedTxns = nil
			} else if (*z).SignedTxns != nil && cap((*z).SignedTxns) >= zb0028 {
				(*z).SignedTxns = ((*z).SignedTxns)[:zb0028]
			} else {
				(*z).SignedTxns = make([]transactions.SignedTxn, zb0028)
			}
			for zb0001 := range (*z).SignedTxns {
				bts, err = (*z).SignedTxns[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedTxns", zb0001)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0030 int
			var zb0031 bool
			zb0030, zb0031, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
			if zb0030 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0030), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
			if zb0031 {
				(*z).encodedSignedTxns.Sig = nil
			} else if (*z).encodedSignedTxns.Sig != nil && cap((*z).encodedSignedTxns.Sig) >= zb0030 {
				(*z).encodedSignedTxns.Sig = ((*z).encodedSignedTxns.Sig)[:zb0030]
			} else {
				(*z).encodedSignedTxns.Sig = make([]crypto.Signature, zb0030)
			}
			for zb0002 := range (*z).encodedSignedTxns.Sig {
				bts, err = (*z).encodedSignedTxns.Sig[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sig", zb0002)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0032 []byte
				zb0032, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskSig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSig")
					return
				}
				(*z).encodedSignedTxns.BitmaskSig = bitmask(zb0032)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0033 int
			var zb0034 bool
			zb0033, zb0034, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Msig")
				return
			}
			if zb0033 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0033), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Msig")
				return
			}
			if zb0034 {
				(*z).encodedSignedTxns.Msig = nil
			} else if (*z).encodedSignedTxns.Msig != nil && cap((*z).encodedSignedTxns.Msig) >= zb0033 {
				(*z).encodedSignedTxns.Msig = ((*z).encodedSignedTxns.Msig)[:zb0033]
			} else {
				(*z).encodedSignedTxns.Msig = make([]crypto.MultisigSig, zb0033)
			}
			for zb0003 := range (*z).encodedSignedTxns.Msig {
				bts, err = (*z).encodedSignedTxns.Msig[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Msig", zb0003)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0035 []byte
				zb0035, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskMsig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMsig")
					return
				}
				(*z).encodedSignedTxns.BitmaskMsig = bitmask(zb0035)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0036 int
			var zb0037 bool
			zb0036, zb0037, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lsig")
				return
			}
			if zb0036 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0036), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Lsig")
				return
			}
			if zb0037 {
				(*z).encodedSignedTxns.Lsig = nil
			} else if (*z).encodedSignedTxns.Lsig != nil && cap((*z).encodedSignedTxns.Lsig) >= zb0036 {
				(*z).encodedSignedTxns.Lsig = ((*z).encodedSignedTxns.Lsig)[:zb0036]
			} else {
				(*z).encodedSignedTxns.Lsig = make([]transactions.LogicSig, zb0036)
			}
			for zb0004 := range (*z).encodedSignedTxns.Lsig {
				bts, err = (*z).encodedSignedTxns.Lsig[zb0004].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Lsig", zb0004)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0038 []byte
				zb0038, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskLsig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLsig")
					return
				}
				(*z).encodedSignedTxns.BitmaskLsig = bitmask(zb0038)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0039 int
			var zb0040 bool
			zb0039, zb0040, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
			if zb0039 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0039), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
			if zb0040 {
				(*z).encodedSignedTxns.AuthAddr = nil
			} else if (*z).encodedSignedTxns.AuthAddr != nil && cap((*z).encodedSignedTxns.AuthAddr) >= zb0039 {
				(*z).encodedSignedTxns.AuthAddr = ((*z).encodedSignedTxns.AuthAddr)[:zb0039]
			} else {
				(*z).encodedSignedTxns.AuthAddr = make([]basics.Address, zb0039)
			}
			for zb0005 := range (*z).encodedSignedTxns.AuthAddr {
				bts, err = (*z).encodedSignedTxns.AuthAddr[zb0005].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AuthAddr", zb0005)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0041 []byte
				zb0041, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskAuthAddr))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAuthAddr")
					return
				}
				(*z).encodedSignedTxns.BitmaskAuthAddr = bitmask(zb0041)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0042 int
			zb0042, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
			if zb0042 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0042), uint64(maxEncodedTransactionGroup))
				return
			}
			(*z).encodedSignedTxns.encodedTxns.TxType, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.TxType)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0043 []byte
				zb0043, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.BitmaskTxType))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskTxType")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.BitmaskTxType = bitmask(zb0043)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0044 int
			var zb0045 bool
			zb0044, zb0045, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
			if zb0044 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0044), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
			if zb0045 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender) >= zb0044 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender)[:zb0044]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender = make([]basics.Address, zb0044)
			}
			for zb0006 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender[zb0006].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sender", zb0006)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0046 []byte
				zb0046, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSender")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender = bitmask(zb0046)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0047 int
			var zb0048 bool
			zb0047, zb0048, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0047 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0047), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Fee")
				return
			}
			if zb0048 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee) >= zb0047 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee)[:zb0047]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee = make([]basics.MicroAlgos, zb0047)
			}
			for zb0007 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee[zb0007].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Fee", zb0007)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0049 []byte
				zb0049, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFee")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee = bitmask(zb0049)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0050 int
			var zb0051 bool
			zb0050, zb0051, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0050 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0050), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "FirstValid")
				return
			}
			if zb0051 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid) >= zb0050 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid)[:zb0050]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid = make([]basics.Round, zb0050)
			}
			for zb0008 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid[zb0008].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "FirstValid", zb0008)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0052 []byte
				zb0052, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskFirstValid")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid = bitmask(zb0052)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0053 int
			var zb0054 bool
			zb0053, zb0054, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0053 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0053), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "LastValid")
				return
			}
			if zb0054 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid) >= zb0053 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid)[:zb0053]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid = make([]basics.Round, zb0053)
			}
			for zb0009 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid[zb0009].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LastValid", zb0009)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0055 []byte
				zb0055, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLastValid")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid = bitmask(zb0055)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0056 int
			var zb0057 bool
			zb0056, zb0057, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0056 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0056), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Note")
				return
			}
			if zb0057 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note) >= zb0056 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note)[:zb0056]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note = make([][]byte, zb0056)
			}
			for zb0010 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note[zb0010], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note[zb0010])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Note", zb0010)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0058 []byte
				zb0058, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNote")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote = bitmask(zb0058)
			}
		}
		if zb0025 > 0 {
			zb0025--
			(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0059 []byte
				zb0059, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisID")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID = bitmask(zb0059)
			}
		}
		if zb0025 > 0 {
			zb0025--
			bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0060 []byte
				zb0060, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisHash))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskGenesisHash")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisHash = bitmask(zb0060)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0061 int
			var zb0062 bool
			zb0061, zb0062, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
			if zb0061 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0061), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Lease")
				return
			}
			if zb0062 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease) >= zb0061 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease)[:zb0061]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease = make([][32]byte, zb0061)
			}
			for zb0011 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease {
				bts, err = msgp.ReadExactBytes(bts, ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease[zb0011])[:])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Lease", zb0011)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0063 []byte
				zb0063, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLease")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease = bitmask(zb0063)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0064 int
			var zb0065 bool
			zb0064, zb0065, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
			if zb0064 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0064), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "RekeyTo")
				return
			}
			if zb0065 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo) >= zb0064 {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo)[:zb0064]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo = make([]basics.Address, zb0064)
			}
			for zb0013 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo[zb0013].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "RekeyTo", zb0013)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0066 []byte
				zb0066, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskRekeyTo")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo = bitmask(zb0066)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0067 int
			var zb0068 bool
			zb0067, zb0068, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
			if zb0067 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0067), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VotePK")
				return
			}
			if zb0068 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK) >= zb0067 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK)[:zb0067]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK = make([]crypto.OneTimeSignatureVerifier, zb0067)
			}
			for zb0014 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK[zb0014].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VotePK", zb0014)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0069 []byte
				zb0069, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVotePK))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVotePK")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVotePK = bitmask(zb0069)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0070 int
			var zb0071 bool
			zb0070, zb0071, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
			if zb0070 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0070), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "SelectionPK")
				return
			}
			if zb0071 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK) >= zb0070 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK)[:zb0070]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK = make([]crypto.VRFVerifier, zb0070)
			}
			for zb0015 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK[zb0015].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SelectionPK", zb0015)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0072 []byte
				zb0072, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSelectionPK")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK = bitmask(zb0072)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0073 int
			var zb0074 bool
			zb0073, zb0074, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0073 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0073), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VoteFirst")
				return
			}
			if zb0074 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst) >= zb0073 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst)[:zb0073]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst = make([]basics.Round, zb0073)
			}
			for zb0016 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0016].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteFirst", zb0016)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0075 []byte
				zb0075, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteFirst")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst = bitmask(zb0075)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0076 int
			var zb0077 bool
			zb0076, zb0077, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0076 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0076), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VoteLast")
				return
			}
			if zb0077 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast) >= zb0076 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast)[:zb0076]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast = make([]basics.Round, zb0076)
			}
			for zb0017 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast[zb0017].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteLast", zb0017)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0078 []byte
				zb0078, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteLast")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast = bitmask(zb0078)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0079 int
			var zb0080 bool
			zb0079, zb0080, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0079 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0079), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution")
				return
			}
			if zb0080 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) >= zb0079 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution)[:zb0079]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = make([]uint64, zb0079)
			}
			for zb0018 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution[zb0018], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteKeyDilution", zb0018)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0081 []byte
				zb0081, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskVoteKeyDilution")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution = bitmask(zb0081)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0082 int
			var zb0083 bool
			zb0082, zb0083, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Nonparticipation")
				return
			}
			if zb0082 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0082), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Nonparticipation")
				return
			}
			if zb0083 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation) >= zb0082 {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation)[:zb0082]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation = make([]bool, zb0082)
			}
			for zb0019 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation {
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation[zb0019], bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Nonparticipation", zb0019)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0084 []byte
				zb0084, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskNonparticipation")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation = bitmask(zb0084)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0085 int
			var zb0086 bool
			zb0085, zb0086, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
			if zb0085 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0085), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Receiver")
				return
			}
			if zb0086 {
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver) >= zb0085 {
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver = ((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver)[:zb0085]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver = make([]basics.Address, zb0085)
			}
			for zb0020 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver[zb0020].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Receiver", zb0020)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0087 []byte
				zb0087, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskReceiver")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver = bitmask(zb0087)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0088 int
			var zb0089 bool
			zb0088, zb0089, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0088 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0088), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Amount")
				return
			}
			if zb0089 {
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount) >= zb0088 {
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount = ((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount)[:zb0088]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount = make([]basics.MicroAlgos, zb0088)
			}
			for zb0021 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount[zb0021].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Amount", zb0021)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0090 []byte
				zb0090, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAmount")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount = bitmask(zb0090)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0091 int
			var zb0092 bool
			zb0091, zb0092, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
			if zb0091 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0091), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo")
				return
			}
			if zb0092 {
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo = nil
			} else if (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) >= zb0091 {
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo = ((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo)[:zb0091]
			} else {
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo = make([]basics.Address, zb0091)
			}
			for zb0022 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo {
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo[zb0022].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CloseRemainderTo", zb0022)
					return
				}
			}
		}
		if zb0025 > 0 {
			zb0025--
			{
				var zb0093 []byte
				zb0093, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskCloseRemainderTo")
					return
				}
				(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo = bitmask(zb0093)
			}
		}
		if zb0025 > 0 {
			zb0025--
			var zb0094 int
			var zb0095 bool
			zb0094, zb0095, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnGroups")
				return
			}
			if zb0094 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0094), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "TxnGroups")
				return
			}
			if zb0095 {
				(*z).TxnGroups = nil
			} else if (*z).TxnGroups != nil && cap((*z).TxnGroups) >= zb0094 {
				(*z).TxnGroups = ((*z).TxnGroups)[:zb0094]
			} else {
				(*z).TxnGroups = make([]txnGroups, zb0094)
			}
			for zb0023 := range (*z).TxnGroups {
				var zb0096 int
				var zb0097 bool
				zb0096, zb0097, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "TxnGroups", zb0023)
					return
				}
				if zb0096 > maxEncodedTransactionGroupEntries {
					err = msgp.ErrOverflow(uint64(zb0096), uint64(maxEncodedTransactionGroupEntries))
					err = msgp.WrapError(err, "struct-from-array", "TxnGroups", zb0023)
					return
				}
				if zb0097 {
					(*z).TxnGroups[zb0023] = nil
				} else if (*z).TxnGroups[zb0023] != nil && cap((*z).TxnGroups[zb0023]) >= zb0096 {
					(*z).TxnGroups[zb0023] = ((*z).TxnGroups[zb0023])[:zb0096]
				} else {
					(*z).TxnGroups[zb0023] = make(txnGroups, zb0096)
				}
				for zb0024 := range (*z).TxnGroups[zb0023] {
					bts, err = (*z).TxnGroups[zb0023][zb0024].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "TxnGroups", zb0023, zb0024)
						return
					}
				}
			}
		}
		if zb0025 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0025)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0026 {
			(*z) = txGroupsEncodingStub{}
		}
		for zb0025 > 0 {
			zb0025--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "ttc":
				(*z).TotalTransactionsCount, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TotalTransactionsCount")
					return
				}
			case "tgc":
				(*z).TransactionGroupCount, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TransactionGroupCount")
					return
				}
			case "tgs":
				var zb0098 int
				zb0098, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "TransactionGroupSizes")
					return
				}
				if zb0098 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0098), uint64(maxEncodedTransactionGroup))
					return
				}
				(*z).TransactionGroupSizes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroupSizes)
				if err != nil {
					err = msgp.WrapError(err, "TransactionGroupSizes")
					return
				}
			case "st":
				var zb0099 int
				var zb0100 bool
				zb0099, zb0100, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SignedTxns")
					return
				}
				if zb0099 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0099), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "SignedTxns")
					return
				}
				if zb0100 {
					(*z).SignedTxns = nil
				} else if (*z).SignedTxns != nil && cap((*z).SignedTxns) >= zb0099 {
					(*z).SignedTxns = ((*z).SignedTxns)[:zb0099]
				} else {
					(*z).SignedTxns = make([]transactions.SignedTxn, zb0099)
				}
				for zb0001 := range (*z).SignedTxns {
					bts, err = (*z).SignedTxns[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedTxns", zb0001)
						return
					}
				}
			case "sig":
				var zb0101 int
				var zb0102 bool
				zb0101, zb0102, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
				if zb0101 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0101), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Sig")
					return
				}
				if zb0102 {
					(*z).encodedSignedTxns.Sig = nil
				} else if (*z).encodedSignedTxns.Sig != nil && cap((*z).encodedSignedTxns.Sig) >= zb0101 {
					(*z).encodedSignedTxns.Sig = ((*z).encodedSignedTxns.Sig)[:zb0101]
				} else {
					(*z).encodedSignedTxns.Sig = make([]crypto.Signature, zb0101)
				}
				for zb0002 := range (*z).encodedSignedTxns.Sig {
					bts, err = (*z).encodedSignedTxns.Sig[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sig", zb0002)
						return
					}
				}
			case "sigbm":
				{
					var zb0103 []byte
					zb0103, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskSig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSig")
						return
					}
					(*z).encodedSignedTxns.BitmaskSig = bitmask(zb0103)
				}
			case "msig":
				var zb0104 int
				var zb0105 bool
				zb0104, zb0105, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Msig")
					return
				}
				if zb0104 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0104), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Msig")
					return
				}
				if zb0105 {
					(*z).encodedSignedTxns.Msig = nil
				} else if (*z).encodedSignedTxns.Msig != nil && cap((*z).encodedSignedTxns.Msig) >= zb0104 {
					(*z).encodedSignedTxns.Msig = ((*z).encodedSignedTxns.Msig)[:zb0104]
				} else {
					(*z).encodedSignedTxns.Msig = make([]crypto.MultisigSig, zb0104)
				}
				for zb0003 := range (*z).encodedSignedTxns.Msig {
					bts, err = (*z).encodedSignedTxns.Msig[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Msig", zb0003)
						return
					}
				}
			case "msigbm":
				{
					var zb0106 []byte
					zb0106, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskMsig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMsig")
						return
					}
					(*z).encodedSignedTxns.BitmaskMsig = bitmask(zb0106)
				}
			case "lsig":
				var zb0107 int
				var zb0108 bool
				zb0107, zb0108, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lsig")
					return
				}
				if zb0107 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0107), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Lsig")
					return
				}
				if zb0108 {
					(*z).encodedSignedTxns.Lsig = nil
				} else if (*z).encodedSignedTxns.Lsig != nil && cap((*z).encodedSignedTxns.Lsig) >= zb0107 {
					(*z).encodedSignedTxns.Lsig = ((*z).encodedSignedTxns.Lsig)[:zb0107]
				} else {
					(*z).encodedSignedTxns.Lsig = make([]transactions.LogicSig, zb0107)
				}
				for zb0004 := range (*z).encodedSignedTxns.Lsig {
					bts, err = (*z).encodedSignedTxns.Lsig[zb0004].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Lsig", zb0004)
						return
					}
				}
			case "lsigbm":
				{
					var zb0109 []byte
					zb0109, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskLsig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLsig")
						return
					}
					(*z).encodedSignedTxns.BitmaskLsig = bitmask(zb0109)
				}
			case "sgnr":
				var zb0110 int
				var zb0111 bool
				zb0110, zb0111, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
				if zb0110 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0110), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
				if zb0111 {
					(*z).encodedSignedTxns.AuthAddr = nil
				} else if (*z).encodedSignedTxns.AuthAddr != nil && cap((*z).encodedSignedTxns.AuthAddr) >= zb0110 {
					(*z).encodedSignedTxns.AuthAddr = ((*z).encodedSignedTxns.AuthAddr)[:zb0110]
				} else {
					(*z).encodedSignedTxns.AuthAddr = make([]basics.Address, zb0110)
				}
				for zb0005 := range (*z).encodedSignedTxns.AuthAddr {
					bts, err = (*z).encodedSignedTxns.AuthAddr[zb0005].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "AuthAddr", zb0005)
						return
					}
				}
			case "sgnrbm":
				{
					var zb0112 []byte
					zb0112, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskAuthAddr))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAuthAddr")
						return
					}
					(*z).encodedSignedTxns.BitmaskAuthAddr = bitmask(zb0112)
				}
			case "type":
				var zb0113 int
				zb0113, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
				if zb0113 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0113), uint64(maxEncodedTransactionGroup))
					return
				}
				(*z).encodedSignedTxns.encodedTxns.TxType, bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.TxType)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
			case "typebm":
				{
					var zb0114 []byte
					zb0114, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.BitmaskTxType))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskTxType")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.BitmaskTxType = bitmask(zb0114)
				}
			case "snd":
				var zb0115 int
				var zb0116 bool
				zb0115, zb0116, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				if zb0115 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0115), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Sender")
					return
				}
				if zb0116 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender) >= zb0115 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender)[:zb0115]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender = make([]basics.Address, zb0115)
				}
				for zb0006 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender[zb0006].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sender", zb0006)
						return
					}
				}
			case "sndbm":
				{
					var zb0117 []byte
					zb0117, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSender")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender = bitmask(zb0117)
				}
			case "fee":
				var zb0118 int
				var zb0119 bool
				zb0118, zb0119, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0118 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0118), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Fee")
					return
				}
				if zb0119 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee) >= zb0118 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee)[:zb0118]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee = make([]basics.MicroAlgos, zb0118)
				}
				for zb0007 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee[zb0007].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Fee", zb0007)
						return
					}
				}
			case "feebm":
				{
					var zb0120 []byte
					zb0120, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFee")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee = bitmask(zb0120)
				}
			case "fv":
				var zb0121 int
				var zb0122 bool
				zb0121, zb0122, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0121 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0121), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "FirstValid")
					return
				}
				if zb0122 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid) >= zb0121 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid)[:zb0121]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid = make([]basics.Round, zb0121)
				}
				for zb0008 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid[zb0008].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "FirstValid", zb0008)
						return
					}
				}
			case "fvbm":
				{
					var zb0123 []byte
					zb0123, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskFirstValid")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid = bitmask(zb0123)
				}
			case "lv":
				var zb0124 int
				var zb0125 bool
				zb0124, zb0125, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0124 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0124), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "LastValid")
					return
				}
				if zb0125 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid) >= zb0124 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid)[:zb0124]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid = make([]basics.Round, zb0124)
				}
				for zb0009 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid[zb0009].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastValid", zb0009)
						return
					}
				}
			case "lvbm":
				{
					var zb0126 []byte
					zb0126, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLastValid")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid = bitmask(zb0126)
				}
			case "note":
				var zb0127 int
				var zb0128 bool
				zb0127, zb0128, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0127 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0127), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Note")
					return
				}
				if zb0128 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note) >= zb0127 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note)[:zb0127]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note = make([][]byte, zb0127)
				}
				for zb0010 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note[zb0010], bts, err = msgp.ReadBytesBytes(bts, (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note[zb0010])
					if err != nil {
						err = msgp.WrapError(err, "Note", zb0010)
						return
					}
				}
			case "notebm":
				{
					var zb0129 []byte
					zb0129, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNote")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote = bitmask(zb0129)
				}
			case "gen":
				(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "genbm":
				{
					var zb0130 []byte
					zb0130, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisID")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID = bitmask(zb0130)
				}
			case "gh":
				bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "ghbm":
				{
					var zb0131 []byte
					zb0131, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisHash))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskGenesisHash")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisHash = bitmask(zb0131)
				}
			case "lx":
				var zb0132 int
				var zb0133 bool
				zb0132, zb0133, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lease")
					return
				}
				if zb0132 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0132), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Lease")
					return
				}
				if zb0133 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease) >= zb0132 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease)[:zb0132]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease = make([][32]byte, zb0132)
				}
				for zb0011 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease {
					bts, err = msgp.ReadExactBytes(bts, ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease[zb0011])[:])
					if err != nil {
						err = msgp.WrapError(err, "Lease", zb0011)
						return
					}
				}
			case "lxbm":
				{
					var zb0134 []byte
					zb0134, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLease")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease = bitmask(zb0134)
				}
			case "rekey":
				var zb0135 int
				var zb0136 bool
				zb0135, zb0136, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
				if zb0135 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0135), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "RekeyTo")
					return
				}
				if zb0136 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo) >= zb0135 {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo = ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo)[:zb0135]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo = make([]basics.Address, zb0135)
				}
				for zb0013 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo[zb0013].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "RekeyTo", zb0013)
						return
					}
				}
			case "rekeybm":
				{
					var zb0137 []byte
					zb0137, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskRekeyTo")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo = bitmask(zb0137)
				}
			case "votekey":
				var zb0138 int
				var zb0139 bool
				zb0138, zb0139, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VotePK")
					return
				}
				if zb0138 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0138), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VotePK")
					return
				}
				if zb0139 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK) >= zb0138 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK)[:zb0138]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK = make([]crypto.OneTimeSignatureVerifier, zb0138)
				}
				for zb0014 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK[zb0014].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VotePK", zb0014)
						return
					}
				}
			case "votekeybm":
				{
					var zb0140 []byte
					zb0140, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVotePK))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVotePK")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVotePK = bitmask(zb0140)
				}
			case "selkey":
				var zb0141 int
				var zb0142 bool
				zb0141, zb0142, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
				if zb0141 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0141), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "SelectionPK")
					return
				}
				if zb0142 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK) >= zb0141 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK)[:zb0141]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK = make([]crypto.VRFVerifier, zb0141)
				}
				for zb0015 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK[zb0015].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "SelectionPK", zb0015)
						return
					}
				}
			case "selkeybm":
				{
					var zb0143 []byte
					zb0143, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSelectionPK")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK = bitmask(zb0143)
				}
			case "votefst":
				var zb0144 int
				var zb0145 bool
				zb0144, zb0145, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0144 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0144), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VoteFirst")
					return
				}
				if zb0145 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst) >= zb0144 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst)[:zb0144]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst = make([]basics.Round, zb0144)
				}
				for zb0016 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0016].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteFirst", zb0016)
						return
					}
				}
			case "votefstbm":
				{
					var zb0146 []byte
					zb0146, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteFirst")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst = bitmask(zb0146)
				}
			case "votelst":
				var zb0147 int
				var zb0148 bool
				zb0147, zb0148, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0147 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0147), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VoteLast")
					return
				}
				if zb0148 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast) >= zb0147 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast)[:zb0147]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast = make([]basics.Round, zb0147)
				}
				for zb0017 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast[zb0017].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteLast", zb0017)
						return
					}
				}
			case "votelstbm":
				{
					var zb0149 []byte
					zb0149, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteLast")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast = bitmask(zb0149)
				}
			case "votekd":
				var zb0150 int
				var zb0151 bool
				zb0150, zb0151, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0150 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0150), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "VoteKeyDilution")
					return
				}
				if zb0151 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) >= zb0150 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution)[:zb0150]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution = make([]uint64, zb0150)
				}
				for zb0018 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution[zb0018], bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteKeyDilution", zb0018)
						return
					}
				}
			case "votekdbm":
				{
					var zb0152 []byte
					zb0152, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskVoteKeyDilution")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution = bitmask(zb0152)
				}
			case "nonpart":
				var zb0153 int
				var zb0154 bool
				zb0153, zb0154, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Nonparticipation")
					return
				}
				if zb0153 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0153), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Nonparticipation")
					return
				}
				if zb0154 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation) >= zb0153 {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation = ((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation)[:zb0153]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation = make([]bool, zb0153)
				}
				for zb0019 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation {
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation[zb0019], bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Nonparticipation", zb0019)
						return
					}
				}
			case "nonpartbm":
				{
					var zb0155 []byte
					zb0155, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskNonparticipation")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation = bitmask(zb0155)
				}
			case "rcv":
				var zb0156 int
				var zb0157 bool
				zb0156, zb0157, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Receiver")
					return
				}
				if zb0156 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0156), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Receiver")
					return
				}
				if zb0157 {
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver) >= zb0156 {
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver = ((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver)[:zb0156]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver = make([]basics.Address, zb0156)
				}
				for zb0020 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver[zb0020].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Receiver", zb0020)
						return
					}
				}
			case "rcvbm":
				{
					var zb0158 []byte
					zb0158, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskReceiver")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver = bitmask(zb0158)
				}
			case "amt":
				var zb0159 int
				var zb0160 bool
				zb0159, zb0160, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0159 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0159), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Amount")
					return
				}
				if zb0160 {
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount) >= zb0159 {
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount = ((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount)[:zb0159]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount = make([]basics.MicroAlgos, zb0159)
				}
				for zb0021 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount[zb0021].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Amount", zb0021)
						return
					}
				}
			case "amtbm":
				{
					var zb0161 []byte
					zb0161, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAmount")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount = bitmask(zb0161)
				}
			case "close":
				var zb0162 int
				var zb0163 bool
				zb0162, zb0163, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
				if zb0162 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0162), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "CloseRemainderTo")
					return
				}
				if zb0163 {
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo = nil
				} else if (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo != nil && cap((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) >= zb0162 {
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo = ((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo)[:zb0162]
				} else {
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo = make([]basics.Address, zb0162)
				}
				for zb0022 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo {
					bts, err = (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo[zb0022].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CloseRemainderTo", zb0022)
						return
					}
				}
			case "closebm":
				{
					var zb0164 []byte
					zb0164, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskCloseRemainderTo")
						return
					}
					(*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo = bitmask(zb0164)
				}
			case "t":
				var zb0165 int
				var zb0166 bool
				zb0165, zb0166, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnGroups")
					return
				}
				if zb0165 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0165), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "TxnGroups")
					return
				}
				if zb0166 {
					(*z).TxnGroups = nil
				} else if (*z).TxnGroups != nil && cap((*z).TxnGroups) >= zb0165 {
					(*z).TxnGroups = ((*z).TxnGroups)[:zb0165]
				} else {
					(*z).TxnGroups = make([]txnGroups, zb0165)
				}
				for zb0023 := range (*z).TxnGroups {
					var zb0167 int
					var zb0168 bool
					zb0167, zb0168, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "TxnGroups", zb0023)
						return
					}
					if zb0167 > maxEncodedTransactionGroupEntries {
						err = msgp.ErrOverflow(uint64(zb0167), uint64(maxEncodedTransactionGroupEntries))
						err = msgp.WrapError(err, "TxnGroups", zb0023)
						return
					}
					if zb0168 {
						(*z).TxnGroups[zb0023] = nil
					} else if (*z).TxnGroups[zb0023] != nil && cap((*z).TxnGroups[zb0023]) >= zb0167 {
						(*z).TxnGroups[zb0023] = ((*z).TxnGroups[zb0023])[:zb0167]
					} else {
						(*z).TxnGroups[zb0023] = make(txnGroups, zb0167)
					}
					for zb0024 := range (*z).TxnGroups[zb0023] {
						bts, err = (*z).TxnGroups[zb0023][zb0024].UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "TxnGroups", zb0023, zb0024)
							return
						}
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *txGroupsEncodingStub) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*txGroupsEncodingStub)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *txGroupsEncodingStub) Msgsize() (s int) {
	s = 3 + 4 + msgp.Uint64Size + 4 + msgp.Uint64Size + 4 + msgp.BytesPrefixSize + len((*z).TransactionGroupSizes) + 3 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).SignedTxns {
		s += (*z).SignedTxns[zb0001].Msgsize()
	}
	s += 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).encodedSignedTxns.Sig {
		s += (*z).encodedSignedTxns.Sig[zb0002].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.BitmaskSig)) + 5 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).encodedSignedTxns.Msig {
		s += (*z).encodedSignedTxns.Msig[zb0003].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.BitmaskMsig)) + 5 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).encodedSignedTxns.Lsig {
		s += (*z).encodedSignedTxns.Lsig[zb0004].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.BitmaskLsig)) + 5 + msgp.ArrayHeaderSize
	for zb0005 := range (*z).encodedSignedTxns.AuthAddr {
		s += (*z).encodedSignedTxns.AuthAddr[zb0005].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.BitmaskAuthAddr)) + 5 + msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.TxType) + 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.BitmaskTxType)) + 4 + msgp.ArrayHeaderSize
	for zb0006 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender {
		s += (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender[zb0006].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender)) + 4 + msgp.ArrayHeaderSize
	for zb0007 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee {
		s += (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee[zb0007].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee)) + 3 + msgp.ArrayHeaderSize
	for zb0008 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid {
		s += (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid[zb0008].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid)) + 3 + msgp.ArrayHeaderSize
	for zb0009 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid {
		s += (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid[zb0009].Msgsize()
	}
	s += 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid)) + 5 + msgp.ArrayHeaderSize
	for zb0010 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note {
		s += msgp.BytesPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note[zb0010])
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote)) + 4 + msgp.StringPrefixSize + len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.GenesisID) + 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID)) + 3 + (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.GenesisHash.Msgsize() + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisHash)) + 3 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease) * (32 * (msgp.ByteSize))) + 5 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease)) + 6 + msgp.ArrayHeaderSize
	for zb0013 := range (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo {
		s += (*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo[zb0013].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo)) + 8 + msgp.ArrayHeaderSize
	for zb0014 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK {
		s += (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK[zb0014].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVotePK)) + 7 + msgp.ArrayHeaderSize
	for zb0015 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK {
		s += (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK[zb0015].Msgsize()
	}
	s += 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK)) + 8 + msgp.ArrayHeaderSize
	for zb0016 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst {
		s += (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst[zb0016].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst)) + 8 + msgp.ArrayHeaderSize
	for zb0017 := range (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast {
		s += (*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast[zb0017].Msgsize()
	}
	s += 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast)) + 7 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) * (msgp.Uint64Size)) + 9 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution)) + 8 + msgp.ArrayHeaderSize + (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation) * (msgp.BoolSize)) + 10 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation)) + 4 + msgp.ArrayHeaderSize
	for zb0020 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver {
		s += (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver[zb0020].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver)) + 4 + msgp.ArrayHeaderSize
	for zb0021 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount {
		s += (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount[zb0021].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount)) + 6 + msgp.ArrayHeaderSize
	for zb0022 := range (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo {
		s += (*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo[zb0022].Msgsize()
	}
	s += 8 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo)) + 2 + msgp.ArrayHeaderSize
	for zb0023 := range (*z).TxnGroups {
		s += msgp.ArrayHeaderSize
		for zb0024 := range (*z).TxnGroups[zb0023] {
			s += (*z).TxnGroups[zb0023][zb0024].Msgsize()
		}
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *txGroupsEncodingStub) MsgIsZero() bool {
	return ((*z).TotalTransactionsCount == 0) && ((*z).TransactionGroupCount == 0) && (len((*z).TransactionGroupSizes) == 0) && (len((*z).SignedTxns) == 0) && (len((*z).encodedSignedTxns.Sig) == 0) && (len((*z).encodedSignedTxns.BitmaskSig) == 0) && (len((*z).encodedSignedTxns.Msig) == 0) && (len((*z).encodedSignedTxns.BitmaskMsig) == 0) && (len((*z).encodedSignedTxns.Lsig) == 0) && (len((*z).encodedSignedTxns.BitmaskLsig) == 0) && (len((*z).encodedSignedTxns.AuthAddr) == 0) && (len((*z).encodedSignedTxns.BitmaskAuthAddr) == 0) && (len((*z).encodedSignedTxns.encodedTxns.TxType) == 0) && (len((*z).encodedSignedTxns.encodedTxns.BitmaskTxType) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Sender) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskSender) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Fee) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFee) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.FirstValid) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskFirstValid) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.LastValid) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLastValid) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Note) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskNote) == 0) && ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.GenesisID == "") && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisID) == 0) && ((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.GenesisHash.MsgIsZero()) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskGenesisHash) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.Lease) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskLease) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.RekeyTo) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedTxnHeaders.BitmaskRekeyTo) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VotePK) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVotePK) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.SelectionPK) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskSelectionPK) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteFirst) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteFirst) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteLast) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteLast) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.VoteKeyDilution) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskVoteKeyDilution) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.Nonparticipation) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedKeyregTxnFields.BitmaskNonparticipation) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Receiver) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskReceiver) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.Amount) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskAmount) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.CloseRemainderTo) == 0) && (len((*z).encodedSignedTxns.encodedTxns.encodedPaymentTxnFields.BitmaskCloseRemainderTo) == 0) && (len((*z).TxnGroups) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z txnGroups) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	if z == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(z)))
	}
	for za0001 := range z {
		o = z[za0001].MarshalMsg(o)
	}
	return
}

func (_ txnGroups) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(txnGroups)
	if !ok {
		_, ok = (z).(*txnGroups)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *txnGroups) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0002 > maxEncodedTransactionGroupEntries {
		err = msgp.ErrOverflow(uint64(zb0002), uint64(maxEncodedTransactionGroupEntries))
		err = msgp.WrapError(err)
		return
	}
	if zb0003 {
		(*z) = nil
	} else if (*z) != nil && cap((*z)) >= zb0002 {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(txnGroups, zb0002)
	}
	for zb0001 := range *z {
		bts, err = (*z)[zb0001].UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

func (_ *txnGroups) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*txnGroups)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z txnGroups) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for za0001 := range z {
		s += z[za0001].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z txnGroups) MsgIsZero() bool {
	return len(z) == 0
}
