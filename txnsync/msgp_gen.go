package txnsync

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	"github.com/algorand/go-algorand/crypto"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/algorand/go-algorand/data/transactions"
	"github.com/algorand/go-algorand/protocol"
	"github.com/algorand/msgp/msgp"
)

// The following msgp objects are implemented in this file:
// bitmask
//    |-----> MarshalMsg
//    |-----> CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> Msgsize
//    |-----> MsgIsZero
//
// encodedBloomFilter
//          |-----> (*) MarshalMsg
//          |-----> (*) CanMarshalMsg
//          |-----> (*) UnmarshalMsg
//          |-----> (*) CanUnmarshalMsg
//          |-----> (*) Msgsize
//          |-----> (*) MsgIsZero
//
// encodedSignedTxns
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//
// encodedTxns
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//
// packedTransactionGroups
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// requestParams
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// timingParams
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// transactionBlockMessage
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//
// txGroupsEncodingStub
//           |-----> (*) MarshalMsg
//           |-----> (*) CanMarshalMsg
//           |-----> (*) UnmarshalMsg
//           |-----> (*) CanUnmarshalMsg
//           |-----> (*) Msgsize
//           |-----> (*) MsgIsZero
//
// txnGroups
//     |-----> MarshalMsg
//     |-----> CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> Msgsize
//     |-----> MsgIsZero
//

// MarshalMsg implements msgp.Marshaler
func (z bitmask) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, []byte(z))
	return
}

func (_ bitmask) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(bitmask)
	if !ok {
		_, ok = (z).(*bitmask)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *bitmask) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 []byte
		zb0001, bts, err = msgp.ReadBytesBytes(bts, []byte((*z)))
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = bitmask(zb0001)
	}
	o = bts
	return
}

func (_ *bitmask) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*bitmask)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z bitmask) Msgsize() (s int) {
	s = msgp.BytesPrefixSize + len([]byte(z))
	return
}

// MsgIsZero returns whether this is a zero value
func (z bitmask) MsgIsZero() bool {
	return len(z) == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedBloomFilter) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 5 bits */
	if len((*z).BloomFilter) == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if ((*z).EncodingParams.Offset == 0) && ((*z).EncodingParams.Modulator == 0) {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Shuffler == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).BloomFilterType == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "f"
			o = append(o, 0xa1, 0x66)
			o = msgp.AppendBytes(o, (*z).BloomFilter)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "p"
			o = append(o, 0xa1, 0x70)
			// omitempty: check for empty values
			zb0002Len := uint32(2)
			var zb0002Mask uint8 /* 3 bits */
			if (*z).EncodingParams.Modulator == 0 {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			if (*z).EncodingParams.Offset == 0 {
				zb0002Len--
				zb0002Mask |= 0x4
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x2) == 0 { // if not empty
				// string "m"
				o = append(o, 0xa1, 0x6d)
				o = msgp.AppendByte(o, (*z).EncodingParams.Modulator)
			}
			if (zb0002Mask & 0x4) == 0 { // if not empty
				// string "o"
				o = append(o, 0xa1, 0x6f)
				o = msgp.AppendByte(o, (*z).EncodingParams.Offset)
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "s"
			o = append(o, 0xa1, 0x73)
			o = msgp.AppendByte(o, (*z).Shuffler)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			o = msgp.AppendByte(o, (*z).BloomFilterType)
		}
	}
	return
}

func (_ *encodedBloomFilter) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedBloomFilter)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedBloomFilter) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).BloomFilterType, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BloomFilterType")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0003 int
			var zb0004 bool
			zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EncodingParams")
					return
				}
				if zb0003 > 0 {
					zb0003--
					(*z).EncodingParams.Offset, bts, err = msgp.ReadByteBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "struct-from-array", "Offset")
						return
					}
				}
				if zb0003 > 0 {
					zb0003--
					(*z).EncodingParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "struct-from-array", "Modulator")
						return
					}
				}
				if zb0003 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0003)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EncodingParams")
					return
				}
				if zb0004 {
					(*z).EncodingParams = requestParams{}
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "EncodingParams")
						return
					}
					switch string(field) {
					case "o":
						(*z).EncodingParams.Offset, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "Offset")
							return
						}
					case "m":
						(*z).EncodingParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "EncodingParams", "Modulator")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "EncodingParams")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Shuffler, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Shuffler")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0005 int
			zb0005, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BloomFilter")
				return
			}
			if zb0005 > maxBloomFilterSize {
				err = msgp.ErrOverflow(uint64(zb0005), uint64(maxBloomFilterSize))
				return
			}
			(*z).BloomFilter, bts, err = msgp.ReadBytesBytes(bts, (*z).BloomFilter)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BloomFilter")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = encodedBloomFilter{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "t":
				(*z).BloomFilterType, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BloomFilterType")
					return
				}
			case "p":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "EncodingParams")
						return
					}
					if zb0006 > 0 {
						zb0006--
						(*z).EncodingParams.Offset, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "EncodingParams", "struct-from-array", "Offset")
							return
						}
					}
					if zb0006 > 0 {
						zb0006--
						(*z).EncodingParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "EncodingParams", "struct-from-array", "Modulator")
							return
						}
					}
					if zb0006 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0006)
						if err != nil {
							err = msgp.WrapError(err, "EncodingParams", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "EncodingParams")
						return
					}
					if zb0007 {
						(*z).EncodingParams = requestParams{}
					}
					for zb0006 > 0 {
						zb0006--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "EncodingParams")
							return
						}
						switch string(field) {
						case "o":
							(*z).EncodingParams.Offset, bts, err = msgp.ReadByteBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "EncodingParams", "Offset")
								return
							}
						case "m":
							(*z).EncodingParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "EncodingParams", "Modulator")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "EncodingParams")
								return
							}
						}
					}
				}
			case "s":
				(*z).Shuffler, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Shuffler")
					return
				}
			case "f":
				var zb0008 int
				zb0008, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "BloomFilter")
					return
				}
				if zb0008 > maxBloomFilterSize {
					err = msgp.ErrOverflow(uint64(zb0008), uint64(maxBloomFilterSize))
					return
				}
				(*z).BloomFilter, bts, err = msgp.ReadBytesBytes(bts, (*z).BloomFilter)
				if err != nil {
					err = msgp.WrapError(err, "BloomFilter")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedBloomFilter) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedBloomFilter)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedBloomFilter) Msgsize() (s int) {
	s = 1 + 2 + msgp.ByteSize + 2 + 1 + 2 + msgp.ByteSize + 2 + msgp.ByteSize + 2 + msgp.ByteSize + 2 + msgp.BytesPrefixSize + len((*z).BloomFilter)
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedBloomFilter) MsgIsZero() bool {
	return ((*z).BloomFilterType == 0) && (((*z).EncodingParams.Offset == 0) && ((*z).EncodingParams.Modulator == 0)) && ((*z).Shuffler == 0) && (len((*z).BloomFilter) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedSignedTxns) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0006Len := uint32(9)
	var zb0006Mask uint16 /* 11 bits */
	if len((*z).Lsig) == 0 {
		zb0006Len--
		zb0006Mask |= 0x4
	}
	if len((*z).BitmaskLsig) == 0 {
		zb0006Len--
		zb0006Mask |= 0x8
	}
	if len((*z).Msig) == 0 {
		zb0006Len--
		zb0006Mask |= 0x10
	}
	if len((*z).BitmaskMsig) == 0 {
		zb0006Len--
		zb0006Mask |= 0x20
	}
	if len((*z).AuthAddr) == 0 {
		zb0006Len--
		zb0006Mask |= 0x40
	}
	if len((*z).BitmaskAuthAddr) == 0 {
		zb0006Len--
		zb0006Mask |= 0x80
	}
	if len((*z).Sig) == 0 {
		zb0006Len--
		zb0006Mask |= 0x100
	}
	if len((*z).BitmaskSig) == 0 {
		zb0006Len--
		zb0006Mask |= 0x200
	}
	if len((*z).encodedTxns.TxType) == 0 {
		zb0006Len--
		zb0006Mask |= 0x400
	}
	// variable map header, size zb0006Len
	o = append(o, 0x80|uint8(zb0006Len))
	if zb0006Len != 0 {
		if (zb0006Mask & 0x4) == 0 { // if not empty
			// string "lsig"
			o = append(o, 0xa4, 0x6c, 0x73, 0x69, 0x67)
			if (*z).Lsig == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Lsig)))
			}
			for zb0003 := range (*z).Lsig {
				o = (*z).Lsig[zb0003].MarshalMsg(o)
			}
		}
		if (zb0006Mask & 0x8) == 0 { // if not empty
			// string "lsigb"
			o = append(o, 0xa5, 0x6c, 0x73, 0x69, 0x67, 0x62)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskLsig))
		}
		if (zb0006Mask & 0x10) == 0 { // if not empty
			// string "msig"
			o = append(o, 0xa4, 0x6d, 0x73, 0x69, 0x67)
			if (*z).Msig == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Msig)))
			}
			for zb0002 := range (*z).Msig {
				o = (*z).Msig[zb0002].MarshalMsg(o)
			}
		}
		if (zb0006Mask & 0x20) == 0 { // if not empty
			// string "msigbm"
			o = append(o, 0xa6, 0x6d, 0x73, 0x69, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskMsig))
		}
		if (zb0006Mask & 0x40) == 0 { // if not empty
			// string "sgnr"
			o = append(o, 0xa4, 0x73, 0x67, 0x6e, 0x72)
			if (*z).AuthAddr == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).AuthAddr)))
			}
			for zb0004 := range (*z).AuthAddr {
				o = (*z).AuthAddr[zb0004].MarshalMsg(o)
			}
		}
		if (zb0006Mask & 0x80) == 0 { // if not empty
			// string "sgnrbm"
			o = append(o, 0xa6, 0x73, 0x67, 0x6e, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskAuthAddr))
		}
		if (zb0006Mask & 0x100) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			if (*z).Sig == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Sig)))
			}
			for zb0001 := range (*z).Sig {
				o = (*z).Sig[zb0001].MarshalMsg(o)
			}
		}
		if (zb0006Mask & 0x200) == 0 { // if not empty
			// string "sigbm"
			o = append(o, 0xa5, 0x73, 0x69, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).BitmaskSig))
		}
		if (zb0006Mask & 0x400) == 0 { // if not empty
			// string "type"
			o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
			if (*z).encodedTxns.TxType == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedTxns.TxType)))
			}
			for zb0005 := range (*z).encodedTxns.TxType {
				o = (*z).encodedTxns.TxType[zb0005].MarshalMsg(o)
			}
		}
	}
	return
}

func (_ *encodedSignedTxns) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedSignedTxns)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedSignedTxns) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0006 int
	var zb0007 bool
	zb0006, zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0006 > 0 {
			zb0006--
			var zb0008 int
			var zb0009 bool
			zb0008, zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
			if zb0008 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0008), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
			if zb0009 {
				(*z).Sig = nil
			} else if (*z).Sig != nil && cap((*z).Sig) >= zb0008 {
				(*z).Sig = ((*z).Sig)[:zb0008]
			} else {
				(*z).Sig = make([]crypto.Signature, zb0008)
			}
			for zb0001 := range (*z).Sig {
				bts, err = (*z).Sig[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sig", zb0001)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0010 []byte
				zb0010, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSig")
					return
				}
				(*z).BitmaskSig = bitmask(zb0010)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0011 int
			var zb0012 bool
			zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Msig")
				return
			}
			if zb0011 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0011), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Msig")
				return
			}
			if zb0012 {
				(*z).Msig = nil
			} else if (*z).Msig != nil && cap((*z).Msig) >= zb0011 {
				(*z).Msig = ((*z).Msig)[:zb0011]
			} else {
				(*z).Msig = make([]crypto.MultisigSig, zb0011)
			}
			for zb0002 := range (*z).Msig {
				bts, err = (*z).Msig[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Msig", zb0002)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0013 []byte
				zb0013, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskMsig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMsig")
					return
				}
				(*z).BitmaskMsig = bitmask(zb0013)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0014 int
			var zb0015 bool
			zb0014, zb0015, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lsig")
				return
			}
			if zb0014 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0014), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Lsig")
				return
			}
			if zb0015 {
				(*z).Lsig = nil
			} else if (*z).Lsig != nil && cap((*z).Lsig) >= zb0014 {
				(*z).Lsig = ((*z).Lsig)[:zb0014]
			} else {
				(*z).Lsig = make([]transactions.LogicSig, zb0014)
			}
			for zb0003 := range (*z).Lsig {
				bts, err = (*z).Lsig[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Lsig", zb0003)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0016 []byte
				zb0016, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLsig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLsig")
					return
				}
				(*z).BitmaskLsig = bitmask(zb0016)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0017 int
			var zb0018 bool
			zb0017, zb0018, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
			if zb0017 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0017), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
			if zb0018 {
				(*z).AuthAddr = nil
			} else if (*z).AuthAddr != nil && cap((*z).AuthAddr) >= zb0017 {
				(*z).AuthAddr = ((*z).AuthAddr)[:zb0017]
			} else {
				(*z).AuthAddr = make([]basics.Address, zb0017)
			}
			for zb0004 := range (*z).AuthAddr {
				bts, err = (*z).AuthAddr[zb0004].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AuthAddr", zb0004)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			{
				var zb0019 []byte
				zb0019, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAuthAddr))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAuthAddr")
					return
				}
				(*z).BitmaskAuthAddr = bitmask(zb0019)
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0020 int
			var zb0021 bool
			zb0020, zb0021, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
			if zb0020 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0020), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
			if zb0021 {
				(*z).encodedTxns.TxType = nil
			} else if (*z).encodedTxns.TxType != nil && cap((*z).encodedTxns.TxType) >= zb0020 {
				(*z).encodedTxns.TxType = ((*z).encodedTxns.TxType)[:zb0020]
			} else {
				(*z).encodedTxns.TxType = make([]protocol.TxType, zb0020)
			}
			for zb0005 := range (*z).encodedTxns.TxType {
				bts, err = (*z).encodedTxns.TxType[zb0005].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "TxType", zb0005)
					return
				}
			}
		}
		if zb0006 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0006)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0007 {
			(*z) = encodedSignedTxns{}
		}
		for zb0006 > 0 {
			zb0006--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "sig":
				var zb0022 int
				var zb0023 bool
				zb0022, zb0023, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
				if zb0022 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0022), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Sig")
					return
				}
				if zb0023 {
					(*z).Sig = nil
				} else if (*z).Sig != nil && cap((*z).Sig) >= zb0022 {
					(*z).Sig = ((*z).Sig)[:zb0022]
				} else {
					(*z).Sig = make([]crypto.Signature, zb0022)
				}
				for zb0001 := range (*z).Sig {
					bts, err = (*z).Sig[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sig", zb0001)
						return
					}
				}
			case "sigbm":
				{
					var zb0024 []byte
					zb0024, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskSig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSig")
						return
					}
					(*z).BitmaskSig = bitmask(zb0024)
				}
			case "msig":
				var zb0025 int
				var zb0026 bool
				zb0025, zb0026, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Msig")
					return
				}
				if zb0025 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0025), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Msig")
					return
				}
				if zb0026 {
					(*z).Msig = nil
				} else if (*z).Msig != nil && cap((*z).Msig) >= zb0025 {
					(*z).Msig = ((*z).Msig)[:zb0025]
				} else {
					(*z).Msig = make([]crypto.MultisigSig, zb0025)
				}
				for zb0002 := range (*z).Msig {
					bts, err = (*z).Msig[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Msig", zb0002)
						return
					}
				}
			case "msigbm":
				{
					var zb0027 []byte
					zb0027, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskMsig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMsig")
						return
					}
					(*z).BitmaskMsig = bitmask(zb0027)
				}
			case "lsig":
				var zb0028 int
				var zb0029 bool
				zb0028, zb0029, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lsig")
					return
				}
				if zb0028 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0028), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Lsig")
					return
				}
				if zb0029 {
					(*z).Lsig = nil
				} else if (*z).Lsig != nil && cap((*z).Lsig) >= zb0028 {
					(*z).Lsig = ((*z).Lsig)[:zb0028]
				} else {
					(*z).Lsig = make([]transactions.LogicSig, zb0028)
				}
				for zb0003 := range (*z).Lsig {
					bts, err = (*z).Lsig[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Lsig", zb0003)
						return
					}
				}
			case "lsigb":
				{
					var zb0030 []byte
					zb0030, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskLsig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLsig")
						return
					}
					(*z).BitmaskLsig = bitmask(zb0030)
				}
			case "sgnr":
				var zb0031 int
				var zb0032 bool
				zb0031, zb0032, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
				if zb0031 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0031), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
				if zb0032 {
					(*z).AuthAddr = nil
				} else if (*z).AuthAddr != nil && cap((*z).AuthAddr) >= zb0031 {
					(*z).AuthAddr = ((*z).AuthAddr)[:zb0031]
				} else {
					(*z).AuthAddr = make([]basics.Address, zb0031)
				}
				for zb0004 := range (*z).AuthAddr {
					bts, err = (*z).AuthAddr[zb0004].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "AuthAddr", zb0004)
						return
					}
				}
			case "sgnrbm":
				{
					var zb0033 []byte
					zb0033, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).BitmaskAuthAddr))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAuthAddr")
						return
					}
					(*z).BitmaskAuthAddr = bitmask(zb0033)
				}
			case "type":
				var zb0034 int
				var zb0035 bool
				zb0034, zb0035, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
				if zb0034 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0034), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "TxType")
					return
				}
				if zb0035 {
					(*z).encodedTxns.TxType = nil
				} else if (*z).encodedTxns.TxType != nil && cap((*z).encodedTxns.TxType) >= zb0034 {
					(*z).encodedTxns.TxType = ((*z).encodedTxns.TxType)[:zb0034]
				} else {
					(*z).encodedTxns.TxType = make([]protocol.TxType, zb0034)
				}
				for zb0005 := range (*z).encodedTxns.TxType {
					bts, err = (*z).encodedTxns.TxType[zb0005].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "TxType", zb0005)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedSignedTxns) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedSignedTxns)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedSignedTxns) Msgsize() (s int) {
	s = 1 + 4 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Sig {
		s += (*z).Sig[zb0001].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskSig)) + 5 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Msig {
		s += (*z).Msig[zb0002].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskMsig)) + 5 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).Lsig {
		s += (*z).Lsig[zb0003].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskLsig)) + 5 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).AuthAddr {
		s += (*z).AuthAddr[zb0004].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).BitmaskAuthAddr)) + 5 + msgp.ArrayHeaderSize
	for zb0005 := range (*z).encodedTxns.TxType {
		s += (*z).encodedTxns.TxType[zb0005].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedSignedTxns) MsgIsZero() bool {
	return (len((*z).Sig) == 0) && (len((*z).BitmaskSig) == 0) && (len((*z).Msig) == 0) && (len((*z).BitmaskMsig) == 0) && (len((*z).Lsig) == 0) && (len((*z).BitmaskLsig) == 0) && (len((*z).AuthAddr) == 0) && (len((*z).BitmaskAuthAddr) == 0) && (len((*z).encodedTxns.TxType) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *encodedTxns) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(1)
	var zb0002Mask uint8 /* 2 bits */
	if len((*z).TxType) == 0 {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "type"
			o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
			if (*z).TxType == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).TxType)))
			}
			for zb0001 := range (*z).TxType {
				o = (*z).TxType[zb0001].MarshalMsg(o)
			}
		}
	}
	return
}

func (_ *encodedTxns) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedTxns)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *encodedTxns) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
			if zb0004 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0004), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
			if zb0005 {
				(*z).TxType = nil
			} else if (*z).TxType != nil && cap((*z).TxType) >= zb0004 {
				(*z).TxType = ((*z).TxType)[:zb0004]
			} else {
				(*z).TxType = make([]protocol.TxType, zb0004)
			}
			for zb0001 := range (*z).TxType {
				bts, err = (*z).TxType[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "TxType", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = encodedTxns{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "type":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
				if zb0006 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0006), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "TxType")
					return
				}
				if zb0007 {
					(*z).TxType = nil
				} else if (*z).TxType != nil && cap((*z).TxType) >= zb0006 {
					(*z).TxType = ((*z).TxType)[:zb0006]
				} else {
					(*z).TxType = make([]protocol.TxType, zb0006)
				}
				for zb0001 := range (*z).TxType {
					bts, err = (*z).TxType[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "TxType", zb0001)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *encodedTxns) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*encodedTxns)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *encodedTxns) Msgsize() (s int) {
	s = 1 + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).TxType {
		s += (*z).TxType[zb0001].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *encodedTxns) MsgIsZero() bool {
	return (len((*z).TxType) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *packedTransactionGroups) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 2 bits */
	if len((*z).Bytes) == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "g"
			o = append(o, 0xa1, 0x67)
			o = msgp.AppendBytes(o, (*z).Bytes)
		}
	}
	return
}

func (_ *packedTransactionGroups) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*packedTransactionGroups)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *packedTransactionGroups) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			var zb0003 int
			zb0003, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Bytes")
				return
			}
			if zb0003 > maxEncodedTransactionGroupBytes {
				err = msgp.ErrOverflow(uint64(zb0003), uint64(maxEncodedTransactionGroupBytes))
				return
			}
			(*z).Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).Bytes)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Bytes")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = packedTransactionGroups{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "g":
				var zb0004 int
				zb0004, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bytes")
					return
				}
				if zb0004 > maxEncodedTransactionGroupBytes {
					err = msgp.ErrOverflow(uint64(zb0004), uint64(maxEncodedTransactionGroupBytes))
					return
				}
				(*z).Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).Bytes)
				if err != nil {
					err = msgp.WrapError(err, "Bytes")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *packedTransactionGroups) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*packedTransactionGroups)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *packedTransactionGroups) Msgsize() (s int) {
	s = 1 + 2 + msgp.BytesPrefixSize + len((*z).Bytes)
	return
}

// MsgIsZero returns whether this is a zero value
func (z *packedTransactionGroups) MsgIsZero() bool {
	return (len((*z).Bytes) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *requestParams) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 3 bits */
	if (*z).Modulator == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Offset == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "m"
			o = append(o, 0xa1, 0x6d)
			o = msgp.AppendByte(o, (*z).Modulator)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "o"
			o = append(o, 0xa1, 0x6f)
			o = msgp.AppendByte(o, (*z).Offset)
		}
	}
	return
}

func (_ *requestParams) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*requestParams)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *requestParams) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Offset, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Offset")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Modulator, bts, err = msgp.ReadByteBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Modulator")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = requestParams{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "o":
				(*z).Offset, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Offset")
					return
				}
			case "m":
				(*z).Modulator, bts, err = msgp.ReadByteBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Modulator")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *requestParams) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*requestParams)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *requestParams) Msgsize() (s int) {
	s = 1 + 2 + msgp.ByteSize + 2 + msgp.ByteSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *requestParams) MsgIsZero() bool {
	return ((*z).Offset == 0) && ((*z).Modulator == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *timingParams) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(4)
	var zb0002Mask uint8 /* 5 bits */
	if len((*z).AcceptedMsgSeq) == 0 {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	if (*z).NextMsgMinDelay == 0 {
		zb0002Len--
		zb0002Mask |= 0x4
	}
	if (*z).ResponseElapsedTime == 0 {
		zb0002Len--
		zb0002Mask |= 0x8
	}
	if (*z).RefTxnBlockMsgSeq == 0 {
		zb0002Len--
		zb0002Mask |= 0x10
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "a"
			o = append(o, 0xa1, 0x61)
			if (*z).AcceptedMsgSeq == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).AcceptedMsgSeq)))
			}
			for zb0001 := range (*z).AcceptedMsgSeq {
				o = msgp.AppendUint32(o, (*z).AcceptedMsgSeq[zb0001])
			}
		}
		if (zb0002Mask & 0x4) == 0 { // if not empty
			// string "m"
			o = append(o, 0xa1, 0x6d)
			o = msgp.AppendUint64(o, (*z).NextMsgMinDelay)
		}
		if (zb0002Mask & 0x8) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = msgp.AppendUint64(o, (*z).ResponseElapsedTime)
		}
		if (zb0002Mask & 0x10) == 0 { // if not empty
			// string "s"
			o = append(o, 0xa1, 0x73)
			o = msgp.AppendUint64(o, (*z).RefTxnBlockMsgSeq)
		}
	}
	return
}

func (_ *timingParams) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*timingParams)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *timingParams) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			(*z).RefTxnBlockMsgSeq, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RefTxnBlockMsgSeq")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).ResponseElapsedTime, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ResponseElapsedTime")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AcceptedMsgSeq")
				return
			}
			if zb0004 > maxAcceptedMsgSeq {
				err = msgp.ErrOverflow(uint64(zb0004), uint64(maxAcceptedMsgSeq))
				err = msgp.WrapError(err, "struct-from-array", "AcceptedMsgSeq")
				return
			}
			if zb0005 {
				(*z).AcceptedMsgSeq = nil
			} else if (*z).AcceptedMsgSeq != nil && cap((*z).AcceptedMsgSeq) >= zb0004 {
				(*z).AcceptedMsgSeq = ((*z).AcceptedMsgSeq)[:zb0004]
			} else {
				(*z).AcceptedMsgSeq = make([]uint32, zb0004)
			}
			for zb0001 := range (*z).AcceptedMsgSeq {
				(*z).AcceptedMsgSeq[zb0001], bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AcceptedMsgSeq", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).NextMsgMinDelay, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextMsgMinDelay")
				return
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = timingParams{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "s":
				(*z).RefTxnBlockMsgSeq, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RefTxnBlockMsgSeq")
					return
				}
			case "r":
				(*z).ResponseElapsedTime, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ResponseElapsedTime")
					return
				}
			case "a":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AcceptedMsgSeq")
					return
				}
				if zb0006 > maxAcceptedMsgSeq {
					err = msgp.ErrOverflow(uint64(zb0006), uint64(maxAcceptedMsgSeq))
					err = msgp.WrapError(err, "AcceptedMsgSeq")
					return
				}
				if zb0007 {
					(*z).AcceptedMsgSeq = nil
				} else if (*z).AcceptedMsgSeq != nil && cap((*z).AcceptedMsgSeq) >= zb0006 {
					(*z).AcceptedMsgSeq = ((*z).AcceptedMsgSeq)[:zb0006]
				} else {
					(*z).AcceptedMsgSeq = make([]uint32, zb0006)
				}
				for zb0001 := range (*z).AcceptedMsgSeq {
					(*z).AcceptedMsgSeq[zb0001], bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AcceptedMsgSeq", zb0001)
						return
					}
				}
			case "m":
				(*z).NextMsgMinDelay, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextMsgMinDelay")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *timingParams) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*timingParams)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *timingParams) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint64Size + 2 + msgp.Uint64Size + 2 + msgp.ArrayHeaderSize + (len((*z).AcceptedMsgSeq) * (msgp.Uint32Size)) + 2 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *timingParams) MsgIsZero() bool {
	return ((*z).RefTxnBlockMsgSeq == 0) && ((*z).ResponseElapsedTime == 0) && (len((*z).AcceptedMsgSeq) == 0) && ((*z).NextMsgMinDelay == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *transactionBlockMessage) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 7 bits */
	if (*z).TxnBloomFilter.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if len((*z).TransactionGroups.Bytes) == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if ((*z).UpdatedRequestParams.Offset == 0) && ((*z).UpdatedRequestParams.Modulator == 0) {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).MsgSync.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).Version == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "b"
			o = append(o, 0xa1, 0x62)
			o = (*z).TxnBloomFilter.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "g"
			o = append(o, 0xa1, 0x67)
			// omitempty: check for empty values
			zb0002Len := uint32(1)
			var zb0002Mask uint8 /* 2 bits */
			if len((*z).TransactionGroups.Bytes) == 0 {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x2) == 0 { // if not empty
				// string "g"
				o = append(o, 0xa1, 0x67)
				o = msgp.AppendBytes(o, (*z).TransactionGroups.Bytes)
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "p"
			o = append(o, 0xa1, 0x70)
			// omitempty: check for empty values
			zb0003Len := uint32(2)
			var zb0003Mask uint8 /* 3 bits */
			if (*z).UpdatedRequestParams.Modulator == 0 {
				zb0003Len--
				zb0003Mask |= 0x2
			}
			if (*z).UpdatedRequestParams.Offset == 0 {
				zb0003Len--
				zb0003Mask |= 0x4
			}
			// variable map header, size zb0003Len
			o = append(o, 0x80|uint8(zb0003Len))
			if (zb0003Mask & 0x2) == 0 { // if not empty
				// string "m"
				o = append(o, 0xa1, 0x6d)
				o = msgp.AppendByte(o, (*z).UpdatedRequestParams.Modulator)
			}
			if (zb0003Mask & 0x4) == 0 { // if not empty
				// string "o"
				o = append(o, 0xa1, 0x6f)
				o = msgp.AppendByte(o, (*z).UpdatedRequestParams.Offset)
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			o = (*z).MsgSync.MarshalMsg(o)
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "v"
			o = append(o, 0xa1, 0x76)
			o = msgp.AppendInt32(o, (*z).Version)
		}
	}
	return
}

func (_ *transactionBlockMessage) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*transactionBlockMessage)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *transactionBlockMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Version, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Version")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).TxnBloomFilter.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnBloomFilter")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0003 int
			var zb0004 bool
			zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams")
					return
				}
				if zb0003 > 0 {
					zb0003--
					(*z).UpdatedRequestParams.Offset, bts, err = msgp.ReadByteBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "struct-from-array", "Offset")
						return
					}
				}
				if zb0003 > 0 {
					zb0003--
					(*z).UpdatedRequestParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "struct-from-array", "Modulator")
						return
					}
				}
				if zb0003 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0003)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams")
					return
				}
				if zb0004 {
					(*z).UpdatedRequestParams = requestParams{}
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams")
						return
					}
					switch string(field) {
					case "o":
						(*z).UpdatedRequestParams.Offset, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "Offset")
							return
						}
					case "m":
						(*z).UpdatedRequestParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams", "Modulator")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "UpdatedRequestParams")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "TransactionGroups")
					return
				}
				if zb0005 > 0 {
					zb0005--
					var zb0007 int
					zb0007, err = msgp.ReadBytesBytesHeader(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "TransactionGroups", "struct-from-array", "Bytes")
						return
					}
					if zb0007 > maxEncodedTransactionGroupBytes {
						err = msgp.ErrOverflow(uint64(zb0007), uint64(maxEncodedTransactionGroupBytes))
						return
					}
					(*z).TransactionGroups.Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroups.Bytes)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "TransactionGroups", "struct-from-array", "Bytes")
						return
					}
				}
				if zb0005 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0005)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "TransactionGroups", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "TransactionGroups")
					return
				}
				if zb0006 {
					(*z).TransactionGroups = packedTransactionGroups{}
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "TransactionGroups")
						return
					}
					switch string(field) {
					case "g":
						var zb0008 int
						zb0008, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "TransactionGroups", "Bytes")
							return
						}
						if zb0008 > maxEncodedTransactionGroupBytes {
							err = msgp.ErrOverflow(uint64(zb0008), uint64(maxEncodedTransactionGroupBytes))
							return
						}
						(*z).TransactionGroups.Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroups.Bytes)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "TransactionGroups", "Bytes")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "TransactionGroups")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).MsgSync.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MsgSync")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = transactionBlockMessage{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "v":
				(*z).Version, bts, err = msgp.ReadInt32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Version")
					return
				}
			case "r":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "b":
				bts, err = (*z).TxnBloomFilter.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnBloomFilter")
					return
				}
			case "p":
				var zb0009 int
				var zb0010 bool
				zb0009, zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "UpdatedRequestParams")
						return
					}
					if zb0009 > 0 {
						zb0009--
						(*z).UpdatedRequestParams.Offset, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "UpdatedRequestParams", "struct-from-array", "Offset")
							return
						}
					}
					if zb0009 > 0 {
						zb0009--
						(*z).UpdatedRequestParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "UpdatedRequestParams", "struct-from-array", "Modulator")
							return
						}
					}
					if zb0009 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0009)
						if err != nil {
							err = msgp.WrapError(err, "UpdatedRequestParams", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "UpdatedRequestParams")
						return
					}
					if zb0010 {
						(*z).UpdatedRequestParams = requestParams{}
					}
					for zb0009 > 0 {
						zb0009--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "UpdatedRequestParams")
							return
						}
						switch string(field) {
						case "o":
							(*z).UpdatedRequestParams.Offset, bts, err = msgp.ReadByteBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "UpdatedRequestParams", "Offset")
								return
							}
						case "m":
							(*z).UpdatedRequestParams.Modulator, bts, err = msgp.ReadByteBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "UpdatedRequestParams", "Modulator")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "UpdatedRequestParams")
								return
							}
						}
					}
				}
			case "g":
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "TransactionGroups")
						return
					}
					if zb0011 > 0 {
						zb0011--
						var zb0013 int
						zb0013, err = msgp.ReadBytesBytesHeader(bts)
						if err != nil {
							err = msgp.WrapError(err, "TransactionGroups", "struct-from-array", "Bytes")
							return
						}
						if zb0013 > maxEncodedTransactionGroupBytes {
							err = msgp.ErrOverflow(uint64(zb0013), uint64(maxEncodedTransactionGroupBytes))
							return
						}
						(*z).TransactionGroups.Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroups.Bytes)
						if err != nil {
							err = msgp.WrapError(err, "TransactionGroups", "struct-from-array", "Bytes")
							return
						}
					}
					if zb0011 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0011)
						if err != nil {
							err = msgp.WrapError(err, "TransactionGroups", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "TransactionGroups")
						return
					}
					if zb0012 {
						(*z).TransactionGroups = packedTransactionGroups{}
					}
					for zb0011 > 0 {
						zb0011--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "TransactionGroups")
							return
						}
						switch string(field) {
						case "g":
							var zb0014 int
							zb0014, err = msgp.ReadBytesBytesHeader(bts)
							if err != nil {
								err = msgp.WrapError(err, "TransactionGroups", "Bytes")
								return
							}
							if zb0014 > maxEncodedTransactionGroupBytes {
								err = msgp.ErrOverflow(uint64(zb0014), uint64(maxEncodedTransactionGroupBytes))
								return
							}
							(*z).TransactionGroups.Bytes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroups.Bytes)
							if err != nil {
								err = msgp.WrapError(err, "TransactionGroups", "Bytes")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "TransactionGroups")
								return
							}
						}
					}
				}
			case "t":
				bts, err = (*z).MsgSync.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "MsgSync")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *transactionBlockMessage) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*transactionBlockMessage)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *transactionBlockMessage) Msgsize() (s int) {
	s = 1 + 2 + msgp.Int32Size + 2 + (*z).Round.Msgsize() + 2 + (*z).TxnBloomFilter.Msgsize() + 2 + 1 + 2 + msgp.ByteSize + 2 + msgp.ByteSize + 2 + 1 + 2 + msgp.BytesPrefixSize + len((*z).TransactionGroups.Bytes) + 2 + (*z).MsgSync.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *transactionBlockMessage) MsgIsZero() bool {
	return ((*z).Version == 0) && ((*z).Round.MsgIsZero()) && ((*z).TxnBloomFilter.MsgIsZero()) && (((*z).UpdatedRequestParams.Offset == 0) && ((*z).UpdatedRequestParams.Modulator == 0)) && (len((*z).TransactionGroups.Bytes) == 0) && ((*z).MsgSync.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *txGroupsEncodingStub) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0007Len := uint32(13)
	var zb0007Mask uint16 /* 16 bits */
	if (*z).TotalTransactionsCount == 0 {
		zb0007Len--
		zb0007Mask |= 0x1
	}
	if (*z).TransactionGroupCount == 0 {
		zb0007Len--
		zb0007Mask |= 0x2
	}
	if len((*z).encodedSignedTxns.Lsig) == 0 {
		zb0007Len--
		zb0007Mask |= 0x20
	}
	if len((*z).encodedSignedTxns.BitmaskLsig) == 0 {
		zb0007Len--
		zb0007Mask |= 0x40
	}
	if len((*z).encodedSignedTxns.Msig) == 0 {
		zb0007Len--
		zb0007Mask |= 0x80
	}
	if len((*z).encodedSignedTxns.BitmaskMsig) == 0 {
		zb0007Len--
		zb0007Mask |= 0x100
	}
	if len((*z).encodedSignedTxns.AuthAddr) == 0 {
		zb0007Len--
		zb0007Mask |= 0x200
	}
	if len((*z).encodedSignedTxns.BitmaskAuthAddr) == 0 {
		zb0007Len--
		zb0007Mask |= 0x400
	}
	if len((*z).encodedSignedTxns.Sig) == 0 {
		zb0007Len--
		zb0007Mask |= 0x800
	}
	if len((*z).encodedSignedTxns.BitmaskSig) == 0 {
		zb0007Len--
		zb0007Mask |= 0x1000
	}
	if len((*z).SignedTxns) == 0 {
		zb0007Len--
		zb0007Mask |= 0x2000
	}
	if len((*z).TransactionGroupSizes) == 0 {
		zb0007Len--
		zb0007Mask |= 0x4000
	}
	if len((*z).encodedSignedTxns.encodedTxns.TxType) == 0 {
		zb0007Len--
		zb0007Mask |= 0x8000
	}
	// variable map header, size zb0007Len
	o = append(o, 0x80|uint8(zb0007Len))
	if zb0007Len != 0 {
		if (zb0007Mask & 0x1) == 0 { // if not empty
			// string "TotalTransactionsCount"
			o = append(o, 0xb6, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendUint64(o, (*z).TotalTransactionsCount)
		}
		if (zb0007Mask & 0x2) == 0 { // if not empty
			// string "TransactionGroupCount"
			o = append(o, 0xb5, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x43, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendUint64(o, (*z).TransactionGroupCount)
		}
		if (zb0007Mask & 0x20) == 0 { // if not empty
			// string "lsig"
			o = append(o, 0xa4, 0x6c, 0x73, 0x69, 0x67)
			if (*z).encodedSignedTxns.Lsig == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.Lsig)))
			}
			for zb0004 := range (*z).encodedSignedTxns.Lsig {
				o = (*z).encodedSignedTxns.Lsig[zb0004].MarshalMsg(o)
			}
		}
		if (zb0007Mask & 0x40) == 0 { // if not empty
			// string "lsigb"
			o = append(o, 0xa5, 0x6c, 0x73, 0x69, 0x67, 0x62)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.BitmaskLsig))
		}
		if (zb0007Mask & 0x80) == 0 { // if not empty
			// string "msig"
			o = append(o, 0xa4, 0x6d, 0x73, 0x69, 0x67)
			if (*z).encodedSignedTxns.Msig == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.Msig)))
			}
			for zb0003 := range (*z).encodedSignedTxns.Msig {
				o = (*z).encodedSignedTxns.Msig[zb0003].MarshalMsg(o)
			}
		}
		if (zb0007Mask & 0x100) == 0 { // if not empty
			// string "msigbm"
			o = append(o, 0xa6, 0x6d, 0x73, 0x69, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.BitmaskMsig))
		}
		if (zb0007Mask & 0x200) == 0 { // if not empty
			// string "sgnr"
			o = append(o, 0xa4, 0x73, 0x67, 0x6e, 0x72)
			if (*z).encodedSignedTxns.AuthAddr == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.AuthAddr)))
			}
			for zb0005 := range (*z).encodedSignedTxns.AuthAddr {
				o = (*z).encodedSignedTxns.AuthAddr[zb0005].MarshalMsg(o)
			}
		}
		if (zb0007Mask & 0x400) == 0 { // if not empty
			// string "sgnrbm"
			o = append(o, 0xa6, 0x73, 0x67, 0x6e, 0x72, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.BitmaskAuthAddr))
		}
		if (zb0007Mask & 0x800) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			if (*z).encodedSignedTxns.Sig == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.Sig)))
			}
			for zb0002 := range (*z).encodedSignedTxns.Sig {
				o = (*z).encodedSignedTxns.Sig[zb0002].MarshalMsg(o)
			}
		}
		if (zb0007Mask & 0x1000) == 0 { // if not empty
			// string "sigbm"
			o = append(o, 0xa5, 0x73, 0x69, 0x67, 0x62, 0x6d)
			o = msgp.AppendBytes(o, []byte((*z).encodedSignedTxns.BitmaskSig))
		}
		if (zb0007Mask & 0x2000) == 0 { // if not empty
			// string "st"
			o = append(o, 0xa2, 0x73, 0x74)
			if (*z).SignedTxns == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).SignedTxns)))
			}
			for zb0001 := range (*z).SignedTxns {
				o = (*z).SignedTxns[zb0001].MarshalMsg(o)
			}
		}
		if (zb0007Mask & 0x4000) == 0 { // if not empty
			// string "tgs"
			o = append(o, 0xa3, 0x74, 0x67, 0x73)
			o = msgp.AppendBytes(o, (*z).TransactionGroupSizes)
		}
		if (zb0007Mask & 0x8000) == 0 { // if not empty
			// string "type"
			o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
			if (*z).encodedSignedTxns.encodedTxns.TxType == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).encodedSignedTxns.encodedTxns.TxType)))
			}
			for zb0006 := range (*z).encodedSignedTxns.encodedTxns.TxType {
				o = (*z).encodedSignedTxns.encodedTxns.TxType[zb0006].MarshalMsg(o)
			}
		}
	}
	return
}

func (_ *txGroupsEncodingStub) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*txGroupsEncodingStub)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *txGroupsEncodingStub) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0007 int
	var zb0008 bool
	zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0007 > 0 {
			zb0007--
			(*z).TotalTransactionsCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TotalTransactionsCount")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			(*z).TransactionGroupCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TransactionGroupCount")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0009 int
			zb0009, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TransactionGroupSizes")
				return
			}
			if zb0009 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(maxEncodedTransactionGroup))
				return
			}
			(*z).TransactionGroupSizes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroupSizes)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TransactionGroupSizes")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0010 int
			var zb0011 bool
			zb0010, zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SignedTxns")
				return
			}
			if zb0010 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0010), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "SignedTxns")
				return
			}
			if zb0011 {
				(*z).SignedTxns = nil
			} else if (*z).SignedTxns != nil && cap((*z).SignedTxns) >= zb0010 {
				(*z).SignedTxns = ((*z).SignedTxns)[:zb0010]
			} else {
				(*z).SignedTxns = make([]transactions.SignedTxn, zb0010)
			}
			for zb0001 := range (*z).SignedTxns {
				bts, err = (*z).SignedTxns[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedTxns", zb0001)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0012 int
			var zb0013 bool
			zb0012, zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
			if zb0012 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0012), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
			if zb0013 {
				(*z).encodedSignedTxns.Sig = nil
			} else if (*z).encodedSignedTxns.Sig != nil && cap((*z).encodedSignedTxns.Sig) >= zb0012 {
				(*z).encodedSignedTxns.Sig = ((*z).encodedSignedTxns.Sig)[:zb0012]
			} else {
				(*z).encodedSignedTxns.Sig = make([]crypto.Signature, zb0012)
			}
			for zb0002 := range (*z).encodedSignedTxns.Sig {
				bts, err = (*z).encodedSignedTxns.Sig[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sig", zb0002)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0014 []byte
				zb0014, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskSig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskSig")
					return
				}
				(*z).encodedSignedTxns.BitmaskSig = bitmask(zb0014)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0015 int
			var zb0016 bool
			zb0015, zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Msig")
				return
			}
			if zb0015 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0015), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Msig")
				return
			}
			if zb0016 {
				(*z).encodedSignedTxns.Msig = nil
			} else if (*z).encodedSignedTxns.Msig != nil && cap((*z).encodedSignedTxns.Msig) >= zb0015 {
				(*z).encodedSignedTxns.Msig = ((*z).encodedSignedTxns.Msig)[:zb0015]
			} else {
				(*z).encodedSignedTxns.Msig = make([]crypto.MultisigSig, zb0015)
			}
			for zb0003 := range (*z).encodedSignedTxns.Msig {
				bts, err = (*z).encodedSignedTxns.Msig[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Msig", zb0003)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0017 []byte
				zb0017, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskMsig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskMsig")
					return
				}
				(*z).encodedSignedTxns.BitmaskMsig = bitmask(zb0017)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0018 int
			var zb0019 bool
			zb0018, zb0019, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lsig")
				return
			}
			if zb0018 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0018), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "Lsig")
				return
			}
			if zb0019 {
				(*z).encodedSignedTxns.Lsig = nil
			} else if (*z).encodedSignedTxns.Lsig != nil && cap((*z).encodedSignedTxns.Lsig) >= zb0018 {
				(*z).encodedSignedTxns.Lsig = ((*z).encodedSignedTxns.Lsig)[:zb0018]
			} else {
				(*z).encodedSignedTxns.Lsig = make([]transactions.LogicSig, zb0018)
			}
			for zb0004 := range (*z).encodedSignedTxns.Lsig {
				bts, err = (*z).encodedSignedTxns.Lsig[zb0004].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Lsig", zb0004)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0020 []byte
				zb0020, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskLsig))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskLsig")
					return
				}
				(*z).encodedSignedTxns.BitmaskLsig = bitmask(zb0020)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0021 int
			var zb0022 bool
			zb0021, zb0022, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
			if zb0021 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0021), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "AuthAddr")
				return
			}
			if zb0022 {
				(*z).encodedSignedTxns.AuthAddr = nil
			} else if (*z).encodedSignedTxns.AuthAddr != nil && cap((*z).encodedSignedTxns.AuthAddr) >= zb0021 {
				(*z).encodedSignedTxns.AuthAddr = ((*z).encodedSignedTxns.AuthAddr)[:zb0021]
			} else {
				(*z).encodedSignedTxns.AuthAddr = make([]basics.Address, zb0021)
			}
			for zb0005 := range (*z).encodedSignedTxns.AuthAddr {
				bts, err = (*z).encodedSignedTxns.AuthAddr[zb0005].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "AuthAddr", zb0005)
					return
				}
			}
		}
		if zb0007 > 0 {
			zb0007--
			{
				var zb0023 []byte
				zb0023, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskAuthAddr))
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "BitmaskAuthAddr")
					return
				}
				(*z).encodedSignedTxns.BitmaskAuthAddr = bitmask(zb0023)
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0024 int
			var zb0025 bool
			zb0024, zb0025, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
			if zb0024 > maxEncodedTransactionGroup {
				err = msgp.ErrOverflow(uint64(zb0024), uint64(maxEncodedTransactionGroup))
				err = msgp.WrapError(err, "struct-from-array", "TxType")
				return
			}
			if zb0025 {
				(*z).encodedSignedTxns.encodedTxns.TxType = nil
			} else if (*z).encodedSignedTxns.encodedTxns.TxType != nil && cap((*z).encodedSignedTxns.encodedTxns.TxType) >= zb0024 {
				(*z).encodedSignedTxns.encodedTxns.TxType = ((*z).encodedSignedTxns.encodedTxns.TxType)[:zb0024]
			} else {
				(*z).encodedSignedTxns.encodedTxns.TxType = make([]protocol.TxType, zb0024)
			}
			for zb0006 := range (*z).encodedSignedTxns.encodedTxns.TxType {
				bts, err = (*z).encodedSignedTxns.encodedTxns.TxType[zb0006].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "TxType", zb0006)
					return
				}
			}
		}
		if zb0007 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0007)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0008 {
			(*z) = txGroupsEncodingStub{}
		}
		for zb0007 > 0 {
			zb0007--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "TotalTransactionsCount":
				(*z).TotalTransactionsCount, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TotalTransactionsCount")
					return
				}
			case "TransactionGroupCount":
				(*z).TransactionGroupCount, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TransactionGroupCount")
					return
				}
			case "tgs":
				var zb0026 int
				zb0026, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "TransactionGroupSizes")
					return
				}
				if zb0026 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0026), uint64(maxEncodedTransactionGroup))
					return
				}
				(*z).TransactionGroupSizes, bts, err = msgp.ReadBytesBytes(bts, (*z).TransactionGroupSizes)
				if err != nil {
					err = msgp.WrapError(err, "TransactionGroupSizes")
					return
				}
			case "st":
				var zb0027 int
				var zb0028 bool
				zb0027, zb0028, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SignedTxns")
					return
				}
				if zb0027 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0027), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "SignedTxns")
					return
				}
				if zb0028 {
					(*z).SignedTxns = nil
				} else if (*z).SignedTxns != nil && cap((*z).SignedTxns) >= zb0027 {
					(*z).SignedTxns = ((*z).SignedTxns)[:zb0027]
				} else {
					(*z).SignedTxns = make([]transactions.SignedTxn, zb0027)
				}
				for zb0001 := range (*z).SignedTxns {
					bts, err = (*z).SignedTxns[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedTxns", zb0001)
						return
					}
				}
			case "sig":
				var zb0029 int
				var zb0030 bool
				zb0029, zb0030, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
				if zb0029 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0029), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Sig")
					return
				}
				if zb0030 {
					(*z).encodedSignedTxns.Sig = nil
				} else if (*z).encodedSignedTxns.Sig != nil && cap((*z).encodedSignedTxns.Sig) >= zb0029 {
					(*z).encodedSignedTxns.Sig = ((*z).encodedSignedTxns.Sig)[:zb0029]
				} else {
					(*z).encodedSignedTxns.Sig = make([]crypto.Signature, zb0029)
				}
				for zb0002 := range (*z).encodedSignedTxns.Sig {
					bts, err = (*z).encodedSignedTxns.Sig[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sig", zb0002)
						return
					}
				}
			case "sigbm":
				{
					var zb0031 []byte
					zb0031, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskSig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskSig")
						return
					}
					(*z).encodedSignedTxns.BitmaskSig = bitmask(zb0031)
				}
			case "msig":
				var zb0032 int
				var zb0033 bool
				zb0032, zb0033, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Msig")
					return
				}
				if zb0032 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0032), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Msig")
					return
				}
				if zb0033 {
					(*z).encodedSignedTxns.Msig = nil
				} else if (*z).encodedSignedTxns.Msig != nil && cap((*z).encodedSignedTxns.Msig) >= zb0032 {
					(*z).encodedSignedTxns.Msig = ((*z).encodedSignedTxns.Msig)[:zb0032]
				} else {
					(*z).encodedSignedTxns.Msig = make([]crypto.MultisigSig, zb0032)
				}
				for zb0003 := range (*z).encodedSignedTxns.Msig {
					bts, err = (*z).encodedSignedTxns.Msig[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Msig", zb0003)
						return
					}
				}
			case "msigbm":
				{
					var zb0034 []byte
					zb0034, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskMsig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskMsig")
						return
					}
					(*z).encodedSignedTxns.BitmaskMsig = bitmask(zb0034)
				}
			case "lsig":
				var zb0035 int
				var zb0036 bool
				zb0035, zb0036, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lsig")
					return
				}
				if zb0035 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0035), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "Lsig")
					return
				}
				if zb0036 {
					(*z).encodedSignedTxns.Lsig = nil
				} else if (*z).encodedSignedTxns.Lsig != nil && cap((*z).encodedSignedTxns.Lsig) >= zb0035 {
					(*z).encodedSignedTxns.Lsig = ((*z).encodedSignedTxns.Lsig)[:zb0035]
				} else {
					(*z).encodedSignedTxns.Lsig = make([]transactions.LogicSig, zb0035)
				}
				for zb0004 := range (*z).encodedSignedTxns.Lsig {
					bts, err = (*z).encodedSignedTxns.Lsig[zb0004].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Lsig", zb0004)
						return
					}
				}
			case "lsigb":
				{
					var zb0037 []byte
					zb0037, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskLsig))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskLsig")
						return
					}
					(*z).encodedSignedTxns.BitmaskLsig = bitmask(zb0037)
				}
			case "sgnr":
				var zb0038 int
				var zb0039 bool
				zb0038, zb0039, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
				if zb0038 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0038), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "AuthAddr")
					return
				}
				if zb0039 {
					(*z).encodedSignedTxns.AuthAddr = nil
				} else if (*z).encodedSignedTxns.AuthAddr != nil && cap((*z).encodedSignedTxns.AuthAddr) >= zb0038 {
					(*z).encodedSignedTxns.AuthAddr = ((*z).encodedSignedTxns.AuthAddr)[:zb0038]
				} else {
					(*z).encodedSignedTxns.AuthAddr = make([]basics.Address, zb0038)
				}
				for zb0005 := range (*z).encodedSignedTxns.AuthAddr {
					bts, err = (*z).encodedSignedTxns.AuthAddr[zb0005].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "AuthAddr", zb0005)
						return
					}
				}
			case "sgnrbm":
				{
					var zb0040 []byte
					zb0040, bts, err = msgp.ReadBytesBytes(bts, []byte((*z).encodedSignedTxns.BitmaskAuthAddr))
					if err != nil {
						err = msgp.WrapError(err, "BitmaskAuthAddr")
						return
					}
					(*z).encodedSignedTxns.BitmaskAuthAddr = bitmask(zb0040)
				}
			case "type":
				var zb0041 int
				var zb0042 bool
				zb0041, zb0042, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxType")
					return
				}
				if zb0041 > maxEncodedTransactionGroup {
					err = msgp.ErrOverflow(uint64(zb0041), uint64(maxEncodedTransactionGroup))
					err = msgp.WrapError(err, "TxType")
					return
				}
				if zb0042 {
					(*z).encodedSignedTxns.encodedTxns.TxType = nil
				} else if (*z).encodedSignedTxns.encodedTxns.TxType != nil && cap((*z).encodedSignedTxns.encodedTxns.TxType) >= zb0041 {
					(*z).encodedSignedTxns.encodedTxns.TxType = ((*z).encodedSignedTxns.encodedTxns.TxType)[:zb0041]
				} else {
					(*z).encodedSignedTxns.encodedTxns.TxType = make([]protocol.TxType, zb0041)
				}
				for zb0006 := range (*z).encodedSignedTxns.encodedTxns.TxType {
					bts, err = (*z).encodedSignedTxns.encodedTxns.TxType[zb0006].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "TxType", zb0006)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *txGroupsEncodingStub) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*txGroupsEncodingStub)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *txGroupsEncodingStub) Msgsize() (s int) {
	s = 1 + 23 + msgp.Uint64Size + 22 + msgp.Uint64Size + 4 + msgp.BytesPrefixSize + len((*z).TransactionGroupSizes) + 3 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).SignedTxns {
		s += (*z).SignedTxns[zb0001].Msgsize()
	}
	s += 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).encodedSignedTxns.Sig {
		s += (*z).encodedSignedTxns.Sig[zb0002].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.BitmaskSig)) + 5 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).encodedSignedTxns.Msig {
		s += (*z).encodedSignedTxns.Msig[zb0003].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.BitmaskMsig)) + 5 + msgp.ArrayHeaderSize
	for zb0004 := range (*z).encodedSignedTxns.Lsig {
		s += (*z).encodedSignedTxns.Lsig[zb0004].Msgsize()
	}
	s += 6 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.BitmaskLsig)) + 5 + msgp.ArrayHeaderSize
	for zb0005 := range (*z).encodedSignedTxns.AuthAddr {
		s += (*z).encodedSignedTxns.AuthAddr[zb0005].Msgsize()
	}
	s += 7 + msgp.BytesPrefixSize + len([]byte((*z).encodedSignedTxns.BitmaskAuthAddr)) + 5 + msgp.ArrayHeaderSize
	for zb0006 := range (*z).encodedSignedTxns.encodedTxns.TxType {
		s += (*z).encodedSignedTxns.encodedTxns.TxType[zb0006].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *txGroupsEncodingStub) MsgIsZero() bool {
	return ((*z).TotalTransactionsCount == 0) && ((*z).TransactionGroupCount == 0) && (len((*z).TransactionGroupSizes) == 0) && (len((*z).SignedTxns) == 0) && (len((*z).encodedSignedTxns.Sig) == 0) && (len((*z).encodedSignedTxns.BitmaskSig) == 0) && (len((*z).encodedSignedTxns.Msig) == 0) && (len((*z).encodedSignedTxns.BitmaskMsig) == 0) && (len((*z).encodedSignedTxns.Lsig) == 0) && (len((*z).encodedSignedTxns.BitmaskLsig) == 0) && (len((*z).encodedSignedTxns.AuthAddr) == 0) && (len((*z).encodedSignedTxns.BitmaskAuthAddr) == 0) && (len((*z).encodedSignedTxns.encodedTxns.TxType) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z txnGroups) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	if z == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len(z)))
	}
	for za0001 := range z {
		o = z[za0001].MarshalMsg(o)
	}
	return
}

func (_ txnGroups) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(txnGroups)
	if !ok {
		_, ok = (z).(*txnGroups)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *txnGroups) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0002 > maxEncodedTransactionGroupEntries {
		err = msgp.ErrOverflow(uint64(zb0002), uint64(maxEncodedTransactionGroupEntries))
		err = msgp.WrapError(err)
		return
	}
	if zb0003 {
		(*z) = nil
	} else if (*z) != nil && cap((*z)) >= zb0002 {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(txnGroups, zb0002)
	}
	for zb0001 := range *z {
		bts, err = (*z)[zb0001].UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

func (_ *txnGroups) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*txnGroups)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z txnGroups) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for za0001 := range z {
		s += z[za0001].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z txnGroups) MsgIsZero() bool {
	return len(z) == 0
}
