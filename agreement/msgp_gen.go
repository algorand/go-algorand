package agreement

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	"sort"

	"github.com/algorand/go-algorand/config"
	"github.com/algorand/go-algorand/protocol"
	"github.com/algorand/msgp/msgp"
)

// MarshalMsg implements msgp.Marshaler
func (z *Certificate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(6)
	var zb0003Mask uint8 /* 7 bits */
	if len((*z).EquivocationVotes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if (*z).Proposal.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if (*z).Step == 0 {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if len((*z).Votes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "eqv"
			o = append(o, 0xa3, 0x65, 0x71, 0x76)
			if (*z).EquivocationVotes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).EquivocationVotes)))
			}
			for zb0002 := range (*z).EquivocationVotes {
				o, err = (*z).EquivocationVotes[zb0002].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "EquivocationVotes", zb0002)
					return
				}
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "prop"
			o = append(o, 0xa4, 0x70, 0x72, 0x6f, 0x70)
			o, err = (*z).Proposal.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Proposal")
				return
			}
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o, err = (*z).Round.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Round")
				return
			}
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "vote"
			o = append(o, 0xa4, 0x76, 0x6f, 0x74, 0x65)
			if (*z).Votes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Votes)))
			}
			for zb0001 := range (*z).Votes {
				o, err = (*z).Votes[zb0001].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Votes", zb0001)
					return
				}
			}
		}
	}
	return
}

func (_ *Certificate) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Certificate)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Certificate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0005)
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0006)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0007 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0007), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0008 {
				(*z).Votes = nil
			} else if (*z).Votes != nil && cap((*z).Votes) >= zb0007 {
				(*z).Votes = ((*z).Votes)[:zb0007]
			} else {
				(*z).Votes = make([]voteAuthenticator, zb0007)
			}
			for zb0001 := range (*z).Votes {
				bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Votes", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0009 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0010 {
				(*z).EquivocationVotes = nil
			} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0009 {
				(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0009]
			} else {
				(*z).EquivocationVotes = make([]equivocationVoteAuthenticator, zb0009)
			}
			for zb0002 := range (*z).EquivocationVotes {
				bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = Certificate{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "per":
				{
					var zb0011 uint64
					zb0011, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0011)
				}
			case "step":
				{
					var zb0012 uint64
					zb0012, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0012)
				}
			case "prop":
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
			case "vote":
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0013 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0014 {
					(*z).Votes = nil
				} else if (*z).Votes != nil && cap((*z).Votes) >= zb0013 {
					(*z).Votes = ((*z).Votes)[:zb0013]
				} else {
					(*z).Votes = make([]voteAuthenticator, zb0013)
				}
				for zb0001 := range (*z).Votes {
					bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Votes", zb0001)
						return
					}
				}
			case "eqv":
				var zb0015 int
				var zb0016 bool
				zb0015, zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0015 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0015), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0016 {
					(*z).EquivocationVotes = nil
				} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0015 {
					(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0015]
				} else {
					(*z).EquivocationVotes = make([]equivocationVoteAuthenticator, zb0015)
				}
				for zb0002 := range (*z).EquivocationVotes {
					bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "EquivocationVotes", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *Certificate) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Certificate)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Certificate) Msgsize() (s int) {
	s = 1 + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Proposal.Msgsize() + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Votes {
		s += (*z).Votes[zb0001].Msgsize()
	}
	s += 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).EquivocationVotes {
		s += (*z).EquivocationVotes[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Certificate) MsgIsZero() bool {
	return ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Proposal.MsgIsZero()) && (len((*z).Votes) == 0) && (len((*z).EquivocationVotes) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *bundle) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(3)
	var zb0003Mask uint8 /* 4 bits */
	if len((*z).EquivocationVotes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).U.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if len((*z).Votes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "eqv"
			o = append(o, 0xa3, 0x65, 0x71, 0x76)
			if (*z).EquivocationVotes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).EquivocationVotes)))
			}
			for zb0002 := range (*z).EquivocationVotes {
				o, err = (*z).EquivocationVotes[zb0002].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "EquivocationVotes", zb0002)
					return
				}
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "u"
			o = append(o, 0xa1, 0x75)
			o, err = (*z).U.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "U")
				return
			}
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "vote"
			o = append(o, 0xa4, 0x76, 0x6f, 0x74, 0x65)
			if (*z).Votes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Votes)))
			}
			for zb0001 := range (*z).Votes {
				o, err = (*z).Votes[zb0001].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Votes", zb0001)
					return
				}
			}
		}
	}
	return
}

func (_ *bundle) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*bundle)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *bundle) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).U.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "U")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0005 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0005), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0006 {
				(*z).Votes = nil
			} else if (*z).Votes != nil && cap((*z).Votes) >= zb0005 {
				(*z).Votes = ((*z).Votes)[:zb0005]
			} else {
				(*z).Votes = make([]vote, zb0005)
			}
			for zb0001 := range (*z).Votes {
				bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Votes", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0007 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0007), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0008 {
				(*z).EquivocationVotes = nil
			} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0007 {
				(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0007]
			} else {
				(*z).EquivocationVotes = make([]equivocationVote, zb0007)
			}
			for zb0002 := range (*z).EquivocationVotes {
				bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = bundle{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "u":
				bts, err = (*z).U.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "U")
					return
				}
			case "vote":
				var zb0009 int
				var zb0010 bool
				zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0009 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0009), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0010 {
					(*z).Votes = nil
				} else if (*z).Votes != nil && cap((*z).Votes) >= zb0009 {
					(*z).Votes = ((*z).Votes)[:zb0009]
				} else {
					(*z).Votes = make([]vote, zb0009)
				}
				for zb0001 := range (*z).Votes {
					bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Votes", zb0001)
						return
					}
				}
			case "eqv":
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0011 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0011), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0012 {
					(*z).EquivocationVotes = nil
				} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0011 {
					(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0011]
				} else {
					(*z).EquivocationVotes = make([]equivocationVote, zb0011)
				}
				for zb0002 := range (*z).EquivocationVotes {
					bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "EquivocationVotes", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *bundle) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*bundle)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *bundle) Msgsize() (s int) {
	s = 1 + 2 + (*z).U.Msgsize() + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Votes {
		s += (*z).Votes[zb0001].Msgsize()
	}
	s += 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).EquivocationVotes {
		s += (*z).EquivocationVotes[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *bundle) MsgIsZero() bool {
	return ((*z).U.MsgIsZero()) && (len((*z).Votes) == 0) && (len((*z).EquivocationVotes) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *equivocationVote) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(7)
	var zb0003Mask uint8 /* 8 bits */
	if (*z).Cred.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if ((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero()) {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if ((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero()) {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if (*z).Sender.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	if (*z).Step == 0 {
		zb0003Len--
		zb0003Mask |= 0x80
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "cred"
			o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
			o, err = (*z).Cred.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Cred")
				return
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "props"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x70, 0x73)
			o = msgp.AppendArrayHeader(o, 2)
			for zb0001 := range (*z).Proposals {
				o, err = (*z).Proposals[zb0001].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Proposals", zb0001)
					return
				}
			}
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o, err = (*z).Round.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Round")
				return
			}
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "sigs"
			o = append(o, 0xa4, 0x73, 0x69, 0x67, 0x73)
			o = msgp.AppendArrayHeader(o, 2)
			for zb0002 := range (*z).Sigs {
				o, err = (*z).Sigs[zb0002].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Sigs", zb0002)
					return
				}
			}
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o, err = (*z).Sender.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		}
		if (zb0003Mask & 0x80) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
	}
	return
}

func (_ *equivocationVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*equivocationVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *equivocationVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0005)
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0006)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			zb0007, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposals")
				return
			}
			if zb0007 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0007}
				return
			}
			for zb0001 := 0; zb0001 < zb0007; zb0001++ {
				bts, err = (*z).Proposals[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proposals", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0008 int
			zb0008, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sigs")
				return
			}
			if zb0008 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0008}
				return
			}
			for zb0002 := 0; zb0002 < zb0008; zb0002++ {
				bts, err = (*z).Sigs[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sigs", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = equivocationVote{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "per":
				{
					var zb0009 uint64
					zb0009, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0009)
				}
			case "step":
				{
					var zb0010 uint64
					zb0010, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0010)
				}
			case "cred":
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
			case "props":
				var zb0011 int
				zb0011, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposals")
					return
				}
				if zb0011 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0011}
					return
				}
				for zb0001 := 0; zb0001 < zb0011; zb0001++ {
					bts, err = (*z).Proposals[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Proposals", zb0001)
						return
					}
				}
			case "sigs":
				var zb0012 int
				zb0012, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sigs")
					return
				}
				if zb0012 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0012}
					return
				}
				for zb0002 := 0; zb0002 < zb0012; zb0002++ {
					bts, err = (*z).Sigs[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sigs", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *equivocationVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*equivocationVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *equivocationVote) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Cred.Msgsize() + 6 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Proposals {
		s += (*z).Proposals[zb0001].Msgsize()
	}
	s += 5 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Sigs {
		s += (*z).Sigs[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *equivocationVote) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Cred.MsgIsZero()) && (((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero())) && (((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero()))
}

// MarshalMsg implements msgp.Marshaler
func (z *equivocationVoteAuthenticator) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(4)
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		// string "cred"
		o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
		o, err = (*z).Cred.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Cred")
			return
		}
		// string "props"
		o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x70, 0x73)
		o = msgp.AppendArrayHeader(o, 2)
		for zb0002 := range (*z).Proposals {
			o, err = (*z).Proposals[zb0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Proposals", zb0002)
				return
			}
		}
		// string "sig"
		o = append(o, 0xa3, 0x73, 0x69, 0x67)
		o = msgp.AppendArrayHeader(o, 2)
		for zb0001 := range (*z).Sigs {
			o, err = (*z).Sigs[zb0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sigs", zb0001)
				return
			}
		}
		// string "snd"
		o = append(o, 0xa3, 0x73, 0x6e, 0x64)
		o, err = (*z).Sender.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Sender")
			return
		}
	}
	return
}

func (_ *equivocationVoteAuthenticator) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*equivocationVoteAuthenticator)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *equivocationVoteAuthenticator) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			zb0005, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sigs")
				return
			}
			if zb0005 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0005}
				return
			}
			for zb0001 := 0; zb0001 < zb0005; zb0001++ {
				bts, err = (*z).Sigs[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sigs", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0006 int
			zb0006, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposals")
				return
			}
			if zb0006 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0006}
				return
			}
			for zb0002 := 0; zb0002 < zb0006; zb0002++ {
				bts, err = (*z).Proposals[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proposals", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = equivocationVoteAuthenticator{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "cred":
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
			case "sig":
				var zb0007 int
				zb0007, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sigs")
					return
				}
				if zb0007 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0007}
					return
				}
				for zb0001 := 0; zb0001 < zb0007; zb0001++ {
					bts, err = (*z).Sigs[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sigs", zb0001)
						return
					}
				}
			case "props":
				var zb0008 int
				zb0008, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposals")
					return
				}
				if zb0008 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0008}
					return
				}
				for zb0002 := 0; zb0002 < zb0008; zb0002++ {
					bts, err = (*z).Proposals[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Proposals", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *equivocationVoteAuthenticator) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*equivocationVoteAuthenticator)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *equivocationVoteAuthenticator) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 5 + (*z).Cred.Msgsize() + 4 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Sigs {
		s += (*z).Sigs[zb0001].Msgsize()
	}
	s += 6 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Proposals {
		s += (*z).Proposals[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *equivocationVoteAuthenticator) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Cred.MsgIsZero()) && (((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero())) && (((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero()))
}

// MarshalMsg implements msgp.Marshaler
func (z period) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

func (_ period) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(period)
	if !ok {
		_, ok = (z).(*period)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *period) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = period(zb0001)
	}
	o = bts
	return
}

func (_ *period) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*period)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z period) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z period) MsgIsZero() bool {
	return z == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *proposal) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(27)
	var zb0003Mask uint32 /* 32 bits */
	if len((*z).unauthenticatedProposal.Block.BlockHeader.CompactCert) == 0 {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel == 0 {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue == 0 {
		zb0003Len--
		zb0003Mask |= 0x80
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.GenesisID == "" {
		zb0003Len--
		zb0003Mask |= 0x100
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x200
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x400
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x800
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x1000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0 {
		zb0003Len--
		zb0003Mask |= 0x2000
	}
	if (*z).unauthenticatedProposal.OriginalPeriod == 0 {
		zb0003Len--
		zb0003Mask |= 0x4000
	}
	if (*z).unauthenticatedProposal.OriginalProposer.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x8000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Branch.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x20000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate == 0 {
		zb0003Len--
		zb0003Mask |= 0x40000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x80000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x100000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x200000
	}
	if (*z).unauthenticatedProposal.SeedProof.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x400000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Seed.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x800000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter == 0 {
		zb0003Len--
		zb0003Mask |= 0x1000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp == 0 {
		zb0003Len--
		zb0003Mask |= 0x2000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnRoot.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x4000000
	}
	if (*z).unauthenticatedProposal.Block.Payset.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x8000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x20000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove == false {
		zb0003Len--
		zb0003Mask |= 0x40000000
	}
	// variable map header, size zb0003Len
	o = msgp.AppendMapHeader(o, zb0003Len)
	if zb0003Len != 0 {
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "cc"
			o = append(o, 0xa2, 0x63, 0x63)
			if (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).unauthenticatedProposal.Block.BlockHeader.CompactCert)))
			}
			zb0001_keys := make([]protocol.CompactCertType, 0, len((*z).unauthenticatedProposal.Block.BlockHeader.CompactCert))
			for zb0001 := range (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort(protocol.SortCompactCertType(zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert[zb0001]
				_ = zb0002
				o, err = zb0001.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "CompactCert", zb0001)
					return
				}
				o, err = zb0002.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "CompactCert", zb0001)
					return
				}
			}
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "earn"
			o = append(o, 0xa4, 0x65, 0x61, 0x72, 0x6e)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel)
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "FeeSink")
				return
			}
		}
		if (zb0003Mask & 0x80) == 0 { // if not empty
			// string "frac"
			o = append(o, 0xa4, 0x66, 0x72, 0x61, 0x63)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue)
		}
		if (zb0003Mask & 0x100) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).unauthenticatedProposal.Block.BlockHeader.GenesisID)
		}
		if (zb0003Mask & 0x200) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "GenesisHash")
				return
			}
		}
		if (zb0003Mask & 0x400) == 0 { // if not empty
			// string "nextbefore"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "NextProtocolVoteBefore")
				return
			}
		}
		if (zb0003Mask & 0x800) == 0 { // if not empty
			// string "nextproto"
			o = append(o, 0xa9, 0x6e, 0x65, 0x78, 0x74, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "NextProtocol")
				return
			}
		}
		if (zb0003Mask & 0x1000) == 0 { // if not empty
			// string "nextswitch"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "NextProtocolSwitchOn")
				return
			}
		}
		if (zb0003Mask & 0x2000) == 0 { // if not empty
			// string "nextyes"
			o = append(o, 0xa7, 0x6e, 0x65, 0x78, 0x74, 0x79, 0x65, 0x73)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals)
		}
		if (zb0003Mask & 0x4000) == 0 { // if not empty
			// string "oper"
			o = append(o, 0xa4, 0x6f, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).unauthenticatedProposal.OriginalPeriod))
		}
		if (zb0003Mask & 0x8000) == 0 { // if not empty
			// string "oprop"
			o = append(o, 0xa5, 0x6f, 0x70, 0x72, 0x6f, 0x70)
			o, err = (*z).unauthenticatedProposal.OriginalProposer.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "OriginalProposer")
				return
			}
		}
		if (zb0003Mask & 0x10000) == 0 { // if not empty
			// string "prev"
			o = append(o, 0xa4, 0x70, 0x72, 0x65, 0x76)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Branch")
				return
			}
		}
		if (zb0003Mask & 0x20000) == 0 { // if not empty
			// string "proto"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "CurrentProtocol")
				return
			}
		}
		if (zb0003Mask & 0x40000) == 0 { // if not empty
			// string "rate"
			o = append(o, 0xa4, 0x72, 0x61, 0x74, 0x65)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate)
		}
		if (zb0003Mask & 0x80000) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Round")
				return
			}
		}
		if (zb0003Mask & 0x100000) == 0 { // if not empty
			// string "rwcalr"
			o = append(o, 0xa6, 0x72, 0x77, 0x63, 0x61, 0x6c, 0x72)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "RewardsRecalculationRound")
				return
			}
		}
		if (zb0003Mask & 0x200000) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "RewardsPool")
				return
			}
		}
		if (zb0003Mask & 0x400000) == 0 { // if not empty
			// string "sdpf"
			o = append(o, 0xa4, 0x73, 0x64, 0x70, 0x66)
			o, err = (*z).unauthenticatedProposal.SeedProof.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "SeedProof")
				return
			}
		}
		if (zb0003Mask & 0x800000) == 0 { // if not empty
			// string "seed"
			o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Seed")
				return
			}
		}
		if (zb0003Mask & 0x1000000) == 0 { // if not empty
			// string "tc"
			o = append(o, 0xa2, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter)
		}
		if (zb0003Mask & 0x2000000) == 0 { // if not empty
			// string "ts"
			o = append(o, 0xa2, 0x74, 0x73)
			o = msgp.AppendInt64(o, (*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp)
		}
		if (zb0003Mask & 0x4000000) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnRoot.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "TxnRoot")
				return
			}
		}
		if (zb0003Mask & 0x8000000) == 0 { // if not empty
			// string "txns"
			o = append(o, 0xa4, 0x74, 0x78, 0x6e, 0x73)
			o, err = (*z).unauthenticatedProposal.Block.Payset.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Payset")
				return
			}
		}
		if (zb0003Mask & 0x10000000) == 0 { // if not empty
			// string "upgradedelay"
			o = append(o, 0xac, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x64, 0x65, 0x6c, 0x61, 0x79)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "UpgradeDelay")
				return
			}
		}
		if (zb0003Mask & 0x20000000) == 0 { // if not empty
			// string "upgradeprop"
			o = append(o, 0xab, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x70)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "UpgradePropose")
				return
			}
		}
		if (zb0003Mask & 0x40000000) == 0 { // if not empty
			// string "upgradeyes"
			o = append(o, 0xaa, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x65, 0x73)
			o = msgp.AppendBool(o, (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove)
		}
	}
	return
}

func (_ *proposal) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposal)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposal) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Branch")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnRoot.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnRoot")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TimeStamp")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRate")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsResidue")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRecalculationRound")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CurrentProtocol")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocol")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolApprovals")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolVoteBefore")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolSwitchOn")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradePropose")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeDelay")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeApprove")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnCounter")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CompactCert")
				return
			}
			if zb0005 > protocol.NumCompactCertTypes {
				err = msgp.ErrOverflow(uint64(zb0005), uint64(protocol.NumCompactCertTypes))
				err = msgp.WrapError(err, "struct-from-array", "CompactCert")
				return
			}
			if zb0006 {
				(*z).unauthenticatedProposal.Block.BlockHeader.CompactCert = nil
			} else if (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert == nil {
				(*z).unauthenticatedProposal.Block.BlockHeader.CompactCert = make(map[protocol.CompactCertType]CompactCertState, zb0005)
			}
			for zb0005 > 0 {
				var zb0001 protocol.CompactCertType
				var zb0002 CompactCertState
				zb0005--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CompactCert")
					return
				}
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CompactCert", zb0001)
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.CompactCert[zb0001] = zb0002
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.Payset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Payset")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.SeedProof.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SeedProof")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0007 uint64
				zb0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "OriginalPeriod")
					return
				}
				(*z).unauthenticatedProposal.OriginalPeriod = period(zb0007)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.OriginalProposer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OriginalProposer")
				return
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = proposal{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "prev":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Branch")
					return
				}
			case "seed":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
			case "txn":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnRoot.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnRoot")
					return
				}
			case "ts":
				(*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimeStamp")
					return
				}
			case "gen":
				(*z).unauthenticatedProposal.Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "gh":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "fees":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
			case "rwd":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
			case "earn":
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
			case "rate":
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRate")
					return
				}
			case "frac":
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsResidue")
					return
				}
			case "rwcalr":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRecalculationRound")
					return
				}
			case "proto":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CurrentProtocol")
					return
				}
			case "nextproto":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocol")
					return
				}
			case "nextyes":
				(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolApprovals")
					return
				}
			case "nextbefore":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolVoteBefore")
					return
				}
			case "nextswitch":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolSwitchOn")
					return
				}
			case "upgradeprop":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradePropose")
					return
				}
			case "upgradedelay":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeDelay")
					return
				}
			case "upgradeyes":
				(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeApprove")
					return
				}
			case "tc":
				(*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnCounter")
					return
				}
			case "cc":
				var zb0008 int
				var zb0009 bool
				zb0008, zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CompactCert")
					return
				}
				if zb0008 > protocol.NumCompactCertTypes {
					err = msgp.ErrOverflow(uint64(zb0008), uint64(protocol.NumCompactCertTypes))
					err = msgp.WrapError(err, "CompactCert")
					return
				}
				if zb0009 {
					(*z).unauthenticatedProposal.Block.BlockHeader.CompactCert = nil
				} else if (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert == nil {
					(*z).unauthenticatedProposal.Block.BlockHeader.CompactCert = make(map[protocol.CompactCertType]CompactCertState, zb0008)
				}
				for zb0008 > 0 {
					var zb0001 protocol.CompactCertType
					var zb0002 CompactCertState
					zb0008--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CompactCert")
						return
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CompactCert", zb0001)
						return
					}
					(*z).unauthenticatedProposal.Block.BlockHeader.CompactCert[zb0001] = zb0002
				}
			case "txns":
				bts, err = (*z).unauthenticatedProposal.Block.Payset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Payset")
					return
				}
			case "sdpf":
				bts, err = (*z).unauthenticatedProposal.SeedProof.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SeedProof")
					return
				}
			case "oper":
				{
					var zb0010 uint64
					zb0010, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OriginalPeriod")
						return
					}
					(*z).unauthenticatedProposal.OriginalPeriod = period(zb0010)
				}
			case "oprop":
				bts, err = (*z).unauthenticatedProposal.OriginalProposer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OriginalProposer")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *proposal) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposal)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposal) Msgsize() (s int) {
	s = 3 + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.Round.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.Branch.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.Seed.Msgsize() + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.TxnRoot.Msgsize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len((*z).unauthenticatedProposal.Block.BlockHeader.GenesisID) + 3 + (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.Msgsize() + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.Msgsize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.Msgsize() + 6 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.Msgsize() + 10 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.Msgsize() + 8 + msgp.Uint64Size + 11 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.Msgsize() + 11 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.Msgsize() + 12 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.Msgsize() + 13 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.Msgsize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 3 + msgp.MapHeaderSize
	if (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert != nil {
		for zb0001, zb0002 := range (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	s += 5 + (*z).unauthenticatedProposal.Block.Payset.Msgsize() + 5 + (*z).unauthenticatedProposal.SeedProof.Msgsize() + 5 + msgp.Uint64Size + 6 + (*z).unauthenticatedProposal.OriginalProposer.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposal) MsgIsZero() bool {
	return ((*z).unauthenticatedProposal.Block.BlockHeader.Round.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.Branch.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.Seed.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnRoot.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.GenesisID == "") && ((*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove == false) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter == 0) && (len((*z).unauthenticatedProposal.Block.BlockHeader.CompactCert) == 0) && ((*z).unauthenticatedProposal.Block.Payset.MsgIsZero()) && ((*z).unauthenticatedProposal.SeedProof.MsgIsZero()) && ((*z).unauthenticatedProposal.OriginalPeriod == 0) && ((*z).unauthenticatedProposal.OriginalProposer.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *proposalValue) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 5 bits */
	if (*z).BlockDigest.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).EncodingDigest.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).OriginalPeriod == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).OriginalProposer.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "dig"
			o = append(o, 0xa3, 0x64, 0x69, 0x67)
			o, err = (*z).BlockDigest.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "BlockDigest")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "encdig"
			o = append(o, 0xa6, 0x65, 0x6e, 0x63, 0x64, 0x69, 0x67)
			o, err = (*z).EncodingDigest.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "EncodingDigest")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "oper"
			o = append(o, 0xa4, 0x6f, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).OriginalPeriod))
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "oprop"
			o = append(o, 0xa5, 0x6f, 0x70, 0x72, 0x6f, 0x70)
			o, err = (*z).OriginalProposer.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "OriginalProposer")
				return
			}
		}
	}
	return
}

func (_ *proposalValue) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalValue)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposalValue) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "OriginalPeriod")
					return
				}
				(*z).OriginalPeriod = period(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).OriginalProposer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OriginalProposer")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).BlockDigest.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BlockDigest")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).EncodingDigest.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EncodingDigest")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = proposalValue{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "oper":
				{
					var zb0004 uint64
					zb0004, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OriginalPeriod")
						return
					}
					(*z).OriginalPeriod = period(zb0004)
				}
			case "oprop":
				bts, err = (*z).OriginalProposer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OriginalProposer")
					return
				}
			case "dig":
				bts, err = (*z).BlockDigest.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BlockDigest")
					return
				}
			case "encdig":
				bts, err = (*z).EncodingDigest.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "EncodingDigest")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *proposalValue) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalValue)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposalValue) Msgsize() (s int) {
	s = 1 + 5 + msgp.Uint64Size + 6 + (*z).OriginalProposer.Msgsize() + 4 + (*z).BlockDigest.Msgsize() + 7 + (*z).EncodingDigest.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposalValue) MsgIsZero() bool {
	return ((*z).OriginalPeriod == 0) && ((*z).OriginalProposer.MsgIsZero()) && ((*z).BlockDigest.MsgIsZero()) && ((*z).EncodingDigest.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *proposerSeed) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "addr"
	o = append(o, 0x82, 0xa4, 0x61, 0x64, 0x64, 0x72)
	o, err = (*z).Addr.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Addr")
		return
	}
	// string "vrf"
	o = append(o, 0xa3, 0x76, 0x72, 0x66)
	o, err = (*z).VRF.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "VRF")
		return
	}
	return
}

func (_ *proposerSeed) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposerSeed)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposerSeed) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Addr.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Addr")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).VRF.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VRF")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = proposerSeed{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "addr":
				bts, err = (*z).Addr.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Addr")
					return
				}
			case "vrf":
				bts, err = (*z).VRF.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "VRF")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *proposerSeed) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposerSeed)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposerSeed) Msgsize() (s int) {
	s = 1 + 5 + (*z).Addr.Msgsize() + 4 + (*z).VRF.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposerSeed) MsgIsZero() bool {
	return ((*z).Addr.MsgIsZero()) && ((*z).VRF.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *rawVote) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 6 bits */
	if (*z).Period == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Proposal.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Round.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).Sender.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).Step == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "prop"
			o = append(o, 0xa4, 0x70, 0x72, 0x6f, 0x70)
			o, err = (*z).Proposal.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Proposal")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o, err = (*z).Round.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Round")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o, err = (*z).Sender.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
	}
	return
}

func (_ *rawVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*rawVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *rawVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0004 uint64
				zb0004, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0004)
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = rawVote{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "per":
				{
					var zb0005 uint64
					zb0005, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0005)
				}
			case "step":
				{
					var zb0006 uint64
					zb0006, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0006)
				}
			case "prop":
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *rawVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*rawVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *rawVote) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Proposal.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *rawVote) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Proposal.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *seedInput) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "alpha"
	o = append(o, 0x82, 0xa5, 0x61, 0x6c, 0x70, 0x68, 0x61)
	o, err = (*z).Alpha.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Alpha")
		return
	}
	// string "hist"
	o = append(o, 0xa4, 0x68, 0x69, 0x73, 0x74)
	o, err = (*z).History.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "History")
		return
	}
	return
}

func (_ *seedInput) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*seedInput)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *seedInput) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Alpha.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Alpha")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).History.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "History")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = seedInput{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "alpha":
				bts, err = (*z).Alpha.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Alpha")
					return
				}
			case "hist":
				bts, err = (*z).History.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "History")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *seedInput) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*seedInput)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *seedInput) Msgsize() (s int) {
	s = 1 + 6 + (*z).Alpha.Msgsize() + 5 + (*z).History.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *seedInput) MsgIsZero() bool {
	return ((*z).Alpha.MsgIsZero()) && ((*z).History.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *selector) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "per"
	o = append(o, 0x84, 0xa3, 0x70, 0x65, 0x72)
	o = msgp.AppendUint64(o, uint64((*z).Period))
	// string "rnd"
	o = append(o, 0xa3, 0x72, 0x6e, 0x64)
	o, err = (*z).Round.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Round")
		return
	}
	// string "seed"
	o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
	o, err = (*z).Seed.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Seed")
		return
	}
	// string "step"
	o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
	o = msgp.AppendUint64(o, uint64((*z).Step))
	return
}

func (_ *selector) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*selector)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *selector) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0004 uint64
				zb0004, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0004)
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = selector{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "seed":
				bts, err = (*z).Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "per":
				{
					var zb0005 uint64
					zb0005, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0005)
				}
			case "step":
				{
					var zb0006 uint64
					zb0006, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0006)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *selector) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*selector)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *selector) Msgsize() (s int) {
	s = 1 + 5 + (*z).Seed.Msgsize() + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *selector) MsgIsZero() bool {
	return ((*z).Seed.MsgIsZero()) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z serializableErrorUnderlying) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

func (_ serializableErrorUnderlying) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(serializableErrorUnderlying)
	if !ok {
		_, ok = (z).(*serializableErrorUnderlying)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *serializableErrorUnderlying) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = serializableErrorUnderlying(zb0001)
	}
	o = bts
	return
}

func (_ *serializableErrorUnderlying) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*serializableErrorUnderlying)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z serializableErrorUnderlying) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MsgIsZero returns whether this is a zero value
func (z serializableErrorUnderlying) MsgIsZero() bool {
	return z == ""
}

// MarshalMsg implements msgp.Marshaler
func (z step) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

func (_ step) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(step)
	if !ok {
		_, ok = (z).(*step)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *step) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = step(zb0001)
	}
	o = bts
	return
}

func (_ *step) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*step)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z step) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z step) MsgIsZero() bool {
	return z == 0
}

// MarshalMsg implements msgp.Marshaler
func (z *transmittedPayload) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(28)
	var zb0003Mask uint64 /* 33 bits */
	if len((*z).unauthenticatedProposal.Block.BlockHeader.CompactCert) == 0 {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel == 0 {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x80
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue == 0 {
		zb0003Len--
		zb0003Mask |= 0x100
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.GenesisID == "" {
		zb0003Len--
		zb0003Mask |= 0x200
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x400
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x800
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x1000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x2000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0 {
		zb0003Len--
		zb0003Mask |= 0x4000
	}
	if (*z).unauthenticatedProposal.OriginalPeriod == 0 {
		zb0003Len--
		zb0003Mask |= 0x8000
	}
	if (*z).unauthenticatedProposal.OriginalProposer.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Branch.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x20000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x40000
	}
	if (*z).PriorVote.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x80000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate == 0 {
		zb0003Len--
		zb0003Mask |= 0x100000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x200000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x400000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x800000
	}
	if (*z).unauthenticatedProposal.SeedProof.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x1000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Seed.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x2000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter == 0 {
		zb0003Len--
		zb0003Mask |= 0x4000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp == 0 {
		zb0003Len--
		zb0003Mask |= 0x8000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnRoot.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10000000
	}
	if (*z).unauthenticatedProposal.Block.Payset.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x20000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x40000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x80000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove == false {
		zb0003Len--
		zb0003Mask |= 0x100000000
	}
	// variable map header, size zb0003Len
	o = msgp.AppendMapHeader(o, zb0003Len)
	if zb0003Len != 0 {
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "cc"
			o = append(o, 0xa2, 0x63, 0x63)
			if (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).unauthenticatedProposal.Block.BlockHeader.CompactCert)))
			}
			zb0001_keys := make([]protocol.CompactCertType, 0, len((*z).unauthenticatedProposal.Block.BlockHeader.CompactCert))
			for zb0001 := range (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort(protocol.SortCompactCertType(zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert[zb0001]
				_ = zb0002
				o, err = zb0001.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "CompactCert", zb0001)
					return
				}
				o, err = zb0002.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "CompactCert", zb0001)
					return
				}
			}
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "earn"
			o = append(o, 0xa4, 0x65, 0x61, 0x72, 0x6e)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel)
		}
		if (zb0003Mask & 0x80) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "FeeSink")
				return
			}
		}
		if (zb0003Mask & 0x100) == 0 { // if not empty
			// string "frac"
			o = append(o, 0xa4, 0x66, 0x72, 0x61, 0x63)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue)
		}
		if (zb0003Mask & 0x200) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).unauthenticatedProposal.Block.BlockHeader.GenesisID)
		}
		if (zb0003Mask & 0x400) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "GenesisHash")
				return
			}
		}
		if (zb0003Mask & 0x800) == 0 { // if not empty
			// string "nextbefore"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "NextProtocolVoteBefore")
				return
			}
		}
		if (zb0003Mask & 0x1000) == 0 { // if not empty
			// string "nextproto"
			o = append(o, 0xa9, 0x6e, 0x65, 0x78, 0x74, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "NextProtocol")
				return
			}
		}
		if (zb0003Mask & 0x2000) == 0 { // if not empty
			// string "nextswitch"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "NextProtocolSwitchOn")
				return
			}
		}
		if (zb0003Mask & 0x4000) == 0 { // if not empty
			// string "nextyes"
			o = append(o, 0xa7, 0x6e, 0x65, 0x78, 0x74, 0x79, 0x65, 0x73)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals)
		}
		if (zb0003Mask & 0x8000) == 0 { // if not empty
			// string "oper"
			o = append(o, 0xa4, 0x6f, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).unauthenticatedProposal.OriginalPeriod))
		}
		if (zb0003Mask & 0x10000) == 0 { // if not empty
			// string "oprop"
			o = append(o, 0xa5, 0x6f, 0x70, 0x72, 0x6f, 0x70)
			o, err = (*z).unauthenticatedProposal.OriginalProposer.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "OriginalProposer")
				return
			}
		}
		if (zb0003Mask & 0x20000) == 0 { // if not empty
			// string "prev"
			o = append(o, 0xa4, 0x70, 0x72, 0x65, 0x76)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Branch")
				return
			}
		}
		if (zb0003Mask & 0x40000) == 0 { // if not empty
			// string "proto"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "CurrentProtocol")
				return
			}
		}
		if (zb0003Mask & 0x80000) == 0 { // if not empty
			// string "pv"
			o = append(o, 0xa2, 0x70, 0x76)
			o, err = (*z).PriorVote.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "PriorVote")
				return
			}
		}
		if (zb0003Mask & 0x100000) == 0 { // if not empty
			// string "rate"
			o = append(o, 0xa4, 0x72, 0x61, 0x74, 0x65)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate)
		}
		if (zb0003Mask & 0x200000) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Round")
				return
			}
		}
		if (zb0003Mask & 0x400000) == 0 { // if not empty
			// string "rwcalr"
			o = append(o, 0xa6, 0x72, 0x77, 0x63, 0x61, 0x6c, 0x72)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "RewardsRecalculationRound")
				return
			}
		}
		if (zb0003Mask & 0x800000) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "RewardsPool")
				return
			}
		}
		if (zb0003Mask & 0x1000000) == 0 { // if not empty
			// string "sdpf"
			o = append(o, 0xa4, 0x73, 0x64, 0x70, 0x66)
			o, err = (*z).unauthenticatedProposal.SeedProof.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "SeedProof")
				return
			}
		}
		if (zb0003Mask & 0x2000000) == 0 { // if not empty
			// string "seed"
			o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Seed")
				return
			}
		}
		if (zb0003Mask & 0x4000000) == 0 { // if not empty
			// string "tc"
			o = append(o, 0xa2, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter)
		}
		if (zb0003Mask & 0x8000000) == 0 { // if not empty
			// string "ts"
			o = append(o, 0xa2, 0x74, 0x73)
			o = msgp.AppendInt64(o, (*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp)
		}
		if (zb0003Mask & 0x10000000) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnRoot.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "TxnRoot")
				return
			}
		}
		if (zb0003Mask & 0x20000000) == 0 { // if not empty
			// string "txns"
			o = append(o, 0xa4, 0x74, 0x78, 0x6e, 0x73)
			o, err = (*z).unauthenticatedProposal.Block.Payset.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Payset")
				return
			}
		}
		if (zb0003Mask & 0x40000000) == 0 { // if not empty
			// string "upgradedelay"
			o = append(o, 0xac, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x64, 0x65, 0x6c, 0x61, 0x79)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "UpgradeDelay")
				return
			}
		}
		if (zb0003Mask & 0x80000000) == 0 { // if not empty
			// string "upgradeprop"
			o = append(o, 0xab, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x70)
			o, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "UpgradePropose")
				return
			}
		}
		if (zb0003Mask & 0x100000000) == 0 { // if not empty
			// string "upgradeyes"
			o = append(o, 0xaa, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x65, 0x73)
			o = msgp.AppendBool(o, (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove)
		}
	}
	return
}

func (_ *transmittedPayload) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*transmittedPayload)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *transmittedPayload) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Branch")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnRoot.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnRoot")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TimeStamp")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRate")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsResidue")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRecalculationRound")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CurrentProtocol")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocol")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolApprovals")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolVoteBefore")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolSwitchOn")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradePropose")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeDelay")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeApprove")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnCounter")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CompactCert")
				return
			}
			if zb0005 > protocol.NumCompactCertTypes {
				err = msgp.ErrOverflow(uint64(zb0005), uint64(protocol.NumCompactCertTypes))
				err = msgp.WrapError(err, "struct-from-array", "CompactCert")
				return
			}
			if zb0006 {
				(*z).unauthenticatedProposal.Block.BlockHeader.CompactCert = nil
			} else if (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert == nil {
				(*z).unauthenticatedProposal.Block.BlockHeader.CompactCert = make(map[protocol.CompactCertType]CompactCertState, zb0005)
			}
			for zb0005 > 0 {
				var zb0001 protocol.CompactCertType
				var zb0002 CompactCertState
				zb0005--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CompactCert")
					return
				}
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CompactCert", zb0001)
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.CompactCert[zb0001] = zb0002
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.Block.Payset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Payset")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.SeedProof.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SeedProof")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0007 uint64
				zb0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "OriginalPeriod")
					return
				}
				(*z).unauthenticatedProposal.OriginalPeriod = period(zb0007)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).unauthenticatedProposal.OriginalProposer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OriginalProposer")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).PriorVote.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PriorVote")
				return
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = transmittedPayload{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "prev":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Branch")
					return
				}
			case "seed":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
			case "txn":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnRoot.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnRoot")
					return
				}
			case "ts":
				(*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimeStamp")
					return
				}
			case "gen":
				(*z).unauthenticatedProposal.Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "gh":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "fees":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
			case "rwd":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
			case "earn":
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
			case "rate":
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRate")
					return
				}
			case "frac":
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsResidue")
					return
				}
			case "rwcalr":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRecalculationRound")
					return
				}
			case "proto":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CurrentProtocol")
					return
				}
			case "nextproto":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocol")
					return
				}
			case "nextyes":
				(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolApprovals")
					return
				}
			case "nextbefore":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolVoteBefore")
					return
				}
			case "nextswitch":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolSwitchOn")
					return
				}
			case "upgradeprop":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradePropose")
					return
				}
			case "upgradedelay":
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeDelay")
					return
				}
			case "upgradeyes":
				(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeApprove")
					return
				}
			case "tc":
				(*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnCounter")
					return
				}
			case "cc":
				var zb0008 int
				var zb0009 bool
				zb0008, zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CompactCert")
					return
				}
				if zb0008 > protocol.NumCompactCertTypes {
					err = msgp.ErrOverflow(uint64(zb0008), uint64(protocol.NumCompactCertTypes))
					err = msgp.WrapError(err, "CompactCert")
					return
				}
				if zb0009 {
					(*z).unauthenticatedProposal.Block.BlockHeader.CompactCert = nil
				} else if (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert == nil {
					(*z).unauthenticatedProposal.Block.BlockHeader.CompactCert = make(map[protocol.CompactCertType]CompactCertState, zb0008)
				}
				for zb0008 > 0 {
					var zb0001 protocol.CompactCertType
					var zb0002 CompactCertState
					zb0008--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CompactCert")
						return
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CompactCert", zb0001)
						return
					}
					(*z).unauthenticatedProposal.Block.BlockHeader.CompactCert[zb0001] = zb0002
				}
			case "txns":
				bts, err = (*z).unauthenticatedProposal.Block.Payset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Payset")
					return
				}
			case "sdpf":
				bts, err = (*z).unauthenticatedProposal.SeedProof.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SeedProof")
					return
				}
			case "oper":
				{
					var zb0010 uint64
					zb0010, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OriginalPeriod")
						return
					}
					(*z).unauthenticatedProposal.OriginalPeriod = period(zb0010)
				}
			case "oprop":
				bts, err = (*z).unauthenticatedProposal.OriginalProposer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OriginalProposer")
					return
				}
			case "pv":
				bts, err = (*z).PriorVote.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "PriorVote")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *transmittedPayload) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*transmittedPayload)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *transmittedPayload) Msgsize() (s int) {
	s = 3 + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.Round.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.Branch.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.Seed.Msgsize() + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.TxnRoot.Msgsize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len((*z).unauthenticatedProposal.Block.BlockHeader.GenesisID) + 3 + (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.Msgsize() + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.Msgsize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.Msgsize() + 6 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.Msgsize() + 10 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.Msgsize() + 8 + msgp.Uint64Size + 11 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.Msgsize() + 11 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.Msgsize() + 12 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.Msgsize() + 13 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.Msgsize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 3 + msgp.MapHeaderSize
	if (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert != nil {
		for zb0001, zb0002 := range (*z).unauthenticatedProposal.Block.BlockHeader.CompactCert {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	s += 5 + (*z).unauthenticatedProposal.Block.Payset.Msgsize() + 5 + (*z).unauthenticatedProposal.SeedProof.Msgsize() + 5 + msgp.Uint64Size + 6 + (*z).unauthenticatedProposal.OriginalProposer.Msgsize() + 3 + (*z).PriorVote.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *transmittedPayload) MsgIsZero() bool {
	return ((*z).unauthenticatedProposal.Block.BlockHeader.Round.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.Branch.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.Seed.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnRoot.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.GenesisID == "") && ((*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove == false) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter == 0) && (len((*z).unauthenticatedProposal.Block.BlockHeader.CompactCert) == 0) && ((*z).unauthenticatedProposal.Block.Payset.MsgIsZero()) && ((*z).unauthenticatedProposal.SeedProof.MsgIsZero()) && ((*z).unauthenticatedProposal.OriginalPeriod == 0) && ((*z).unauthenticatedProposal.OriginalProposer.MsgIsZero()) && ((*z).PriorVote.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *unauthenticatedBundle) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(6)
	var zb0003Mask uint8 /* 7 bits */
	if len((*z).EquivocationVotes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if (*z).Proposal.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if (*z).Step == 0 {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if len((*z).Votes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "eqv"
			o = append(o, 0xa3, 0x65, 0x71, 0x76)
			if (*z).EquivocationVotes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).EquivocationVotes)))
			}
			for zb0002 := range (*z).EquivocationVotes {
				o, err = (*z).EquivocationVotes[zb0002].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "EquivocationVotes", zb0002)
					return
				}
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "prop"
			o = append(o, 0xa4, 0x70, 0x72, 0x6f, 0x70)
			o, err = (*z).Proposal.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Proposal")
				return
			}
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o, err = (*z).Round.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Round")
				return
			}
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "vote"
			o = append(o, 0xa4, 0x76, 0x6f, 0x74, 0x65)
			if (*z).Votes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Votes)))
			}
			for zb0001 := range (*z).Votes {
				o, err = (*z).Votes[zb0001].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Votes", zb0001)
					return
				}
			}
		}
	}
	return
}

func (_ *unauthenticatedBundle) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedBundle)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *unauthenticatedBundle) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0005)
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0006)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0007 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0007), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0008 {
				(*z).Votes = nil
			} else if (*z).Votes != nil && cap((*z).Votes) >= zb0007 {
				(*z).Votes = ((*z).Votes)[:zb0007]
			} else {
				(*z).Votes = make([]voteAuthenticator, zb0007)
			}
			for zb0001 := range (*z).Votes {
				bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Votes", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0009 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0010 {
				(*z).EquivocationVotes = nil
			} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0009 {
				(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0009]
			} else {
				(*z).EquivocationVotes = make([]equivocationVoteAuthenticator, zb0009)
			}
			for zb0002 := range (*z).EquivocationVotes {
				bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = unauthenticatedBundle{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "per":
				{
					var zb0011 uint64
					zb0011, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0011)
				}
			case "step":
				{
					var zb0012 uint64
					zb0012, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0012)
				}
			case "prop":
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
			case "vote":
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0013 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0014 {
					(*z).Votes = nil
				} else if (*z).Votes != nil && cap((*z).Votes) >= zb0013 {
					(*z).Votes = ((*z).Votes)[:zb0013]
				} else {
					(*z).Votes = make([]voteAuthenticator, zb0013)
				}
				for zb0001 := range (*z).Votes {
					bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Votes", zb0001)
						return
					}
				}
			case "eqv":
				var zb0015 int
				var zb0016 bool
				zb0015, zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0015 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0015), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0016 {
					(*z).EquivocationVotes = nil
				} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0015 {
					(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0015]
				} else {
					(*z).EquivocationVotes = make([]equivocationVoteAuthenticator, zb0015)
				}
				for zb0002 := range (*z).EquivocationVotes {
					bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "EquivocationVotes", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *unauthenticatedBundle) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedBundle)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *unauthenticatedBundle) Msgsize() (s int) {
	s = 1 + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Proposal.Msgsize() + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Votes {
		s += (*z).Votes[zb0001].Msgsize()
	}
	s += 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).EquivocationVotes {
		s += (*z).EquivocationVotes[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *unauthenticatedBundle) MsgIsZero() bool {
	return ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Proposal.MsgIsZero()) && (len((*z).Votes) == 0) && (len((*z).EquivocationVotes) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *unauthenticatedEquivocationVote) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(7)
	var zb0003Mask uint8 /* 8 bits */
	if (*z).Cred.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if ((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero()) {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if ((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero()) {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if (*z).Sender.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	if (*z).Step == 0 {
		zb0003Len--
		zb0003Mask |= 0x80
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "cred"
			o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
			o, err = (*z).Cred.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Cred")
				return
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "props"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x70, 0x73)
			o = msgp.AppendArrayHeader(o, 2)
			for zb0001 := range (*z).Proposals {
				o, err = (*z).Proposals[zb0001].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Proposals", zb0001)
					return
				}
			}
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o, err = (*z).Round.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Round")
				return
			}
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "sigs"
			o = append(o, 0xa4, 0x73, 0x69, 0x67, 0x73)
			o = msgp.AppendArrayHeader(o, 2)
			for zb0002 := range (*z).Sigs {
				o, err = (*z).Sigs[zb0002].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Sigs", zb0002)
					return
				}
			}
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o, err = (*z).Sender.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sender")
				return
			}
		}
		if (zb0003Mask & 0x80) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
	}
	return
}

func (_ *unauthenticatedEquivocationVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedEquivocationVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *unauthenticatedEquivocationVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0005)
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0006)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			zb0007, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposals")
				return
			}
			if zb0007 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0007}
				return
			}
			for zb0001 := 0; zb0001 < zb0007; zb0001++ {
				bts, err = (*z).Proposals[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proposals", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0008 int
			zb0008, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sigs")
				return
			}
			if zb0008 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0008}
				return
			}
			for zb0002 := 0; zb0002 < zb0008; zb0002++ {
				bts, err = (*z).Sigs[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sigs", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = unauthenticatedEquivocationVote{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "rnd":
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "per":
				{
					var zb0009 uint64
					zb0009, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0009)
				}
			case "step":
				{
					var zb0010 uint64
					zb0010, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0010)
				}
			case "cred":
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
			case "props":
				var zb0011 int
				zb0011, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposals")
					return
				}
				if zb0011 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0011}
					return
				}
				for zb0001 := 0; zb0001 < zb0011; zb0001++ {
					bts, err = (*z).Proposals[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Proposals", zb0001)
						return
					}
				}
			case "sigs":
				var zb0012 int
				zb0012, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sigs")
					return
				}
				if zb0012 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0012}
					return
				}
				for zb0002 := 0; zb0002 < zb0012; zb0002++ {
					bts, err = (*z).Sigs[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sigs", zb0002)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *unauthenticatedEquivocationVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedEquivocationVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *unauthenticatedEquivocationVote) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Cred.Msgsize() + 6 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Proposals {
		s += (*z).Proposals[zb0001].Msgsize()
	}
	s += 5 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Sigs {
		s += (*z).Sigs[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *unauthenticatedEquivocationVote) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Cred.MsgIsZero()) && (((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero())) && (((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero()))
}

// MarshalMsg implements msgp.Marshaler
func (z *unauthenticatedProposal) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(27)
	var zb0003Mask uint32 /* 31 bits */
	if len((*z).Block.BlockHeader.CompactCert) == 0 {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsLevel == 0 {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if (*z).Block.BlockHeader.RewardsState.FeeSink.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsResidue == 0 {
		zb0003Len--
		zb0003Mask |= 0x80
	}
	if (*z).Block.BlockHeader.GenesisID == "" {
		zb0003Len--
		zb0003Mask |= 0x100
	}
	if (*z).Block.BlockHeader.GenesisHash.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x200
	}
	if (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x400
	}
	if (*z).Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x800
	}
	if (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x1000
	}
	if (*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0 {
		zb0003Len--
		zb0003Mask |= 0x2000
	}
	if (*z).OriginalPeriod == 0 {
		zb0003Len--
		zb0003Mask |= 0x4000
	}
	if (*z).OriginalProposer.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x8000
	}
	if (*z).Block.BlockHeader.Branch.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10000
	}
	if (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x20000
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsRate == 0 {
		zb0003Len--
		zb0003Mask |= 0x40000
	}
	if (*z).Block.BlockHeader.Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x80000
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x100000
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x200000
	}
	if (*z).SeedProof.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x400000
	}
	if (*z).Block.BlockHeader.Seed.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x800000
	}
	if (*z).Block.BlockHeader.TxnCounter == 0 {
		zb0003Len--
		zb0003Mask |= 0x1000000
	}
	if (*z).Block.BlockHeader.TimeStamp == 0 {
		zb0003Len--
		zb0003Mask |= 0x2000000
	}
	if (*z).Block.BlockHeader.TxnRoot.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x4000000
	}
	if (*z).Block.Payset.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x8000000
	}
	if (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10000000
	}
	if (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x20000000
	}
	if (*z).Block.BlockHeader.UpgradeVote.UpgradeApprove == false {
		zb0003Len--
		zb0003Mask |= 0x40000000
	}
	// variable map header, size zb0003Len
	o = msgp.AppendMapHeader(o, zb0003Len)
	if zb0003Len != 0 {
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "cc"
			o = append(o, 0xa2, 0x63, 0x63)
			if (*z).Block.BlockHeader.CompactCert == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).Block.BlockHeader.CompactCert)))
			}
			zb0001_keys := make([]protocol.CompactCertType, 0, len((*z).Block.BlockHeader.CompactCert))
			for zb0001 := range (*z).Block.BlockHeader.CompactCert {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort(protocol.SortCompactCertType(zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).Block.BlockHeader.CompactCert[zb0001]
				_ = zb0002
				o, err = zb0001.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "CompactCert", zb0001)
					return
				}
				o, err = zb0002.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "CompactCert", zb0001)
					return
				}
			}
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "earn"
			o = append(o, 0xa4, 0x65, 0x61, 0x72, 0x6e)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.RewardsState.RewardsLevel)
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o, err = (*z).Block.BlockHeader.RewardsState.FeeSink.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "FeeSink")
				return
			}
		}
		if (zb0003Mask & 0x80) == 0 { // if not empty
			// string "frac"
			o = append(o, 0xa4, 0x66, 0x72, 0x61, 0x63)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.RewardsState.RewardsResidue)
		}
		if (zb0003Mask & 0x100) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).Block.BlockHeader.GenesisID)
		}
		if (zb0003Mask & 0x200) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o, err = (*z).Block.BlockHeader.GenesisHash.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "GenesisHash")
				return
			}
		}
		if (zb0003Mask & 0x400) == 0 { // if not empty
			// string "nextbefore"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
			o, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "NextProtocolVoteBefore")
				return
			}
		}
		if (zb0003Mask & 0x800) == 0 { // if not empty
			// string "nextproto"
			o = append(o, 0xa9, 0x6e, 0x65, 0x78, 0x74, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o, err = (*z).Block.BlockHeader.UpgradeState.NextProtocol.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "NextProtocol")
				return
			}
		}
		if (zb0003Mask & 0x1000) == 0 { // if not empty
			// string "nextswitch"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68)
			o, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "NextProtocolSwitchOn")
				return
			}
		}
		if (zb0003Mask & 0x2000) == 0 { // if not empty
			// string "nextyes"
			o = append(o, 0xa7, 0x6e, 0x65, 0x78, 0x74, 0x79, 0x65, 0x73)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals)
		}
		if (zb0003Mask & 0x4000) == 0 { // if not empty
			// string "oper"
			o = append(o, 0xa4, 0x6f, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).OriginalPeriod))
		}
		if (zb0003Mask & 0x8000) == 0 { // if not empty
			// string "oprop"
			o = append(o, 0xa5, 0x6f, 0x70, 0x72, 0x6f, 0x70)
			o, err = (*z).OriginalProposer.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "OriginalProposer")
				return
			}
		}
		if (zb0003Mask & 0x10000) == 0 { // if not empty
			// string "prev"
			o = append(o, 0xa4, 0x70, 0x72, 0x65, 0x76)
			o, err = (*z).Block.BlockHeader.Branch.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Branch")
				return
			}
		}
		if (zb0003Mask & 0x20000) == 0 { // if not empty
			// string "proto"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o, err = (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "CurrentProtocol")
				return
			}
		}
		if (zb0003Mask & 0x40000) == 0 { // if not empty
			// string "rate"
			o = append(o, 0xa4, 0x72, 0x61, 0x74, 0x65)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.RewardsState.RewardsRate)
		}
		if (zb0003Mask & 0x80000) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o, err = (*z).Block.BlockHeader.Round.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Round")
				return
			}
		}
		if (zb0003Mask & 0x100000) == 0 { // if not empty
			// string "rwcalr"
			o = append(o, 0xa6, 0x72, 0x77, 0x63, 0x61, 0x6c, 0x72)
			o, err = (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "RewardsRecalculationRound")
				return
			}
		}
		if (zb0003Mask & 0x200000) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o, err = (*z).Block.BlockHeader.RewardsState.RewardsPool.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "RewardsPool")
				return
			}
		}
		if (zb0003Mask & 0x400000) == 0 { // if not empty
			// string "sdpf"
			o = append(o, 0xa4, 0x73, 0x64, 0x70, 0x66)
			o, err = (*z).SeedProof.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "SeedProof")
				return
			}
		}
		if (zb0003Mask & 0x800000) == 0 { // if not empty
			// string "seed"
			o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
			o, err = (*z).Block.BlockHeader.Seed.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Seed")
				return
			}
		}
		if (zb0003Mask & 0x1000000) == 0 { // if not empty
			// string "tc"
			o = append(o, 0xa2, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.TxnCounter)
		}
		if (zb0003Mask & 0x2000000) == 0 { // if not empty
			// string "ts"
			o = append(o, 0xa2, 0x74, 0x73)
			o = msgp.AppendInt64(o, (*z).Block.BlockHeader.TimeStamp)
		}
		if (zb0003Mask & 0x4000000) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o, err = (*z).Block.BlockHeader.TxnRoot.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "TxnRoot")
				return
			}
		}
		if (zb0003Mask & 0x8000000) == 0 { // if not empty
			// string "txns"
			o = append(o, 0xa4, 0x74, 0x78, 0x6e, 0x73)
			o, err = (*z).Block.Payset.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Payset")
				return
			}
		}
		if (zb0003Mask & 0x10000000) == 0 { // if not empty
			// string "upgradedelay"
			o = append(o, 0xac, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x64, 0x65, 0x6c, 0x61, 0x79)
			o, err = (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "UpgradeDelay")
				return
			}
		}
		if (zb0003Mask & 0x20000000) == 0 { // if not empty
			// string "upgradeprop"
			o = append(o, 0xab, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x70)
			o, err = (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "UpgradePropose")
				return
			}
		}
		if (zb0003Mask & 0x40000000) == 0 { // if not empty
			// string "upgradeyes"
			o = append(o, 0xaa, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x65, 0x73)
			o = msgp.AppendBool(o, (*z).Block.BlockHeader.UpgradeVote.UpgradeApprove)
		}
	}
	return
}

func (_ *unauthenticatedProposal) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedProposal)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *unauthenticatedProposal) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.Branch.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Branch")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.TxnRoot.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnRoot")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TimeStamp")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRate")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsResidue")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRecalculationRound")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CurrentProtocol")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocol")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolApprovals")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolVoteBefore")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolSwitchOn")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradePropose")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeDelay")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeApprove")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnCounter")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CompactCert")
				return
			}
			if zb0005 > protocol.NumCompactCertTypes {
				err = msgp.ErrOverflow(uint64(zb0005), uint64(protocol.NumCompactCertTypes))
				err = msgp.WrapError(err, "struct-from-array", "CompactCert")
				return
			}
			if zb0006 {
				(*z).Block.BlockHeader.CompactCert = nil
			} else if (*z).Block.BlockHeader.CompactCert == nil {
				(*z).Block.BlockHeader.CompactCert = make(map[protocol.CompactCertType]CompactCertState, zb0005)
			}
			for zb0005 > 0 {
				var zb0001 protocol.CompactCertType
				var zb0002 CompactCertState
				zb0005--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CompactCert")
					return
				}
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CompactCert", zb0001)
					return
				}
				(*z).Block.BlockHeader.CompactCert[zb0001] = zb0002
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Block.Payset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Payset")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).SeedProof.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SeedProof")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0007 uint64
				zb0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "OriginalPeriod")
					return
				}
				(*z).OriginalPeriod = period(zb0007)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).OriginalProposer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OriginalProposer")
				return
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = unauthenticatedProposal{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				bts, err = (*z).Block.BlockHeader.Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "prev":
				bts, err = (*z).Block.BlockHeader.Branch.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Branch")
					return
				}
			case "seed":
				bts, err = (*z).Block.BlockHeader.Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
			case "txn":
				bts, err = (*z).Block.BlockHeader.TxnRoot.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnRoot")
					return
				}
			case "ts":
				(*z).Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimeStamp")
					return
				}
			case "gen":
				(*z).Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
			case "gh":
				bts, err = (*z).Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
			case "fees":
				bts, err = (*z).Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
			case "rwd":
				bts, err = (*z).Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
			case "earn":
				(*z).Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
			case "rate":
				(*z).Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRate")
					return
				}
			case "frac":
				(*z).Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsResidue")
					return
				}
			case "rwcalr":
				bts, err = (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRecalculationRound")
					return
				}
			case "proto":
				bts, err = (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CurrentProtocol")
					return
				}
			case "nextproto":
				bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocol")
					return
				}
			case "nextyes":
				(*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolApprovals")
					return
				}
			case "nextbefore":
				bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolVoteBefore")
					return
				}
			case "nextswitch":
				bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolSwitchOn")
					return
				}
			case "upgradeprop":
				bts, err = (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradePropose")
					return
				}
			case "upgradedelay":
				bts, err = (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeDelay")
					return
				}
			case "upgradeyes":
				(*z).Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeApprove")
					return
				}
			case "tc":
				(*z).Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnCounter")
					return
				}
			case "cc":
				var zb0008 int
				var zb0009 bool
				zb0008, zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CompactCert")
					return
				}
				if zb0008 > protocol.NumCompactCertTypes {
					err = msgp.ErrOverflow(uint64(zb0008), uint64(protocol.NumCompactCertTypes))
					err = msgp.WrapError(err, "CompactCert")
					return
				}
				if zb0009 {
					(*z).Block.BlockHeader.CompactCert = nil
				} else if (*z).Block.BlockHeader.CompactCert == nil {
					(*z).Block.BlockHeader.CompactCert = make(map[protocol.CompactCertType]CompactCertState, zb0008)
				}
				for zb0008 > 0 {
					var zb0001 protocol.CompactCertType
					var zb0002 CompactCertState
					zb0008--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CompactCert")
						return
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "CompactCert", zb0001)
						return
					}
					(*z).Block.BlockHeader.CompactCert[zb0001] = zb0002
				}
			case "txns":
				bts, err = (*z).Block.Payset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Payset")
					return
				}
			case "sdpf":
				bts, err = (*z).SeedProof.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SeedProof")
					return
				}
			case "oper":
				{
					var zb0010 uint64
					zb0010, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OriginalPeriod")
						return
					}
					(*z).OriginalPeriod = period(zb0010)
				}
			case "oprop":
				bts, err = (*z).OriginalProposer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OriginalProposer")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *unauthenticatedProposal) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedProposal)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *unauthenticatedProposal) Msgsize() (s int) {
	s = 3 + 4 + (*z).Block.BlockHeader.Round.Msgsize() + 5 + (*z).Block.BlockHeader.Branch.Msgsize() + 5 + (*z).Block.BlockHeader.Seed.Msgsize() + 4 + (*z).Block.BlockHeader.TxnRoot.Msgsize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len((*z).Block.BlockHeader.GenesisID) + 3 + (*z).Block.BlockHeader.GenesisHash.Msgsize() + 5 + (*z).Block.BlockHeader.RewardsState.FeeSink.Msgsize() + 4 + (*z).Block.BlockHeader.RewardsState.RewardsPool.Msgsize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.Msgsize() + 6 + (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.Msgsize() + 10 + (*z).Block.BlockHeader.UpgradeState.NextProtocol.Msgsize() + 8 + msgp.Uint64Size + 11 + (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.Msgsize() + 11 + (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.Msgsize() + 12 + (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.Msgsize() + 13 + (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.Msgsize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 3 + msgp.MapHeaderSize
	if (*z).Block.BlockHeader.CompactCert != nil {
		for zb0001, zb0002 := range (*z).Block.BlockHeader.CompactCert {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	s += 5 + (*z).Block.Payset.Msgsize() + 5 + (*z).SeedProof.Msgsize() + 5 + msgp.Uint64Size + 6 + (*z).OriginalProposer.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *unauthenticatedProposal) MsgIsZero() bool {
	return ((*z).Block.BlockHeader.Round.MsgIsZero()) && ((*z).Block.BlockHeader.Branch.MsgIsZero()) && ((*z).Block.BlockHeader.Seed.MsgIsZero()) && ((*z).Block.BlockHeader.TxnRoot.MsgIsZero()) && ((*z).Block.BlockHeader.TimeStamp == 0) && ((*z).Block.BlockHeader.GenesisID == "") && ((*z).Block.BlockHeader.GenesisHash.MsgIsZero()) && ((*z).Block.BlockHeader.RewardsState.FeeSink.MsgIsZero()) && ((*z).Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero()) && ((*z).Block.BlockHeader.RewardsState.RewardsLevel == 0) && ((*z).Block.BlockHeader.RewardsState.RewardsRate == 0) && ((*z).Block.BlockHeader.RewardsState.RewardsResidue == 0) && ((*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0) && ((*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeVote.UpgradeApprove == false) && ((*z).Block.BlockHeader.TxnCounter == 0) && (len((*z).Block.BlockHeader.CompactCert) == 0) && ((*z).Block.Payset.MsgIsZero()) && ((*z).SeedProof.MsgIsZero()) && ((*z).OriginalPeriod == 0) && ((*z).OriginalProposer.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *unauthenticatedVote) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).Cred.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).R.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "cred"
			o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
			o, err = (*z).Cred.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Cred")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o, err = (*z).R.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "R")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o, err = (*z).Sig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sig")
				return
			}
		}
	}
	return
}

func (_ *unauthenticatedVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *unauthenticatedVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).R.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "R")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = unauthenticatedVote{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "r":
				bts, err = (*z).R.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "R")
					return
				}
			case "cred":
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
			case "sig":
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *unauthenticatedVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *unauthenticatedVote) Msgsize() (s int) {
	s = 1 + 2 + (*z).R.Msgsize() + 5 + (*z).Cred.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *unauthenticatedVote) MsgIsZero() bool {
	return ((*z).R.MsgIsZero()) && ((*z).Cred.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *vote) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).Cred.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).R.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "cred"
			o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
			o, err = (*z).Cred.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Cred")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o, err = (*z).R.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "R")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o, err = (*z).Sig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sig")
				return
			}
		}
	}
	return
}

func (_ *vote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*vote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *vote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).R.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "R")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = vote{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "r":
				bts, err = (*z).R.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "R")
					return
				}
			case "cred":
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
			case "sig":
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *vote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*vote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *vote) Msgsize() (s int) {
	s = 1 + 2 + (*z).R.Msgsize() + 5 + (*z).Cred.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *vote) MsgIsZero() bool {
	return ((*z).R.MsgIsZero()) && ((*z).Cred.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *voteAuthenticator) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		// string "cred"
		o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
		o, err = (*z).Cred.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Cred")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o, err = (*z).Sig.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Sig")
				return
			}
		}
		// string "snd"
		o = append(o, 0xa3, 0x73, 0x6e, 0x64)
		o, err = (*z).Sender.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Sender")
			return
		}
	}
	return
}

func (_ *voteAuthenticator) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteAuthenticator)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *voteAuthenticator) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = voteAuthenticator{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
			case "cred":
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
			case "sig":
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *voteAuthenticator) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteAuthenticator)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *voteAuthenticator) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 5 + (*z).Cred.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *voteAuthenticator) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Cred.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}
