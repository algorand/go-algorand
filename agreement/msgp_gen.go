package agreement

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	"sort"

	"github.com/algorand/msgp/msgp"

	"github.com/algorand/go-algorand/config"
	"github.com/algorand/go-algorand/crypto"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/algorand/go-algorand/data/bookkeeping"
	"github.com/algorand/go-algorand/data/committee"
	"github.com/algorand/go-algorand/protocol"
)

// The following msgp objects are implemented in this file:
// Certificate
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) UnmarshalValidateMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//      |-----> CertificateMaxSize()
//
// ConsensusVersionView
//           |-----> (*) MarshalMsg
//           |-----> (*) CanMarshalMsg
//           |-----> (*) UnmarshalMsg
//           |-----> (*) UnmarshalValidateMsg
//           |-----> (*) CanUnmarshalMsg
//           |-----> (*) Msgsize
//           |-----> (*) MsgIsZero
//           |-----> ConsensusVersionViewMaxSize()
//
// actionType
//      |-----> MarshalMsg
//      |-----> CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) UnmarshalValidateMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> Msgsize
//      |-----> MsgIsZero
//      |-----> ActionTypeMaxSize()
//
// blockAssembler
//        |-----> (*) MarshalMsg
//        |-----> (*) CanMarshalMsg
//        |-----> (*) UnmarshalMsg
//        |-----> (*) UnmarshalValidateMsg
//        |-----> (*) CanUnmarshalMsg
//        |-----> (*) Msgsize
//        |-----> (*) MsgIsZero
//        |-----> BlockAssemblerMaxSize()
//
// bundle
//    |-----> (*) MarshalMsg
//    |-----> (*) CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) UnmarshalValidateMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> (*) Msgsize
//    |-----> (*) MsgIsZero
//    |-----> BundleMaxSize()
//
// compoundMessage
//        |-----> (*) MarshalMsg
//        |-----> (*) CanMarshalMsg
//        |-----> (*) UnmarshalMsg
//        |-----> (*) UnmarshalValidateMsg
//        |-----> (*) CanUnmarshalMsg
//        |-----> (*) Msgsize
//        |-----> (*) MsgIsZero
//        |-----> CompoundMessageMaxSize()
//
// diskState
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) UnmarshalValidateMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//     |-----> DiskStateMaxSize()
//
// equivocationVote
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) UnmarshalValidateMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//         |-----> EquivocationVoteMaxSize()
//
// equivocationVoteAuthenticator
//               |-----> (*) MarshalMsg
//               |-----> (*) CanMarshalMsg
//               |-----> (*) UnmarshalMsg
//               |-----> (*) UnmarshalValidateMsg
//               |-----> (*) CanUnmarshalMsg
//               |-----> (*) Msgsize
//               |-----> (*) MsgIsZero
//               |-----> EquivocationVoteAuthenticatorMaxSize()
//
// eventType
//     |-----> MarshalMsg
//     |-----> CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) UnmarshalValidateMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> Msgsize
//     |-----> MsgIsZero
//     |-----> EventTypeMaxSize()
//
// freshnessData
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) UnmarshalValidateMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//       |-----> FreshnessDataMaxSize()
//
// message
//    |-----> (*) MarshalMsg
//    |-----> (*) CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) UnmarshalValidateMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> (*) Msgsize
//    |-----> (*) MsgIsZero
//    |-----> MessageMaxSize()
//
// messageEvent
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) UnmarshalValidateMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//       |-----> MessageEventMaxSize()
//
// nextThresholdStatusEvent
//             |-----> (*) MarshalMsg
//             |-----> (*) CanMarshalMsg
//             |-----> (*) UnmarshalMsg
//             |-----> (*) UnmarshalValidateMsg
//             |-----> (*) CanUnmarshalMsg
//             |-----> (*) Msgsize
//             |-----> (*) MsgIsZero
//             |-----> NextThresholdStatusEventMaxSize()
//
// period
//    |-----> MarshalMsg
//    |-----> CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) UnmarshalValidateMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> Msgsize
//    |-----> MsgIsZero
//    |-----> PeriodMaxSize()
//
// periodRouter
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) UnmarshalValidateMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//       |-----> PeriodRouterMaxSize()
//
// player
//    |-----> (*) MarshalMsg
//    |-----> (*) CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) UnmarshalValidateMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> (*) Msgsize
//    |-----> (*) MsgIsZero
//    |-----> PlayerMaxSize()
//
// proposal
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) UnmarshalValidateMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//     |-----> ProposalMaxSize()
//
// proposalManager
//        |-----> (*) MarshalMsg
//        |-----> (*) CanMarshalMsg
//        |-----> (*) UnmarshalMsg
//        |-----> (*) UnmarshalValidateMsg
//        |-----> (*) CanUnmarshalMsg
//        |-----> (*) Msgsize
//        |-----> (*) MsgIsZero
//        |-----> ProposalManagerMaxSize()
//
// proposalSeeker
//        |-----> (*) MarshalMsg
//        |-----> (*) CanMarshalMsg
//        |-----> (*) UnmarshalMsg
//        |-----> (*) UnmarshalValidateMsg
//        |-----> (*) CanUnmarshalMsg
//        |-----> (*) Msgsize
//        |-----> (*) MsgIsZero
//        |-----> ProposalSeekerMaxSize()
//
// proposalStore
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) UnmarshalValidateMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//       |-----> ProposalStoreMaxSize()
//
// proposalTable
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) UnmarshalValidateMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//       |-----> ProposalTableMaxSize()
//
// proposalTracker
//        |-----> (*) MarshalMsg
//        |-----> (*) CanMarshalMsg
//        |-----> (*) UnmarshalMsg
//        |-----> (*) UnmarshalValidateMsg
//        |-----> (*) CanUnmarshalMsg
//        |-----> (*) Msgsize
//        |-----> (*) MsgIsZero
//        |-----> ProposalTrackerMaxSize()
//
// proposalTrackerContract
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) UnmarshalValidateMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//            |-----> ProposalTrackerContractMaxSize()
//
// proposalValue
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) UnmarshalValidateMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//       |-----> ProposalValueMaxSize()
//
// proposalVoteCounter
//          |-----> (*) MarshalMsg
//          |-----> (*) CanMarshalMsg
//          |-----> (*) UnmarshalMsg
//          |-----> (*) UnmarshalValidateMsg
//          |-----> (*) CanUnmarshalMsg
//          |-----> (*) Msgsize
//          |-----> (*) MsgIsZero
//          |-----> ProposalVoteCounterMaxSize()
//
// proposerSeed
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) UnmarshalValidateMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//       |-----> ProposerSeedMaxSize()
//
// rawVote
//    |-----> (*) MarshalMsg
//    |-----> (*) CanMarshalMsg
//    |-----> (*) UnmarshalMsg
//    |-----> (*) UnmarshalValidateMsg
//    |-----> (*) CanUnmarshalMsg
//    |-----> (*) Msgsize
//    |-----> (*) MsgIsZero
//    |-----> RawVoteMaxSize()
//
// rootRouter
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) UnmarshalValidateMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//      |-----> RootRouterMaxSize()
//
// roundRouter
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) UnmarshalValidateMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//      |-----> RoundRouterMaxSize()
//
// seedInput
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) UnmarshalValidateMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//     |-----> SeedInputMaxSize()
//
// selector
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) UnmarshalValidateMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//     |-----> SelectorMaxSize()
//
// serializableError
//         |-----> MarshalMsg
//         |-----> CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) UnmarshalValidateMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> Msgsize
//         |-----> MsgIsZero
//         |-----> SerializableErrorMaxSize()
//
// step
//   |-----> MarshalMsg
//   |-----> CanMarshalMsg
//   |-----> (*) UnmarshalMsg
//   |-----> (*) UnmarshalValidateMsg
//   |-----> (*) CanUnmarshalMsg
//   |-----> Msgsize
//   |-----> MsgIsZero
//   |-----> StepMaxSize()
//
// stepRouter
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) UnmarshalValidateMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//      |-----> StepRouterMaxSize()
//
// thresholdEvent
//        |-----> (*) MarshalMsg
//        |-----> (*) CanMarshalMsg
//        |-----> (*) UnmarshalMsg
//        |-----> (*) UnmarshalValidateMsg
//        |-----> (*) CanUnmarshalMsg
//        |-----> (*) Msgsize
//        |-----> (*) MsgIsZero
//        |-----> ThresholdEventMaxSize()
//
// transmittedPayload
//          |-----> (*) MarshalMsg
//          |-----> (*) CanMarshalMsg
//          |-----> (*) UnmarshalMsg
//          |-----> (*) UnmarshalValidateMsg
//          |-----> (*) CanUnmarshalMsg
//          |-----> (*) Msgsize
//          |-----> (*) MsgIsZero
//          |-----> TransmittedPayloadMaxSize()
//
// unauthenticatedBundle
//           |-----> (*) MarshalMsg
//           |-----> (*) CanMarshalMsg
//           |-----> (*) UnmarshalMsg
//           |-----> (*) UnmarshalValidateMsg
//           |-----> (*) CanUnmarshalMsg
//           |-----> (*) Msgsize
//           |-----> (*) MsgIsZero
//           |-----> UnauthenticatedBundleMaxSize()
//
// unauthenticatedEquivocationVote
//                |-----> (*) MarshalMsg
//                |-----> (*) CanMarshalMsg
//                |-----> (*) UnmarshalMsg
//                |-----> (*) UnmarshalValidateMsg
//                |-----> (*) CanUnmarshalMsg
//                |-----> (*) Msgsize
//                |-----> (*) MsgIsZero
//                |-----> UnauthenticatedEquivocationVoteMaxSize()
//
// unauthenticatedProposal
//            |-----> (*) MarshalMsg
//            |-----> (*) CanMarshalMsg
//            |-----> (*) UnmarshalMsg
//            |-----> (*) UnmarshalValidateMsg
//            |-----> (*) CanUnmarshalMsg
//            |-----> (*) Msgsize
//            |-----> (*) MsgIsZero
//            |-----> UnauthenticatedProposalMaxSize()
//
// unauthenticatedVote
//          |-----> (*) MarshalMsg
//          |-----> (*) CanMarshalMsg
//          |-----> (*) UnmarshalMsg
//          |-----> (*) UnmarshalValidateMsg
//          |-----> (*) CanUnmarshalMsg
//          |-----> (*) Msgsize
//          |-----> (*) MsgIsZero
//          |-----> UnauthenticatedVoteMaxSize()
//
// vote
//   |-----> (*) MarshalMsg
//   |-----> (*) CanMarshalMsg
//   |-----> (*) UnmarshalMsg
//   |-----> (*) UnmarshalValidateMsg
//   |-----> (*) CanUnmarshalMsg
//   |-----> (*) Msgsize
//   |-----> (*) MsgIsZero
//   |-----> VoteMaxSize()
//
// voteAggregator
//        |-----> (*) MarshalMsg
//        |-----> (*) CanMarshalMsg
//        |-----> (*) UnmarshalMsg
//        |-----> (*) UnmarshalValidateMsg
//        |-----> (*) CanUnmarshalMsg
//        |-----> (*) Msgsize
//        |-----> (*) MsgIsZero
//        |-----> VoteAggregatorMaxSize()
//
// voteAuthenticator
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) UnmarshalValidateMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//         |-----> VoteAuthenticatorMaxSize()
//
// voteTracker
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) UnmarshalValidateMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//      |-----> VoteTrackerMaxSize()
//
// voteTrackerContract
//          |-----> (*) MarshalMsg
//          |-----> (*) CanMarshalMsg
//          |-----> (*) UnmarshalMsg
//          |-----> (*) UnmarshalValidateMsg
//          |-----> (*) CanUnmarshalMsg
//          |-----> (*) Msgsize
//          |-----> (*) MsgIsZero
//          |-----> VoteTrackerContractMaxSize()
//
// voteTrackerPeriod
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) UnmarshalValidateMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//         |-----> VoteTrackerPeriodMaxSize()
//
// voteTrackerRound
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) UnmarshalValidateMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//         |-----> VoteTrackerRoundMaxSize()
//

// MarshalMsg implements msgp.Marshaler
func (z *Certificate) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(6)
	var zb0003Mask uint8 /* 7 bits */
	if len((*z).EquivocationVotes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if (*z).Proposal.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if (*z).Step == 0 {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if len((*z).Votes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "eqv"
			o = append(o, 0xa3, 0x65, 0x71, 0x76)
			if (*z).EquivocationVotes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).EquivocationVotes)))
			}
			for zb0002 := range (*z).EquivocationVotes {
				o = (*z).EquivocationVotes[zb0002].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "prop"
			o = append(o, 0xa4, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).Proposal.MarshalMsg(o)
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "vote"
			o = append(o, 0xa4, 0x76, 0x6f, 0x74, 0x65)
			if (*z).Votes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Votes)))
			}
			for zb0001 := range (*z).Votes {
				o = (*z).Votes[zb0001].MarshalMsg(o)
			}
		}
	}
	return
}

func (_ *Certificate) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Certificate)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Certificate) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0007 uint64
				zb0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0007)
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0008 uint64
				zb0008, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0008)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0009 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0010 {
				(*z).Votes = nil
			} else if (*z).Votes != nil && cap((*z).Votes) >= zb0009 {
				(*z).Votes = ((*z).Votes)[:zb0009]
			} else {
				(*z).Votes = make([]voteAuthenticator, zb0009)
			}
			for zb0001 := range (*z).Votes {
				bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Votes", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0011 int
			var zb0012 bool
			zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0011 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0011), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0012 {
				(*z).EquivocationVotes = nil
			} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0011 {
				(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0011]
			} else {
				(*z).EquivocationVotes = make([]equivocationVoteAuthenticator, zb0011)
			}
			for zb0002 := range (*z).EquivocationVotes {
				bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = Certificate{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				if validate && zb0006 && "rnd" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
				zb0005 = "rnd"
			case "per":
				if validate && zb0006 && "per" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0013 uint64
					zb0013, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0013)
				}
				zb0005 = "per"
			case "step":
				if validate && zb0006 && "step" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0014 uint64
					zb0014, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0014)
				}
				zb0005 = "step"
			case "prop":
				if validate && zb0006 && "prop" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
				zb0005 = "prop"
			case "vote":
				if validate && zb0006 && "vote" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0015 int
				var zb0016 bool
				zb0015, zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0015 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0015), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0016 {
					(*z).Votes = nil
				} else if (*z).Votes != nil && cap((*z).Votes) >= zb0015 {
					(*z).Votes = ((*z).Votes)[:zb0015]
				} else {
					(*z).Votes = make([]voteAuthenticator, zb0015)
				}
				for zb0001 := range (*z).Votes {
					bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Votes", zb0001)
						return
					}
				}
				zb0005 = "vote"
			case "eqv":
				if validate && zb0006 && "eqv" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0017 int
				var zb0018 bool
				zb0017, zb0018, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0017 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0017), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0018 {
					(*z).EquivocationVotes = nil
				} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0017 {
					(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0017]
				} else {
					(*z).EquivocationVotes = make([]equivocationVoteAuthenticator, zb0017)
				}
				for zb0002 := range (*z).EquivocationVotes {
					bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "EquivocationVotes", zb0002)
						return
					}
				}
				zb0005 = "eqv"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *Certificate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *Certificate) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *Certificate) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Certificate)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Certificate) Msgsize() (s int) {
	s = 1 + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Proposal.Msgsize() + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Votes {
		s += (*z).Votes[zb0001].Msgsize()
	}
	s += 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).EquivocationVotes {
		s += (*z).EquivocationVotes[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Certificate) MsgIsZero() bool {
	return ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Proposal.MsgIsZero()) && (len((*z).Votes) == 0) && (len((*z).EquivocationVotes) == 0)
}

// MaxSize returns a maximum valid message size for this message type
func CertificateMaxSize() (s int) {
	s = 1 + 4 + basics.RoundMaxSize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + ProposalValueMaxSize() + 5
	// Calculating size of slice: z.Votes
	s += msgp.ArrayHeaderSize + ((config.MaxVoteThreshold) * (VoteAuthenticatorMaxSize()))
	s += 4
	// Calculating size of slice: z.EquivocationVotes
	s += msgp.ArrayHeaderSize + ((config.MaxVoteThreshold) * (EquivocationVoteAuthenticatorMaxSize()))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ConsensusVersionView) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Err"
	o = append(o, 0x82, 0xa3, 0x45, 0x72, 0x72)
	if (*z).Err == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, string(*(*z).Err))
	}
	// string "Version"
	o = append(o, 0xa7, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	o = (*z).Version.MarshalMsg(o)
	return
}

func (_ *ConsensusVersionView) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*ConsensusVersionView)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ConsensusVersionView) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				(*z).Err = nil
			} else {
				if (*z).Err == nil {
					(*z).Err = new(serializableError)
				}
				{
					var zb0005 string
					zb0005, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Err")
						return
					}
					*(*z).Err = serializableError(zb0005)
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Version.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Version")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = ConsensusVersionView{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Err":
				if validate && zb0004 && "Err" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					(*z).Err = nil
				} else {
					if (*z).Err == nil {
						(*z).Err = new(serializableError)
					}
					{
						var zb0006 string
						zb0006, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Err")
							return
						}
						*(*z).Err = serializableError(zb0006)
					}
				}
				zb0003 = "Err"
			case "Version":
				if validate && zb0004 && "Version" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Version.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Version")
					return
				}
				zb0003 = "Version"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *ConsensusVersionView) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *ConsensusVersionView) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *ConsensusVersionView) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*ConsensusVersionView)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ConsensusVersionView) Msgsize() (s int) {
	s = 1 + 4
	if (*z).Err == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*(*z).Err))
	}
	s += 8 + (*z).Version.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *ConsensusVersionView) MsgIsZero() bool {
	return ((*z).Err == nil) && ((*z).Version.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func ConsensusVersionViewMaxSize() (s int) {
	s = 1 + 4
	panic("Unable to determine max size: String type string(*z.Err) is unbounded")
	s += 8 + protocol.ConsensusVersionMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z actionType) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint8(o, uint8(z))
	return
}

func (_ actionType) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(actionType)
	if !ok {
		_, ok = (z).(*actionType)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *actionType) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	{
		var zb0001 uint8
		zb0001, bts, err = msgp.ReadUint8Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = actionType(zb0001)
	}
	o = bts
	return
}

func (z *actionType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *actionType) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *actionType) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*actionType)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z actionType) Msgsize() (s int) {
	s = msgp.Uint8Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z actionType) MsgIsZero() bool {
	return z == 0
}

// MaxSize returns a maximum valid message size for this message type
func ActionTypeMaxSize() (s int) {
	s = msgp.Uint8Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *blockAssembler) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "Assembled"
	o = append(o, 0x85, 0xa9, 0x41, 0x73, 0x73, 0x65, 0x6d, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, (*z).Assembled)
	// string "Authenticators"
	o = append(o, 0xae, 0x41, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x73)
	if (*z).Authenticators == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len((*z).Authenticators)))
	}
	for zb0001 := range (*z).Authenticators {
		o = (*z).Authenticators[zb0001].MarshalMsg(o)
	}
	// string "Filled"
	o = append(o, 0xa6, 0x46, 0x69, 0x6c, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, (*z).Filled)
	// string "Payload"
	o = append(o, 0xa7, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64)
	o = (*z).Payload.MarshalMsg(o)
	// string "Pipeline"
	o = append(o, 0xa8, 0x50, 0x69, 0x70, 0x65, 0x6c, 0x69, 0x6e, 0x65)
	o = (*z).Pipeline.MarshalMsg(o)
	return
}

func (_ *blockAssembler) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*blockAssembler)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *blockAssembler) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0004 string
	var zb0005 bool
	var zb0003 bool
	_ = zb0004
	_ = zb0005
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Pipeline.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Pipeline")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Filled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Filled")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).Payload.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Payload")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Assembled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Assembled")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			var zb0006 int
			var zb0007 bool
			zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Authenticators")
				return
			}
			if zb0007 {
				(*z).Authenticators = nil
			} else if (*z).Authenticators != nil && cap((*z).Authenticators) >= zb0006 {
				(*z).Authenticators = ((*z).Authenticators)[:zb0006]
			} else {
				(*z).Authenticators = make([]vote, zb0006)
			}
			for zb0001 := range (*z).Authenticators {
				bts, err = (*z).Authenticators[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Authenticators", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = blockAssembler{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Pipeline":
				if validate && zb0005 && "Pipeline" < zb0004 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Pipeline.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pipeline")
					return
				}
				zb0004 = "Pipeline"
			case "Filled":
				if validate && zb0005 && "Filled" < zb0004 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Filled, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Filled")
					return
				}
				zb0004 = "Filled"
			case "Payload":
				if validate && zb0005 && "Payload" < zb0004 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Payload.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Payload")
					return
				}
				zb0004 = "Payload"
			case "Assembled":
				if validate && zb0005 && "Assembled" < zb0004 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Assembled, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Assembled")
					return
				}
				zb0004 = "Assembled"
			case "Authenticators":
				if validate && zb0005 && "Authenticators" < zb0004 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0008 int
				var zb0009 bool
				zb0008, zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Authenticators")
					return
				}
				if zb0009 {
					(*z).Authenticators = nil
				} else if (*z).Authenticators != nil && cap((*z).Authenticators) >= zb0008 {
					(*z).Authenticators = ((*z).Authenticators)[:zb0008]
				} else {
					(*z).Authenticators = make([]vote, zb0008)
				}
				for zb0001 := range (*z).Authenticators {
					bts, err = (*z).Authenticators[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Authenticators", zb0001)
						return
					}
				}
				zb0004 = "Authenticators"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0005 = true
		}
	}
	o = bts
	return
}

func (z *blockAssembler) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *blockAssembler) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *blockAssembler) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*blockAssembler)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *blockAssembler) Msgsize() (s int) {
	s = 1 + 9 + (*z).Pipeline.Msgsize() + 7 + msgp.BoolSize + 8 + (*z).Payload.Msgsize() + 10 + msgp.BoolSize + 15 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Authenticators {
		s += (*z).Authenticators[zb0001].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *blockAssembler) MsgIsZero() bool {
	return ((*z).Pipeline.MsgIsZero()) && ((*z).Filled == false) && ((*z).Payload.MsgIsZero()) && ((*z).Assembled == false) && (len((*z).Authenticators) == 0)
}

// MaxSize returns a maximum valid message size for this message type
func BlockAssemblerMaxSize() (s int) {
	s = 1 + 9 + UnauthenticatedProposalMaxSize() + 7 + msgp.BoolSize + 8 + ProposalMaxSize() + 10 + msgp.BoolSize + 15
	// Calculating size of slice: z.Authenticators
	panic("Slice z.Authenticators is unbounded")
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *bundle) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(3)
	var zb0003Mask uint8 /* 4 bits */
	if len((*z).EquivocationVotes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).U.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if len((*z).Votes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "eqv"
			o = append(o, 0xa3, 0x65, 0x71, 0x76)
			if (*z).EquivocationVotes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).EquivocationVotes)))
			}
			for zb0002 := range (*z).EquivocationVotes {
				o = (*z).EquivocationVotes[zb0002].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "u"
			o = append(o, 0xa1, 0x75)
			o = (*z).U.MarshalMsg(o)
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "vote"
			o = append(o, 0xa4, 0x76, 0x6f, 0x74, 0x65)
			if (*z).Votes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Votes)))
			}
			for zb0001 := range (*z).Votes {
				o = (*z).Votes[zb0001].MarshalMsg(o)
			}
		}
	}
	return
}

func (_ *bundle) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*bundle)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *bundle) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).U.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "U")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0007 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0007), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0008 {
				(*z).Votes = nil
			} else if (*z).Votes != nil && cap((*z).Votes) >= zb0007 {
				(*z).Votes = ((*z).Votes)[:zb0007]
			} else {
				(*z).Votes = make([]vote, zb0007)
			}
			for zb0001 := range (*z).Votes {
				bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Votes", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0009 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0010 {
				(*z).EquivocationVotes = nil
			} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0009 {
				(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0009]
			} else {
				(*z).EquivocationVotes = make([]equivocationVote, zb0009)
			}
			for zb0002 := range (*z).EquivocationVotes {
				bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = bundle{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "u":
				if validate && zb0006 && "u" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).U.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "U")
					return
				}
				zb0005 = "u"
			case "vote":
				if validate && zb0006 && "vote" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0011 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0011), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0012 {
					(*z).Votes = nil
				} else if (*z).Votes != nil && cap((*z).Votes) >= zb0011 {
					(*z).Votes = ((*z).Votes)[:zb0011]
				} else {
					(*z).Votes = make([]vote, zb0011)
				}
				for zb0001 := range (*z).Votes {
					bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Votes", zb0001)
						return
					}
				}
				zb0005 = "vote"
			case "eqv":
				if validate && zb0006 && "eqv" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0013 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0014 {
					(*z).EquivocationVotes = nil
				} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0013 {
					(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0013]
				} else {
					(*z).EquivocationVotes = make([]equivocationVote, zb0013)
				}
				for zb0002 := range (*z).EquivocationVotes {
					bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "EquivocationVotes", zb0002)
						return
					}
				}
				zb0005 = "eqv"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *bundle) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *bundle) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *bundle) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*bundle)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *bundle) Msgsize() (s int) {
	s = 1 + 2 + (*z).U.Msgsize() + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Votes {
		s += (*z).Votes[zb0001].Msgsize()
	}
	s += 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).EquivocationVotes {
		s += (*z).EquivocationVotes[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *bundle) MsgIsZero() bool {
	return ((*z).U.MsgIsZero()) && (len((*z).Votes) == 0) && (len((*z).EquivocationVotes) == 0)
}

// MaxSize returns a maximum valid message size for this message type
func BundleMaxSize() (s int) {
	s = 1 + 2 + UnauthenticatedBundleMaxSize() + 5
	// Calculating size of slice: z.Votes
	s += msgp.ArrayHeaderSize + ((config.MaxVoteThreshold) * (VoteMaxSize()))
	s += 4
	// Calculating size of slice: z.EquivocationVotes
	s += msgp.ArrayHeaderSize + ((config.MaxVoteThreshold) * (EquivocationVoteMaxSize()))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *compoundMessage) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Proposal"
	o = append(o, 0x82, 0xa8, 0x50, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c)
	o = (*z).Proposal.MarshalMsg(o)
	// string "Vote"
	o = append(o, 0xa4, 0x56, 0x6f, 0x74, 0x65)
	o = (*z).Vote.MarshalMsg(o)
	return
}

func (_ *compoundMessage) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*compoundMessage)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *compoundMessage) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Vote.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Vote")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = compoundMessage{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Vote":
				if validate && zb0004 && "Vote" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Vote.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Vote")
					return
				}
				zb0003 = "Vote"
			case "Proposal":
				if validate && zb0004 && "Proposal" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
				zb0003 = "Proposal"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *compoundMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *compoundMessage) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *compoundMessage) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*compoundMessage)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *compoundMessage) Msgsize() (s int) {
	s = 1 + 5 + (*z).Vote.Msgsize() + 9 + (*z).Proposal.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *compoundMessage) MsgIsZero() bool {
	return ((*z).Vote.MsgIsZero()) && ((*z).Proposal.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func CompoundMessageMaxSize() (s int) {
	s = 1 + 5 + UnauthenticatedVoteMaxSize() + 9 + UnauthenticatedProposalMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *diskState) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "ActionTypes"
	o = append(o, 0x85, 0xab, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x73)
	if (*z).ActionTypes == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len((*z).ActionTypes)))
	}
	for zb0001 := range (*z).ActionTypes {
		o = msgp.AppendUint8(o, uint8((*z).ActionTypes[zb0001]))
	}
	// string "Actions"
	o = append(o, 0xa7, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if (*z).Actions == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendArrayHeader(o, uint32(len((*z).Actions)))
	}
	for zb0002 := range (*z).Actions {
		o = msgp.AppendBytes(o, (*z).Actions[zb0002])
	}
	// string "Clock"
	o = append(o, 0xa5, 0x43, 0x6c, 0x6f, 0x63, 0x6b)
	o = msgp.AppendBytes(o, (*z).Clock)
	// string "Player"
	o = append(o, 0xa6, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72)
	o = msgp.AppendBytes(o, (*z).Player)
	// string "Router"
	o = append(o, 0xa6, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x72)
	o = msgp.AppendBytes(o, (*z).Router)
	return
}

func (_ *diskState) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*diskState)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *diskState) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Router, bts, err = msgp.ReadBytesBytes(bts, (*z).Router)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Router")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Player, bts, err = msgp.ReadBytesBytes(bts, (*z).Player)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Player")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Clock, bts, err = msgp.ReadBytesBytes(bts, (*z).Clock)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Clock")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ActionTypes")
				return
			}
			if zb0008 {
				(*z).ActionTypes = nil
			} else if (*z).ActionTypes != nil && cap((*z).ActionTypes) >= zb0007 {
				(*z).ActionTypes = ((*z).ActionTypes)[:zb0007]
			} else {
				(*z).ActionTypes = make([]actionType, zb0007)
			}
			for zb0001 := range (*z).ActionTypes {
				{
					var zb0009 uint8
					zb0009, bts, err = msgp.ReadUint8Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ActionTypes", zb0001)
						return
					}
					(*z).ActionTypes[zb0001] = actionType(zb0009)
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0010 int
			var zb0011 bool
			zb0010, zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Actions")
				return
			}
			if zb0011 {
				(*z).Actions = nil
			} else if (*z).Actions != nil && cap((*z).Actions) >= zb0010 {
				(*z).Actions = ((*z).Actions)[:zb0010]
			} else {
				(*z).Actions = make([][]byte, zb0010)
			}
			for zb0002 := range (*z).Actions {
				(*z).Actions[zb0002], bts, err = msgp.ReadBytesBytes(bts, (*z).Actions[zb0002])
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Actions", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = diskState{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Router":
				if validate && zb0006 && "Router" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Router, bts, err = msgp.ReadBytesBytes(bts, (*z).Router)
				if err != nil {
					err = msgp.WrapError(err, "Router")
					return
				}
				zb0005 = "Router"
			case "Player":
				if validate && zb0006 && "Player" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Player, bts, err = msgp.ReadBytesBytes(bts, (*z).Player)
				if err != nil {
					err = msgp.WrapError(err, "Player")
					return
				}
				zb0005 = "Player"
			case "Clock":
				if validate && zb0006 && "Clock" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Clock, bts, err = msgp.ReadBytesBytes(bts, (*z).Clock)
				if err != nil {
					err = msgp.WrapError(err, "Clock")
					return
				}
				zb0005 = "Clock"
			case "ActionTypes":
				if validate && zb0006 && "ActionTypes" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0012 int
				var zb0013 bool
				zb0012, zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ActionTypes")
					return
				}
				if zb0013 {
					(*z).ActionTypes = nil
				} else if (*z).ActionTypes != nil && cap((*z).ActionTypes) >= zb0012 {
					(*z).ActionTypes = ((*z).ActionTypes)[:zb0012]
				} else {
					(*z).ActionTypes = make([]actionType, zb0012)
				}
				for zb0001 := range (*z).ActionTypes {
					{
						var zb0014 uint8
						zb0014, bts, err = msgp.ReadUint8Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "ActionTypes", zb0001)
							return
						}
						(*z).ActionTypes[zb0001] = actionType(zb0014)
					}
				}
				zb0005 = "ActionTypes"
			case "Actions":
				if validate && zb0006 && "Actions" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0015 int
				var zb0016 bool
				zb0015, zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Actions")
					return
				}
				if zb0016 {
					(*z).Actions = nil
				} else if (*z).Actions != nil && cap((*z).Actions) >= zb0015 {
					(*z).Actions = ((*z).Actions)[:zb0015]
				} else {
					(*z).Actions = make([][]byte, zb0015)
				}
				for zb0002 := range (*z).Actions {
					(*z).Actions[zb0002], bts, err = msgp.ReadBytesBytes(bts, (*z).Actions[zb0002])
					if err != nil {
						err = msgp.WrapError(err, "Actions", zb0002)
						return
					}
				}
				zb0005 = "Actions"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *diskState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *diskState) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *diskState) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*diskState)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *diskState) Msgsize() (s int) {
	s = 1 + 7 + msgp.BytesPrefixSize + len((*z).Router) + 7 + msgp.BytesPrefixSize + len((*z).Player) + 6 + msgp.BytesPrefixSize + len((*z).Clock) + 12 + msgp.ArrayHeaderSize + (len((*z).ActionTypes) * (msgp.Uint8Size)) + 8 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Actions {
		s += msgp.BytesPrefixSize + len((*z).Actions[zb0002])
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *diskState) MsgIsZero() bool {
	return (len((*z).Router) == 0) && (len((*z).Player) == 0) && (len((*z).Clock) == 0) && (len((*z).ActionTypes) == 0) && (len((*z).Actions) == 0)
}

// MaxSize returns a maximum valid message size for this message type
func DiskStateMaxSize() (s int) {
	s = 1 + 7
	panic("Unable to determine max size: Byteslice type z.Router is unbounded")
	s += 7
	panic("Unable to determine max size: Byteslice type z.Player is unbounded")
	s += 6
	panic("Unable to determine max size: Byteslice type z.Clock is unbounded")
	s += 12
	// Calculating size of slice: z.ActionTypes
	panic("Slice z.ActionTypes is unbounded")
	s += 8
	// Calculating size of slice: z.Actions
	panic("Slice z.Actions is unbounded")
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *equivocationVote) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(7)
	var zb0003Mask uint8 /* 8 bits */
	if (*z).Cred.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if ((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero()) {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if ((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero()) {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if (*z).Sender.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	if (*z).Step == 0 {
		zb0003Len--
		zb0003Mask |= 0x80
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "cred"
			o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
			o = (*z).Cred.MarshalMsg(o)
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "props"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x70, 0x73)
			o = msgp.AppendArrayHeader(o, 2)
			for zb0001 := range (*z).Proposals {
				o = (*z).Proposals[zb0001].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "sigs"
			o = append(o, 0xa4, 0x73, 0x69, 0x67, 0x73)
			o = msgp.AppendArrayHeader(o, 2)
			for zb0002 := range (*z).Sigs {
				o = (*z).Sigs[zb0002].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o = (*z).Sender.MarshalMsg(o)
		}
		if (zb0003Mask & 0x80) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
	}
	return
}

func (_ *equivocationVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*equivocationVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *equivocationVote) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0007 uint64
				zb0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0007)
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0008 uint64
				zb0008, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0008)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0009 int
			zb0009, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposals")
				return
			}
			if zb0009 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0009}
				return
			}
			for zb0001 := 0; zb0001 < zb0009; zb0001++ {
				bts, err = (*z).Proposals[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proposals", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0010 int
			zb0010, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sigs")
				return
			}
			if zb0010 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0010}
				return
			}
			for zb0002 := 0; zb0002 < zb0010; zb0002++ {
				bts, err = (*z).Sigs[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sigs", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = equivocationVote{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				if validate && zb0006 && "snd" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				zb0005 = "snd"
			case "rnd":
				if validate && zb0006 && "rnd" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
				zb0005 = "rnd"
			case "per":
				if validate && zb0006 && "per" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0011 uint64
					zb0011, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0011)
				}
				zb0005 = "per"
			case "step":
				if validate && zb0006 && "step" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0012 uint64
					zb0012, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0012)
				}
				zb0005 = "step"
			case "cred":
				if validate && zb0006 && "cred" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
				zb0005 = "cred"
			case "props":
				if validate && zb0006 && "props" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0013 int
				zb0013, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposals")
					return
				}
				if zb0013 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0013}
					return
				}
				for zb0001 := 0; zb0001 < zb0013; zb0001++ {
					bts, err = (*z).Proposals[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Proposals", zb0001)
						return
					}
				}
				zb0005 = "props"
			case "sigs":
				if validate && zb0006 && "sigs" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0014 int
				zb0014, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sigs")
					return
				}
				if zb0014 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0014}
					return
				}
				for zb0002 := 0; zb0002 < zb0014; zb0002++ {
					bts, err = (*z).Sigs[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sigs", zb0002)
						return
					}
				}
				zb0005 = "sigs"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *equivocationVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *equivocationVote) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *equivocationVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*equivocationVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *equivocationVote) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Cred.Msgsize() + 6 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Proposals {
		s += (*z).Proposals[zb0001].Msgsize()
	}
	s += 5 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Sigs {
		s += (*z).Sigs[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *equivocationVote) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Cred.MsgIsZero()) && (((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero())) && (((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero()))
}

// MaxSize returns a maximum valid message size for this message type
func EquivocationVoteMaxSize() (s int) {
	s = 1 + 4 + basics.AddressMaxSize() + 4 + basics.RoundMaxSize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + committee.CredentialMaxSize() + 6
	// Calculating size of array: z.Proposals
	s += msgp.ArrayHeaderSize + ((2) * (ProposalValueMaxSize()))
	s += 5
	// Calculating size of array: z.Sigs
	s += msgp.ArrayHeaderSize + ((2) * (crypto.OneTimeSignatureMaxSize()))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *equivocationVoteAuthenticator) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(4)
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		// string "cred"
		o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
		o = (*z).Cred.MarshalMsg(o)
		// string "props"
		o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x70, 0x73)
		o = msgp.AppendArrayHeader(o, 2)
		for zb0002 := range (*z).Proposals {
			o = (*z).Proposals[zb0002].MarshalMsg(o)
		}
		// string "sig"
		o = append(o, 0xa3, 0x73, 0x69, 0x67)
		o = msgp.AppendArrayHeader(o, 2)
		for zb0001 := range (*z).Sigs {
			o = (*z).Sigs[zb0001].MarshalMsg(o)
		}
		// string "snd"
		o = append(o, 0xa3, 0x73, 0x6e, 0x64)
		o = (*z).Sender.MarshalMsg(o)
	}
	return
}

func (_ *equivocationVoteAuthenticator) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*equivocationVoteAuthenticator)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *equivocationVoteAuthenticator) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			zb0007, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sigs")
				return
			}
			if zb0007 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0007}
				return
			}
			for zb0001 := 0; zb0001 < zb0007; zb0001++ {
				bts, err = (*z).Sigs[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sigs", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0008 int
			zb0008, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposals")
				return
			}
			if zb0008 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0008}
				return
			}
			for zb0002 := 0; zb0002 < zb0008; zb0002++ {
				bts, err = (*z).Proposals[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proposals", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = equivocationVoteAuthenticator{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				if validate && zb0006 && "snd" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				zb0005 = "snd"
			case "cred":
				if validate && zb0006 && "cred" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
				zb0005 = "cred"
			case "sig":
				if validate && zb0006 && "sig" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0009 int
				zb0009, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sigs")
					return
				}
				if zb0009 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0009}
					return
				}
				for zb0001 := 0; zb0001 < zb0009; zb0001++ {
					bts, err = (*z).Sigs[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sigs", zb0001)
						return
					}
				}
				zb0005 = "sig"
			case "props":
				if validate && zb0006 && "props" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0010 int
				zb0010, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposals")
					return
				}
				if zb0010 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0010}
					return
				}
				for zb0002 := 0; zb0002 < zb0010; zb0002++ {
					bts, err = (*z).Proposals[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Proposals", zb0002)
						return
					}
				}
				zb0005 = "props"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *equivocationVoteAuthenticator) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *equivocationVoteAuthenticator) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *equivocationVoteAuthenticator) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*equivocationVoteAuthenticator)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *equivocationVoteAuthenticator) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 5 + (*z).Cred.Msgsize() + 4 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Sigs {
		s += (*z).Sigs[zb0001].Msgsize()
	}
	s += 6 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Proposals {
		s += (*z).Proposals[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *equivocationVoteAuthenticator) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Cred.MsgIsZero()) && (((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero())) && (((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero()))
}

// MaxSize returns a maximum valid message size for this message type
func EquivocationVoteAuthenticatorMaxSize() (s int) {
	s = 1 + 4 + basics.AddressMaxSize() + 5 + committee.UnauthenticatedCredentialMaxSize() + 4
	// Calculating size of array: z.Sigs
	s += msgp.ArrayHeaderSize + ((2) * (crypto.OneTimeSignatureMaxSize()))
	s += 6
	// Calculating size of array: z.Proposals
	s += msgp.ArrayHeaderSize + ((2) * (ProposalValueMaxSize()))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z eventType) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint8(o, uint8(z))
	return
}

func (_ eventType) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(eventType)
	if !ok {
		_, ok = (z).(*eventType)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *eventType) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	{
		var zb0001 uint8
		zb0001, bts, err = msgp.ReadUint8Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = eventType(zb0001)
	}
	o = bts
	return
}

func (z *eventType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *eventType) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *eventType) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*eventType)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z eventType) Msgsize() (s int) {
	s = msgp.Uint8Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z eventType) MsgIsZero() bool {
	return z == 0
}

// MaxSize returns a maximum valid message size for this message type
func EventTypeMaxSize() (s int) {
	s = msgp.Uint8Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *freshnessData) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "PlayerLastConcluding"
	o = append(o, 0x84, 0xb4, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x4c, 0x61, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x69, 0x6e, 0x67)
	o = msgp.AppendUint64(o, uint64((*z).PlayerLastConcluding))
	// string "PlayerPeriod"
	o = append(o, 0xac, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x50, 0x65, 0x72, 0x69, 0x6f, 0x64)
	o = msgp.AppendUint64(o, uint64((*z).PlayerPeriod))
	// string "PlayerRound"
	o = append(o, 0xab, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	o = (*z).PlayerRound.MarshalMsg(o)
	// string "PlayerStep"
	o = append(o, 0xaa, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x53, 0x74, 0x65, 0x70)
	o = msgp.AppendUint64(o, uint64((*z).PlayerStep))
	return
}

func (_ *freshnessData) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*freshnessData)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *freshnessData) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).PlayerRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PlayerRound")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PlayerPeriod")
					return
				}
				(*z).PlayerPeriod = period(zb0005)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PlayerStep")
					return
				}
				(*z).PlayerStep = step(zb0006)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0007 uint64
				zb0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "PlayerLastConcluding")
					return
				}
				(*z).PlayerLastConcluding = step(zb0007)
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = freshnessData{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "PlayerRound":
				if validate && zb0004 && "PlayerRound" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).PlayerRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "PlayerRound")
					return
				}
				zb0003 = "PlayerRound"
			case "PlayerPeriod":
				if validate && zb0004 && "PlayerPeriod" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0008 uint64
					zb0008, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PlayerPeriod")
						return
					}
					(*z).PlayerPeriod = period(zb0008)
				}
				zb0003 = "PlayerPeriod"
			case "PlayerStep":
				if validate && zb0004 && "PlayerStep" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0009 uint64
					zb0009, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PlayerStep")
						return
					}
					(*z).PlayerStep = step(zb0009)
				}
				zb0003 = "PlayerStep"
			case "PlayerLastConcluding":
				if validate && zb0004 && "PlayerLastConcluding" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0010 uint64
					zb0010, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PlayerLastConcluding")
						return
					}
					(*z).PlayerLastConcluding = step(zb0010)
				}
				zb0003 = "PlayerLastConcluding"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *freshnessData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *freshnessData) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *freshnessData) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*freshnessData)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *freshnessData) Msgsize() (s int) {
	s = 1 + 12 + (*z).PlayerRound.Msgsize() + 13 + msgp.Uint64Size + 11 + msgp.Uint64Size + 21 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *freshnessData) MsgIsZero() bool {
	return ((*z).PlayerRound.MsgIsZero()) && ((*z).PlayerPeriod == 0) && ((*z).PlayerStep == 0) && ((*z).PlayerLastConcluding == 0)
}

// MaxSize returns a maximum valid message size for this message type
func FreshnessDataMaxSize() (s int) {
	s = 1 + 12 + basics.RoundMaxSize() + 13 + msgp.Uint64Size + 11 + msgp.Uint64Size + 21 + msgp.Uint64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *message) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "Bundle"
	o = append(o, 0x89, 0xa6, 0x42, 0x75, 0x6e, 0x64, 0x6c, 0x65)
	o = (*z).Bundle.MarshalMsg(o)
	// string "CompoundMessage"
	o = append(o, 0xaf, 0x43, 0x6f, 0x6d, 0x70, 0x6f, 0x75, 0x6e, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65)
	// map header, size 2
	// string "Proposal"
	o = append(o, 0x82, 0xa8, 0x50, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c)
	o = (*z).CompoundMessage.Proposal.MarshalMsg(o)
	// string "Vote"
	o = append(o, 0xa4, 0x56, 0x6f, 0x74, 0x65)
	o = (*z).CompoundMessage.Vote.MarshalMsg(o)
	// string "MessageHandle"
	o = append(o, 0xad, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65)
	o = (*z).MessageHandle.MarshalMsg(o)
	// string "Proposal"
	o = append(o, 0xa8, 0x50, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c)
	o = (*z).Proposal.MarshalMsg(o)
	// string "Tag"
	o = append(o, 0xa3, 0x54, 0x61, 0x67)
	o = (*z).Tag.MarshalMsg(o)
	// string "UnauthenticatedBundle"
	o = append(o, 0xb5, 0x55, 0x6e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x42, 0x75, 0x6e, 0x64, 0x6c, 0x65)
	o = (*z).UnauthenticatedBundle.MarshalMsg(o)
	// string "UnauthenticatedProposal"
	o = append(o, 0xb7, 0x55, 0x6e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x50, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c)
	o = (*z).UnauthenticatedProposal.MarshalMsg(o)
	// string "UnauthenticatedVote"
	o = append(o, 0xb3, 0x55, 0x6e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x56, 0x6f, 0x74, 0x65)
	o = (*z).UnauthenticatedVote.MarshalMsg(o)
	// string "Vote"
	o = append(o, 0xa4, 0x56, 0x6f, 0x74, 0x65)
	o = (*z).Vote.MarshalMsg(o)
	return
}

func (_ *message) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*message)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *message) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).MessageHandle.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MessageHandle")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Tag.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Tag")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Vote.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Vote")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Bundle.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Bundle")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).UnauthenticatedVote.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UnauthenticatedVote")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).UnauthenticatedProposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UnauthenticatedProposal")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).UnauthenticatedBundle.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UnauthenticatedBundle")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0005 int
			var zb0007 string
			var zb0008 bool
			var zb0006 bool
			_ = zb0007
			_ = zb0008
			zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CompoundMessage")
					return
				}
				if validate {
					err = &msgp.ErrNonCanonical{}
					return
				}
				if zb0005 > 0 {
					zb0005--
					bts, err = (*z).CompoundMessage.Vote.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "CompoundMessage", "struct-from-array", "Vote")
						return
					}
				}
				if zb0005 > 0 {
					zb0005--
					bts, err = (*z).CompoundMessage.Proposal.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "CompoundMessage", "struct-from-array", "Proposal")
						return
					}
				}
				if zb0005 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0005)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "CompoundMessage", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "CompoundMessage")
					return
				}
				if zb0006 {
					(*z).CompoundMessage = compoundMessage{}
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "CompoundMessage")
						return
					}
					switch string(field) {
					case "Vote":
						if validate && zb0008 && "Vote" < zb0007 {
							err = &msgp.ErrNonCanonical{}
							return
						}
						bts, err = (*z).CompoundMessage.Vote.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "CompoundMessage", "Vote")
							return
						}
						zb0007 = "Vote"
					case "Proposal":
						if validate && zb0008 && "Proposal" < zb0007 {
							err = &msgp.ErrNonCanonical{}
							return
						}
						bts, err = (*z).CompoundMessage.Proposal.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "CompoundMessage", "Proposal")
							return
						}
						zb0007 = "Proposal"
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "CompoundMessage")
							return
						}
					}
					zb0008 = true
				}
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = message{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "MessageHandle":
				if validate && zb0004 && "MessageHandle" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).MessageHandle.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "MessageHandle")
					return
				}
				zb0003 = "MessageHandle"
			case "Tag":
				if validate && zb0004 && "Tag" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Tag.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Tag")
					return
				}
				zb0003 = "Tag"
			case "Vote":
				if validate && zb0004 && "Vote" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Vote.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Vote")
					return
				}
				zb0003 = "Vote"
			case "Proposal":
				if validate && zb0004 && "Proposal" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
				zb0003 = "Proposal"
			case "Bundle":
				if validate && zb0004 && "Bundle" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Bundle.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bundle")
					return
				}
				zb0003 = "Bundle"
			case "UnauthenticatedVote":
				if validate && zb0004 && "UnauthenticatedVote" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).UnauthenticatedVote.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UnauthenticatedVote")
					return
				}
				zb0003 = "UnauthenticatedVote"
			case "UnauthenticatedProposal":
				if validate && zb0004 && "UnauthenticatedProposal" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).UnauthenticatedProposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UnauthenticatedProposal")
					return
				}
				zb0003 = "UnauthenticatedProposal"
			case "UnauthenticatedBundle":
				if validate && zb0004 && "UnauthenticatedBundle" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).UnauthenticatedBundle.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UnauthenticatedBundle")
					return
				}
				zb0003 = "UnauthenticatedBundle"
			case "CompoundMessage":
				if validate && zb0004 && "CompoundMessage" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0009 int
				var zb0011 string
				var zb0012 bool
				var zb0010 bool
				_ = zb0011
				_ = zb0012
				zb0009, zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "CompoundMessage")
						return
					}
					if validate {
						err = &msgp.ErrNonCanonical{}
						return
					}
					if zb0009 > 0 {
						zb0009--
						bts, err = (*z).CompoundMessage.Vote.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "CompoundMessage", "struct-from-array", "Vote")
							return
						}
					}
					if zb0009 > 0 {
						zb0009--
						bts, err = (*z).CompoundMessage.Proposal.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "CompoundMessage", "struct-from-array", "Proposal")
							return
						}
					}
					if zb0009 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0009)
						if err != nil {
							err = msgp.WrapError(err, "CompoundMessage", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "CompoundMessage")
						return
					}
					if zb0010 {
						(*z).CompoundMessage = compoundMessage{}
					}
					for zb0009 > 0 {
						zb0009--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "CompoundMessage")
							return
						}
						switch string(field) {
						case "Vote":
							if validate && zb0012 && "Vote" < zb0011 {
								err = &msgp.ErrNonCanonical{}
								return
							}
							bts, err = (*z).CompoundMessage.Vote.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "CompoundMessage", "Vote")
								return
							}
							zb0011 = "Vote"
						case "Proposal":
							if validate && zb0012 && "Proposal" < zb0011 {
								err = &msgp.ErrNonCanonical{}
								return
							}
							bts, err = (*z).CompoundMessage.Proposal.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "CompoundMessage", "Proposal")
								return
							}
							zb0011 = "Proposal"
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "CompoundMessage")
								return
							}
						}
						zb0012 = true
					}
				}
				zb0003 = "CompoundMessage"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *message) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *message) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *message) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*message)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *message) Msgsize() (s int) {
	s = 1 + 14 + (*z).MessageHandle.Msgsize() + 4 + (*z).Tag.Msgsize() + 5 + (*z).Vote.Msgsize() + 9 + (*z).Proposal.Msgsize() + 7 + (*z).Bundle.Msgsize() + 20 + (*z).UnauthenticatedVote.Msgsize() + 24 + (*z).UnauthenticatedProposal.Msgsize() + 22 + (*z).UnauthenticatedBundle.Msgsize() + 16 + 1 + 5 + (*z).CompoundMessage.Vote.Msgsize() + 9 + (*z).CompoundMessage.Proposal.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *message) MsgIsZero() bool {
	return ((*z).MessageHandle.MsgIsZero()) && ((*z).Tag.MsgIsZero()) && ((*z).Vote.MsgIsZero()) && ((*z).Proposal.MsgIsZero()) && ((*z).Bundle.MsgIsZero()) && ((*z).UnauthenticatedVote.MsgIsZero()) && ((*z).UnauthenticatedProposal.MsgIsZero()) && ((*z).UnauthenticatedBundle.MsgIsZero()) && (((*z).CompoundMessage.Vote.MsgIsZero()) && ((*z).CompoundMessage.Proposal.MsgIsZero()))
}

// MaxSize returns a maximum valid message size for this message type
func MessageMaxSize() (s int) {
	s = 1 + 14
	panic("Unable to determine max size: MaxSize() not implemented for Raw type")
	s += 4 + protocol.TagMaxSize() + 5 + VoteMaxSize() + 9 + ProposalMaxSize() + 7 + BundleMaxSize() + 20 + UnauthenticatedVoteMaxSize() + 24 + UnauthenticatedProposalMaxSize() + 22 + UnauthenticatedBundleMaxSize() + 16 + 1 + 5 + UnauthenticatedVoteMaxSize() + 9 + UnauthenticatedProposalMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *messageEvent) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "Cancelled"
	o = append(o, 0x87, 0xa9, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, (*z).Cancelled)
	// string "Err"
	o = append(o, 0xa3, 0x45, 0x72, 0x72)
	if (*z).Err == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, string(*(*z).Err))
	}
	// string "Input"
	o = append(o, 0xa5, 0x49, 0x6e, 0x70, 0x75, 0x74)
	o = (*z).Input.MarshalMsg(o)
	// string "Proto"
	o = append(o, 0xa5, 0x50, 0x72, 0x6f, 0x74, 0x6f)
	o = (*z).Proto.MarshalMsg(o)
	// string "T"
	o = append(o, 0xa1, 0x54)
	o = msgp.AppendUint8(o, uint8((*z).T))
	// string "Tail"
	o = append(o, 0xa4, 0x54, 0x61, 0x69, 0x6c)
	if (*z).Tail == nil {
		o = msgp.AppendNil(o)
	} else {
		o = (*z).Tail.MarshalMsg(o)
	}
	// string "TaskIndex"
	o = append(o, 0xa9, 0x54, 0x61, 0x73, 0x6b, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendUint64(o, (*z).TaskIndex)
	return
}

func (_ *messageEvent) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*messageEvent)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *messageEvent) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0005 uint8
				zb0005, bts, err = msgp.ReadUint8Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "T")
					return
				}
				(*z).T = eventType(zb0005)
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Input.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Input")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				(*z).Err = nil
			} else {
				if (*z).Err == nil {
					(*z).Err = new(serializableError)
				}
				{
					var zb0006 string
					zb0006, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Err")
						return
					}
					*(*z).Err = serializableError(zb0006)
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).TaskIndex, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TaskIndex")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				(*z).Tail = nil
			} else {
				if (*z).Tail == nil {
					(*z).Tail = new(messageEvent)
				}
				bts, err = (*z).Tail.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Tail")
					return
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Cancelled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cancelled")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Proto.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proto")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = messageEvent{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "T":
				if validate && zb0004 && "T" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0007 uint8
					zb0007, bts, err = msgp.ReadUint8Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "T")
						return
					}
					(*z).T = eventType(zb0007)
				}
				zb0003 = "T"
			case "Input":
				if validate && zb0004 && "Input" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Input.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Input")
					return
				}
				zb0003 = "Input"
			case "Err":
				if validate && zb0004 && "Err" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					(*z).Err = nil
				} else {
					if (*z).Err == nil {
						(*z).Err = new(serializableError)
					}
					{
						var zb0008 string
						zb0008, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Err")
							return
						}
						*(*z).Err = serializableError(zb0008)
					}
				}
				zb0003 = "Err"
			case "TaskIndex":
				if validate && zb0004 && "TaskIndex" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).TaskIndex, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TaskIndex")
					return
				}
				zb0003 = "TaskIndex"
			case "Tail":
				if validate && zb0004 && "Tail" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					(*z).Tail = nil
				} else {
					if (*z).Tail == nil {
						(*z).Tail = new(messageEvent)
					}
					bts, err = (*z).Tail.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Tail")
						return
					}
				}
				zb0003 = "Tail"
			case "Cancelled":
				if validate && zb0004 && "Cancelled" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Cancelled, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cancelled")
					return
				}
				zb0003 = "Cancelled"
			case "Proto":
				if validate && zb0004 && "Proto" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Proto.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proto")
					return
				}
				zb0003 = "Proto"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *messageEvent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *messageEvent) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *messageEvent) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*messageEvent)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *messageEvent) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint8Size + 6 + (*z).Input.Msgsize() + 4
	if (*z).Err == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*(*z).Err))
	}
	s += 10 + msgp.Uint64Size + 5
	if (*z).Tail == nil {
		s += msgp.NilSize
	} else {
		s += (*z).Tail.Msgsize()
	}
	s += 10 + msgp.BoolSize + 6 + (*z).Proto.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *messageEvent) MsgIsZero() bool {
	return ((*z).T == 0) && ((*z).Input.MsgIsZero()) && ((*z).Err == nil) && ((*z).TaskIndex == 0) && ((*z).Tail == nil) && ((*z).Cancelled == false) && ((*z).Proto.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func MessageEventMaxSize() (s int) {
	s = 1 + 2 + msgp.Uint8Size + 6 + MessageMaxSize() + 4
	panic("Unable to determine max size: String type string(*z.Err) is unbounded")
	s += 10 + msgp.Uint64Size + 5
	s += MessageEventMaxSize()
	s += 10 + msgp.BoolSize + 6 + ConsensusVersionViewMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *nextThresholdStatusEvent) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Bottom"
	o = append(o, 0x82, 0xa6, 0x42, 0x6f, 0x74, 0x74, 0x6f, 0x6d)
	o = msgp.AppendBool(o, (*z).Bottom)
	// string "Proposal"
	o = append(o, 0xa8, 0x50, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c)
	o = (*z).Proposal.MarshalMsg(o)
	return
}

func (_ *nextThresholdStatusEvent) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*nextThresholdStatusEvent)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *nextThresholdStatusEvent) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Bottom, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Bottom")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = nextThresholdStatusEvent{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Bottom":
				if validate && zb0004 && "Bottom" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Bottom, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bottom")
					return
				}
				zb0003 = "Bottom"
			case "Proposal":
				if validate && zb0004 && "Proposal" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
				zb0003 = "Proposal"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *nextThresholdStatusEvent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *nextThresholdStatusEvent) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *nextThresholdStatusEvent) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*nextThresholdStatusEvent)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *nextThresholdStatusEvent) Msgsize() (s int) {
	s = 1 + 7 + msgp.BoolSize + 9 + (*z).Proposal.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *nextThresholdStatusEvent) MsgIsZero() bool {
	return ((*z).Bottom == false) && ((*z).Proposal.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func NextThresholdStatusEventMaxSize() (s int) {
	s = 1 + 7 + msgp.BoolSize + 9 + ProposalValueMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z period) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

func (_ period) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(period)
	if !ok {
		_, ok = (z).(*period)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *period) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = period(zb0001)
	}
	o = bts
	return
}

func (z *period) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *period) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *period) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*period)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z period) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z period) MsgIsZero() bool {
	return z == 0
}

// MaxSize returns a maximum valid message size for this message type
func PeriodMaxSize() (s int) {
	s = msgp.Uint64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *periodRouter) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Children"
	o = append(o, 0x84, 0xa8, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	if (*z).Children == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendMapHeader(o, uint32(len((*z).Children)))
	}
	zb0001_keys := make([]step, 0, len((*z).Children))
	for zb0001 := range (*z).Children {
		zb0001_keys = append(zb0001_keys, zb0001)
	}
	sort.Sort(SortStep(zb0001_keys))
	for _, zb0001 := range zb0001_keys {
		zb0002 := (*z).Children[zb0001]
		_ = zb0002
		o = zb0001.MarshalMsg(o)
		if zb0002 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = zb0002.MarshalMsg(o)
		}
	}
	// string "ProposalTracker"
	o = append(o, 0xaf, 0x50, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72)
	o = (*z).ProposalTracker.MarshalMsg(o)
	// string "ProposalTrackerContract"
	o = append(o, 0xb7, 0x50, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x74)
	o = (*z).ProposalTrackerContract.MarshalMsg(o)
	// string "VoteTrackerPeriod"
	o = append(o, 0xb1, 0x56, 0x6f, 0x74, 0x65, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x50, 0x65, 0x72, 0x69, 0x6f, 0x64)
	o = (*z).VoteTrackerPeriod.MarshalMsg(o)
	return
}

func (_ *periodRouter) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*periodRouter)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *periodRouter) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).ProposalTracker.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ProposalTracker")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).VoteTrackerPeriod.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteTrackerPeriod")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).ProposalTrackerContract.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ProposalTrackerContract")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Children")
				return
			}
			if zb0008 {
				(*z).Children = nil
			} else if (*z).Children == nil {
				(*z).Children = make(map[step]*stepRouter, zb0007)
			}
			var zb0009 step
			_ = zb0009
			var zb0010 bool
			_ = zb0010
			for zb0007 > 0 {
				var zb0001 step
				var zb0002 *stepRouter
				zb0007--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Children")
					return
				}
				if validate && zb0010 && StepLess(zb0001, zb0009) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0009 = zb0001
				zb0010 = true
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					zb0002 = nil
				} else {
					if zb0002 == nil {
						zb0002 = new(stepRouter)
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Children", zb0001)
						return
					}
				}
				(*z).Children[zb0001] = zb0002
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = periodRouter{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "ProposalTracker":
				if validate && zb0006 && "ProposalTracker" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).ProposalTracker.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProposalTracker")
					return
				}
				zb0005 = "ProposalTracker"
			case "VoteTrackerPeriod":
				if validate && zb0006 && "VoteTrackerPeriod" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).VoteTrackerPeriod.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteTrackerPeriod")
					return
				}
				zb0005 = "VoteTrackerPeriod"
			case "ProposalTrackerContract":
				if validate && zb0006 && "ProposalTrackerContract" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).ProposalTrackerContract.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProposalTrackerContract")
					return
				}
				zb0005 = "ProposalTrackerContract"
			case "Children":
				if validate && zb0006 && "Children" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Children")
					return
				}
				if zb0012 {
					(*z).Children = nil
				} else if (*z).Children == nil {
					(*z).Children = make(map[step]*stepRouter, zb0011)
				}
				var zb0013 step
				_ = zb0013
				var zb0014 bool
				_ = zb0014
				for zb0011 > 0 {
					var zb0001 step
					var zb0002 *stepRouter
					zb0011--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Children")
						return
					}
					if validate && zb0014 && StepLess(zb0001, zb0013) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0013 = zb0001
					zb0014 = true
					if msgp.IsNil(bts) {
						bts, err = msgp.ReadNilBytes(bts)
						if err != nil {
							return
						}
						zb0002 = nil
					} else {
						if zb0002 == nil {
							zb0002 = new(stepRouter)
						}
						bts, err = zb0002.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Children", zb0001)
							return
						}
					}
					(*z).Children[zb0001] = zb0002
				}
				zb0005 = "Children"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *periodRouter) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *periodRouter) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *periodRouter) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*periodRouter)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *periodRouter) Msgsize() (s int) {
	s = 1 + 16 + (*z).ProposalTracker.Msgsize() + 18 + (*z).VoteTrackerPeriod.Msgsize() + 24 + (*z).ProposalTrackerContract.Msgsize() + 9 + msgp.MapHeaderSize
	if (*z).Children != nil {
		for zb0001, zb0002 := range (*z).Children {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize()
			if zb0002 == nil {
				s += msgp.NilSize
			} else {
				s += zb0002.Msgsize()
			}
		}
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *periodRouter) MsgIsZero() bool {
	return ((*z).ProposalTracker.MsgIsZero()) && ((*z).VoteTrackerPeriod.MsgIsZero()) && ((*z).ProposalTrackerContract.MsgIsZero()) && (len((*z).Children) == 0)
}

// MaxSize returns a maximum valid message size for this message type
func PeriodRouterMaxSize() (s int) {
	s = 1 + 16 + ProposalTrackerMaxSize() + 18 + VoteTrackerPeriodMaxSize() + 24 + ProposalTrackerContractMaxSize() + 9
	s += msgp.MapHeaderSize
	panic("Map z.Children is unbounded")
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *player) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "Deadline"
	o = append(o, 0x88, 0xa8, 0x44, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65)
	o = msgp.AppendDuration(o, (*z).Deadline)
	// string "FastRecoveryDeadline"
	o = append(o, 0xb4, 0x46, 0x61, 0x73, 0x74, 0x52, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x44, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65)
	o = msgp.AppendDuration(o, (*z).FastRecoveryDeadline)
	// string "LastConcluding"
	o = append(o, 0xae, 0x4c, 0x61, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x69, 0x6e, 0x67)
	o = msgp.AppendUint64(o, uint64((*z).LastConcluding))
	// string "Napping"
	o = append(o, 0xa7, 0x4e, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67)
	o = msgp.AppendBool(o, (*z).Napping)
	// string "Pending"
	o = append(o, 0xa7, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67)
	o = (*z).Pending.MarshalMsg(o)
	// string "Period"
	o = append(o, 0xa6, 0x50, 0x65, 0x72, 0x69, 0x6f, 0x64)
	o = msgp.AppendUint64(o, uint64((*z).Period))
	// string "Round"
	o = append(o, 0xa5, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	o = (*z).Round.MarshalMsg(o)
	// string "Step"
	o = append(o, 0xa4, 0x53, 0x74, 0x65, 0x70)
	o = msgp.AppendUint64(o, uint64((*z).Step))
	return
}

func (_ *player) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*player)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *player) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0005)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0006)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0007 uint64
				zb0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "LastConcluding")
					return
				}
				(*z).LastConcluding = step(zb0007)
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Deadline, bts, err = msgp.ReadDurationBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Deadline")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Napping, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Napping")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).FastRecoveryDeadline, bts, err = msgp.ReadDurationBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FastRecoveryDeadline")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Pending.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Pending")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = player{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Round":
				if validate && zb0004 && "Round" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
				zb0003 = "Round"
			case "Period":
				if validate && zb0004 && "Period" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0008 uint64
					zb0008, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0008)
				}
				zb0003 = "Period"
			case "Step":
				if validate && zb0004 && "Step" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0009 uint64
					zb0009, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0009)
				}
				zb0003 = "Step"
			case "LastConcluding":
				if validate && zb0004 && "LastConcluding" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0010 uint64
					zb0010, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastConcluding")
						return
					}
					(*z).LastConcluding = step(zb0010)
				}
				zb0003 = "LastConcluding"
			case "Deadline":
				if validate && zb0004 && "Deadline" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Deadline, bts, err = msgp.ReadDurationBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Deadline")
					return
				}
				zb0003 = "Deadline"
			case "Napping":
				if validate && zb0004 && "Napping" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Napping, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Napping")
					return
				}
				zb0003 = "Napping"
			case "FastRecoveryDeadline":
				if validate && zb0004 && "FastRecoveryDeadline" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).FastRecoveryDeadline, bts, err = msgp.ReadDurationBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FastRecoveryDeadline")
					return
				}
				zb0003 = "FastRecoveryDeadline"
			case "Pending":
				if validate && zb0004 && "Pending" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Pending.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pending")
					return
				}
				zb0003 = "Pending"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *player) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *player) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *player) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*player)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *player) Msgsize() (s int) {
	s = 1 + 6 + (*z).Round.Msgsize() + 7 + msgp.Uint64Size + 5 + msgp.Uint64Size + 15 + msgp.Uint64Size + 9 + msgp.DurationSize + 8 + msgp.BoolSize + 21 + msgp.DurationSize + 8 + (*z).Pending.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *player) MsgIsZero() bool {
	return ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).LastConcluding == 0) && ((*z).Deadline == 0) && ((*z).Napping == false) && ((*z).FastRecoveryDeadline == 0) && ((*z).Pending.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func PlayerMaxSize() (s int) {
	s = 1 + 6 + basics.RoundMaxSize() + 7 + msgp.Uint64Size + 5 + msgp.Uint64Size + 15 + msgp.Uint64Size + 9 + msgp.DurationSize + 8 + msgp.BoolSize + 21 + msgp.DurationSize + 8 + ProposalTableMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *proposal) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0004Len := uint32(29)
	var zb0004Mask uint64 /* 38 bits */
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel == 0 {
		zb0004Len--
		zb0004Mask |= 0x40
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue == 0 {
		zb0004Len--
		zb0004Mask |= 0x100
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.GenesisID == "" {
		zb0004Len--
		zb0004Mask |= 0x200
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x2000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0 {
		zb0004Len--
		zb0004Mask |= 0x4000
	}
	if (*z).unauthenticatedProposal.OriginalPeriod == 0 {
		zb0004Len--
		zb0004Mask |= 0x8000
	}
	if (*z).unauthenticatedProposal.OriginalProposer.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x10000
	}
	if len((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) == 0 {
		zb0004Len--
		zb0004Mask |= 0x20000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Branch.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x40000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate == 0 {
		zb0004Len--
		zb0004Mask |= 0x100000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Round.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000000
	}
	if (*z).unauthenticatedProposal.SeedProof.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x2000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Seed.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x4000000
	}
	if len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking) == 0 {
		zb0004Len--
		zb0004Mask |= 0x8000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter == 0 {
		zb0004Len--
		zb0004Mask |= 0x10000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp == 0 {
		zb0004Len--
		zb0004Mask |= 0x20000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x40000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80000000
	}
	if (*z).unauthenticatedProposal.Block.Payset.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x100000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x200000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove == false {
		zb0004Len--
		zb0004Mask |= 0x800000000
	}
	// variable map header, size zb0004Len
	o = msgp.AppendMapHeader(o, zb0004Len)
	if zb0004Len != 0 {
		if (zb0004Mask & 0x40) == 0 { // if not empty
			// string "earn"
			o = append(o, 0xa4, 0x65, 0x61, 0x72, 0x6e)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel)
		}
		if (zb0004Mask & 0x80) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100) == 0 { // if not empty
			// string "frac"
			o = append(o, 0xa4, 0x66, 0x72, 0x61, 0x63)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue)
		}
		if (zb0004Mask & 0x200) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).unauthenticatedProposal.Block.BlockHeader.GenesisID)
		}
		if (zb0004Mask & 0x400) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800) == 0 { // if not empty
			// string "nextbefore"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000) == 0 { // if not empty
			// string "nextproto"
			o = append(o, 0xa9, 0x6e, 0x65, 0x78, 0x74, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000) == 0 { // if not empty
			// string "nextswitch"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MarshalMsg(o)
		}
		if (zb0004Mask & 0x4000) == 0 { // if not empty
			// string "nextyes"
			o = append(o, 0xa7, 0x6e, 0x65, 0x78, 0x74, 0x79, 0x65, 0x73)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals)
		}
		if (zb0004Mask & 0x8000) == 0 { // if not empty
			// string "oper"
			o = append(o, 0xa4, 0x6f, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).unauthenticatedProposal.OriginalPeriod))
		}
		if (zb0004Mask & 0x10000) == 0 { // if not empty
			// string "oprop"
			o = append(o, 0xa5, 0x6f, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).unauthenticatedProposal.OriginalProposer.MarshalMsg(o)
		}
		if (zb0004Mask & 0x20000) == 0 { // if not empty
			// string "partupdrmv"
			o = append(o, 0xaa, 0x70, 0x61, 0x72, 0x74, 0x75, 0x70, 0x64, 0x72, 0x6d, 0x76)
			if (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)))
			}
			for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
				o = (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x40000) == 0 { // if not empty
			// string "prev"
			o = append(o, 0xa4, 0x70, 0x72, 0x65, 0x76)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.MarshalMsg(o)
		}
		if (zb0004Mask & 0x80000) == 0 { // if not empty
			// string "proto"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100000) == 0 { // if not empty
			// string "rate"
			o = append(o, 0xa4, 0x72, 0x61, 0x74, 0x65)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate)
		}
		if (zb0004Mask & 0x400000) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.Round.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800000) == 0 { // if not empty
			// string "rwcalr"
			o = append(o, 0xa6, 0x72, 0x77, 0x63, 0x61, 0x6c, 0x72)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000000) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000000) == 0 { // if not empty
			// string "sdpf"
			o = append(o, 0xa4, 0x73, 0x64, 0x70, 0x66)
			o = (*z).unauthenticatedProposal.SeedProof.MarshalMsg(o)
		}
		if (zb0004Mask & 0x4000000) == 0 { // if not empty
			// string "seed"
			o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.MarshalMsg(o)
		}
		if (zb0004Mask & 0x8000000) == 0 { // if not empty
			// string "spt"
			o = append(o, 0xa3, 0x73, 0x70, 0x74)
			if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking)))
			}
			zb0001_keys := make([]protocol.StateProofType, 0, len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking))
			for zb0001 := range (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort(protocol.SortStateProofType(zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking[zb0001]
				_ = zb0002
				o = zb0001.MarshalMsg(o)
				o = zb0002.MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x10000000) == 0 { // if not empty
			// string "tc"
			o = append(o, 0xa2, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter)
		}
		if (zb0004Mask & 0x20000000) == 0 { // if not empty
			// string "ts"
			o = append(o, 0xa2, 0x74, 0x73)
			o = msgp.AppendInt64(o, (*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp)
		}
		if (zb0004Mask & 0x40000000) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MarshalMsg(o)
		}
		if (zb0004Mask & 0x80000000) == 0 { // if not empty
			// string "txn256"
			o = append(o, 0xa6, 0x74, 0x78, 0x6e, 0x32, 0x35, 0x36)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100000000) == 0 { // if not empty
			// string "txns"
			o = append(o, 0xa4, 0x74, 0x78, 0x6e, 0x73)
			o = (*z).unauthenticatedProposal.Block.Payset.MarshalMsg(o)
		}
		if (zb0004Mask & 0x200000000) == 0 { // if not empty
			// string "upgradedelay"
			o = append(o, 0xac, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x64, 0x65, 0x6c, 0x61, 0x79)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MarshalMsg(o)
		}
		if (zb0004Mask & 0x400000000) == 0 { // if not empty
			// string "upgradeprop"
			o = append(o, 0xab, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800000000) == 0 { // if not empty
			// string "upgradeyes"
			o = append(o, 0xaa, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x65, 0x73)
			o = msgp.AppendBool(o, (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove)
		}
	}
	return
}

func (_ *proposal) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposal)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposal) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0004 int
	var zb0006 string
	var zb0007 bool
	var zb0005 bool
	_ = zb0006
	_ = zb0007
	zb0004, zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Branch")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NativeSha512_256Commitment")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sha256Commitment")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TimeStamp")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0008 int
			zb0008, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
			if zb0008 > config.MaxGenesisIDLen {
				err = msgp.ErrOverflow(uint64(zb0008), uint64(config.MaxGenesisIDLen))
				return
			}
			(*z).unauthenticatedProposal.Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRate")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsResidue")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRecalculationRound")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CurrentProtocol")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocol")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolApprovals")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolVoteBefore")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolSwitchOn")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradePropose")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeDelay")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeApprove")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnCounter")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
				return
			}
			if zb0009 > protocol.NumStateProofTypes {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(protocol.NumStateProofTypes))
				err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
				return
			}
			if zb0010 {
				(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = nil
			} else if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking == nil {
				(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = make(map[protocol.StateProofType]bookkeeping.StateProofTrackingData, zb0009)
			}
			var zb0011 protocol.StateProofType
			_ = zb0011
			var zb0012 bool
			_ = zb0012
			for zb0009 > 0 {
				var zb0001 protocol.StateProofType
				var zb0002 bookkeeping.StateProofTrackingData
				zb0009--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
					return
				}
				if validate && zb0012 && protocol.StateProofTypeLess(zb0001, zb0011) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0011 = zb0001
				zb0012 = true
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "StateProofTracking", zb0001)
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking[zb0001] = zb0002
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0013 int
			var zb0014 bool
			zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts")
				return
			}
			if zb0013 > config.MaxProposedExpiredOnlineAccounts {
				err = msgp.ErrOverflow(uint64(zb0013), uint64(config.MaxProposedExpiredOnlineAccounts))
				err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts")
				return
			}
			if zb0014 {
				(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = nil
			} else if (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts != nil && cap((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) >= zb0013 {
				(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = ((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)[:zb0013]
			} else {
				(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = make([]basics.Address, zb0013)
			}
			for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts", zb0003)
					return
				}
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.Payset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Payset")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.SeedProof.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SeedProof")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			{
				var zb0015 uint64
				zb0015, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "OriginalPeriod")
					return
				}
				(*z).unauthenticatedProposal.OriginalPeriod = period(zb0015)
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.OriginalProposer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OriginalProposer")
				return
			}
		}
		if zb0004 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0004)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0005 {
			(*z) = proposal{}
		}
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				if validate && zb0007 && "rnd" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
				zb0006 = "rnd"
			case "prev":
				if validate && zb0007 && "prev" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Branch")
					return
				}
				zb0006 = "prev"
			case "seed":
				if validate && zb0007 && "seed" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
				zb0006 = "seed"
			case "txn":
				if validate && zb0007 && "txn" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NativeSha512_256Commitment")
					return
				}
				zb0006 = "txn"
			case "txn256":
				if validate && zb0007 && "txn256" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sha256Commitment")
					return
				}
				zb0006 = "txn256"
			case "ts":
				if validate && zb0007 && "ts" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimeStamp")
					return
				}
				zb0006 = "ts"
			case "gen":
				if validate && zb0007 && "gen" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0016 int
				zb0016, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
				if zb0016 > config.MaxGenesisIDLen {
					err = msgp.ErrOverflow(uint64(zb0016), uint64(config.MaxGenesisIDLen))
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
				zb0006 = "gen"
			case "gh":
				if validate && zb0007 && "gh" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
				zb0006 = "gh"
			case "fees":
				if validate && zb0007 && "fees" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
				zb0006 = "fees"
			case "rwd":
				if validate && zb0007 && "rwd" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
				zb0006 = "rwd"
			case "earn":
				if validate && zb0007 && "earn" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
				zb0006 = "earn"
			case "rate":
				if validate && zb0007 && "rate" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRate")
					return
				}
				zb0006 = "rate"
			case "frac":
				if validate && zb0007 && "frac" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsResidue")
					return
				}
				zb0006 = "frac"
			case "rwcalr":
				if validate && zb0007 && "rwcalr" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRecalculationRound")
					return
				}
				zb0006 = "rwcalr"
			case "proto":
				if validate && zb0007 && "proto" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CurrentProtocol")
					return
				}
				zb0006 = "proto"
			case "nextproto":
				if validate && zb0007 && "nextproto" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocol")
					return
				}
				zb0006 = "nextproto"
			case "nextyes":
				if validate && zb0007 && "nextyes" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolApprovals")
					return
				}
				zb0006 = "nextyes"
			case "nextbefore":
				if validate && zb0007 && "nextbefore" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolVoteBefore")
					return
				}
				zb0006 = "nextbefore"
			case "nextswitch":
				if validate && zb0007 && "nextswitch" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolSwitchOn")
					return
				}
				zb0006 = "nextswitch"
			case "upgradeprop":
				if validate && zb0007 && "upgradeprop" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradePropose")
					return
				}
				zb0006 = "upgradeprop"
			case "upgradedelay":
				if validate && zb0007 && "upgradedelay" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeDelay")
					return
				}
				zb0006 = "upgradedelay"
			case "upgradeyes":
				if validate && zb0007 && "upgradeyes" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeApprove")
					return
				}
				zb0006 = "upgradeyes"
			case "tc":
				if validate && zb0007 && "tc" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnCounter")
					return
				}
				zb0006 = "tc"
			case "spt":
				if validate && zb0007 && "spt" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0017 int
				var zb0018 bool
				zb0017, zb0018, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StateProofTracking")
					return
				}
				if zb0017 > protocol.NumStateProofTypes {
					err = msgp.ErrOverflow(uint64(zb0017), uint64(protocol.NumStateProofTypes))
					err = msgp.WrapError(err, "StateProofTracking")
					return
				}
				if zb0018 {
					(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = nil
				} else if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking == nil {
					(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = make(map[protocol.StateProofType]bookkeeping.StateProofTrackingData, zb0017)
				}
				var zb0019 protocol.StateProofType
				_ = zb0019
				var zb0020 bool
				_ = zb0020
				for zb0017 > 0 {
					var zb0001 protocol.StateProofType
					var zb0002 bookkeeping.StateProofTrackingData
					zb0017--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "StateProofTracking")
						return
					}
					if validate && zb0020 && protocol.StateProofTypeLess(zb0001, zb0019) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0019 = zb0001
					zb0020 = true
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "StateProofTracking", zb0001)
						return
					}
					(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking[zb0001] = zb0002
				}
				zb0006 = "spt"
			case "partupdrmv":
				if validate && zb0007 && "partupdrmv" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0021 int
				var zb0022 bool
				zb0021, zb0022, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExpiredParticipationAccounts")
					return
				}
				if zb0021 > config.MaxProposedExpiredOnlineAccounts {
					err = msgp.ErrOverflow(uint64(zb0021), uint64(config.MaxProposedExpiredOnlineAccounts))
					err = msgp.WrapError(err, "ExpiredParticipationAccounts")
					return
				}
				if zb0022 {
					(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = nil
				} else if (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts != nil && cap((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) >= zb0021 {
					(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = ((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)[:zb0021]
				} else {
					(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = make([]basics.Address, zb0021)
				}
				for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
					bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ExpiredParticipationAccounts", zb0003)
						return
					}
				}
				zb0006 = "partupdrmv"
			case "txns":
				if validate && zb0007 && "txns" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.Payset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Payset")
					return
				}
				zb0006 = "txns"
			case "sdpf":
				if validate && zb0007 && "sdpf" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.SeedProof.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SeedProof")
					return
				}
				zb0006 = "sdpf"
			case "oper":
				if validate && zb0007 && "oper" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0023 uint64
					zb0023, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OriginalPeriod")
						return
					}
					(*z).unauthenticatedProposal.OriginalPeriod = period(zb0023)
				}
				zb0006 = "oper"
			case "oprop":
				if validate && zb0007 && "oprop" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.OriginalProposer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OriginalProposer")
					return
				}
				zb0006 = "oprop"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0007 = true
		}
	}
	o = bts
	return
}

func (z *proposal) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *proposal) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *proposal) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposal)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposal) Msgsize() (s int) {
	s = 3 + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.Round.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.Branch.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.Seed.Msgsize() + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.Msgsize() + 7 + (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.Msgsize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len((*z).unauthenticatedProposal.Block.BlockHeader.GenesisID) + 3 + (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.Msgsize() + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.Msgsize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.Msgsize() + 6 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.Msgsize() + 10 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.Msgsize() + 8 + msgp.Uint64Size + 11 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.Msgsize() + 11 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.Msgsize() + 12 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.Msgsize() + 13 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.Msgsize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 4 + msgp.MapHeaderSize
	if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking != nil {
		for zb0001, zb0002 := range (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	s += 11 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
		s += (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].Msgsize()
	}
	s += 5 + (*z).unauthenticatedProposal.Block.Payset.Msgsize() + 5 + (*z).unauthenticatedProposal.SeedProof.Msgsize() + 5 + msgp.Uint64Size + 6 + (*z).unauthenticatedProposal.OriginalProposer.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposal) MsgIsZero() bool {
	return ((*z).unauthenticatedProposal.Block.BlockHeader.Round.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.Branch.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.Seed.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.GenesisID == "") && ((*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove == false) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter == 0) && (len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking) == 0) && (len((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) == 0) && ((*z).unauthenticatedProposal.Block.Payset.MsgIsZero()) && ((*z).unauthenticatedProposal.SeedProof.MsgIsZero()) && ((*z).unauthenticatedProposal.OriginalPeriod == 0) && ((*z).unauthenticatedProposal.OriginalProposer.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func ProposalMaxSize() (s int) {
	s = 3 + 4 + basics.RoundMaxSize() + 5 + bookkeeping.BlockHashMaxSize() + 5 + committee.SeedMaxSize() + 4 + crypto.DigestMaxSize() + 7 + crypto.DigestMaxSize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + config.MaxGenesisIDLen + 3 + crypto.DigestMaxSize() + 5 + basics.AddressMaxSize() + 4 + basics.AddressMaxSize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + basics.RoundMaxSize() + 6 + protocol.ConsensusVersionMaxSize() + 10 + protocol.ConsensusVersionMaxSize() + 8 + msgp.Uint64Size + 11 + basics.RoundMaxSize() + 11 + basics.RoundMaxSize() + 12 + protocol.ConsensusVersionMaxSize() + 13 + basics.RoundMaxSize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 4
	s += msgp.MapHeaderSize
	// Adding size of map keys for z.unauthenticatedProposal.Block.BlockHeader.StateProofTracking
	s += protocol.NumStateProofTypes * (protocol.StateProofTypeMaxSize())
	// Adding size of map values for z.unauthenticatedProposal.Block.BlockHeader.StateProofTracking
	s += protocol.NumStateProofTypes * (bookkeeping.StateProofTrackingDataMaxSize())
	s += 11
	// Calculating size of slice: z.unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts
	s += msgp.ArrayHeaderSize + ((config.MaxProposedExpiredOnlineAccounts) * (basics.AddressMaxSize()))
	s += 5
	// Using maxtotalbytes for: z.unauthenticatedProposal.Block.Payset
	s += config.MaxTxnBytesPerBlock
	s += 5 + crypto.VrfProofMaxSize() + 5 + msgp.Uint64Size + 6 + basics.AddressMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *proposalManager) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

func (_ *proposalManager) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalManager)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposalManager) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = proposalManager{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *proposalManager) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *proposalManager) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *proposalManager) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalManager)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposalManager) Msgsize() (s int) {
	s = 1
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposalManager) MsgIsZero() bool {
	return true
}

// MaxSize returns a maximum valid message size for this message type
func ProposalManagerMaxSize() (s int) {
	s = 1
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *proposalSeeker) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Filled"
	o = append(o, 0x83, 0xa6, 0x46, 0x69, 0x6c, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, (*z).Filled)
	// string "Frozen"
	o = append(o, 0xa6, 0x46, 0x72, 0x6f, 0x7a, 0x65, 0x6e)
	o = msgp.AppendBool(o, (*z).Frozen)
	// string "Lowest"
	o = append(o, 0xa6, 0x4c, 0x6f, 0x77, 0x65, 0x73, 0x74)
	o = (*z).Lowest.MarshalMsg(o)
	return
}

func (_ *proposalSeeker) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalSeeker)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposalSeeker) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Lowest.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Lowest")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Filled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Filled")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Frozen, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Frozen")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = proposalSeeker{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Lowest":
				if validate && zb0004 && "Lowest" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Lowest.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lowest")
					return
				}
				zb0003 = "Lowest"
			case "Filled":
				if validate && zb0004 && "Filled" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Filled, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Filled")
					return
				}
				zb0003 = "Filled"
			case "Frozen":
				if validate && zb0004 && "Frozen" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Frozen, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Frozen")
					return
				}
				zb0003 = "Frozen"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *proposalSeeker) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *proposalSeeker) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *proposalSeeker) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalSeeker)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposalSeeker) Msgsize() (s int) {
	s = 1 + 7 + (*z).Lowest.Msgsize() + 7 + msgp.BoolSize + 7 + msgp.BoolSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposalSeeker) MsgIsZero() bool {
	return ((*z).Lowest.MsgIsZero()) && ((*z).Filled == false) && ((*z).Frozen == false)
}

// MaxSize returns a maximum valid message size for this message type
func ProposalSeekerMaxSize() (s int) {
	s = 1 + 7 + VoteMaxSize() + 7 + msgp.BoolSize + 7 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *proposalStore) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Assemblers"
	o = append(o, 0x83, 0xaa, 0x41, 0x73, 0x73, 0x65, 0x6d, 0x62, 0x6c, 0x65, 0x72, 0x73)
	if (*z).Assemblers == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendMapHeader(o, uint32(len((*z).Assemblers)))
	}
	zb0003_keys := make([]proposalValue, 0, len((*z).Assemblers))
	for zb0003 := range (*z).Assemblers {
		zb0003_keys = append(zb0003_keys, zb0003)
	}
	sort.Sort(SortProposalValue(zb0003_keys))
	for _, zb0003 := range zb0003_keys {
		zb0004 := (*z).Assemblers[zb0003]
		_ = zb0004
		o = zb0003.MarshalMsg(o)
		o = zb0004.MarshalMsg(o)
	}
	// string "Pinned"
	o = append(o, 0xa6, 0x50, 0x69, 0x6e, 0x6e, 0x65, 0x64)
	o = (*z).Pinned.MarshalMsg(o)
	// string "Relevant"
	o = append(o, 0xa8, 0x52, 0x65, 0x6c, 0x65, 0x76, 0x61, 0x6e, 0x74)
	if (*z).Relevant == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendMapHeader(o, uint32(len((*z).Relevant)))
	}
	zb0001_keys := make([]period, 0, len((*z).Relevant))
	for zb0001 := range (*z).Relevant {
		zb0001_keys = append(zb0001_keys, zb0001)
	}
	sort.Sort(SortPeriod(zb0001_keys))
	for _, zb0001 := range zb0001_keys {
		zb0002 := (*z).Relevant[zb0001]
		_ = zb0002
		o = zb0001.MarshalMsg(o)
		o = zb0002.MarshalMsg(o)
	}
	return
}

func (_ *proposalStore) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalStore)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposalStore) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0005 int
	var zb0007 string
	var zb0008 bool
	var zb0006 bool
	_ = zb0007
	_ = zb0008
	zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0005 > 0 {
			zb0005--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Relevant")
				return
			}
			if zb0010 {
				(*z).Relevant = nil
			} else if (*z).Relevant == nil {
				(*z).Relevant = make(map[period]proposalValue, zb0009)
			}
			var zb0011 period
			_ = zb0011
			var zb0012 bool
			_ = zb0012
			for zb0009 > 0 {
				var zb0001 period
				var zb0002 proposalValue
				zb0009--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Relevant")
					return
				}
				if validate && zb0012 && PeriodLess(zb0001, zb0011) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0011 = zb0001
				zb0012 = true
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Relevant", zb0001)
					return
				}
				(*z).Relevant[zb0001] = zb0002
			}
		}
		if zb0005 > 0 {
			zb0005--
			bts, err = (*z).Pinned.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Pinned")
				return
			}
		}
		if zb0005 > 0 {
			zb0005--
			var zb0013 int
			var zb0014 bool
			zb0013, zb0014, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Assemblers")
				return
			}
			if zb0014 {
				(*z).Assemblers = nil
			} else if (*z).Assemblers == nil {
				(*z).Assemblers = make(map[proposalValue]blockAssembler, zb0013)
			}
			var zb0015 proposalValue
			_ = zb0015
			var zb0016 bool
			_ = zb0016
			for zb0013 > 0 {
				var zb0003 proposalValue
				var zb0004 blockAssembler
				zb0013--
				bts, err = zb0003.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Assemblers")
					return
				}
				if validate && zb0016 && ProposalValueLess(zb0003, zb0015) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0015 = zb0003
				zb0016 = true
				bts, err = zb0004.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Assemblers", zb0003)
					return
				}
				(*z).Assemblers[zb0003] = zb0004
			}
		}
		if zb0005 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0005)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0006 {
			(*z) = proposalStore{}
		}
		for zb0005 > 0 {
			zb0005--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Relevant":
				if validate && zb0008 && "Relevant" < zb0007 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0017 int
				var zb0018 bool
				zb0017, zb0018, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Relevant")
					return
				}
				if zb0018 {
					(*z).Relevant = nil
				} else if (*z).Relevant == nil {
					(*z).Relevant = make(map[period]proposalValue, zb0017)
				}
				var zb0019 period
				_ = zb0019
				var zb0020 bool
				_ = zb0020
				for zb0017 > 0 {
					var zb0001 period
					var zb0002 proposalValue
					zb0017--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Relevant")
						return
					}
					if validate && zb0020 && PeriodLess(zb0001, zb0019) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0019 = zb0001
					zb0020 = true
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Relevant", zb0001)
						return
					}
					(*z).Relevant[zb0001] = zb0002
				}
				zb0007 = "Relevant"
			case "Pinned":
				if validate && zb0008 && "Pinned" < zb0007 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Pinned.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pinned")
					return
				}
				zb0007 = "Pinned"
			case "Assemblers":
				if validate && zb0008 && "Assemblers" < zb0007 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0021 int
				var zb0022 bool
				zb0021, zb0022, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Assemblers")
					return
				}
				if zb0022 {
					(*z).Assemblers = nil
				} else if (*z).Assemblers == nil {
					(*z).Assemblers = make(map[proposalValue]blockAssembler, zb0021)
				}
				var zb0023 proposalValue
				_ = zb0023
				var zb0024 bool
				_ = zb0024
				for zb0021 > 0 {
					var zb0003 proposalValue
					var zb0004 blockAssembler
					zb0021--
					bts, err = zb0003.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Assemblers")
						return
					}
					if validate && zb0024 && ProposalValueLess(zb0003, zb0023) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0023 = zb0003
					zb0024 = true
					bts, err = zb0004.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Assemblers", zb0003)
						return
					}
					(*z).Assemblers[zb0003] = zb0004
				}
				zb0007 = "Assemblers"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0008 = true
		}
	}
	o = bts
	return
}

func (z *proposalStore) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *proposalStore) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *proposalStore) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalStore)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposalStore) Msgsize() (s int) {
	s = 1 + 9 + msgp.MapHeaderSize
	if (*z).Relevant != nil {
		for zb0001, zb0002 := range (*z).Relevant {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	s += 7 + (*z).Pinned.Msgsize() + 11 + msgp.MapHeaderSize
	if (*z).Assemblers != nil {
		for zb0003, zb0004 := range (*z).Assemblers {
			_ = zb0003
			_ = zb0004
			s += 0 + zb0003.Msgsize() + zb0004.Msgsize()
		}
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposalStore) MsgIsZero() bool {
	return (len((*z).Relevant) == 0) && ((*z).Pinned.MsgIsZero()) && (len((*z).Assemblers) == 0)
}

// MaxSize returns a maximum valid message size for this message type
func ProposalStoreMaxSize() (s int) {
	s = 1 + 9
	s += msgp.MapHeaderSize
	panic("Map z.Relevant is unbounded")
	s += 7 + ProposalValueMaxSize() + 11
	s += msgp.MapHeaderSize
	panic("Map z.Assemblers is unbounded")
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *proposalTable) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(2)
	var zb0003Mask uint8 /* 3 bits */
	if len((*z).Pending) == 0 {
		zb0003Len--
		zb0003Mask |= 0x1
	}
	if (*z).PendingNext == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x1) == 0 { // if not empty
			// string "Pending"
			o = append(o, 0xa7, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67)
			if (*z).Pending == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).Pending)))
			}
			zb0001_keys := make([]uint64, 0, len((*z).Pending))
			for zb0001 := range (*z).Pending {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort(SortUint64(zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).Pending[zb0001]
				_ = zb0002
				o = msgp.AppendUint64(o, zb0001)
				if zb0002 == nil {
					o = msgp.AppendNil(o)
				} else {
					o = zb0002.MarshalMsg(o)
				}
			}
		}
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "PendingNext"
			o = append(o, 0xab, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x4e, 0x65, 0x78, 0x74)
			o = msgp.AppendUint64(o, (*z).PendingNext)
		}
	}
	return
}

func (_ *proposalTable) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalTable)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposalTable) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Pending")
				return
			}
			if zb0008 {
				(*z).Pending = nil
			} else if (*z).Pending == nil {
				(*z).Pending = make(map[uint64]*messageEvent, zb0007)
			}
			var zb0009 uint64
			_ = zb0009
			var zb0010 bool
			_ = zb0010
			for zb0007 > 0 {
				var zb0001 uint64
				var zb0002 *messageEvent
				zb0007--
				zb0001, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Pending")
					return
				}
				if validate && zb0010 && Uint64Less(zb0001, zb0009) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0009 = zb0001
				zb0010 = true
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					zb0002 = nil
				} else {
					if zb0002 == nil {
						zb0002 = new(messageEvent)
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Pending", zb0001)
						return
					}
				}
				(*z).Pending[zb0001] = zb0002
			}
		}
		if zb0003 > 0 {
			zb0003--
			(*z).PendingNext, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PendingNext")
				return
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = proposalTable{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Pending":
				if validate && zb0006 && "Pending" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pending")
					return
				}
				if zb0012 {
					(*z).Pending = nil
				} else if (*z).Pending == nil {
					(*z).Pending = make(map[uint64]*messageEvent, zb0011)
				}
				var zb0013 uint64
				_ = zb0013
				var zb0014 bool
				_ = zb0014
				for zb0011 > 0 {
					var zb0001 uint64
					var zb0002 *messageEvent
					zb0011--
					zb0001, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Pending")
						return
					}
					if validate && zb0014 && Uint64Less(zb0001, zb0013) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0013 = zb0001
					zb0014 = true
					if msgp.IsNil(bts) {
						bts, err = msgp.ReadNilBytes(bts)
						if err != nil {
							return
						}
						zb0002 = nil
					} else {
						if zb0002 == nil {
							zb0002 = new(messageEvent)
						}
						bts, err = zb0002.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Pending", zb0001)
							return
						}
					}
					(*z).Pending[zb0001] = zb0002
				}
				zb0005 = "Pending"
			case "PendingNext":
				if validate && zb0006 && "PendingNext" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).PendingNext, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PendingNext")
					return
				}
				zb0005 = "PendingNext"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *proposalTable) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *proposalTable) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *proposalTable) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalTable)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposalTable) Msgsize() (s int) {
	s = 1 + 8 + msgp.MapHeaderSize
	if (*z).Pending != nil {
		for zb0001, zb0002 := range (*z).Pending {
			_ = zb0001
			_ = zb0002
			s += 0 + msgp.Uint64Size
			if zb0002 == nil {
				s += msgp.NilSize
			} else {
				s += zb0002.Msgsize()
			}
		}
	}
	s += 12 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposalTable) MsgIsZero() bool {
	return (len((*z).Pending) == 0) && ((*z).PendingNext == 0)
}

// MaxSize returns a maximum valid message size for this message type
func ProposalTableMaxSize() (s int) {
	s = 1 + 8
	s += msgp.MapHeaderSize
	panic("Map z.Pending is unbounded")
	s += 12 + msgp.Uint64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *proposalTracker) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Duplicate"
	o = append(o, 0x83, 0xa9, 0x44, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65)
	if (*z).Duplicate == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendMapHeader(o, uint32(len((*z).Duplicate)))
	}
	zb0001_keys := make([]basics.Address, 0, len((*z).Duplicate))
	for zb0001 := range (*z).Duplicate {
		zb0001_keys = append(zb0001_keys, zb0001)
	}
	sort.Sort(SortAddress(zb0001_keys))
	for _, zb0001 := range zb0001_keys {
		zb0002 := (*z).Duplicate[zb0001]
		_ = zb0002
		o = zb0001.MarshalMsg(o)
		o = msgp.AppendBool(o, zb0002)
	}
	// string "Freezer"
	o = append(o, 0xa7, 0x46, 0x72, 0x65, 0x65, 0x7a, 0x65, 0x72)
	o = (*z).Freezer.MarshalMsg(o)
	// string "Staging"
	o = append(o, 0xa7, 0x53, 0x74, 0x61, 0x67, 0x69, 0x6e, 0x67)
	o = (*z).Staging.MarshalMsg(o)
	return
}

func (_ *proposalTracker) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalTracker)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposalTracker) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Duplicate")
				return
			}
			if zb0008 {
				(*z).Duplicate = nil
			} else if (*z).Duplicate == nil {
				(*z).Duplicate = make(map[basics.Address]bool, zb0007)
			}
			var zb0009 basics.Address
			_ = zb0009
			var zb0010 bool
			_ = zb0010
			for zb0007 > 0 {
				var zb0001 basics.Address
				var zb0002 bool
				zb0007--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Duplicate")
					return
				}
				if validate && zb0010 && basics.AddressLess(zb0001, zb0009) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0009 = zb0001
				zb0010 = true
				zb0002, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Duplicate", zb0001)
					return
				}
				(*z).Duplicate[zb0001] = zb0002
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Freezer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Freezer")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Staging.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Staging")
				return
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = proposalTracker{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Duplicate":
				if validate && zb0006 && "Duplicate" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Duplicate")
					return
				}
				if zb0012 {
					(*z).Duplicate = nil
				} else if (*z).Duplicate == nil {
					(*z).Duplicate = make(map[basics.Address]bool, zb0011)
				}
				var zb0013 basics.Address
				_ = zb0013
				var zb0014 bool
				_ = zb0014
				for zb0011 > 0 {
					var zb0001 basics.Address
					var zb0002 bool
					zb0011--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Duplicate")
						return
					}
					if validate && zb0014 && basics.AddressLess(zb0001, zb0013) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0013 = zb0001
					zb0014 = true
					zb0002, bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Duplicate", zb0001)
						return
					}
					(*z).Duplicate[zb0001] = zb0002
				}
				zb0005 = "Duplicate"
			case "Freezer":
				if validate && zb0006 && "Freezer" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Freezer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Freezer")
					return
				}
				zb0005 = "Freezer"
			case "Staging":
				if validate && zb0006 && "Staging" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Staging.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Staging")
					return
				}
				zb0005 = "Staging"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *proposalTracker) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *proposalTracker) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *proposalTracker) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalTracker)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposalTracker) Msgsize() (s int) {
	s = 1 + 10 + msgp.MapHeaderSize
	if (*z).Duplicate != nil {
		for zb0001, zb0002 := range (*z).Duplicate {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + msgp.BoolSize
		}
	}
	s += 8 + (*z).Freezer.Msgsize() + 8 + (*z).Staging.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposalTracker) MsgIsZero() bool {
	return (len((*z).Duplicate) == 0) && ((*z).Freezer.MsgIsZero()) && ((*z).Staging.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func ProposalTrackerMaxSize() (s int) {
	s = 1 + 10
	s += msgp.MapHeaderSize
	panic("Map z.Duplicate is unbounded")
	s += 8 + ProposalSeekerMaxSize() + 8 + ProposalValueMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *proposalTrackerContract) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Froze"
	o = append(o, 0x84, 0xa5, 0x46, 0x72, 0x6f, 0x7a, 0x65)
	o = msgp.AppendBool(o, (*z).Froze)
	// string "SawCertThreshold"
	o = append(o, 0xb0, 0x53, 0x61, 0x77, 0x43, 0x65, 0x72, 0x74, 0x54, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64)
	o = msgp.AppendBool(o, (*z).SawCertThreshold)
	// string "SawOneVote"
	o = append(o, 0xaa, 0x53, 0x61, 0x77, 0x4f, 0x6e, 0x65, 0x56, 0x6f, 0x74, 0x65)
	o = msgp.AppendBool(o, (*z).SawOneVote)
	// string "SawSoftThreshold"
	o = append(o, 0xb0, 0x53, 0x61, 0x77, 0x53, 0x6f, 0x66, 0x74, 0x54, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64)
	o = msgp.AppendBool(o, (*z).SawSoftThreshold)
	return
}

func (_ *proposalTrackerContract) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalTrackerContract)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposalTrackerContract) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).SawOneVote, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SawOneVote")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Froze, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Froze")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).SawSoftThreshold, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SawSoftThreshold")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).SawCertThreshold, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SawCertThreshold")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = proposalTrackerContract{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "SawOneVote":
				if validate && zb0004 && "SawOneVote" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).SawOneVote, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SawOneVote")
					return
				}
				zb0003 = "SawOneVote"
			case "Froze":
				if validate && zb0004 && "Froze" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Froze, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Froze")
					return
				}
				zb0003 = "Froze"
			case "SawSoftThreshold":
				if validate && zb0004 && "SawSoftThreshold" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).SawSoftThreshold, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SawSoftThreshold")
					return
				}
				zb0003 = "SawSoftThreshold"
			case "SawCertThreshold":
				if validate && zb0004 && "SawCertThreshold" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).SawCertThreshold, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SawCertThreshold")
					return
				}
				zb0003 = "SawCertThreshold"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *proposalTrackerContract) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *proposalTrackerContract) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *proposalTrackerContract) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalTrackerContract)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposalTrackerContract) Msgsize() (s int) {
	s = 1 + 11 + msgp.BoolSize + 6 + msgp.BoolSize + 17 + msgp.BoolSize + 17 + msgp.BoolSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposalTrackerContract) MsgIsZero() bool {
	return ((*z).SawOneVote == false) && ((*z).Froze == false) && ((*z).SawSoftThreshold == false) && ((*z).SawCertThreshold == false)
}

// MaxSize returns a maximum valid message size for this message type
func ProposalTrackerContractMaxSize() (s int) {
	s = 1 + 11 + msgp.BoolSize + 6 + msgp.BoolSize + 17 + msgp.BoolSize + 17 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *proposalValue) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 5 bits */
	if (*z).BlockDigest.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).EncodingDigest.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).OriginalPeriod == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).OriginalProposer.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "dig"
			o = append(o, 0xa3, 0x64, 0x69, 0x67)
			o = (*z).BlockDigest.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "encdig"
			o = append(o, 0xa6, 0x65, 0x6e, 0x63, 0x64, 0x69, 0x67)
			o = (*z).EncodingDigest.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "oper"
			o = append(o, 0xa4, 0x6f, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).OriginalPeriod))
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "oprop"
			o = append(o, 0xa5, 0x6f, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).OriginalProposer.MarshalMsg(o)
		}
	}
	return
}

func (_ *proposalValue) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalValue)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposalValue) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "OriginalPeriod")
					return
				}
				(*z).OriginalPeriod = period(zb0005)
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).OriginalProposer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OriginalProposer")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).BlockDigest.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BlockDigest")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).EncodingDigest.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EncodingDigest")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = proposalValue{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "oper":
				if validate && zb0004 && "oper" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0006 uint64
					zb0006, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OriginalPeriod")
						return
					}
					(*z).OriginalPeriod = period(zb0006)
				}
				zb0003 = "oper"
			case "oprop":
				if validate && zb0004 && "oprop" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).OriginalProposer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OriginalProposer")
					return
				}
				zb0003 = "oprop"
			case "dig":
				if validate && zb0004 && "dig" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).BlockDigest.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BlockDigest")
					return
				}
				zb0003 = "dig"
			case "encdig":
				if validate && zb0004 && "encdig" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).EncodingDigest.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "EncodingDigest")
					return
				}
				zb0003 = "encdig"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *proposalValue) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *proposalValue) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *proposalValue) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalValue)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposalValue) Msgsize() (s int) {
	s = 1 + 5 + msgp.Uint64Size + 6 + (*z).OriginalProposer.Msgsize() + 4 + (*z).BlockDigest.Msgsize() + 7 + (*z).EncodingDigest.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposalValue) MsgIsZero() bool {
	return ((*z).OriginalPeriod == 0) && ((*z).OriginalProposer.MsgIsZero()) && ((*z).BlockDigest.MsgIsZero()) && ((*z).EncodingDigest.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func ProposalValueMaxSize() (s int) {
	s = 1 + 5 + msgp.Uint64Size + 6 + basics.AddressMaxSize() + 4 + crypto.DigestMaxSize() + 7 + crypto.DigestMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *proposalVoteCounter) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Count"
	o = append(o, 0x82, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, (*z).Count)
	// string "Votes"
	o = append(o, 0xa5, 0x56, 0x6f, 0x74, 0x65, 0x73)
	if (*z).Votes == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendMapHeader(o, uint32(len((*z).Votes)))
	}
	zb0001_keys := make([]basics.Address, 0, len((*z).Votes))
	for zb0001 := range (*z).Votes {
		zb0001_keys = append(zb0001_keys, zb0001)
	}
	sort.Sort(SortAddress(zb0001_keys))
	for _, zb0001 := range zb0001_keys {
		zb0002 := (*z).Votes[zb0001]
		_ = zb0002
		o = zb0001.MarshalMsg(o)
		o = zb0002.MarshalMsg(o)
	}
	return
}

func (_ *proposalVoteCounter) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalVoteCounter)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposalVoteCounter) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			(*z).Count, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Count")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0008 {
				(*z).Votes = nil
			} else if (*z).Votes == nil {
				(*z).Votes = make(map[basics.Address]vote, zb0007)
			}
			var zb0009 basics.Address
			_ = zb0009
			var zb0010 bool
			_ = zb0010
			for zb0007 > 0 {
				var zb0001 basics.Address
				var zb0002 vote
				zb0007--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Votes")
					return
				}
				if validate && zb0010 && basics.AddressLess(zb0001, zb0009) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0009 = zb0001
				zb0010 = true
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Votes", zb0001)
					return
				}
				(*z).Votes[zb0001] = zb0002
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = proposalVoteCounter{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Count":
				if validate && zb0006 && "Count" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Count, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Count")
					return
				}
				zb0005 = "Count"
			case "Votes":
				if validate && zb0006 && "Votes" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0012 {
					(*z).Votes = nil
				} else if (*z).Votes == nil {
					(*z).Votes = make(map[basics.Address]vote, zb0011)
				}
				var zb0013 basics.Address
				_ = zb0013
				var zb0014 bool
				_ = zb0014
				for zb0011 > 0 {
					var zb0001 basics.Address
					var zb0002 vote
					zb0011--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Votes")
						return
					}
					if validate && zb0014 && basics.AddressLess(zb0001, zb0013) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0013 = zb0001
					zb0014 = true
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Votes", zb0001)
						return
					}
					(*z).Votes[zb0001] = zb0002
				}
				zb0005 = "Votes"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *proposalVoteCounter) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *proposalVoteCounter) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *proposalVoteCounter) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposalVoteCounter)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposalVoteCounter) Msgsize() (s int) {
	s = 1 + 6 + msgp.Uint64Size + 6 + msgp.MapHeaderSize
	if (*z).Votes != nil {
		for zb0001, zb0002 := range (*z).Votes {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposalVoteCounter) MsgIsZero() bool {
	return ((*z).Count == 0) && (len((*z).Votes) == 0)
}

// MaxSize returns a maximum valid message size for this message type
func ProposalVoteCounterMaxSize() (s int) {
	s = 1 + 6 + msgp.Uint64Size + 6
	s += msgp.MapHeaderSize
	panic("Map z.Votes is unbounded")
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *proposerSeed) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "addr"
	o = append(o, 0x82, 0xa4, 0x61, 0x64, 0x64, 0x72)
	o = (*z).Addr.MarshalMsg(o)
	// string "vrf"
	o = append(o, 0xa3, 0x76, 0x72, 0x66)
	o = (*z).VRF.MarshalMsg(o)
	return
}

func (_ *proposerSeed) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposerSeed)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *proposerSeed) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Addr.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Addr")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).VRF.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VRF")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = proposerSeed{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "addr":
				if validate && zb0004 && "addr" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Addr.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Addr")
					return
				}
				zb0003 = "addr"
			case "vrf":
				if validate && zb0004 && "vrf" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).VRF.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "VRF")
					return
				}
				zb0003 = "vrf"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *proposerSeed) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *proposerSeed) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *proposerSeed) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*proposerSeed)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *proposerSeed) Msgsize() (s int) {
	s = 1 + 5 + (*z).Addr.Msgsize() + 4 + (*z).VRF.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *proposerSeed) MsgIsZero() bool {
	return ((*z).Addr.MsgIsZero()) && ((*z).VRF.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func ProposerSeedMaxSize() (s int) {
	s = 1 + 5 + basics.AddressMaxSize() + 4 + crypto.VrfOutputMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *rawVote) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 6 bits */
	if (*z).Period == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Proposal.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Round.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).Sender.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).Step == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "prop"
			o = append(o, 0xa4, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).Proposal.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o = (*z).Sender.MarshalMsg(o)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
	}
	return
}

func (_ *rawVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*rawVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *rawVote) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0005)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0006)
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = rawVote{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				if validate && zb0004 && "snd" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				zb0003 = "snd"
			case "rnd":
				if validate && zb0004 && "rnd" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
				zb0003 = "rnd"
			case "per":
				if validate && zb0004 && "per" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0007 uint64
					zb0007, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0007)
				}
				zb0003 = "per"
			case "step":
				if validate && zb0004 && "step" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0008 uint64
					zb0008, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0008)
				}
				zb0003 = "step"
			case "prop":
				if validate && zb0004 && "prop" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
				zb0003 = "prop"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *rawVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *rawVote) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *rawVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*rawVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *rawVote) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Proposal.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *rawVote) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Proposal.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func RawVoteMaxSize() (s int) {
	s = 1 + 4 + basics.AddressMaxSize() + 4 + basics.RoundMaxSize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + ProposalValueMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *rootRouter) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Children"
	o = append(o, 0x83, 0xa8, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	if (*z).Children == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendMapHeader(o, uint32(len((*z).Children)))
	}
	zb0001_keys := make([]basics.Round, 0, len((*z).Children))
	for zb0001 := range (*z).Children {
		zb0001_keys = append(zb0001_keys, zb0001)
	}
	sort.Sort(SortRound(zb0001_keys))
	for _, zb0001 := range zb0001_keys {
		zb0002 := (*z).Children[zb0001]
		_ = zb0002
		o = zb0001.MarshalMsg(o)
		if zb0002 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = zb0002.MarshalMsg(o)
		}
	}
	// string "ProposalManager"
	o = append(o, 0xaf, 0x50, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72)
	// map header, size 0
	o = append(o, 0x80)
	// string "VoteAggregator"
	o = append(o, 0xae, 0x56, 0x6f, 0x74, 0x65, 0x41, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x6f, 0x72)
	// map header, size 0
	o = append(o, 0x80)
	return
}

func (_ *rootRouter) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*rootRouter)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *rootRouter) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0009 string
			var zb0010 bool
			var zb0008 bool
			_ = zb0009
			_ = zb0010
			zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ProposalManager")
					return
				}
				if validate {
					err = &msgp.ErrNonCanonical{}
					return
				}
				if zb0007 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0007)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ProposalManager", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ProposalManager")
					return
				}
				if zb0008 {
					(*z).ProposalManager = proposalManager{}
				}
				for zb0007 > 0 {
					zb0007--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "ProposalManager")
						return
					}
					switch string(field) {
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "ProposalManager")
							return
						}
					}
					zb0010 = true
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0011 int
			var zb0013 string
			var zb0014 bool
			var zb0012 bool
			_ = zb0013
			_ = zb0014
			zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteAggregator")
					return
				}
				if validate {
					err = &msgp.ErrNonCanonical{}
					return
				}
				if zb0011 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0011)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "VoteAggregator", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteAggregator")
					return
				}
				if zb0012 {
					(*z).VoteAggregator = voteAggregator{}
				}
				for zb0011 > 0 {
					zb0011--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "VoteAggregator")
						return
					}
					switch string(field) {
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "VoteAggregator")
							return
						}
					}
					zb0014 = true
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0015 int
			var zb0016 bool
			zb0015, zb0016, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Children")
				return
			}
			if zb0016 {
				(*z).Children = nil
			} else if (*z).Children == nil {
				(*z).Children = make(map[round]*roundRouter, zb0015)
			}
			var zb0017 basics.Round
			_ = zb0017
			var zb0018 bool
			_ = zb0018
			for zb0015 > 0 {
				var zb0001 basics.Round
				var zb0002 *roundRouter
				zb0015--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Children")
					return
				}
				if validate && zb0018 && RoundLess(zb0001, zb0017) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0017 = zb0001
				zb0018 = true
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					zb0002 = nil
				} else {
					if zb0002 == nil {
						zb0002 = new(roundRouter)
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Children", zb0001)
						return
					}
				}
				(*z).Children[zb0001] = zb0002
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = rootRouter{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "ProposalManager":
				if validate && zb0006 && "ProposalManager" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0019 int
				var zb0021 string
				var zb0022 bool
				var zb0020 bool
				_ = zb0021
				_ = zb0022
				zb0019, zb0020, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0019, zb0020, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ProposalManager")
						return
					}
					if validate {
						err = &msgp.ErrNonCanonical{}
						return
					}
					if zb0019 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0019)
						if err != nil {
							err = msgp.WrapError(err, "ProposalManager", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "ProposalManager")
						return
					}
					if zb0020 {
						(*z).ProposalManager = proposalManager{}
					}
					for zb0019 > 0 {
						zb0019--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "ProposalManager")
							return
						}
						switch string(field) {
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "ProposalManager")
								return
							}
						}
						zb0022 = true
					}
				}
				zb0005 = "ProposalManager"
			case "VoteAggregator":
				if validate && zb0006 && "VoteAggregator" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0023 int
				var zb0025 string
				var zb0026 bool
				var zb0024 bool
				_ = zb0025
				_ = zb0026
				zb0023, zb0024, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0023, zb0024, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteAggregator")
						return
					}
					if validate {
						err = &msgp.ErrNonCanonical{}
						return
					}
					if zb0023 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0023)
						if err != nil {
							err = msgp.WrapError(err, "VoteAggregator", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "VoteAggregator")
						return
					}
					if zb0024 {
						(*z).VoteAggregator = voteAggregator{}
					}
					for zb0023 > 0 {
						zb0023--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "VoteAggregator")
							return
						}
						switch string(field) {
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "VoteAggregator")
								return
							}
						}
						zb0026 = true
					}
				}
				zb0005 = "VoteAggregator"
			case "Children":
				if validate && zb0006 && "Children" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0027 int
				var zb0028 bool
				zb0027, zb0028, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Children")
					return
				}
				if zb0028 {
					(*z).Children = nil
				} else if (*z).Children == nil {
					(*z).Children = make(map[round]*roundRouter, zb0027)
				}
				var zb0029 basics.Round
				_ = zb0029
				var zb0030 bool
				_ = zb0030
				for zb0027 > 0 {
					var zb0001 basics.Round
					var zb0002 *roundRouter
					zb0027--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Children")
						return
					}
					if validate && zb0030 && RoundLess(zb0001, zb0029) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0029 = zb0001
					zb0030 = true
					if msgp.IsNil(bts) {
						bts, err = msgp.ReadNilBytes(bts)
						if err != nil {
							return
						}
						zb0002 = nil
					} else {
						if zb0002 == nil {
							zb0002 = new(roundRouter)
						}
						bts, err = zb0002.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Children", zb0001)
							return
						}
					}
					(*z).Children[zb0001] = zb0002
				}
				zb0005 = "Children"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *rootRouter) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *rootRouter) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *rootRouter) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*rootRouter)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *rootRouter) Msgsize() (s int) {
	s = 1 + 16 + 1 + 15 + 1 + 9 + msgp.MapHeaderSize
	if (*z).Children != nil {
		for zb0001, zb0002 := range (*z).Children {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize()
			if zb0002 == nil {
				s += msgp.NilSize
			} else {
				s += zb0002.Msgsize()
			}
		}
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *rootRouter) MsgIsZero() bool {
	return (len((*z).Children) == 0)
}

// MaxSize returns a maximum valid message size for this message type
func RootRouterMaxSize() (s int) {
	s = 1 + 16 + 1 + 15 + 1 + 9
	s += msgp.MapHeaderSize
	panic("Map z.Children is unbounded")
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *roundRouter) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Children"
	o = append(o, 0x83, 0xa8, 0x43, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e)
	if (*z).Children == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendMapHeader(o, uint32(len((*z).Children)))
	}
	zb0001_keys := make([]period, 0, len((*z).Children))
	for zb0001 := range (*z).Children {
		zb0001_keys = append(zb0001_keys, zb0001)
	}
	sort.Sort(SortPeriod(zb0001_keys))
	for _, zb0001 := range zb0001_keys {
		zb0002 := (*z).Children[zb0001]
		_ = zb0002
		o = zb0001.MarshalMsg(o)
		if zb0002 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = zb0002.MarshalMsg(o)
		}
	}
	// string "ProposalStore"
	o = append(o, 0xad, 0x50, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c, 0x53, 0x74, 0x6f, 0x72, 0x65)
	o = (*z).ProposalStore.MarshalMsg(o)
	// string "VoteTrackerRound"
	o = append(o, 0xb0, 0x56, 0x6f, 0x74, 0x65, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	// map header, size 2
	// string "Freshest"
	o = append(o, 0x82, 0xa8, 0x46, 0x72, 0x65, 0x73, 0x68, 0x65, 0x73, 0x74)
	o = (*z).VoteTrackerRound.Freshest.MarshalMsg(o)
	// string "Ok"
	o = append(o, 0xa2, 0x4f, 0x6b)
	o = msgp.AppendBool(o, (*z).VoteTrackerRound.Ok)
	return
}

func (_ *roundRouter) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*roundRouter)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *roundRouter) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).ProposalStore.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ProposalStore")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0007 int
			var zb0009 string
			var zb0010 bool
			var zb0008 bool
			_ = zb0009
			_ = zb0010
			zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteTrackerRound")
					return
				}
				if validate {
					err = &msgp.ErrNonCanonical{}
					return
				}
				if zb0007 > 0 {
					zb0007--
					bts, err = (*z).VoteTrackerRound.Freshest.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "VoteTrackerRound", "struct-from-array", "Freshest")
						return
					}
				}
				if zb0007 > 0 {
					zb0007--
					(*z).VoteTrackerRound.Ok, bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "VoteTrackerRound", "struct-from-array", "Ok")
						return
					}
				}
				if zb0007 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0007)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "VoteTrackerRound", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "VoteTrackerRound")
					return
				}
				if zb0008 {
					(*z).VoteTrackerRound = voteTrackerRound{}
				}
				for zb0007 > 0 {
					zb0007--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "VoteTrackerRound")
						return
					}
					switch string(field) {
					case "Freshest":
						if validate && zb0010 && "Freshest" < zb0009 {
							err = &msgp.ErrNonCanonical{}
							return
						}
						bts, err = (*z).VoteTrackerRound.Freshest.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "VoteTrackerRound", "Freshest")
							return
						}
						zb0009 = "Freshest"
					case "Ok":
						if validate && zb0010 && "Ok" < zb0009 {
							err = &msgp.ErrNonCanonical{}
							return
						}
						(*z).VoteTrackerRound.Ok, bts, err = msgp.ReadBoolBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "VoteTrackerRound", "Ok")
							return
						}
						zb0009 = "Ok"
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "VoteTrackerRound")
							return
						}
					}
					zb0010 = true
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0011 int
			var zb0012 bool
			zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Children")
				return
			}
			if zb0012 {
				(*z).Children = nil
			} else if (*z).Children == nil {
				(*z).Children = make(map[period]*periodRouter, zb0011)
			}
			var zb0013 period
			_ = zb0013
			var zb0014 bool
			_ = zb0014
			for zb0011 > 0 {
				var zb0001 period
				var zb0002 *periodRouter
				zb0011--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Children")
					return
				}
				if validate && zb0014 && PeriodLess(zb0001, zb0013) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0013 = zb0001
				zb0014 = true
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					zb0002 = nil
				} else {
					if zb0002 == nil {
						zb0002 = new(periodRouter)
					}
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Children", zb0001)
						return
					}
				}
				(*z).Children[zb0001] = zb0002
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = roundRouter{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "ProposalStore":
				if validate && zb0006 && "ProposalStore" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).ProposalStore.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProposalStore")
					return
				}
				zb0005 = "ProposalStore"
			case "VoteTrackerRound":
				if validate && zb0006 && "VoteTrackerRound" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0015 int
				var zb0017 string
				var zb0018 bool
				var zb0016 bool
				_ = zb0017
				_ = zb0018
				zb0015, zb0016, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0015, zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "VoteTrackerRound")
						return
					}
					if validate {
						err = &msgp.ErrNonCanonical{}
						return
					}
					if zb0015 > 0 {
						zb0015--
						bts, err = (*z).VoteTrackerRound.Freshest.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "VoteTrackerRound", "struct-from-array", "Freshest")
							return
						}
					}
					if zb0015 > 0 {
						zb0015--
						(*z).VoteTrackerRound.Ok, bts, err = msgp.ReadBoolBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "VoteTrackerRound", "struct-from-array", "Ok")
							return
						}
					}
					if zb0015 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0015)
						if err != nil {
							err = msgp.WrapError(err, "VoteTrackerRound", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "VoteTrackerRound")
						return
					}
					if zb0016 {
						(*z).VoteTrackerRound = voteTrackerRound{}
					}
					for zb0015 > 0 {
						zb0015--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "VoteTrackerRound")
							return
						}
						switch string(field) {
						case "Freshest":
							if validate && zb0018 && "Freshest" < zb0017 {
								err = &msgp.ErrNonCanonical{}
								return
							}
							bts, err = (*z).VoteTrackerRound.Freshest.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "VoteTrackerRound", "Freshest")
								return
							}
							zb0017 = "Freshest"
						case "Ok":
							if validate && zb0018 && "Ok" < zb0017 {
								err = &msgp.ErrNonCanonical{}
								return
							}
							(*z).VoteTrackerRound.Ok, bts, err = msgp.ReadBoolBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "VoteTrackerRound", "Ok")
								return
							}
							zb0017 = "Ok"
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "VoteTrackerRound")
								return
							}
						}
						zb0018 = true
					}
				}
				zb0005 = "VoteTrackerRound"
			case "Children":
				if validate && zb0006 && "Children" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0019 int
				var zb0020 bool
				zb0019, zb0020, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Children")
					return
				}
				if zb0020 {
					(*z).Children = nil
				} else if (*z).Children == nil {
					(*z).Children = make(map[period]*periodRouter, zb0019)
				}
				var zb0021 period
				_ = zb0021
				var zb0022 bool
				_ = zb0022
				for zb0019 > 0 {
					var zb0001 period
					var zb0002 *periodRouter
					zb0019--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Children")
						return
					}
					if validate && zb0022 && PeriodLess(zb0001, zb0021) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0021 = zb0001
					zb0022 = true
					if msgp.IsNil(bts) {
						bts, err = msgp.ReadNilBytes(bts)
						if err != nil {
							return
						}
						zb0002 = nil
					} else {
						if zb0002 == nil {
							zb0002 = new(periodRouter)
						}
						bts, err = zb0002.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Children", zb0001)
							return
						}
					}
					(*z).Children[zb0001] = zb0002
				}
				zb0005 = "Children"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *roundRouter) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *roundRouter) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *roundRouter) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*roundRouter)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *roundRouter) Msgsize() (s int) {
	s = 1 + 14 + (*z).ProposalStore.Msgsize() + 17 + 1 + 9 + (*z).VoteTrackerRound.Freshest.Msgsize() + 3 + msgp.BoolSize + 9 + msgp.MapHeaderSize
	if (*z).Children != nil {
		for zb0001, zb0002 := range (*z).Children {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize()
			if zb0002 == nil {
				s += msgp.NilSize
			} else {
				s += zb0002.Msgsize()
			}
		}
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *roundRouter) MsgIsZero() bool {
	return ((*z).ProposalStore.MsgIsZero()) && (((*z).VoteTrackerRound.Freshest.MsgIsZero()) && ((*z).VoteTrackerRound.Ok == false)) && (len((*z).Children) == 0)
}

// MaxSize returns a maximum valid message size for this message type
func RoundRouterMaxSize() (s int) {
	s = 1 + 14 + ProposalStoreMaxSize() + 17 + 1 + 9 + ThresholdEventMaxSize() + 3 + msgp.BoolSize + 9
	s += msgp.MapHeaderSize
	panic("Map z.Children is unbounded")
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *seedInput) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "alpha"
	o = append(o, 0x82, 0xa5, 0x61, 0x6c, 0x70, 0x68, 0x61)
	o = (*z).Alpha.MarshalMsg(o)
	// string "hist"
	o = append(o, 0xa4, 0x68, 0x69, 0x73, 0x74)
	o = (*z).History.MarshalMsg(o)
	return
}

func (_ *seedInput) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*seedInput)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *seedInput) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Alpha.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Alpha")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).History.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "History")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = seedInput{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "alpha":
				if validate && zb0004 && "alpha" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Alpha.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Alpha")
					return
				}
				zb0003 = "alpha"
			case "hist":
				if validate && zb0004 && "hist" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).History.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "History")
					return
				}
				zb0003 = "hist"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *seedInput) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *seedInput) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *seedInput) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*seedInput)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *seedInput) Msgsize() (s int) {
	s = 1 + 6 + (*z).Alpha.Msgsize() + 5 + (*z).History.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *seedInput) MsgIsZero() bool {
	return ((*z).Alpha.MsgIsZero()) && ((*z).History.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func SeedInputMaxSize() (s int) {
	s = 1 + 6 + crypto.DigestMaxSize() + 5 + crypto.DigestMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *selector) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "per"
	o = append(o, 0x84, 0xa3, 0x70, 0x65, 0x72)
	o = msgp.AppendUint64(o, uint64((*z).Period))
	// string "rnd"
	o = append(o, 0xa3, 0x72, 0x6e, 0x64)
	o = (*z).Round.MarshalMsg(o)
	// string "seed"
	o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
	o = (*z).Seed.MarshalMsg(o)
	// string "step"
	o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
	o = msgp.AppendUint64(o, uint64((*z).Step))
	return
}

func (_ *selector) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*selector)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *selector) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0005)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0006)
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = selector{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "seed":
				if validate && zb0004 && "seed" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
				zb0003 = "seed"
			case "rnd":
				if validate && zb0004 && "rnd" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
				zb0003 = "rnd"
			case "per":
				if validate && zb0004 && "per" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0007 uint64
					zb0007, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0007)
				}
				zb0003 = "per"
			case "step":
				if validate && zb0004 && "step" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0008 uint64
					zb0008, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0008)
				}
				zb0003 = "step"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *selector) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *selector) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *selector) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*selector)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *selector) Msgsize() (s int) {
	s = 1 + 5 + (*z).Seed.Msgsize() + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *selector) MsgIsZero() bool {
	return ((*z).Seed.MsgIsZero()) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0)
}

// MaxSize returns a maximum valid message size for this message type
func SelectorMaxSize() (s int) {
	s = 1 + 5 + committee.SeedMaxSize() + 4 + basics.RoundMaxSize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z serializableError) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

func (_ serializableError) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(serializableError)
	if !ok {
		_, ok = (z).(*serializableError)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *serializableError) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = serializableError(zb0001)
	}
	o = bts
	return
}

func (z *serializableError) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *serializableError) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *serializableError) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*serializableError)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z serializableError) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MsgIsZero returns whether this is a zero value
func (z serializableError) MsgIsZero() bool {
	return z == ""
}

// MaxSize returns a maximum valid message size for this message type
func SerializableErrorMaxSize() (s int) {
	panic("Unable to determine max size: String type string(z) is unbounded")
	return
}

// MarshalMsg implements msgp.Marshaler
func (z step) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

func (_ step) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(step)
	if !ok {
		_, ok = (z).(*step)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *step) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = step(zb0001)
	}
	o = bts
	return
}

func (z *step) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *step) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *step) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*step)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z step) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z step) MsgIsZero() bool {
	return z == 0
}

// MaxSize returns a maximum valid message size for this message type
func StepMaxSize() (s int) {
	s = msgp.Uint64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *stepRouter) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "VoteTracker"
	o = append(o, 0x82, 0xab, 0x56, 0x6f, 0x74, 0x65, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72)
	o = (*z).VoteTracker.MarshalMsg(o)
	// string "VoteTrackerContract"
	o = append(o, 0xb3, 0x56, 0x6f, 0x74, 0x65, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x74)
	o = (*z).VoteTrackerContract.MarshalMsg(o)
	return
}

func (_ *stepRouter) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*stepRouter)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *stepRouter) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).VoteTracker.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteTracker")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).VoteTrackerContract.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "VoteTrackerContract")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = stepRouter{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "VoteTracker":
				if validate && zb0004 && "VoteTracker" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).VoteTracker.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteTracker")
					return
				}
				zb0003 = "VoteTracker"
			case "VoteTrackerContract":
				if validate && zb0004 && "VoteTrackerContract" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).VoteTrackerContract.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "VoteTrackerContract")
					return
				}
				zb0003 = "VoteTrackerContract"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *stepRouter) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *stepRouter) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *stepRouter) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*stepRouter)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *stepRouter) Msgsize() (s int) {
	s = 1 + 12 + (*z).VoteTracker.Msgsize() + 20 + (*z).VoteTrackerContract.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *stepRouter) MsgIsZero() bool {
	return ((*z).VoteTracker.MsgIsZero()) && ((*z).VoteTrackerContract.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func StepRouterMaxSize() (s int) {
	s = 1 + 12 + VoteTrackerMaxSize() + 20 + VoteTrackerContractMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *thresholdEvent) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "Bundle"
	o = append(o, 0x87, 0xa6, 0x42, 0x75, 0x6e, 0x64, 0x6c, 0x65)
	o = (*z).Bundle.MarshalMsg(o)
	// string "Period"
	o = append(o, 0xa6, 0x50, 0x65, 0x72, 0x69, 0x6f, 0x64)
	o = msgp.AppendUint64(o, uint64((*z).Period))
	// string "Proposal"
	o = append(o, 0xa8, 0x50, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c)
	o = (*z).Proposal.MarshalMsg(o)
	// string "Proto"
	o = append(o, 0xa5, 0x50, 0x72, 0x6f, 0x74, 0x6f)
	o = (*z).Proto.MarshalMsg(o)
	// string "Round"
	o = append(o, 0xa5, 0x52, 0x6f, 0x75, 0x6e, 0x64)
	o = (*z).Round.MarshalMsg(o)
	// string "Step"
	o = append(o, 0xa4, 0x53, 0x74, 0x65, 0x70)
	o = msgp.AppendUint64(o, uint64((*z).Step))
	// string "T"
	o = append(o, 0xa1, 0x54)
	o = msgp.AppendUint8(o, uint8((*z).T))
	return
}

func (_ *thresholdEvent) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*thresholdEvent)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *thresholdEvent) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0005 uint8
				zb0005, bts, err = msgp.ReadUint8Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "T")
					return
				}
				(*z).T = eventType(zb0005)
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0006 uint64
				zb0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0006)
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0007 uint64
				zb0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0007)
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Bundle.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Bundle")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Proto.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proto")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = thresholdEvent{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "T":
				if validate && zb0004 && "T" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0008 uint8
					zb0008, bts, err = msgp.ReadUint8Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "T")
						return
					}
					(*z).T = eventType(zb0008)
				}
				zb0003 = "T"
			case "Round":
				if validate && zb0004 && "Round" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
				zb0003 = "Round"
			case "Period":
				if validate && zb0004 && "Period" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0009 uint64
					zb0009, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0009)
				}
				zb0003 = "Period"
			case "Step":
				if validate && zb0004 && "Step" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0010 uint64
					zb0010, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0010)
				}
				zb0003 = "Step"
			case "Proposal":
				if validate && zb0004 && "Proposal" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
				zb0003 = "Proposal"
			case "Bundle":
				if validate && zb0004 && "Bundle" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Bundle.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bundle")
					return
				}
				zb0003 = "Bundle"
			case "Proto":
				if validate && zb0004 && "Proto" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Proto.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proto")
					return
				}
				zb0003 = "Proto"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *thresholdEvent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *thresholdEvent) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *thresholdEvent) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*thresholdEvent)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *thresholdEvent) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint8Size + 6 + (*z).Round.Msgsize() + 7 + msgp.Uint64Size + 5 + msgp.Uint64Size + 9 + (*z).Proposal.Msgsize() + 7 + (*z).Bundle.Msgsize() + 6 + (*z).Proto.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *thresholdEvent) MsgIsZero() bool {
	return ((*z).T == 0) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Proposal.MsgIsZero()) && ((*z).Bundle.MsgIsZero()) && ((*z).Proto.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func ThresholdEventMaxSize() (s int) {
	s = 1 + 2 + msgp.Uint8Size + 6 + basics.RoundMaxSize() + 7 + msgp.Uint64Size + 5 + msgp.Uint64Size + 9 + ProposalValueMaxSize() + 7 + UnauthenticatedBundleMaxSize() + 6 + protocol.ConsensusVersionMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *transmittedPayload) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0004Len := uint32(30)
	var zb0004Mask uint64 /* 38 bits */
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel == 0 {
		zb0004Len--
		zb0004Mask |= 0x80
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x100
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue == 0 {
		zb0004Len--
		zb0004Mask |= 0x200
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.GenesisID == "" {
		zb0004Len--
		zb0004Mask |= 0x400
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x2000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x4000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0 {
		zb0004Len--
		zb0004Mask |= 0x8000
	}
	if (*z).unauthenticatedProposal.OriginalPeriod == 0 {
		zb0004Len--
		zb0004Mask |= 0x10000
	}
	if (*z).unauthenticatedProposal.OriginalProposer.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x20000
	}
	if len((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) == 0 {
		zb0004Len--
		zb0004Mask |= 0x40000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Branch.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x100000
	}
	if (*z).PriorVote.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x200000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate == 0 {
		zb0004Len--
		zb0004Mask |= 0x400000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Round.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x2000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x4000000
	}
	if (*z).unauthenticatedProposal.SeedProof.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x8000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.Seed.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x10000000
	}
	if len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking) == 0 {
		zb0004Len--
		zb0004Mask |= 0x20000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter == 0 {
		zb0004Len--
		zb0004Mask |= 0x40000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp == 0 {
		zb0004Len--
		zb0004Mask |= 0x80000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x100000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x200000000
	}
	if (*z).unauthenticatedProposal.Block.Payset.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000000000
	}
	if (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove == false {
		zb0004Len--
		zb0004Mask |= 0x2000000000
	}
	// variable map header, size zb0004Len
	o = msgp.AppendMapHeader(o, zb0004Len)
	if zb0004Len != 0 {
		if (zb0004Mask & 0x80) == 0 { // if not empty
			// string "earn"
			o = append(o, 0xa4, 0x65, 0x61, 0x72, 0x6e)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel)
		}
		if (zb0004Mask & 0x100) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MarshalMsg(o)
		}
		if (zb0004Mask & 0x200) == 0 { // if not empty
			// string "frac"
			o = append(o, 0xa4, 0x66, 0x72, 0x61, 0x63)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue)
		}
		if (zb0004Mask & 0x400) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).unauthenticatedProposal.Block.BlockHeader.GenesisID)
		}
		if (zb0004Mask & 0x800) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000) == 0 { // if not empty
			// string "nextbefore"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000) == 0 { // if not empty
			// string "nextproto"
			o = append(o, 0xa9, 0x6e, 0x65, 0x78, 0x74, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MarshalMsg(o)
		}
		if (zb0004Mask & 0x4000) == 0 { // if not empty
			// string "nextswitch"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MarshalMsg(o)
		}
		if (zb0004Mask & 0x8000) == 0 { // if not empty
			// string "nextyes"
			o = append(o, 0xa7, 0x6e, 0x65, 0x78, 0x74, 0x79, 0x65, 0x73)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals)
		}
		if (zb0004Mask & 0x10000) == 0 { // if not empty
			// string "oper"
			o = append(o, 0xa4, 0x6f, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).unauthenticatedProposal.OriginalPeriod))
		}
		if (zb0004Mask & 0x20000) == 0 { // if not empty
			// string "oprop"
			o = append(o, 0xa5, 0x6f, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).unauthenticatedProposal.OriginalProposer.MarshalMsg(o)
		}
		if (zb0004Mask & 0x40000) == 0 { // if not empty
			// string "partupdrmv"
			o = append(o, 0xaa, 0x70, 0x61, 0x72, 0x74, 0x75, 0x70, 0x64, 0x72, 0x6d, 0x76)
			if (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)))
			}
			for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
				o = (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x80000) == 0 { // if not empty
			// string "prev"
			o = append(o, 0xa4, 0x70, 0x72, 0x65, 0x76)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100000) == 0 { // if not empty
			// string "proto"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MarshalMsg(o)
		}
		if (zb0004Mask & 0x200000) == 0 { // if not empty
			// string "pv"
			o = append(o, 0xa2, 0x70, 0x76)
			o = (*z).PriorVote.MarshalMsg(o)
		}
		if (zb0004Mask & 0x400000) == 0 { // if not empty
			// string "rate"
			o = append(o, 0xa4, 0x72, 0x61, 0x74, 0x65)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate)
		}
		if (zb0004Mask & 0x1000000) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.Round.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000000) == 0 { // if not empty
			// string "rwcalr"
			o = append(o, 0xa6, 0x72, 0x77, 0x63, 0x61, 0x6c, 0x72)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MarshalMsg(o)
		}
		if (zb0004Mask & 0x4000000) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MarshalMsg(o)
		}
		if (zb0004Mask & 0x8000000) == 0 { // if not empty
			// string "sdpf"
			o = append(o, 0xa4, 0x73, 0x64, 0x70, 0x66)
			o = (*z).unauthenticatedProposal.SeedProof.MarshalMsg(o)
		}
		if (zb0004Mask & 0x10000000) == 0 { // if not empty
			// string "seed"
			o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.MarshalMsg(o)
		}
		if (zb0004Mask & 0x20000000) == 0 { // if not empty
			// string "spt"
			o = append(o, 0xa3, 0x73, 0x70, 0x74)
			if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking)))
			}
			zb0001_keys := make([]protocol.StateProofType, 0, len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking))
			for zb0001 := range (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort(protocol.SortStateProofType(zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking[zb0001]
				_ = zb0002
				o = zb0001.MarshalMsg(o)
				o = zb0002.MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x40000000) == 0 { // if not empty
			// string "tc"
			o = append(o, 0xa2, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter)
		}
		if (zb0004Mask & 0x80000000) == 0 { // if not empty
			// string "ts"
			o = append(o, 0xa2, 0x74, 0x73)
			o = msgp.AppendInt64(o, (*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp)
		}
		if (zb0004Mask & 0x100000000) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MarshalMsg(o)
		}
		if (zb0004Mask & 0x200000000) == 0 { // if not empty
			// string "txn256"
			o = append(o, 0xa6, 0x74, 0x78, 0x6e, 0x32, 0x35, 0x36)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.MarshalMsg(o)
		}
		if (zb0004Mask & 0x400000000) == 0 { // if not empty
			// string "txns"
			o = append(o, 0xa4, 0x74, 0x78, 0x6e, 0x73)
			o = (*z).unauthenticatedProposal.Block.Payset.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800000000) == 0 { // if not empty
			// string "upgradedelay"
			o = append(o, 0xac, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x64, 0x65, 0x6c, 0x61, 0x79)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000000000) == 0 { // if not empty
			// string "upgradeprop"
			o = append(o, 0xab, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000000000) == 0 { // if not empty
			// string "upgradeyes"
			o = append(o, 0xaa, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x65, 0x73)
			o = msgp.AppendBool(o, (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove)
		}
	}
	return
}

func (_ *transmittedPayload) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*transmittedPayload)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *transmittedPayload) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0004 int
	var zb0006 string
	var zb0007 bool
	var zb0005 bool
	_ = zb0006
	_ = zb0007
	zb0004, zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Branch")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NativeSha512_256Commitment")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sha256Commitment")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TimeStamp")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0008 int
			zb0008, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
			if zb0008 > config.MaxGenesisIDLen {
				err = msgp.ErrOverflow(uint64(zb0008), uint64(config.MaxGenesisIDLen))
				return
			}
			(*z).unauthenticatedProposal.Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRate")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsResidue")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRecalculationRound")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CurrentProtocol")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocol")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolApprovals")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolVoteBefore")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolSwitchOn")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradePropose")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeDelay")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeApprove")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnCounter")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
				return
			}
			if zb0009 > protocol.NumStateProofTypes {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(protocol.NumStateProofTypes))
				err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
				return
			}
			if zb0010 {
				(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = nil
			} else if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking == nil {
				(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = make(map[protocol.StateProofType]bookkeeping.StateProofTrackingData, zb0009)
			}
			var zb0011 protocol.StateProofType
			_ = zb0011
			var zb0012 bool
			_ = zb0012
			for zb0009 > 0 {
				var zb0001 protocol.StateProofType
				var zb0002 bookkeeping.StateProofTrackingData
				zb0009--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
					return
				}
				if validate && zb0012 && protocol.StateProofTypeLess(zb0001, zb0011) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0011 = zb0001
				zb0012 = true
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "StateProofTracking", zb0001)
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking[zb0001] = zb0002
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0013 int
			var zb0014 bool
			zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts")
				return
			}
			if zb0013 > config.MaxProposedExpiredOnlineAccounts {
				err = msgp.ErrOverflow(uint64(zb0013), uint64(config.MaxProposedExpiredOnlineAccounts))
				err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts")
				return
			}
			if zb0014 {
				(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = nil
			} else if (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts != nil && cap((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) >= zb0013 {
				(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = ((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)[:zb0013]
			} else {
				(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = make([]basics.Address, zb0013)
			}
			for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts", zb0003)
					return
				}
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.Block.Payset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Payset")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.SeedProof.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SeedProof")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			{
				var zb0015 uint64
				zb0015, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "OriginalPeriod")
					return
				}
				(*z).unauthenticatedProposal.OriginalPeriod = period(zb0015)
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).unauthenticatedProposal.OriginalProposer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OriginalProposer")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).PriorVote.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PriorVote")
				return
			}
		}
		if zb0004 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0004)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0005 {
			(*z) = transmittedPayload{}
		}
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				if validate && zb0007 && "rnd" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
				zb0006 = "rnd"
			case "prev":
				if validate && zb0007 && "prev" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Branch.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Branch")
					return
				}
				zb0006 = "prev"
			case "seed":
				if validate && zb0007 && "seed" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
				zb0006 = "seed"
			case "txn":
				if validate && zb0007 && "txn" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NativeSha512_256Commitment")
					return
				}
				zb0006 = "txn"
			case "txn256":
				if validate && zb0007 && "txn256" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sha256Commitment")
					return
				}
				zb0006 = "txn256"
			case "ts":
				if validate && zb0007 && "ts" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimeStamp")
					return
				}
				zb0006 = "ts"
			case "gen":
				if validate && zb0007 && "gen" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0016 int
				zb0016, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
				if zb0016 > config.MaxGenesisIDLen {
					err = msgp.ErrOverflow(uint64(zb0016), uint64(config.MaxGenesisIDLen))
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
				zb0006 = "gen"
			case "gh":
				if validate && zb0007 && "gh" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
				zb0006 = "gh"
			case "fees":
				if validate && zb0007 && "fees" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
				zb0006 = "fees"
			case "rwd":
				if validate && zb0007 && "rwd" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
				zb0006 = "rwd"
			case "earn":
				if validate && zb0007 && "earn" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
				zb0006 = "earn"
			case "rate":
				if validate && zb0007 && "rate" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRate")
					return
				}
				zb0006 = "rate"
			case "frac":
				if validate && zb0007 && "frac" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsResidue")
					return
				}
				zb0006 = "frac"
			case "rwcalr":
				if validate && zb0007 && "rwcalr" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRecalculationRound")
					return
				}
				zb0006 = "rwcalr"
			case "proto":
				if validate && zb0007 && "proto" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CurrentProtocol")
					return
				}
				zb0006 = "proto"
			case "nextproto":
				if validate && zb0007 && "nextproto" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocol")
					return
				}
				zb0006 = "nextproto"
			case "nextyes":
				if validate && zb0007 && "nextyes" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolApprovals")
					return
				}
				zb0006 = "nextyes"
			case "nextbefore":
				if validate && zb0007 && "nextbefore" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolVoteBefore")
					return
				}
				zb0006 = "nextbefore"
			case "nextswitch":
				if validate && zb0007 && "nextswitch" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolSwitchOn")
					return
				}
				zb0006 = "nextswitch"
			case "upgradeprop":
				if validate && zb0007 && "upgradeprop" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradePropose")
					return
				}
				zb0006 = "upgradeprop"
			case "upgradedelay":
				if validate && zb0007 && "upgradedelay" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeDelay")
					return
				}
				zb0006 = "upgradedelay"
			case "upgradeyes":
				if validate && zb0007 && "upgradeyes" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeApprove")
					return
				}
				zb0006 = "upgradeyes"
			case "tc":
				if validate && zb0007 && "tc" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnCounter")
					return
				}
				zb0006 = "tc"
			case "spt":
				if validate && zb0007 && "spt" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0017 int
				var zb0018 bool
				zb0017, zb0018, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StateProofTracking")
					return
				}
				if zb0017 > protocol.NumStateProofTypes {
					err = msgp.ErrOverflow(uint64(zb0017), uint64(protocol.NumStateProofTypes))
					err = msgp.WrapError(err, "StateProofTracking")
					return
				}
				if zb0018 {
					(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = nil
				} else if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking == nil {
					(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking = make(map[protocol.StateProofType]bookkeeping.StateProofTrackingData, zb0017)
				}
				var zb0019 protocol.StateProofType
				_ = zb0019
				var zb0020 bool
				_ = zb0020
				for zb0017 > 0 {
					var zb0001 protocol.StateProofType
					var zb0002 bookkeeping.StateProofTrackingData
					zb0017--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "StateProofTracking")
						return
					}
					if validate && zb0020 && protocol.StateProofTypeLess(zb0001, zb0019) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0019 = zb0001
					zb0020 = true
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "StateProofTracking", zb0001)
						return
					}
					(*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking[zb0001] = zb0002
				}
				zb0006 = "spt"
			case "partupdrmv":
				if validate && zb0007 && "partupdrmv" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0021 int
				var zb0022 bool
				zb0021, zb0022, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExpiredParticipationAccounts")
					return
				}
				if zb0021 > config.MaxProposedExpiredOnlineAccounts {
					err = msgp.ErrOverflow(uint64(zb0021), uint64(config.MaxProposedExpiredOnlineAccounts))
					err = msgp.WrapError(err, "ExpiredParticipationAccounts")
					return
				}
				if zb0022 {
					(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = nil
				} else if (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts != nil && cap((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) >= zb0021 {
					(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = ((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)[:zb0021]
				} else {
					(*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = make([]basics.Address, zb0021)
				}
				for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
					bts, err = (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ExpiredParticipationAccounts", zb0003)
						return
					}
				}
				zb0006 = "partupdrmv"
			case "txns":
				if validate && zb0007 && "txns" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.Block.Payset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Payset")
					return
				}
				zb0006 = "txns"
			case "sdpf":
				if validate && zb0007 && "sdpf" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.SeedProof.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SeedProof")
					return
				}
				zb0006 = "sdpf"
			case "oper":
				if validate && zb0007 && "oper" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0023 uint64
					zb0023, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OriginalPeriod")
						return
					}
					(*z).unauthenticatedProposal.OriginalPeriod = period(zb0023)
				}
				zb0006 = "oper"
			case "oprop":
				if validate && zb0007 && "oprop" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).unauthenticatedProposal.OriginalProposer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OriginalProposer")
					return
				}
				zb0006 = "oprop"
			case "pv":
				if validate && zb0007 && "pv" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).PriorVote.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "PriorVote")
					return
				}
				zb0006 = "pv"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0007 = true
		}
	}
	o = bts
	return
}

func (z *transmittedPayload) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *transmittedPayload) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *transmittedPayload) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*transmittedPayload)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *transmittedPayload) Msgsize() (s int) {
	s = 3 + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.Round.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.Branch.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.Seed.Msgsize() + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.Msgsize() + 7 + (*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.Msgsize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len((*z).unauthenticatedProposal.Block.BlockHeader.GenesisID) + 3 + (*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.Msgsize() + 5 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.Msgsize() + 4 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.Msgsize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + (*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.Msgsize() + 6 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.Msgsize() + 10 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.Msgsize() + 8 + msgp.Uint64Size + 11 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.Msgsize() + 11 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.Msgsize() + 12 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.Msgsize() + 13 + (*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.Msgsize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 4 + msgp.MapHeaderSize
	if (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking != nil {
		for zb0001, zb0002 := range (*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	s += 11 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
		s += (*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].Msgsize()
	}
	s += 5 + (*z).unauthenticatedProposal.Block.Payset.Msgsize() + 5 + (*z).unauthenticatedProposal.SeedProof.Msgsize() + 5 + msgp.Uint64Size + 6 + (*z).unauthenticatedProposal.OriginalProposer.Msgsize() + 3 + (*z).PriorVote.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *transmittedPayload) MsgIsZero() bool {
	return ((*z).unauthenticatedProposal.Block.BlockHeader.Round.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.Branch.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.Seed.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCommitments.Sha256Commitment.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.TimeStamp == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.GenesisID == "") && ((*z).unauthenticatedProposal.Block.BlockHeader.GenesisHash.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.FeeSink.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsLevel == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRate == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsResidue == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero()) && ((*z).unauthenticatedProposal.Block.BlockHeader.UpgradeVote.UpgradeApprove == false) && ((*z).unauthenticatedProposal.Block.BlockHeader.TxnCounter == 0) && (len((*z).unauthenticatedProposal.Block.BlockHeader.StateProofTracking) == 0) && (len((*z).unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) == 0) && ((*z).unauthenticatedProposal.Block.Payset.MsgIsZero()) && ((*z).unauthenticatedProposal.SeedProof.MsgIsZero()) && ((*z).unauthenticatedProposal.OriginalPeriod == 0) && ((*z).unauthenticatedProposal.OriginalProposer.MsgIsZero()) && ((*z).PriorVote.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func TransmittedPayloadMaxSize() (s int) {
	s = 3 + 4 + basics.RoundMaxSize() + 5 + bookkeeping.BlockHashMaxSize() + 5 + committee.SeedMaxSize() + 4 + crypto.DigestMaxSize() + 7 + crypto.DigestMaxSize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + config.MaxGenesisIDLen + 3 + crypto.DigestMaxSize() + 5 + basics.AddressMaxSize() + 4 + basics.AddressMaxSize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + basics.RoundMaxSize() + 6 + protocol.ConsensusVersionMaxSize() + 10 + protocol.ConsensusVersionMaxSize() + 8 + msgp.Uint64Size + 11 + basics.RoundMaxSize() + 11 + basics.RoundMaxSize() + 12 + protocol.ConsensusVersionMaxSize() + 13 + basics.RoundMaxSize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 4
	s += msgp.MapHeaderSize
	// Adding size of map keys for z.unauthenticatedProposal.Block.BlockHeader.StateProofTracking
	s += protocol.NumStateProofTypes * (protocol.StateProofTypeMaxSize())
	// Adding size of map values for z.unauthenticatedProposal.Block.BlockHeader.StateProofTracking
	s += protocol.NumStateProofTypes * (bookkeeping.StateProofTrackingDataMaxSize())
	s += 11
	// Calculating size of slice: z.unauthenticatedProposal.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts
	s += msgp.ArrayHeaderSize + ((config.MaxProposedExpiredOnlineAccounts) * (basics.AddressMaxSize()))
	s += 5
	// Using maxtotalbytes for: z.unauthenticatedProposal.Block.Payset
	s += config.MaxTxnBytesPerBlock
	s += 5 + crypto.VrfProofMaxSize() + 5 + msgp.Uint64Size + 6 + basics.AddressMaxSize() + 3 + UnauthenticatedVoteMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *unauthenticatedBundle) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(6)
	var zb0003Mask uint8 /* 7 bits */
	if len((*z).EquivocationVotes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if (*z).Proposal.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if (*z).Step == 0 {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if len((*z).Votes) == 0 {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "eqv"
			o = append(o, 0xa3, 0x65, 0x71, 0x76)
			if (*z).EquivocationVotes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).EquivocationVotes)))
			}
			for zb0002 := range (*z).EquivocationVotes {
				o = (*z).EquivocationVotes[zb0002].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "prop"
			o = append(o, 0xa4, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).Proposal.MarshalMsg(o)
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "vote"
			o = append(o, 0xa4, 0x76, 0x6f, 0x74, 0x65)
			if (*z).Votes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Votes)))
			}
			for zb0001 := range (*z).Votes {
				o = (*z).Votes[zb0001].MarshalMsg(o)
			}
		}
	}
	return
}

func (_ *unauthenticatedBundle) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedBundle)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *unauthenticatedBundle) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0007 uint64
				zb0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0007)
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0008 uint64
				zb0008, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0008)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Proposal.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposal")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0009 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "Votes")
				return
			}
			if zb0010 {
				(*z).Votes = nil
			} else if (*z).Votes != nil && cap((*z).Votes) >= zb0009 {
				(*z).Votes = ((*z).Votes)[:zb0009]
			} else {
				(*z).Votes = make([]voteAuthenticator, zb0009)
			}
			for zb0001 := range (*z).Votes {
				bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Votes", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0011 int
			var zb0012 bool
			zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0011 > config.MaxVoteThreshold {
				err = msgp.ErrOverflow(uint64(zb0011), uint64(config.MaxVoteThreshold))
				err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes")
				return
			}
			if zb0012 {
				(*z).EquivocationVotes = nil
			} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0011 {
				(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0011]
			} else {
				(*z).EquivocationVotes = make([]equivocationVoteAuthenticator, zb0011)
			}
			for zb0002 := range (*z).EquivocationVotes {
				bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "EquivocationVotes", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = unauthenticatedBundle{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				if validate && zb0006 && "rnd" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
				zb0005 = "rnd"
			case "per":
				if validate && zb0006 && "per" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0013 uint64
					zb0013, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0013)
				}
				zb0005 = "per"
			case "step":
				if validate && zb0006 && "step" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0014 uint64
					zb0014, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0014)
				}
				zb0005 = "step"
			case "prop":
				if validate && zb0006 && "prop" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Proposal.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposal")
					return
				}
				zb0005 = "prop"
			case "vote":
				if validate && zb0006 && "vote" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0015 int
				var zb0016 bool
				zb0015, zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0015 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0015), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "Votes")
					return
				}
				if zb0016 {
					(*z).Votes = nil
				} else if (*z).Votes != nil && cap((*z).Votes) >= zb0015 {
					(*z).Votes = ((*z).Votes)[:zb0015]
				} else {
					(*z).Votes = make([]voteAuthenticator, zb0015)
				}
				for zb0001 := range (*z).Votes {
					bts, err = (*z).Votes[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Votes", zb0001)
						return
					}
				}
				zb0005 = "vote"
			case "eqv":
				if validate && zb0006 && "eqv" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0017 int
				var zb0018 bool
				zb0017, zb0018, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0017 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0017), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "EquivocationVotes")
					return
				}
				if zb0018 {
					(*z).EquivocationVotes = nil
				} else if (*z).EquivocationVotes != nil && cap((*z).EquivocationVotes) >= zb0017 {
					(*z).EquivocationVotes = ((*z).EquivocationVotes)[:zb0017]
				} else {
					(*z).EquivocationVotes = make([]equivocationVoteAuthenticator, zb0017)
				}
				for zb0002 := range (*z).EquivocationVotes {
					bts, err = (*z).EquivocationVotes[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "EquivocationVotes", zb0002)
						return
					}
				}
				zb0005 = "eqv"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *unauthenticatedBundle) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *unauthenticatedBundle) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *unauthenticatedBundle) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedBundle)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *unauthenticatedBundle) Msgsize() (s int) {
	s = 1 + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Proposal.Msgsize() + 5 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Votes {
		s += (*z).Votes[zb0001].Msgsize()
	}
	s += 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).EquivocationVotes {
		s += (*z).EquivocationVotes[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *unauthenticatedBundle) MsgIsZero() bool {
	return ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Proposal.MsgIsZero()) && (len((*z).Votes) == 0) && (len((*z).EquivocationVotes) == 0)
}

// MaxSize returns a maximum valid message size for this message type
func UnauthenticatedBundleMaxSize() (s int) {
	s = 1 + 4 + basics.RoundMaxSize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + ProposalValueMaxSize() + 5
	// Calculating size of slice: z.Votes
	s += msgp.ArrayHeaderSize + ((config.MaxVoteThreshold) * (VoteAuthenticatorMaxSize()))
	s += 4
	// Calculating size of slice: z.EquivocationVotes
	s += msgp.ArrayHeaderSize + ((config.MaxVoteThreshold) * (EquivocationVoteAuthenticatorMaxSize()))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *unauthenticatedEquivocationVote) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(7)
	var zb0003Mask uint8 /* 8 bits */
	if (*z).Cred.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Period == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	if ((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero()) {
		zb0003Len--
		zb0003Mask |= 0x8
	}
	if (*z).Round.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x10
	}
	if ((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero()) {
		zb0003Len--
		zb0003Mask |= 0x20
	}
	if (*z).Sender.MsgIsZero() {
		zb0003Len--
		zb0003Mask |= 0x40
	}
	if (*z).Step == 0 {
		zb0003Len--
		zb0003Mask |= 0x80
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "cred"
			o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
			o = (*z).Cred.MarshalMsg(o)
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "per"
			o = append(o, 0xa3, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).Period))
		}
		if (zb0003Mask & 0x8) == 0 { // if not empty
			// string "props"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x70, 0x73)
			o = msgp.AppendArrayHeader(o, 2)
			for zb0001 := range (*z).Proposals {
				o = (*z).Proposals[zb0001].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x10) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Round.MarshalMsg(o)
		}
		if (zb0003Mask & 0x20) == 0 { // if not empty
			// string "sigs"
			o = append(o, 0xa4, 0x73, 0x69, 0x67, 0x73)
			o = msgp.AppendArrayHeader(o, 2)
			for zb0002 := range (*z).Sigs {
				o = (*z).Sigs[zb0002].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x40) == 0 { // if not empty
			// string "snd"
			o = append(o, 0xa3, 0x73, 0x6e, 0x64)
			o = (*z).Sender.MarshalMsg(o)
		}
		if (zb0003Mask & 0x80) == 0 { // if not empty
			// string "step"
			o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
			o = msgp.AppendUint64(o, uint64((*z).Step))
		}
	}
	return
}

func (_ *unauthenticatedEquivocationVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedEquivocationVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *unauthenticatedEquivocationVote) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0005 string
	var zb0006 bool
	var zb0004 bool
	_ = zb0005
	_ = zb0006
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0007 uint64
				zb0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Period")
					return
				}
				(*z).Period = period(zb0007)
			}
		}
		if zb0003 > 0 {
			zb0003--
			{
				var zb0008 uint64
				zb0008, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0008)
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0009 int
			zb0009, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Proposals")
				return
			}
			if zb0009 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0009}
				return
			}
			for zb0001 := 0; zb0001 < zb0009; zb0001++ {
				bts, err = (*z).Proposals[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Proposals", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 {
			zb0003--
			var zb0010 int
			zb0010, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sigs")
				return
			}
			if zb0010 > 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zb0010}
				return
			}
			for zb0002 := 0; zb0002 < zb0010; zb0002++ {
				bts, err = (*z).Sigs[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Sigs", zb0002)
					return
				}
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = unauthenticatedEquivocationVote{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				if validate && zb0006 && "snd" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				zb0005 = "snd"
			case "rnd":
				if validate && zb0006 && "rnd" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
				zb0005 = "rnd"
			case "per":
				if validate && zb0006 && "per" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0011 uint64
					zb0011, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Period")
						return
					}
					(*z).Period = period(zb0011)
				}
				zb0005 = "per"
			case "step":
				if validate && zb0006 && "step" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0012 uint64
					zb0012, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0012)
				}
				zb0005 = "step"
			case "cred":
				if validate && zb0006 && "cred" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
				zb0005 = "cred"
			case "props":
				if validate && zb0006 && "props" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0013 int
				zb0013, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Proposals")
					return
				}
				if zb0013 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0013}
					return
				}
				for zb0001 := 0; zb0001 < zb0013; zb0001++ {
					bts, err = (*z).Proposals[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Proposals", zb0001)
						return
					}
				}
				zb0005 = "props"
			case "sigs":
				if validate && zb0006 && "sigs" < zb0005 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0014 int
				zb0014, _, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sigs")
					return
				}
				if zb0014 > 2 {
					err = msgp.ArrayError{Wanted: 2, Got: zb0014}
					return
				}
				for zb0002 := 0; zb0002 < zb0014; zb0002++ {
					bts, err = (*z).Sigs[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sigs", zb0002)
						return
					}
				}
				zb0005 = "sigs"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0006 = true
		}
	}
	o = bts
	return
}

func (z *unauthenticatedEquivocationVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *unauthenticatedEquivocationVote) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *unauthenticatedEquivocationVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedEquivocationVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *unauthenticatedEquivocationVote) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 4 + (*z).Round.Msgsize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + (*z).Cred.Msgsize() + 6 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Proposals {
		s += (*z).Proposals[zb0001].Msgsize()
	}
	s += 5 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Sigs {
		s += (*z).Sigs[zb0002].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *unauthenticatedEquivocationVote) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Round.MsgIsZero()) && ((*z).Period == 0) && ((*z).Step == 0) && ((*z).Cred.MsgIsZero()) && (((*z).Proposals[0].MsgIsZero()) && ((*z).Proposals[1].MsgIsZero())) && (((*z).Sigs[0].MsgIsZero()) && ((*z).Sigs[1].MsgIsZero()))
}

// MaxSize returns a maximum valid message size for this message type
func UnauthenticatedEquivocationVoteMaxSize() (s int) {
	s = 1 + 4 + basics.AddressMaxSize() + 4 + basics.RoundMaxSize() + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + committee.UnauthenticatedCredentialMaxSize() + 6
	// Calculating size of array: z.Proposals
	s += msgp.ArrayHeaderSize + ((2) * (ProposalValueMaxSize()))
	s += 5
	// Calculating size of array: z.Sigs
	s += msgp.ArrayHeaderSize + ((2) * (crypto.OneTimeSignatureMaxSize()))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *unauthenticatedProposal) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0004Len := uint32(29)
	var zb0004Mask uint64 /* 36 bits */
	if (*z).Block.BlockHeader.RewardsState.RewardsLevel == 0 {
		zb0004Len--
		zb0004Mask |= 0x40
	}
	if (*z).Block.BlockHeader.RewardsState.FeeSink.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsResidue == 0 {
		zb0004Len--
		zb0004Mask |= 0x100
	}
	if (*z).Block.BlockHeader.GenesisID == "" {
		zb0004Len--
		zb0004Mask |= 0x200
	}
	if (*z).Block.BlockHeader.GenesisHash.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400
	}
	if (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800
	}
	if (*z).Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000
	}
	if (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x2000
	}
	if (*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0 {
		zb0004Len--
		zb0004Mask |= 0x4000
	}
	if (*z).OriginalPeriod == 0 {
		zb0004Len--
		zb0004Mask |= 0x8000
	}
	if (*z).OriginalProposer.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x10000
	}
	if len((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) == 0 {
		zb0004Len--
		zb0004Mask |= 0x20000
	}
	if (*z).Block.BlockHeader.Branch.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x40000
	}
	if (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80000
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsRate == 0 {
		zb0004Len--
		zb0004Mask |= 0x100000
	}
	if (*z).Block.BlockHeader.Round.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400000
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x800000
	}
	if (*z).Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x1000000
	}
	if (*z).SeedProof.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x2000000
	}
	if (*z).Block.BlockHeader.Seed.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x4000000
	}
	if len((*z).Block.BlockHeader.StateProofTracking) == 0 {
		zb0004Len--
		zb0004Mask |= 0x8000000
	}
	if (*z).Block.BlockHeader.TxnCounter == 0 {
		zb0004Len--
		zb0004Mask |= 0x10000000
	}
	if (*z).Block.BlockHeader.TimeStamp == 0 {
		zb0004Len--
		zb0004Mask |= 0x20000000
	}
	if (*z).Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x40000000
	}
	if (*z).Block.BlockHeader.TxnCommitments.Sha256Commitment.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x80000000
	}
	if (*z).Block.Payset.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x100000000
	}
	if (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x200000000
	}
	if (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero() {
		zb0004Len--
		zb0004Mask |= 0x400000000
	}
	if (*z).Block.BlockHeader.UpgradeVote.UpgradeApprove == false {
		zb0004Len--
		zb0004Mask |= 0x800000000
	}
	// variable map header, size zb0004Len
	o = msgp.AppendMapHeader(o, zb0004Len)
	if zb0004Len != 0 {
		if (zb0004Mask & 0x40) == 0 { // if not empty
			// string "earn"
			o = append(o, 0xa4, 0x65, 0x61, 0x72, 0x6e)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.RewardsState.RewardsLevel)
		}
		if (zb0004Mask & 0x80) == 0 { // if not empty
			// string "fees"
			o = append(o, 0xa4, 0x66, 0x65, 0x65, 0x73)
			o = (*z).Block.BlockHeader.RewardsState.FeeSink.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100) == 0 { // if not empty
			// string "frac"
			o = append(o, 0xa4, 0x66, 0x72, 0x61, 0x63)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.RewardsState.RewardsResidue)
		}
		if (zb0004Mask & 0x200) == 0 { // if not empty
			// string "gen"
			o = append(o, 0xa3, 0x67, 0x65, 0x6e)
			o = msgp.AppendString(o, (*z).Block.BlockHeader.GenesisID)
		}
		if (zb0004Mask & 0x400) == 0 { // if not empty
			// string "gh"
			o = append(o, 0xa2, 0x67, 0x68)
			o = (*z).Block.BlockHeader.GenesisHash.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800) == 0 { // if not empty
			// string "nextbefore"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
			o = (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000) == 0 { // if not empty
			// string "nextproto"
			o = append(o, 0xa9, 0x6e, 0x65, 0x78, 0x74, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).Block.BlockHeader.UpgradeState.NextProtocol.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000) == 0 { // if not empty
			// string "nextswitch"
			o = append(o, 0xaa, 0x6e, 0x65, 0x78, 0x74, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68)
			o = (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MarshalMsg(o)
		}
		if (zb0004Mask & 0x4000) == 0 { // if not empty
			// string "nextyes"
			o = append(o, 0xa7, 0x6e, 0x65, 0x78, 0x74, 0x79, 0x65, 0x73)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals)
		}
		if (zb0004Mask & 0x8000) == 0 { // if not empty
			// string "oper"
			o = append(o, 0xa4, 0x6f, 0x70, 0x65, 0x72)
			o = msgp.AppendUint64(o, uint64((*z).OriginalPeriod))
		}
		if (zb0004Mask & 0x10000) == 0 { // if not empty
			// string "oprop"
			o = append(o, 0xa5, 0x6f, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).OriginalProposer.MarshalMsg(o)
		}
		if (zb0004Mask & 0x20000) == 0 { // if not empty
			// string "partupdrmv"
			o = append(o, 0xaa, 0x70, 0x61, 0x72, 0x74, 0x75, 0x70, 0x64, 0x72, 0x6d, 0x76)
			if (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)))
			}
			for zb0003 := range (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
				o = (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x40000) == 0 { // if not empty
			// string "prev"
			o = append(o, 0xa4, 0x70, 0x72, 0x65, 0x76)
			o = (*z).Block.BlockHeader.Branch.MarshalMsg(o)
		}
		if (zb0004Mask & 0x80000) == 0 { // if not empty
			// string "proto"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x74, 0x6f)
			o = (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100000) == 0 { // if not empty
			// string "rate"
			o = append(o, 0xa4, 0x72, 0x61, 0x74, 0x65)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.RewardsState.RewardsRate)
		}
		if (zb0004Mask & 0x400000) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = (*z).Block.BlockHeader.Round.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800000) == 0 { // if not empty
			// string "rwcalr"
			o = append(o, 0xa6, 0x72, 0x77, 0x63, 0x61, 0x6c, 0x72)
			o = (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.MarshalMsg(o)
		}
		if (zb0004Mask & 0x1000000) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o = (*z).Block.BlockHeader.RewardsState.RewardsPool.MarshalMsg(o)
		}
		if (zb0004Mask & 0x2000000) == 0 { // if not empty
			// string "sdpf"
			o = append(o, 0xa4, 0x73, 0x64, 0x70, 0x66)
			o = (*z).SeedProof.MarshalMsg(o)
		}
		if (zb0004Mask & 0x4000000) == 0 { // if not empty
			// string "seed"
			o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
			o = (*z).Block.BlockHeader.Seed.MarshalMsg(o)
		}
		if (zb0004Mask & 0x8000000) == 0 { // if not empty
			// string "spt"
			o = append(o, 0xa3, 0x73, 0x70, 0x74)
			if (*z).Block.BlockHeader.StateProofTracking == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendMapHeader(o, uint32(len((*z).Block.BlockHeader.StateProofTracking)))
			}
			zb0001_keys := make([]protocol.StateProofType, 0, len((*z).Block.BlockHeader.StateProofTracking))
			for zb0001 := range (*z).Block.BlockHeader.StateProofTracking {
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			sort.Sort(protocol.SortStateProofType(zb0001_keys))
			for _, zb0001 := range zb0001_keys {
				zb0002 := (*z).Block.BlockHeader.StateProofTracking[zb0001]
				_ = zb0002
				o = zb0001.MarshalMsg(o)
				o = zb0002.MarshalMsg(o)
			}
		}
		if (zb0004Mask & 0x10000000) == 0 { // if not empty
			// string "tc"
			o = append(o, 0xa2, 0x74, 0x63)
			o = msgp.AppendUint64(o, (*z).Block.BlockHeader.TxnCounter)
		}
		if (zb0004Mask & 0x20000000) == 0 { // if not empty
			// string "ts"
			o = append(o, 0xa2, 0x74, 0x73)
			o = msgp.AppendInt64(o, (*z).Block.BlockHeader.TimeStamp)
		}
		if (zb0004Mask & 0x40000000) == 0 { // if not empty
			// string "txn"
			o = append(o, 0xa3, 0x74, 0x78, 0x6e)
			o = (*z).Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MarshalMsg(o)
		}
		if (zb0004Mask & 0x80000000) == 0 { // if not empty
			// string "txn256"
			o = append(o, 0xa6, 0x74, 0x78, 0x6e, 0x32, 0x35, 0x36)
			o = (*z).Block.BlockHeader.TxnCommitments.Sha256Commitment.MarshalMsg(o)
		}
		if (zb0004Mask & 0x100000000) == 0 { // if not empty
			// string "txns"
			o = append(o, 0xa4, 0x74, 0x78, 0x6e, 0x73)
			o = (*z).Block.Payset.MarshalMsg(o)
		}
		if (zb0004Mask & 0x200000000) == 0 { // if not empty
			// string "upgradedelay"
			o = append(o, 0xac, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x64, 0x65, 0x6c, 0x61, 0x79)
			o = (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.MarshalMsg(o)
		}
		if (zb0004Mask & 0x400000000) == 0 { // if not empty
			// string "upgradeprop"
			o = append(o, 0xab, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x70)
			o = (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.MarshalMsg(o)
		}
		if (zb0004Mask & 0x800000000) == 0 { // if not empty
			// string "upgradeyes"
			o = append(o, 0xaa, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x79, 0x65, 0x73)
			o = msgp.AppendBool(o, (*z).Block.BlockHeader.UpgradeVote.UpgradeApprove)
		}
	}
	return
}

func (_ *unauthenticatedProposal) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedProposal)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *unauthenticatedProposal) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0004 int
	var zb0006 string
	var zb0007 bool
	var zb0005 bool
	_ = zb0006
	_ = zb0007
	zb0004, zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.Round.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.Branch.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Branch")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.Seed.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Seed")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NativeSha512_256Commitment")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.TxnCommitments.Sha256Commitment.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sha256Commitment")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TimeStamp")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0008 int
			zb0008, err = msgp.ReadBytesBytesHeader(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
			if zb0008 > config.MaxGenesisIDLen {
				err = msgp.ErrOverflow(uint64(zb0008), uint64(config.MaxGenesisIDLen))
				return
			}
			(*z).Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisID")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "GenesisHash")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FeeSink")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsPool")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRate")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsResidue")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsRecalculationRound")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "CurrentProtocol")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocol")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolApprovals")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolVoteBefore")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NextProtocolSwitchOn")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradePropose")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeDelay")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "UpgradeApprove")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			(*z).Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "TxnCounter")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0009 int
			var zb0010 bool
			zb0009, zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
				return
			}
			if zb0009 > protocol.NumStateProofTypes {
				err = msgp.ErrOverflow(uint64(zb0009), uint64(protocol.NumStateProofTypes))
				err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
				return
			}
			if zb0010 {
				(*z).Block.BlockHeader.StateProofTracking = nil
			} else if (*z).Block.BlockHeader.StateProofTracking == nil {
				(*z).Block.BlockHeader.StateProofTracking = make(map[protocol.StateProofType]bookkeeping.StateProofTrackingData, zb0009)
			}
			var zb0011 protocol.StateProofType
			_ = zb0011
			var zb0012 bool
			_ = zb0012
			for zb0009 > 0 {
				var zb0001 protocol.StateProofType
				var zb0002 bookkeeping.StateProofTrackingData
				zb0009--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "StateProofTracking")
					return
				}
				if validate && zb0012 && protocol.StateProofTypeLess(zb0001, zb0011) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0011 = zb0001
				zb0012 = true
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "StateProofTracking", zb0001)
					return
				}
				(*z).Block.BlockHeader.StateProofTracking[zb0001] = zb0002
			}
		}
		if zb0004 > 0 {
			zb0004--
			var zb0013 int
			var zb0014 bool
			zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts")
				return
			}
			if zb0013 > config.MaxProposedExpiredOnlineAccounts {
				err = msgp.ErrOverflow(uint64(zb0013), uint64(config.MaxProposedExpiredOnlineAccounts))
				err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts")
				return
			}
			if zb0014 {
				(*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = nil
			} else if (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts != nil && cap((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) >= zb0013 {
				(*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = ((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)[:zb0013]
			} else {
				(*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = make([]basics.Address, zb0013)
			}
			for zb0003 := range (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
				bts, err = (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "ExpiredParticipationAccounts", zb0003)
					return
				}
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).Block.Payset.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Payset")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).SeedProof.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SeedProof")
				return
			}
		}
		if zb0004 > 0 {
			zb0004--
			{
				var zb0015 uint64
				zb0015, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "OriginalPeriod")
					return
				}
				(*z).OriginalPeriod = period(zb0015)
			}
		}
		if zb0004 > 0 {
			zb0004--
			bts, err = (*z).OriginalProposer.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OriginalProposer")
				return
			}
		}
		if zb0004 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0004)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0005 {
			(*z) = unauthenticatedProposal{}
		}
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				if validate && zb0007 && "rnd" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.Round.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
				zb0006 = "rnd"
			case "prev":
				if validate && zb0007 && "prev" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.Branch.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Branch")
					return
				}
				zb0006 = "prev"
			case "seed":
				if validate && zb0007 && "seed" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.Seed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seed")
					return
				}
				zb0006 = "seed"
			case "txn":
				if validate && zb0007 && "txn" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NativeSha512_256Commitment")
					return
				}
				zb0006 = "txn"
			case "txn256":
				if validate && zb0007 && "txn256" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.TxnCommitments.Sha256Commitment.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sha256Commitment")
					return
				}
				zb0006 = "txn256"
			case "ts":
				if validate && zb0007 && "ts" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Block.BlockHeader.TimeStamp, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimeStamp")
					return
				}
				zb0006 = "ts"
			case "gen":
				if validate && zb0007 && "gen" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0016 int
				zb0016, err = msgp.ReadBytesBytesHeader(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
				if zb0016 > config.MaxGenesisIDLen {
					err = msgp.ErrOverflow(uint64(zb0016), uint64(config.MaxGenesisIDLen))
					return
				}
				(*z).Block.BlockHeader.GenesisID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisID")
					return
				}
				zb0006 = "gen"
			case "gh":
				if validate && zb0007 && "gh" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.GenesisHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenesisHash")
					return
				}
				zb0006 = "gh"
			case "fees":
				if validate && zb0007 && "fees" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.RewardsState.FeeSink.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "FeeSink")
					return
				}
				zb0006 = "fees"
			case "rwd":
				if validate && zb0007 && "rwd" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.RewardsState.RewardsPool.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsPool")
					return
				}
				zb0006 = "rwd"
			case "earn":
				if validate && zb0007 && "earn" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Block.BlockHeader.RewardsState.RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
				zb0006 = "earn"
			case "rate":
				if validate && zb0007 && "rate" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Block.BlockHeader.RewardsState.RewardsRate, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRate")
					return
				}
				zb0006 = "rate"
			case "frac":
				if validate && zb0007 && "frac" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Block.BlockHeader.RewardsState.RewardsResidue, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsResidue")
					return
				}
				zb0006 = "frac"
			case "rwcalr":
				if validate && zb0007 && "rwcalr" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsRecalculationRound")
					return
				}
				zb0006 = "rwcalr"
			case "proto":
				if validate && zb0007 && "proto" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CurrentProtocol")
					return
				}
				zb0006 = "proto"
			case "nextproto":
				if validate && zb0007 && "nextproto" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocol.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocol")
					return
				}
				zb0006 = "nextproto"
			case "nextyes":
				if validate && zb0007 && "nextyes" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolApprovals")
					return
				}
				zb0006 = "nextyes"
			case "nextbefore":
				if validate && zb0007 && "nextbefore" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolVoteBefore")
					return
				}
				zb0006 = "nextbefore"
			case "nextswitch":
				if validate && zb0007 && "nextswitch" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextProtocolSwitchOn")
					return
				}
				zb0006 = "nextswitch"
			case "upgradeprop":
				if validate && zb0007 && "upgradeprop" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradePropose")
					return
				}
				zb0006 = "upgradeprop"
			case "upgradedelay":
				if validate && zb0007 && "upgradedelay" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeDelay")
					return
				}
				zb0006 = "upgradedelay"
			case "upgradeyes":
				if validate && zb0007 && "upgradeyes" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Block.BlockHeader.UpgradeVote.UpgradeApprove, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UpgradeApprove")
					return
				}
				zb0006 = "upgradeyes"
			case "tc":
				if validate && zb0007 && "tc" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Block.BlockHeader.TxnCounter, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TxnCounter")
					return
				}
				zb0006 = "tc"
			case "spt":
				if validate && zb0007 && "spt" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0017 int
				var zb0018 bool
				zb0017, zb0018, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StateProofTracking")
					return
				}
				if zb0017 > protocol.NumStateProofTypes {
					err = msgp.ErrOverflow(uint64(zb0017), uint64(protocol.NumStateProofTypes))
					err = msgp.WrapError(err, "StateProofTracking")
					return
				}
				if zb0018 {
					(*z).Block.BlockHeader.StateProofTracking = nil
				} else if (*z).Block.BlockHeader.StateProofTracking == nil {
					(*z).Block.BlockHeader.StateProofTracking = make(map[protocol.StateProofType]bookkeeping.StateProofTrackingData, zb0017)
				}
				var zb0019 protocol.StateProofType
				_ = zb0019
				var zb0020 bool
				_ = zb0020
				for zb0017 > 0 {
					var zb0001 protocol.StateProofType
					var zb0002 bookkeeping.StateProofTrackingData
					zb0017--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "StateProofTracking")
						return
					}
					if validate && zb0020 && protocol.StateProofTypeLess(zb0001, zb0019) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0019 = zb0001
					zb0020 = true
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "StateProofTracking", zb0001)
						return
					}
					(*z).Block.BlockHeader.StateProofTracking[zb0001] = zb0002
				}
				zb0006 = "spt"
			case "partupdrmv":
				if validate && zb0007 && "partupdrmv" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0021 int
				var zb0022 bool
				zb0021, zb0022, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExpiredParticipationAccounts")
					return
				}
				if zb0021 > config.MaxProposedExpiredOnlineAccounts {
					err = msgp.ErrOverflow(uint64(zb0021), uint64(config.MaxProposedExpiredOnlineAccounts))
					err = msgp.WrapError(err, "ExpiredParticipationAccounts")
					return
				}
				if zb0022 {
					(*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = nil
				} else if (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts != nil && cap((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) >= zb0021 {
					(*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = ((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts)[:zb0021]
				} else {
					(*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts = make([]basics.Address, zb0021)
				}
				for zb0003 := range (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
					bts, err = (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ExpiredParticipationAccounts", zb0003)
						return
					}
				}
				zb0006 = "partupdrmv"
			case "txns":
				if validate && zb0007 && "txns" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Block.Payset.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Payset")
					return
				}
				zb0006 = "txns"
			case "sdpf":
				if validate && zb0007 && "sdpf" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).SeedProof.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SeedProof")
					return
				}
				zb0006 = "sdpf"
			case "oper":
				if validate && zb0007 && "oper" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0023 uint64
					zb0023, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OriginalPeriod")
						return
					}
					(*z).OriginalPeriod = period(zb0023)
				}
				zb0006 = "oper"
			case "oprop":
				if validate && zb0007 && "oprop" < zb0006 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).OriginalProposer.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OriginalProposer")
					return
				}
				zb0006 = "oprop"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0007 = true
		}
	}
	o = bts
	return
}

func (z *unauthenticatedProposal) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *unauthenticatedProposal) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *unauthenticatedProposal) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedProposal)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *unauthenticatedProposal) Msgsize() (s int) {
	s = 3 + 4 + (*z).Block.BlockHeader.Round.Msgsize() + 5 + (*z).Block.BlockHeader.Branch.Msgsize() + 5 + (*z).Block.BlockHeader.Seed.Msgsize() + 4 + (*z).Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.Msgsize() + 7 + (*z).Block.BlockHeader.TxnCommitments.Sha256Commitment.Msgsize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + len((*z).Block.BlockHeader.GenesisID) + 3 + (*z).Block.BlockHeader.GenesisHash.Msgsize() + 5 + (*z).Block.BlockHeader.RewardsState.FeeSink.Msgsize() + 4 + (*z).Block.BlockHeader.RewardsState.RewardsPool.Msgsize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + (*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.Msgsize() + 6 + (*z).Block.BlockHeader.UpgradeState.CurrentProtocol.Msgsize() + 10 + (*z).Block.BlockHeader.UpgradeState.NextProtocol.Msgsize() + 8 + msgp.Uint64Size + 11 + (*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.Msgsize() + 11 + (*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.Msgsize() + 12 + (*z).Block.BlockHeader.UpgradeVote.UpgradePropose.Msgsize() + 13 + (*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.Msgsize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 4 + msgp.MapHeaderSize
	if (*z).Block.BlockHeader.StateProofTracking != nil {
		for zb0001, zb0002 := range (*z).Block.BlockHeader.StateProofTracking {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	s += 11 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts {
		s += (*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts[zb0003].Msgsize()
	}
	s += 5 + (*z).Block.Payset.Msgsize() + 5 + (*z).SeedProof.Msgsize() + 5 + msgp.Uint64Size + 6 + (*z).OriginalProposer.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *unauthenticatedProposal) MsgIsZero() bool {
	return ((*z).Block.BlockHeader.Round.MsgIsZero()) && ((*z).Block.BlockHeader.Branch.MsgIsZero()) && ((*z).Block.BlockHeader.Seed.MsgIsZero()) && ((*z).Block.BlockHeader.TxnCommitments.NativeSha512_256Commitment.MsgIsZero()) && ((*z).Block.BlockHeader.TxnCommitments.Sha256Commitment.MsgIsZero()) && ((*z).Block.BlockHeader.TimeStamp == 0) && ((*z).Block.BlockHeader.GenesisID == "") && ((*z).Block.BlockHeader.GenesisHash.MsgIsZero()) && ((*z).Block.BlockHeader.RewardsState.FeeSink.MsgIsZero()) && ((*z).Block.BlockHeader.RewardsState.RewardsPool.MsgIsZero()) && ((*z).Block.BlockHeader.RewardsState.RewardsLevel == 0) && ((*z).Block.BlockHeader.RewardsState.RewardsRate == 0) && ((*z).Block.BlockHeader.RewardsState.RewardsResidue == 0) && ((*z).Block.BlockHeader.RewardsState.RewardsRecalculationRound.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeState.CurrentProtocol.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeState.NextProtocol.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeState.NextProtocolApprovals == 0) && ((*z).Block.BlockHeader.UpgradeState.NextProtocolVoteBefore.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeState.NextProtocolSwitchOn.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeVote.UpgradePropose.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeVote.UpgradeDelay.MsgIsZero()) && ((*z).Block.BlockHeader.UpgradeVote.UpgradeApprove == false) && ((*z).Block.BlockHeader.TxnCounter == 0) && (len((*z).Block.BlockHeader.StateProofTracking) == 0) && (len((*z).Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts) == 0) && ((*z).Block.Payset.MsgIsZero()) && ((*z).SeedProof.MsgIsZero()) && ((*z).OriginalPeriod == 0) && ((*z).OriginalProposer.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func UnauthenticatedProposalMaxSize() (s int) {
	s = 3 + 4 + basics.RoundMaxSize() + 5 + bookkeeping.BlockHashMaxSize() + 5 + committee.SeedMaxSize() + 4 + crypto.DigestMaxSize() + 7 + crypto.DigestMaxSize() + 3 + msgp.Int64Size + 4 + msgp.StringPrefixSize + config.MaxGenesisIDLen + 3 + crypto.DigestMaxSize() + 5 + basics.AddressMaxSize() + 4 + basics.AddressMaxSize() + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 7 + basics.RoundMaxSize() + 6 + protocol.ConsensusVersionMaxSize() + 10 + protocol.ConsensusVersionMaxSize() + 8 + msgp.Uint64Size + 11 + basics.RoundMaxSize() + 11 + basics.RoundMaxSize() + 12 + protocol.ConsensusVersionMaxSize() + 13 + basics.RoundMaxSize() + 11 + msgp.BoolSize + 3 + msgp.Uint64Size + 4
	s += msgp.MapHeaderSize
	// Adding size of map keys for z.Block.BlockHeader.StateProofTracking
	s += protocol.NumStateProofTypes * (protocol.StateProofTypeMaxSize())
	// Adding size of map values for z.Block.BlockHeader.StateProofTracking
	s += protocol.NumStateProofTypes * (bookkeeping.StateProofTrackingDataMaxSize())
	s += 11
	// Calculating size of slice: z.Block.BlockHeader.ParticipationUpdates.ExpiredParticipationAccounts
	s += msgp.ArrayHeaderSize + ((config.MaxProposedExpiredOnlineAccounts) * (basics.AddressMaxSize()))
	s += 5
	// Using maxtotalbytes for: z.Block.Payset
	s += config.MaxTxnBytesPerBlock
	s += 5 + crypto.VrfProofMaxSize() + 5 + msgp.Uint64Size + 6 + basics.AddressMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *unauthenticatedVote) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).Cred.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).R.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "cred"
			o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
			o = (*z).Cred.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = (*z).R.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o = (*z).Sig.MarshalMsg(o)
		}
	}
	return
}

func (_ *unauthenticatedVote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedVote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *unauthenticatedVote) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).R.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "R")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = unauthenticatedVote{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "r":
				if validate && zb0004 && "r" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).R.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "R")
					return
				}
				zb0003 = "r"
			case "cred":
				if validate && zb0004 && "cred" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
				zb0003 = "cred"
			case "sig":
				if validate && zb0004 && "sig" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
				zb0003 = "sig"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *unauthenticatedVote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *unauthenticatedVote) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *unauthenticatedVote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*unauthenticatedVote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *unauthenticatedVote) Msgsize() (s int) {
	s = 1 + 2 + (*z).R.Msgsize() + 5 + (*z).Cred.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *unauthenticatedVote) MsgIsZero() bool {
	return ((*z).R.MsgIsZero()) && ((*z).Cred.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func UnauthenticatedVoteMaxSize() (s int) {
	s = 1 + 2 + RawVoteMaxSize() + 5 + committee.UnauthenticatedCredentialMaxSize() + 4 + crypto.OneTimeSignatureMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *vote) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).Cred.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).R.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "cred"
			o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
			o = (*z).Cred.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "r"
			o = append(o, 0xa1, 0x72)
			o = (*z).R.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o = (*z).Sig.MarshalMsg(o)
		}
	}
	return
}

func (_ *vote) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*vote)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *vote) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).R.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "R")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = vote{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "r":
				if validate && zb0004 && "r" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).R.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "R")
					return
				}
				zb0003 = "r"
			case "cred":
				if validate && zb0004 && "cred" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
				zb0003 = "cred"
			case "sig":
				if validate && zb0004 && "sig" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
				zb0003 = "sig"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *vote) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *vote) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *vote) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*vote)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *vote) Msgsize() (s int) {
	s = 1 + 2 + (*z).R.Msgsize() + 5 + (*z).Cred.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *vote) MsgIsZero() bool {
	return ((*z).R.MsgIsZero()) && ((*z).Cred.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func VoteMaxSize() (s int) {
	s = 1 + 2 + RawVoteMaxSize() + 5 + committee.CredentialMaxSize() + 4 + crypto.OneTimeSignatureMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *voteAggregator) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

func (_ *voteAggregator) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteAggregator)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *voteAggregator) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = voteAggregator{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *voteAggregator) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *voteAggregator) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *voteAggregator) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteAggregator)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *voteAggregator) Msgsize() (s int) {
	s = 1
	return
}

// MsgIsZero returns whether this is a zero value
func (z *voteAggregator) MsgIsZero() bool {
	return true
}

// MaxSize returns a maximum valid message size for this message type
func VoteAggregatorMaxSize() (s int) {
	s = 1
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *voteAuthenticator) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 4 bits */
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		// string "cred"
		o = append(o, 0xa4, 0x63, 0x72, 0x65, 0x64)
		o = (*z).Cred.MarshalMsg(o)
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o = (*z).Sig.MarshalMsg(o)
		}
		// string "snd"
		o = append(o, 0xa3, 0x73, 0x6e, 0x64)
		o = (*z).Sender.MarshalMsg(o)
	}
	return
}

func (_ *voteAuthenticator) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteAuthenticator)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *voteAuthenticator) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sender.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sender")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Cred.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cred")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = voteAuthenticator{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "snd":
				if validate && zb0004 && "snd" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Sender.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sender")
					return
				}
				zb0003 = "snd"
			case "cred":
				if validate && zb0004 && "cred" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Cred.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cred")
					return
				}
				zb0003 = "cred"
			case "sig":
				if validate && zb0004 && "sig" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
				zb0003 = "sig"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *voteAuthenticator) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *voteAuthenticator) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *voteAuthenticator) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteAuthenticator)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *voteAuthenticator) Msgsize() (s int) {
	s = 1 + 4 + (*z).Sender.Msgsize() + 5 + (*z).Cred.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *voteAuthenticator) MsgIsZero() bool {
	return ((*z).Sender.MsgIsZero()) && ((*z).Cred.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}

// MaxSize returns a maximum valid message size for this message type
func VoteAuthenticatorMaxSize() (s int) {
	s = 1 + 4 + basics.AddressMaxSize() + 5 + committee.UnauthenticatedCredentialMaxSize() + 4 + crypto.OneTimeSignatureMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *voteTracker) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Counts"
	o = append(o, 0x84, 0xa6, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x73)
	if (*z).Counts == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendMapHeader(o, uint32(len((*z).Counts)))
	}
	zb0003_keys := make([]proposalValue, 0, len((*z).Counts))
	for zb0003 := range (*z).Counts {
		zb0003_keys = append(zb0003_keys, zb0003)
	}
	sort.Sort(SortProposalValue(zb0003_keys))
	for _, zb0003 := range zb0003_keys {
		zb0004 := (*z).Counts[zb0003]
		_ = zb0004
		o = zb0003.MarshalMsg(o)
		o = zb0004.MarshalMsg(o)
	}
	// string "Equivocators"
	o = append(o, 0xac, 0x45, 0x71, 0x75, 0x69, 0x76, 0x6f, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x73)
	if (*z).Equivocators == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendMapHeader(o, uint32(len((*z).Equivocators)))
	}
	zb0005_keys := make([]basics.Address, 0, len((*z).Equivocators))
	for zb0005 := range (*z).Equivocators {
		zb0005_keys = append(zb0005_keys, zb0005)
	}
	sort.Sort(SortAddress(zb0005_keys))
	for _, zb0005 := range zb0005_keys {
		zb0006 := (*z).Equivocators[zb0005]
		_ = zb0006
		o = zb0005.MarshalMsg(o)
		o = zb0006.MarshalMsg(o)
	}
	// string "EquivocatorsCount"
	o = append(o, 0xb1, 0x45, 0x71, 0x75, 0x69, 0x76, 0x6f, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, (*z).EquivocatorsCount)
	// string "Voters"
	o = append(o, 0xa6, 0x56, 0x6f, 0x74, 0x65, 0x72, 0x73)
	if (*z).Voters == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendMapHeader(o, uint32(len((*z).Voters)))
	}
	zb0001_keys := make([]basics.Address, 0, len((*z).Voters))
	for zb0001 := range (*z).Voters {
		zb0001_keys = append(zb0001_keys, zb0001)
	}
	sort.Sort(SortAddress(zb0001_keys))
	for _, zb0001 := range zb0001_keys {
		zb0002 := (*z).Voters[zb0001]
		_ = zb0002
		o = zb0001.MarshalMsg(o)
		o = zb0002.MarshalMsg(o)
	}
	return
}

func (_ *voteTracker) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteTracker)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *voteTracker) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0007 int
	var zb0009 string
	var zb0010 bool
	var zb0008 bool
	_ = zb0009
	_ = zb0010
	zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0007 > 0 {
			zb0007--
			var zb0011 int
			var zb0012 bool
			zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Voters")
				return
			}
			if zb0012 {
				(*z).Voters = nil
			} else if (*z).Voters == nil {
				(*z).Voters = make(map[basics.Address]vote, zb0011)
			}
			var zb0013 basics.Address
			_ = zb0013
			var zb0014 bool
			_ = zb0014
			for zb0011 > 0 {
				var zb0001 basics.Address
				var zb0002 vote
				zb0011--
				bts, err = zb0001.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Voters")
					return
				}
				if validate && zb0014 && basics.AddressLess(zb0001, zb0013) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0013 = zb0001
				zb0014 = true
				bts, err = zb0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Voters", zb0001)
					return
				}
				(*z).Voters[zb0001] = zb0002
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0015 int
			var zb0016 bool
			zb0015, zb0016, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Counts")
				return
			}
			if zb0016 {
				(*z).Counts = nil
			} else if (*z).Counts == nil {
				(*z).Counts = make(map[proposalValue]proposalVoteCounter, zb0015)
			}
			var zb0017 proposalValue
			_ = zb0017
			var zb0018 bool
			_ = zb0018
			for zb0015 > 0 {
				var zb0003 proposalValue
				var zb0004 proposalVoteCounter
				zb0015--
				bts, err = zb0003.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Counts")
					return
				}
				if validate && zb0018 && ProposalValueLess(zb0003, zb0017) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0017 = zb0003
				zb0018 = true
				bts, err = zb0004.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Counts", zb0003)
					return
				}
				(*z).Counts[zb0003] = zb0004
			}
		}
		if zb0007 > 0 {
			zb0007--
			var zb0019 int
			var zb0020 bool
			zb0019, zb0020, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Equivocators")
				return
			}
			if zb0020 {
				(*z).Equivocators = nil
			} else if (*z).Equivocators == nil {
				(*z).Equivocators = make(map[basics.Address]equivocationVote, zb0019)
			}
			var zb0021 basics.Address
			_ = zb0021
			var zb0022 bool
			_ = zb0022
			for zb0019 > 0 {
				var zb0005 basics.Address
				var zb0006 equivocationVote
				zb0019--
				bts, err = zb0005.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Equivocators")
					return
				}
				if validate && zb0022 && basics.AddressLess(zb0005, zb0021) {
					err = &msgp.ErrNonCanonical{}
					return
				}
				zb0021 = zb0005
				zb0022 = true
				bts, err = zb0006.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Equivocators", zb0005)
					return
				}
				(*z).Equivocators[zb0005] = zb0006
			}
		}
		if zb0007 > 0 {
			zb0007--
			(*z).EquivocatorsCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "EquivocatorsCount")
				return
			}
		}
		if zb0007 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0007)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0008 {
			(*z) = voteTracker{}
		}
		for zb0007 > 0 {
			zb0007--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Voters":
				if validate && zb0010 && "Voters" < zb0009 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0023 int
				var zb0024 bool
				zb0023, zb0024, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Voters")
					return
				}
				if zb0024 {
					(*z).Voters = nil
				} else if (*z).Voters == nil {
					(*z).Voters = make(map[basics.Address]vote, zb0023)
				}
				var zb0025 basics.Address
				_ = zb0025
				var zb0026 bool
				_ = zb0026
				for zb0023 > 0 {
					var zb0001 basics.Address
					var zb0002 vote
					zb0023--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Voters")
						return
					}
					if validate && zb0026 && basics.AddressLess(zb0001, zb0025) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0025 = zb0001
					zb0026 = true
					bts, err = zb0002.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Voters", zb0001)
						return
					}
					(*z).Voters[zb0001] = zb0002
				}
				zb0009 = "Voters"
			case "Counts":
				if validate && zb0010 && "Counts" < zb0009 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0027 int
				var zb0028 bool
				zb0027, zb0028, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Counts")
					return
				}
				if zb0028 {
					(*z).Counts = nil
				} else if (*z).Counts == nil {
					(*z).Counts = make(map[proposalValue]proposalVoteCounter, zb0027)
				}
				var zb0029 proposalValue
				_ = zb0029
				var zb0030 bool
				_ = zb0030
				for zb0027 > 0 {
					var zb0003 proposalValue
					var zb0004 proposalVoteCounter
					zb0027--
					bts, err = zb0003.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Counts")
						return
					}
					if validate && zb0030 && ProposalValueLess(zb0003, zb0029) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0029 = zb0003
					zb0030 = true
					bts, err = zb0004.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Counts", zb0003)
						return
					}
					(*z).Counts[zb0003] = zb0004
				}
				zb0009 = "Counts"
			case "Equivocators":
				if validate && zb0010 && "Equivocators" < zb0009 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0031 int
				var zb0032 bool
				zb0031, zb0032, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Equivocators")
					return
				}
				if zb0032 {
					(*z).Equivocators = nil
				} else if (*z).Equivocators == nil {
					(*z).Equivocators = make(map[basics.Address]equivocationVote, zb0031)
				}
				var zb0033 basics.Address
				_ = zb0033
				var zb0034 bool
				_ = zb0034
				for zb0031 > 0 {
					var zb0005 basics.Address
					var zb0006 equivocationVote
					zb0031--
					bts, err = zb0005.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Equivocators")
						return
					}
					if validate && zb0034 && basics.AddressLess(zb0005, zb0033) {
						err = &msgp.ErrNonCanonical{}
						return
					}
					zb0033 = zb0005
					zb0034 = true
					bts, err = zb0006.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Equivocators", zb0005)
						return
					}
					(*z).Equivocators[zb0005] = zb0006
				}
				zb0009 = "Equivocators"
			case "EquivocatorsCount":
				if validate && zb0010 && "EquivocatorsCount" < zb0009 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).EquivocatorsCount, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquivocatorsCount")
					return
				}
				zb0009 = "EquivocatorsCount"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0010 = true
		}
	}
	o = bts
	return
}

func (z *voteTracker) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *voteTracker) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *voteTracker) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteTracker)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *voteTracker) Msgsize() (s int) {
	s = 1 + 7 + msgp.MapHeaderSize
	if (*z).Voters != nil {
		for zb0001, zb0002 := range (*z).Voters {
			_ = zb0001
			_ = zb0002
			s += 0 + zb0001.Msgsize() + zb0002.Msgsize()
		}
	}
	s += 7 + msgp.MapHeaderSize
	if (*z).Counts != nil {
		for zb0003, zb0004 := range (*z).Counts {
			_ = zb0003
			_ = zb0004
			s += 0 + zb0003.Msgsize() + zb0004.Msgsize()
		}
	}
	s += 13 + msgp.MapHeaderSize
	if (*z).Equivocators != nil {
		for zb0005, zb0006 := range (*z).Equivocators {
			_ = zb0005
			_ = zb0006
			s += 0 + zb0005.Msgsize() + zb0006.Msgsize()
		}
	}
	s += 18 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *voteTracker) MsgIsZero() bool {
	return (len((*z).Voters) == 0) && (len((*z).Counts) == 0) && (len((*z).Equivocators) == 0) && ((*z).EquivocatorsCount == 0)
}

// MaxSize returns a maximum valid message size for this message type
func VoteTrackerMaxSize() (s int) {
	s = 1 + 7
	s += msgp.MapHeaderSize
	panic("Map z.Voters is unbounded")
	s += 7
	s += msgp.MapHeaderSize
	panic("Map z.Counts is unbounded")
	s += 13
	s += msgp.MapHeaderSize
	panic("Map z.Equivocators is unbounded")
	s += 18 + msgp.Uint64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *voteTrackerContract) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Emitted"
	o = append(o, 0x83, 0xa7, 0x45, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, (*z).Emitted)
	// string "Step"
	o = append(o, 0xa4, 0x53, 0x74, 0x65, 0x70)
	o = msgp.AppendUint64(o, uint64((*z).Step))
	// string "StepOk"
	o = append(o, 0xa6, 0x53, 0x74, 0x65, 0x70, 0x4f, 0x6b)
	o = msgp.AppendBool(o, (*z).StepOk)
	return
}

func (_ *voteTrackerContract) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteTrackerContract)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *voteTrackerContract) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Step")
					return
				}
				(*z).Step = step(zb0005)
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).StepOk, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "StepOk")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Emitted, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Emitted")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = voteTrackerContract{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Step":
				if validate && zb0004 && "Step" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				{
					var zb0006 uint64
					zb0006, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Step")
						return
					}
					(*z).Step = step(zb0006)
				}
				zb0003 = "Step"
			case "StepOk":
				if validate && zb0004 && "StepOk" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).StepOk, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StepOk")
					return
				}
				zb0003 = "StepOk"
			case "Emitted":
				if validate && zb0004 && "Emitted" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Emitted, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Emitted")
					return
				}
				zb0003 = "Emitted"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *voteTrackerContract) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *voteTrackerContract) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *voteTrackerContract) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteTrackerContract)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *voteTrackerContract) Msgsize() (s int) {
	s = 1 + 5 + msgp.Uint64Size + 7 + msgp.BoolSize + 8 + msgp.BoolSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *voteTrackerContract) MsgIsZero() bool {
	return ((*z).Step == 0) && ((*z).StepOk == false) && ((*z).Emitted == false)
}

// MaxSize returns a maximum valid message size for this message type
func VoteTrackerContractMaxSize() (s int) {
	s = 1 + 5 + msgp.Uint64Size + 7 + msgp.BoolSize + 8 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *voteTrackerPeriod) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Cached"
	o = append(o, 0x81, 0xa6, 0x43, 0x61, 0x63, 0x68, 0x65, 0x64)
	// map header, size 2
	// string "Bottom"
	o = append(o, 0x82, 0xa6, 0x42, 0x6f, 0x74, 0x74, 0x6f, 0x6d)
	o = msgp.AppendBool(o, (*z).Cached.Bottom)
	// string "Proposal"
	o = append(o, 0xa8, 0x50, 0x72, 0x6f, 0x70, 0x6f, 0x73, 0x61, 0x6c)
	o = (*z).Cached.Proposal.MarshalMsg(o)
	return
}

func (_ *voteTrackerPeriod) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteTrackerPeriod)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *voteTrackerPeriod) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			var zb0005 int
			var zb0007 string
			var zb0008 bool
			var zb0006 bool
			_ = zb0007
			_ = zb0008
			zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Cached")
					return
				}
				if validate {
					err = &msgp.ErrNonCanonical{}
					return
				}
				if zb0005 > 0 {
					zb0005--
					(*z).Cached.Bottom, bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Cached", "struct-from-array", "Bottom")
						return
					}
				}
				if zb0005 > 0 {
					zb0005--
					bts, err = (*z).Cached.Proposal.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Cached", "struct-from-array", "Proposal")
						return
					}
				}
				if zb0005 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0005)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Cached", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Cached")
					return
				}
				if zb0006 {
					(*z).Cached = nextThresholdStatusEvent{}
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Cached")
						return
					}
					switch string(field) {
					case "Bottom":
						if validate && zb0008 && "Bottom" < zb0007 {
							err = &msgp.ErrNonCanonical{}
							return
						}
						(*z).Cached.Bottom, bts, err = msgp.ReadBoolBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Cached", "Bottom")
							return
						}
						zb0007 = "Bottom"
					case "Proposal":
						if validate && zb0008 && "Proposal" < zb0007 {
							err = &msgp.ErrNonCanonical{}
							return
						}
						bts, err = (*z).Cached.Proposal.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Cached", "Proposal")
							return
						}
						zb0007 = "Proposal"
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Cached")
							return
						}
					}
					zb0008 = true
				}
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = voteTrackerPeriod{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Cached":
				if validate && zb0004 && "Cached" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				var zb0009 int
				var zb0011 string
				var zb0012 bool
				var zb0010 bool
				_ = zb0011
				_ = zb0012
				zb0009, zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Cached")
						return
					}
					if validate {
						err = &msgp.ErrNonCanonical{}
						return
					}
					if zb0009 > 0 {
						zb0009--
						(*z).Cached.Bottom, bts, err = msgp.ReadBoolBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Cached", "struct-from-array", "Bottom")
							return
						}
					}
					if zb0009 > 0 {
						zb0009--
						bts, err = (*z).Cached.Proposal.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Cached", "struct-from-array", "Proposal")
							return
						}
					}
					if zb0009 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0009)
						if err != nil {
							err = msgp.WrapError(err, "Cached", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "Cached")
						return
					}
					if zb0010 {
						(*z).Cached = nextThresholdStatusEvent{}
					}
					for zb0009 > 0 {
						zb0009--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Cached")
							return
						}
						switch string(field) {
						case "Bottom":
							if validate && zb0012 && "Bottom" < zb0011 {
								err = &msgp.ErrNonCanonical{}
								return
							}
							(*z).Cached.Bottom, bts, err = msgp.ReadBoolBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Cached", "Bottom")
								return
							}
							zb0011 = "Bottom"
						case "Proposal":
							if validate && zb0012 && "Proposal" < zb0011 {
								err = &msgp.ErrNonCanonical{}
								return
							}
							bts, err = (*z).Cached.Proposal.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Cached", "Proposal")
								return
							}
							zb0011 = "Proposal"
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "Cached")
								return
							}
						}
						zb0012 = true
					}
				}
				zb0003 = "Cached"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *voteTrackerPeriod) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *voteTrackerPeriod) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *voteTrackerPeriod) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteTrackerPeriod)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *voteTrackerPeriod) Msgsize() (s int) {
	s = 1 + 7 + 1 + 7 + msgp.BoolSize + 9 + (*z).Cached.Proposal.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *voteTrackerPeriod) MsgIsZero() bool {
	return (((*z).Cached.Bottom == false) && ((*z).Cached.Proposal.MsgIsZero()))
}

// MaxSize returns a maximum valid message size for this message type
func VoteTrackerPeriodMaxSize() (s int) {
	s = 1 + 7 + 1 + 7 + msgp.BoolSize + 9 + ProposalValueMaxSize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *voteTrackerRound) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Freshest"
	o = append(o, 0x82, 0xa8, 0x46, 0x72, 0x65, 0x73, 0x68, 0x65, 0x73, 0x74)
	o = (*z).Freshest.MarshalMsg(o)
	// string "Ok"
	o = append(o, 0xa2, 0x4f, 0x6b)
	o = msgp.AppendBool(o, (*z).Ok)
	return
}

func (_ *voteTrackerRound) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteTrackerRound)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *voteTrackerRound) unmarshalMsg(bts []byte, validate bool) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0003 string
	var zb0004 bool
	var zb0002 bool
	_ = zb0003
	_ = zb0004
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if validate {
			err = &msgp.ErrNonCanonical{}
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Freshest.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Freshest")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Ok, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Ok")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = voteTrackerRound{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "Freshest":
				if validate && zb0004 && "Freshest" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				bts, err = (*z).Freshest.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Freshest")
					return
				}
				zb0003 = "Freshest"
			case "Ok":
				if validate && zb0004 && "Ok" < zb0003 {
					err = &msgp.ErrNonCanonical{}
					return
				}
				(*z).Ok, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Ok")
					return
				}
				zb0003 = "Ok"
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
			zb0004 = true
		}
	}
	o = bts
	return
}

func (z *voteTrackerRound) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, false)
}
func (z *voteTrackerRound) UnmarshalValidateMsg(bts []byte) (o []byte, err error) {
	return z.unmarshalMsg(bts, true)
}
func (_ *voteTrackerRound) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*voteTrackerRound)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *voteTrackerRound) Msgsize() (s int) {
	s = 1 + 9 + (*z).Freshest.Msgsize() + 3 + msgp.BoolSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *voteTrackerRound) MsgIsZero() bool {
	return ((*z).Freshest.MsgIsZero()) && ((*z).Ok == false)
}

// MaxSize returns a maximum valid message size for this message type
func VoteTrackerRoundMaxSize() (s int) {
	s = 1 + 9 + ThresholdEventMaxSize() + 3 + msgp.BoolSize
	return
}
