# Algorand Goal Expect Utility Package
namespace eval ::AlgorandGoal {

  # Export Procedures
  namespace export Info
  namespace export Abort
  namespace export StartNetwork
  namespace export StopNetwork
  namespace export CreateWallet
  namespace export VerifyWallet
  namespace export RecoverWallet
  namespace export CreateAccountForWallet
  namespace export GetAccountAddress
  namespace export GetAccountBalance
  namespace export GetAccountRewards
  namespace export AccountTransfer
  namespace export WaitForAccountBalance
  namespace export GetHighestFundedAccountForWallet
  namespace export GetAlgodNetworkAddress
  namespace export GetKMDNetworkAddress
  namespace export GetLedgerSupply
  namespace export WaitForRound
  namespace export Report
  namespace export ListParticipationKeys
  namespace export AddParticipationKey
  namespace export TakeAccountOnline

  # My Variables
   set version 1.0
   set description "Algorand Goal Expect Package"

  # Variable for the path of the script
   variable home [file join [pwd] [file dirname [info script]]]
}

# Definition of the procedure MyProcedure
proc ::AlgorandGoal::Info {} {
   puts AlgorandGoal::description
}

package provide AlgorandGoal $AlgorandGoal::version
package require Tcl 8.0


# Utility method to abort out of this script
proc ::AlgorandGoal::Abort { ERROR } {
    puts "Aborting with Error: $ERROR"

    if { "$::GLOBAL_TEST_ALGO_DIR" != "" && "$::GLOBAL_TEST_ROOT_DIR" != "" } {
        # terminate child algod processes, if there are active child processes the test will hang on a test failure
        puts "GLOBAL_TEST_ALGO_DIR $::GLOBAL_TEST_ALGO_DIR"
        puts "GLOBAL_TEST_ROOT_DIR $::GLOBAL_TEST_ROOT_DIR"
        puts "GLOBAL_NETWORK_NAME $::GLOBAL_NETWORK_NAME"
        ::AlgorandGoal::StopNetwork $::GLOBAL_NETWORK_NAME $::GLOBAL_TEST_ALGO_DIR $::GLOBAL_TEST_ROOT_DIR
    }
    exit 1
}

# Start the node
proc ::AlgorandGoal::StartNode { TEST_ALGO_DIR {SYSTEMD_MANAGED "False"} {PEER_ADDRESS ""} } {
    set ::GLOBAL_TEST_ALGO_DIR $TEST_ALGO_DIR
    set timeout 15
    set GOAL_PARAMS "node start -d $TEST_ALGO_DIR"
    if { $PEER_ADDRESS != "" } {
        set GOAL_PARAMS "$GOAL_PARAMS -p $PEER_ADDRESS"
    }
    if { [catch {
        puts "node start with $TEST_ALGO_DIR"
        spawn goal {*}$GOAL_PARAMS
        if { $SYSTEMD_MANAGED eq "True" } {
            expect {
                timeout { close; ::AlgorandGoal::Abort "Did not receive appropriate message during node start" }
                "^This node is managed by systemd, you must run the following command to make your desired state change to your node:*" { puts "Goal showed correct error message for systemd" ; close}
                eof { ::AlgorandGoal::CheckEOF "Unable to start network" }
            }
        } else {
            expect {
                timeout { close; ::AlgorandGoal::Abort "Did not receive appropriate message during node start" }
                "^Algorand node successfully started!*" {puts "Node started successfully"; close}
                eof { ::AlgorandGoal::CheckEOF "Unable to start network" }
            }
        }
    } EXCEPTION] } {
        puts "ERROR in StartNode: $EXCEPTION"
        exit 1
    }
}

# Stop the node
proc ::AlgorandGoal::StopNode { TEST_ALGO_DIR {SYSTEMD_MANAGED ""} } {
    set ::GLOBAL_TEST_ALGO_DIR $TEST_ALGO_DIR
    set timeout 15

    if { [catch {
        puts "node stop with $TEST_ALGO_DIR"
        if { $SYSTEMD_MANAGED eq "" } {
            spawn goal node stop -d $TEST_ALGO_DIR
            expect {
                timeout { close; ::AlgorandGoal::Abort "Did not receive appropriate message during node stop" }
                "*The node was successfully stopped.*" {puts "Node stopped successfully"; close}
                eof { close; ::AlgorandGoal::Abort "Did not receive appropriate message before goal command completion" }
            }
        } else {
            spawn goal node stop -d $TEST_ALGO_DIR
            expect {
                timeout { close; ::AlgorandGoal::Abort "Did not receive appropriate message during node stop" }
                "*This node is managed by systemd, you must run the following command to make your desired state change to your node:*" { puts "Goal showed correct error message for systemd" ; close}
                eof { close; ::AlgorandGoal::Abort "Did not receive appropriate message before goal command completion" }
            }
        }
    } EXCEPTION] } {
        puts "ERROR in StopNode: $EXCEPTION"
        exit 1
    }
}

# Restart the node
proc ::AlgorandGoal::RestartNode { TEST_ALGO_DIR {SYSTEMD_MANAGED ""} } {
    set ::GLOBAL_TEST_ALGO_DIR $TEST_ALGO_DIR
    set timeout 30

    if { [catch {
        puts "node restart with $TEST_ALGO_DIR"
        if { $SYSTEMD_MANAGED eq "" } {
            spawn goal node restart -d $TEST_ALGO_DIR
            expect {
                timeout { close; ::AlgorandGoal::Abort "Did not receive appropriate message during node restart" }
                "^The node was successfully stopped.*Algorand node successfully started!*" {puts "Node restarted successfully"; close}
            }
        } else {
            spawn goal node restart -d $TEST_ALGO_DIR
            expect {
                timeout { close; ::AlgorandGoal::Abort "Did not receive appropriate message during node restart" }
                "^This node is managed by systemd, you must run the following command to make your desired state change to your node:*" { puts "Goal showed correct error message for systemd" ; close}
            }
        }
    } EXCEPTION] } {
        puts "ERROR in RestartNode: $EXCEPTION"
        exit 1
    }
}

# Create the network
proc ::AlgorandGoal::CreateNetwork { NETWORK_NAME NETWORK_TEMPLATE TEST_ALGO_DIR TEST_ROOT_DIR } {
    # Running on ARM64, it seems that network creation is pretty slow.
    # 30 second won't be enough here, so I'm changing this to 120 seconds.
    set timeout 120

    if { [catch {
        # Create network
        puts "network create $NETWORK_NAME"
        spawn goal network create --network $NETWORK_NAME --template $NETWORK_TEMPLATE --datadir $TEST_ALGO_DIR --rootdir $TEST_ROOT_DIR
        expect {
            timeout { close; ::AlgorandGoal::Abort "Timed out creating network" }
            "^Network $NETWORK_NAME created under.*" { puts "Network $NETWORK_NAME created" ; exp_continue }
            eof { ::AlgorandGoal::CheckEOF "Unable to create network" }
        }
    } EXCEPTION ] } {
       puts "ERROR in CreateNetwork: $EXCEPTION"
       exit 1
    }
}

# Start the network
proc ::AlgorandGoal::StartNetwork { NETWORK_NAME NETWORK_TEMPLATE TEST_ALGO_DIR TEST_ROOT_DIR } {
    set ::GLOBAL_TEST_ALGO_DIR $TEST_ALGO_DIR
    set ::GLOBAL_TEST_ROOT_DIR $TEST_ROOT_DIR
    set ::GLOBAL_NETWORK_NAME $NETWORK_NAME

    if { [catch {
        # Start network
        puts "network start $NETWORK_NAME"
        spawn goal network start -r $TEST_ROOT_DIR
        expect {
            timeout { close; ::AlgorandGoal::Abort "Timed out starting network"  }
            ".*Network started under.*" { puts "Network $NETWORK_NAME started"  ;close  }
            close
        }
    } EXCEPTION ] } {
       puts "ERROR in StartNetwork: $EXCEPTION"
       exit 1
    }

    if { [catch {
        # Check network status
        puts "network status $NETWORK_NAME"
        spawn goal network status -r $TEST_ROOT_DIR
        expect {
            timeout { close; ::AlgorandGoal::Abort "Timed out retrieving network status"  }
            ".*Error getting status.*" { close; ::AlgorandGoal::Abort "error getting network status: $expect_out(buffer)"}
            "^Network Started under.*"   { puts "Network $NETWORK_NAME status ok"; close }
            close
        }
        puts "StartNetwork complete"
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in StartNetwork: $EXCEPTION"
    }
}

# Stop the network
proc ::AlgorandGoal::StopNetwork { NETWORK_NAME TEST_ALGO_DIR TEST_ROOT_DIR } {
    set timeout 60
    set NETWORK_STOP_MESSAGE ""
    puts "Stopping network: $NETWORK_NAME"
    spawn goal network stop -d $TEST_ALGO_DIR -r $TEST_ROOT_DIR
    expect {
        timeout {
	      close
	      puts "Timed out shutting down network"
	      puts "GLOBAL_TEST_ALGO_DIR $::GLOBAL_TEST_ALGO_DIR"
	      puts "GLOBAL_TEST_ROOT_DIR $::GLOBAL_TEST_ROOT_DIR"
	      puts "GLOBAL_NETWORK_NAME $::GLOBAL_NETWORK_NAME"
	      exit 1
	    }
        "Network Stopped under.*" {set NETWORK_STOP_MESSAGE $expect_out(buffer); close}
    }
    puts $NETWORK_STOP_MESSAGE
}

# Create a new wallet
proc ::AlgorandGoal::CreateWallet { WALLET_NAME WALLET_PASSWORD TEST_PRIMARY_NODE_DIR } {
    set timeout 60
    if { [catch {
        set WALLET_PASS_PHRASE "NOT SET"
        spawn goal wallet new $WALLET_NAME -d $TEST_PRIMARY_NODE_DIR

        expect {
            timeout {::AlgorandGoal::Abort "Timed out CreateWallet password"  }
            "Please choose a password for wallet*" { send "$WALLET_PASSWORD\r" }
        }
        expect {
            timeout {::AlgorandGoal::Abort "Timed out CreateWallet confirmation"  }
            "Please confirm*" { send "$WALLET_PASSWORD\r"}
        }
        expect {
             timeout {::AlgorandGoal::Abort "Timed out CreateWallet see it now"  }
             "Would you like to see it now? (Y/n):" { send "y\r" }
        }
        expect {
              timeout {::AlgorandGoal::Abort "Timed out CreateWallet keep info safe"  }
              "Keep this information safe -- never share it with anyone!" {}
        }
        expect {
             timeout {::AlgorandGoal::Abort "Timed out CreateWallet pass phrase"  }
             -re {32m([a-z ]+)} {set WALLET_PASS_PHRASE $expect_out(1,string); close;}
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in CreateWallet: $EXCEPTION"
    }
    return $WALLET_PASS_PHRASE
}

# Verify that the wallet exists
proc ::AlgorandGoal::VerifyWallet { WALLET_NAME TEST_PRIMARY_NODE_DIR } {
    set timeout 60
    if { [catch {
        spawn goal wallet list -d $TEST_PRIMARY_NODE_DIR
        expect {
             timeout { ::AlgorandGoal::Abort "Timed out seeing expected input for spawn goal wallet list" }
             "*$WALLET_NAME*" {close}
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in VerifyWallet: $EXCEPTION"
    }
}

proc ::AlgorandGoal::RecoverWallet { NEW_WALLET_NAME WALLET_PASSPHRASE NEW_WALLET_PASSWORD TEST_PRIMARY_NODE_DIR } {
    set timeout 60
    if { [catch {
        spawn goal wallet new -r $NEW_WALLET_NAME -d $TEST_PRIMARY_NODE_DIR
           expect {
               timeout { puts "TIMEOUT"    }
               {Please type your recovery mnemonic below, and hit return when you are done:*} { send "$WALLET_PASSPHRASE\r" }
            }
        for { set index 1}  {$index <= 5} {incr index} {
            expect {
               timeout { puts "TIMEOUT"  }
               {Please choose a password for wallet* } { send "$NEW_WALLET_PASSWORD\r"}
               {Please confirm the password:*} { send "$NEW_WALLET_PASSWORD\r"}
               {Creating wallet...*} {puts $expect_out(buffer) }
               -re {Created wallet '([-a-zA-Z0-9_]+)'} {set RECOVERED_WALLET_NAME $expect_out(1,string) }
            }
        }
        puts "Recovered wallet: $RECOVERED_WALLET_NAME"
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in RecoverWallet: $EXCEPTION"
    }
    return $RECOVERED_WALLET_NAME
}

# Associate a new account with a specific wallet
proc ::AlgorandGoal::CreateAccountForWallet { WALLET_NAME WALLET_PASSWORD TEST_PRIMARY_NODE_DIR } {
    set timeout 60
    if { [catch {
        spawn goal account new -w $WALLET_NAME -d $TEST_PRIMARY_NODE_DIR
        while 1 {
            expect {
                timeout { break; ::AlgorandGoal::Abort "Timed out seeing new account created for wallet $WALLET_NAME" }
                "Please enter the password for wallet*" { send "$WALLET_PASSWORD\r" }
                 -re {Created new account with address ([a-zA-Z0-9]+)} {set ACCOUNT_ADDRESS $expect_out(1,string) ;close; break }
            }
        }
        puts "Account Address: $ACCOUNT_ADDRESS"
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in VerifyAccount: $EXCEPTION"
    }
    return $ACCOUNT_ADDRESS
}

# Verify that account exists
proc ::AlgorandGoal::VerifyAccount { WALLET_NAME WALLET_PASSWORD ACCOUNT_ADDRESS TEST_PRIMARY_NODE_DIR } {
    set timeout 60
    if { [catch {
        spawn goal account list -w $WALLET_NAME -d $TEST_PRIMARY_NODE_DIR
        while 1 {
            expect {
                timeout {break; ::AlgorandGoal::Abort "Timed out seeing expected account: $ACCOUNT_ADDRESS"}
                "Please enter the password for wallet*" { send "$WALLET_PASSWORD\r" }
                -re {\t([A-Z0-9]+)\t([A-Z0-9]+)} {set RETURN_ACCOUNT_ADDRESS $expect_out(1,string); break  }
            }
        }
        puts "Account Address: $RETURN_ACCOUNT_ADDRESS "
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in VerifyAccount: $EXCEPTION"
    }
}

# Delete an account
proc ::AlgorandGoal::DeleteAccount { WALLET_NAME ACCOUNT_ADDRESS } {
    set timeout 60
    spawn goal account delete --wallet $WALLET_NAME --address $ACCOUNT_ADDRESS
    expect {*}
}

#Select an account from the Wallet
proc ::AlgorandGoal::GetAccountAddress { WALLET_NAME TEST_PRIMARY_NODE_DIR } {
    set timeout 60
    if { [catch {
        spawn goal account list -w $WALLET_NAME -d $TEST_PRIMARY_NODE_DIR
        expect {
            timeout { ::AlgorandGoal::Abort "Failed to find primary wallet: $WALLET_NAME"  }
            -re {\[online\]\t([a-zA-Z0-9]+)\t([a-zA-Z0-9]+)\t([0-9]+)} {set ACCOUNT_ADDRESS $expect_out(2,string); set ACCOUNT_BALANCE $expect_out(3,string);close }
        }
        puts "Primary Account Address: $ACCOUNT_ADDRESS   Balance: $ACCOUNT_BALANCE"
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in GetAccountAddress: $EXCEPTION"
    }
    return $ACCOUNT_ADDRESS
}

# Return the Account Balance
proc ::AlgorandGoal::GetAccountBalance { WALLET_NAME ACCOUNT_ADDRESS TEST_PRIMARY_NODE_DIR } {
    set timeout 60
    if { [ catch {
        spawn goal account balance -w $WALLET_NAME -a $ACCOUNT_ADDRESS -d $TEST_PRIMARY_NODE_DIR
        expect {
            timeout { ::AlgorandGoal::Abort "Timed out retrieving account balance for wallet $WALLET_NAME and account $ACCOUNT_ADDRESS"  }
            -re {\d+} {set ACCOUNT_BALANCE  $expect_out(0,string)}
        }
        puts "Wallet: $WALLET_NAME, Account: $ACCOUNT_ADDRESS, Balance: $ACCOUNT_BALANCE"
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in GetAccountBalance: $EXCEPTION"
    }
    return $ACCOUNT_BALANCE
}

# Return the Account Rewards
proc ::AlgorandGoal::GetAccountRewards { WALLET_NAME ACCOUNT_ADDRESS TEST_PRIMARY_NODE_DIR } {
    set timeout 60
    spawn goal account rewards -w $WALLET_NAME -a $ACCOUNT_ADDRESS -d $TEST_PRIMARY_NODE_DIR
    expect {
        timeout { ::AlgorandGoal::Abort "Timed out retrieving account rewards for wallet $WALLET_NAME and account $ACCOUNT_ADDRESS"  }
        -re {\d+} {set ACCOUNT_EARNINGS  $expect_out(0,string)}
    }
    puts "Wallet: $WALLET_NAME, Account: $ACCOUNT_ADDRESS, Rewards: $ACCOUNT_EARNINGS"
    return $ACCOUNT_EARNINGS
}

# Account Transfer
proc ::AlgorandGoal::AccountTransfer { FROM_WALLET_NAME FROM_WALLET_PASSWORD FROM_ACCOUNT_ADDRESS TRANSFER_AMOUNT TO_ACCOUNT_ADDRESS FEE_AMOUNT TEST_PRIMARY_NODE_DIR } {
    set timeout 60
    if { [ catch {
        set TRANSACTION_ID "NOT SET"
        spawn goal clerk send --fee $FEE_AMOUNT --wallet $FROM_WALLET_NAME --amount $TRANSFER_AMOUNT --from $FROM_ACCOUNT_ADDRESS --to $TO_ACCOUNT_ADDRESS -d $TEST_PRIMARY_NODE_DIR
        expect {
            timeout { close; ::AlgorandGoal::Abort "Timed out transferring funds"  }
            "Please enter the password for wallet '$FROM_WALLET_NAME':" { send "$FROM_WALLET_PASSWORD\r" }
            -re {transaction ID: ([A-Z0-9]{52})} {set TRANSACTION_ID $expect_out(1,string); close }
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in AccountTransfer: $EXCEPTION"
    }
    return $TRANSACTION_ID
}

# Wait for Account to achieve given balance
proc ::AlgorandGoal::WaitForAccountBalance { WALLET_NAME ACCOUNT_ADDRESS EXPECTED_BALANCE TEST_PRIMARY_NODE_DIR } {
    set timeout 60
    if { [catch {
    set i 0
        while 1 {
            incr i
            exec sleep 2

            # Retrieve the target account balance
            spawn goal account balance -a $ACCOUNT_ADDRESS -w $WALLET_NAME -d $TEST_PRIMARY_NODE_DIR
            expect {
                timeout { ::AlgorandGoal::Abort "Timed out retrieving account balance"  }
                -re {(\d+)} {set ACCOUNT_BALANCE $expect_out(0,string); close }
            }
            puts "Account Balance: $ACCOUNT_BALANCE"

            # Validate the new account balance
            if { $ACCOUNT_BALANCE == $EXPECTED_BALANCE } {
                puts "Account balance OK: $ACCOUNT_BALANCE"; break
            } else {
               puts "Account balance: '$ACCOUNT_BALANCE' does not match expected balance: '$EXPECTED_BALANCE'"
               if { $i >= 10 } then { ::AlgorandGoal::Abort "Account balance $ACCOUNT_BALANCE does not match expected amount: $EXPECTED_BALANCE"; break;}
            }
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in WaitForAccountBalance: $EXCEPTION"
    }
    return $ACCOUNT_BALANCE
}

# Create an asset
proc ::AlgorandGoal::AssetCreate { CREATOR WALLET_NAME WALLET_PASSWORD TOTAL_SUPPLY UNIT_NAME TEST_PRIMARY_NODE_DIR } {
    set timeout 40
    if { [ catch {
        spawn goal asset create -d $TEST_PRIMARY_NODE_DIR -w $WALLET_NAME --creator $CREATOR --total $TOTAL_SUPPLY --unitname $UNIT_NAME
        expect {
            timeout { ::AlgorandGoal::Abort "Timed out create asset"  }
	    "Please enter the password for wallet '$WALLET_NAME':" { send "$WALLET_PASSWORD\r" }
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in AssetCreate: $EXCEPTION"
    }
}

# Transfer asset
proc ::AlgorandGoal::AssetTransfer { WALLET_NAME WALLET_PASSWORD FROM_ADDR TO_ADDR ASSET_ID ASSET_AMOUNT TEST_PRIMARY_NODE_DIR} {
    if { [ catch {
        spawn goal asset send -d $TEST_PRIMARY_NODE_DIR -w $WALLET_NAME --from $FROM_ADDR --to $TO_ADDR --assetid $ASSET_ID --amount $ASSET_AMOUNT
        expect {
            timeout { ::AlgorandGoal::Abort "Timed out asset transfer"  }
	    "Please enter the password for wallet '$WALLET_NAME':" { send "$WALLET_PASSWORD\r" }
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in AssetTransfer: $EXCEPTION"
    }
}

# write asset transfer to a txn file
proc ::AlgorandGoal::CreateAssetTransfer { FROM_ADDR TO_ADDR ASSET_ID ASSET_AMOUNT TEST_PRIMARY_NODE_DIR TXN_OUTPUT} {
    if { [ catch {
        spawn goal asset send -d $TEST_PRIMARY_NODE_DIR --from $FROM_ADDR --to $TO_ADDR --assetid $ASSET_ID --amount $ASSET_AMOUNT -o $TXN_OUTPUT
	expect {
            timeout { ::AlgorandGoal::Abort "Timed out creating asset transfer transaction"  }
	    close
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in CreateAssetTransfer: $EXCEPTION"
    }
}

# Get asset id
proc ::AlgorandGoal::AssetLookup { CREATOR UNIT_NAME TEST_PRIMARY_NODE_DIR } {
    set timeout 10
    if { [ catch {
	set ASSET_ID "NOT SET"
        spawn goal asset info -d $TEST_PRIMARY_NODE_DIR --creator $CREATOR  --asset $UNIT_NAME
        expect {
            timeout { ::AlgorandGoal::Abort "Timed out asset lookup"  }
            -re {Asset ID:\s+([0-9]+)} {set ASSET_ID $expect_out(1,string); close }
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in AssetLookup: $EXCEPTION"
    }
    return $ASSET_ID
}

# Assemble group txn
proc ::AlgorandGoal::AssembleGroup { INPUT_GROUP OUTPUT_GROUP } {
    if { [ catch {
        spawn goal clerk group -i $INPUT_GROUP -o $OUTPUT_GROUP
	expect {
            timeout { ::AlgorandGoal::Abort "Timed out assembling group transaction"  }
	    close
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in AssembleGroup: $EXCEPTION"
    }
}


# Generate limit order code from teal template
proc ::AlgorandGoal::LimitOrder {TEAL_DRIVER SWAP_N SWAP_D MIN_TRD OWNER FEE TIME_OUT ASSET_ID TEAL_OUTPUT}  {
    if { [ catch {
	set limitf [open $TEAL_OUTPUT w]
        spawn python $TEAL_DRIVER "limit-order" --swapn $SWAP_N --swapd $SWAP_D --mintrd $MIN_TRD --own $OWNER  --fee $FEE --timeout $TIME_OUT --asset $ASSET_ID
        expect {
            timeout { ::AlgorandGoal::Abort "Timed out limit order"  }
	    -re {^.+$} { puts $limitf $expect_out(buffer); close $limitf; close }
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in LimitOrder: $EXCEPTION"
    }
}

# Compile
proc ::AlgorandGoal::TealCompile { TEAL_SOURCE } {
    if { [ catch {
        set TEAL_HASH "NOT SET"
        spawn goal clerk compile $TEAL_SOURCE
        expect {
            timeout { ::AlgorandGoal::Abort "Timed out compiling $TEAL_SOURCE"  }
            -re {[A-Z2-9]{58}} {set TEAL_HASH $expect_out(0,string); close }
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in TealCompile: $EXCEPTION"
    }
    return $TEAL_HASH
}

# Compile and sign
proc ::AlgorandGoal::TealCompileSign { TEAL_SOURCE TEAL_BYTES ACCOUNT_ADDRESS } {
    if { [ catch {
        set TEAL_HASH "NOT SET"
        spawn goal clerk compile $TEAL_SOURCE -o $TEAL_BYTES -s -a $ACCOUNT_ADDRESS
        expect {
            timeout { ::AlgorandGoal::Abort "Timed out compiling and signing $TEAL_SOURCE using $ACCOUNT_ADDRESS"  }
            -re {[A-Z2-9]{58}} {set TEAL_HASH $expect_out(0,string); close }
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in TealCompileSign: $EXCEPTION"
    }
    return $TEAL_HASH
}

# create txn with logic sig
proc ::AlgorandGoal::TealTxnCreate { TEAL_SOURCE TO_ADDR CLOSE_TO SEND_AMOUNT NODE_DIR OUTPUT_TXN } {
    if { [ catch {
        spawn goal clerk send --from-program $TEAL_SOURCE --to $TO_ADDR -c $CLOSE_TO --amount $SEND_AMOUNT -d $NODE_DIR -o $OUTPUT_TXN
	expect {
            timeout { ::AlgorandGoal::Abort "Timed out Teal transaction create"  }
	    close
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in TealTxnCreate: $EXCEPTION"
    }
}

# Transfer asset
proc ::AlgorandGoal::SignTransaction { WALLET_NAME WALLET_PASSWORD INPUT_TXN OUTPUT_TXN TEST_PRIMARY_NODE_DIR} {
    if { [ catch {
        spawn goal clerk sign -d $TEST_PRIMARY_NODE_DIR -w $WALLET_NAME -i $INPUT_TXN -o $OUTPUT_TXN
        expect {
            timeout { ::AlgorandGoal::Abort "Timed out signing transaction"  }
	    "Please enter the password for wallet '$WALLET_NAME':" { send "$WALLET_PASSWORD\r" }
	    close
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in SignTransaction: $EXCEPTION"
    }
}

# Raw send
proc ::AlgorandGoal::RawSend { TXN_FILE TEST_PRIMARY_NODE_DIR } {
    set timeout 30
    if { [ catch {
        set TRANSACTION_ID "NOT SET"
        spawn goal clerk rawsend -f $TXN_FILE -d $TEST_PRIMARY_NODE_DIR
        expect {
            timeout { close; ::AlgorandGoal::Abort "Timed out rawsend $TXN_FILE"  }
            -re {Transaction ([A-Z0-9]{52}) committed} {set TRANSACTION_ID $expect_out(1,string); close }
	    -re {Rejected transactions written to (.+rej)} {::AlgorandGoal::Abort "RawSend rejected."}
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in RawSend: $EXCEPTION"
    }
    return $TRANSACTION_ID
}

# Return the highest funded account for the given Wallet
proc ::AlgorandGoal::GetHighestFundedAccountForWallet { WALLET_NAME NODE_DIR } {
    if { [catch {
        spawn goal account list -w $WALLET_NAME -d $NODE_DIR
        set ACCOUNT_BALANCE 0
        set ACCOUNT_ADDRESS "NONE"
        expect {
            timeout { ::AlgorandGoal::Abort "Timed out finding primary wallet: $WALLET_NAME"  }
            -re {\[online\]\t([a-zA-Z0-9]+)\t([a-zA-Z0-9]+)\t([0-9]+)} {
                    set CURRENT_ACCOUNT_ADDRESS $expect_out(2,string);
                    set  CURRENT_ACCOUNT_BALANCE $expect_out(3,string);
                    if { $CURRENT_ACCOUNT_BALANCE > $ACCOUNT_BALANCE } then { set ACCOUNT_BALANCE $CURRENT_ACCOUNT_BALANCE; set ACCOUNT_ADDRESS $CURRENT_ACCOUNT_ADDRESS };
                    close;
                }
        }
        puts "Account Address: $ACCOUNT_ADDRESS   Balance: $ACCOUNT_BALANCE"
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in GetHighestFundedAccountForWallet: $EXCEPTION"
    }
    return $ACCOUNT_ADDRESS
}

# Return the Algod Network Address for the node directory
proc ::AlgorandGoal::GetAlgodNetworkAddress { TEST_PRIMARY_NODE_DIR } {
    if { [ catch {
        set NET_FILE [open $TEST_PRIMARY_NODE_DIR/algod.net]
        set PRIMARY_NODE_ADDRESS [string trim [read $NET_FILE ]]
        puts "Primary node address is: $PRIMARY_NODE_ADDRESS"
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in GetAlgodNetworkAddress: $EXCEPTION"
    }
    return $PRIMARY_NODE_ADDRESS
}

# Return the KMD Network Address
proc ::AlgorandGoal::GetKMDNetworkAddress { TEST_PRIMARY_NODE_DIR } {
    if { [ catch {
        set KMD_DIR [glob -type d -directory $TEST_PRIMARY_NODE_DIR kmd-v*]
        set NET_FILE [open $KMD_DIR/kmd.net]
        set KMD_NET_ADDRESS [string trim [read $NET_FILE ]]
        puts "KMD network address is: $KMD_NET_ADDRESS"
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in GetKMDNetworkAddress: $EXCEPTION"
    }
    return $KMD_NET_ADDRESS
}

# Use curl to check if a network address supports CORS
proc ::AlgorandGoal::CheckNetworkAddressForCors { NET_ADDRESS } {
    if { [ catch {
        spawn curl -X OPTIONS -H "Origin: http://algorand.com" --head $NET_ADDRESS
        expect {
            timeout { close; ::AlgorandGoal::Abort "Timeout failure in CheckNetworkAddressForCors" }
            "Access-Control-Allow-Origin" { puts "success" ; close  }
            close
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in CheckNetworkAddressForCors: $EXCEPTION"
    }
}

# Show the Ledger Supply
proc ::AlgorandGoal::GetLedgerSupply { TEST_PRIMARY_NODE_DIR } {
    if { [ catch {
        spawn goal ledger supply -d $TEST_PRIMARY_NODE_DIR
        expect {
            timeout { ::AlgorandGoal::Abort "Get Ledger Supply timed out"  }
            -re {Round: (\d+)} {set ROUND $expect_out(1,string); exp_continue }
            -re {Total Money: (\d+)} {set TOTAL_MONEY $expect_out(1,string); exp_continue }
            -re {Online Money: (\d+)} {set ONLINE_MONEY $expect_out(1,string) }
        }
        puts "Round: $ROUND"
        puts "Total Money: $TOTAL_MONEY"
        puts "Online Money: $ONLINE_MONEY"
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in GetLedgerSupply: $EXCEPTION"
    }
}

# Create a multisig address from two accounts
proc ::AlgorandGoal::CreateOneOfTwoMultisigForWallet { ADDRESS_1 ADDRESS_2 WALLET_NAME WALLET_PASSWORD TEST_PRIMARY_NODE_DIR } {
    if { [ catch {
        spawn goal account multisig new $ADDRESS_1 $ADDRESS_2 -T 1 -d $TEST_PRIMARY_NODE_DIR -w $WALLET_NAME
        expect {
            timeout { ::AlgorandGoal::Abort "Timed out creating a multisig account from $ADDRESS_1 and $ADDRESS_2"  }
            "Please enter the password for wallet*" { send "$WALLET_PASSWORD\r" }
            -re {Created new account with address ([a-zA-Z0-9]+)} {
                    set MULTISIG_ADDRESS $expect_out(1,string);
                    close;
            }
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in CreateOneOfTwoMultisigForWallet: $EXCEPTION"
    }
    return $MULTISIG_ADDRESS
}

# Query info for a 1-of-2 multisig account, and verify
proc ::AlgorandGoal::VerifyMultisigInfoForOneOfTwoMultisig { MULTISIG_ADDRESS ADDRESS_1 ADDRESS_2 WALLET_NAME TEST_PRIMARY_NODE_DIR } {
    if { [ catch {
        spawn goal account multisig info --address $MULTISIG_ADDRESS -d $TEST_PRIMARY_NODE_DIR -w $WALLET_NAME
        expect {
            timeout { ::AlgorandGoal::Abort "Timed out querying info about multisig account $MULTISIG_ADDRESS"  }
            -re {Version: (\d+)\r\nThreshold: (\d+)\r\nPublic keys:\r\n  ([a-zA-Z0-9]+)\r\n  ([a-zA-Z0-9]+)\r\n} {
                set VERSION $expect_out(1,string);
                set THRESHOLD $expect_out(2,string);
                set ADDRESS_RESPONSE_1 $expect_out(3,string);
                set ADDRESS_RESPONSE_2 $expect_out(4,string);
                close;
            }
        }
        if { $THRESHOLD != "1" } then { ::AlgorandGoal::Abort "Key threshold $THRESHOLD is not the expected threshold of 1"  }
        if { $ADDRESS_RESPONSE_1 != $ADDRESS_1 } then { ::AlgorandGoal::Abort "Responded address $ADDRESS_RESPONSE_1 is not the expected address $ADDRESS_1"  }
        if { $ADDRESS_RESPONSE_2 != $ADDRESS_2 } then { ::AlgorandGoal::Abort "Responded address $ADDRESS_RESPONSE_2 is not the expected address $ADDRESS_2"  }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in VerifyMultisigInfoForOneOfTwoMultisig: $EXCEPTION"
    }
}

# Delete a multisig address
proc ::AlgorandGoal::DeleteMultisigAccount { MULTISIG_ADDRESS TEST_PRIMARY_NODE_DIR } {
    if { [ catch {
        spawn goal account multisig delete --address $MULTISIG_ADDRESS -d $TEST_PRIMARY_NODE_DIR
        expect {*}
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in DeleteMultisigAccount: $EXCEPTION"
    }
}

# Wait for node to reach a specific round
proc ::AlgorandGoal::GetNodeLastCatchpoint { NODE_DATA_DIR } {
    set CATCHPOINT ""
    if { [catch {
        # Check node status
        puts "spawn node status"
        spawn goal node status -d $NODE_DATA_DIR
        expect {
            timeout { ::AlgorandGoal::Abort "goal node status timed out" }
            -re {Last Catchpoint: ([0-9]*#[A-Z2-7]*)} {regexp -- {[0-9]*#[A-Z2-7]*} $expect_out(0,string) CATCHPOINT; exp_continue }
            eof { catch wait result; if { [lindex $result 3] != 0 } { ::AlgorandGoal::Abort "failed to perform goal node status : error code [lindex $result 3]"} }
        }
        if { $CATCHPOINT == "" } {
            ::AlgorandGoal::Abort "Last Catchpoint entry was missing from goal node status"
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in GetNodeLastCatchpoint: $EXCEPTION"
    }
    return $CATCHPOINT
}

# Start catching up to a specific catchpoint
proc ::AlgorandGoal::StartCatchup { NODE_DATA_DIR CATCHPOINT } {
    if { [catch {
        # start catchup
        puts "spawn node catchup $CATCHPOINT"
        spawn goal node catchup $CATCHPOINT -d $NODE_DATA_DIR
        expect {
            timeout { ::AlgorandGoal::Abort "goal node catchup timed out" }
            eof { catch wait result; if { [lindex $result 3] != 0 } { ::AlgorandGoal::Abort "failed to start catching up : error code [lindex $result 3]"} }
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in StartCatchup: $EXCEPTION"
    }
    return $CATCHPOINT
}

# Wait for node to get into catchup mode
proc ::AlgorandGoal::WaitCatchup { TEST_PRIMARY_NODE_DIR WAIT_DURATION_SEC } {
    if { [catch {
        set i 0
        while { $i < $WAIT_DURATION_SEC } {
            # Check node status
            puts "spawn node status  "
            spawn goal node status -d $TEST_PRIMARY_NODE_DIR
            expect {
                timeout { ::AlgorandGoal::Abort "goal node status timed out"  }
                -re {Catchpoint: ([0-9]*#[A-Z2-7]*)} { set CATCHPOINT $expect_out(1,string); exp_continue }
                eof { catch wait result; if { [lindex $result 3] != 0 } { ::AlgorandGoal::Abort "failed to wait for catchup mode : error code [lindex $result 3]"} }
            }
            if { [info exists CATCHPOINT] } {
                break
            }

            incr i
            exec sleep 1
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in WaitCatchup: $EXCEPTION"
    }
    if { [info exists CATCHPOINT] == 0 } {
        ::AlgorandGoal::Abort "Node failed to start catching up within $WAIT_DURATION_SEC seconds"
    }
}

# Wait for node to reach a specific round
proc ::AlgorandGoal::WaitForRound { WAIT_FOR_ROUND_NUMBER NODE_DATA_DIR } {
    puts "node status waiting for Round $WAIT_FOR_ROUND_NUMBER "
    set LAST_ROUND -1
    set SLEEP_TIME 1
    if { [catch {
        set i 0
        while 1 {
            incr i

            # Check node status
            puts "spawn node status"
            log_user 0
            set BLOCK -1
            spawn goal node status -d $NODE_DATA_DIR
            expect {
                timeout { ::AlgorandGoal::Abort "goal node status timed out"  }
                -re {Cannot contact Algorand node: (\d+)} {set BLOCK -1; close }
                -re {Last committed block: (\d+)} {set BLOCK $expect_out(1,string); exp_continue }
                -re {Time since last block: ([0-9]*\.?[0-9]*)s} {set TIME_SINCE_LAST_BLOCK $expect_out(1,string); exp_continue }
                -re {Sync Time: ([0-9]*\.?[0-9]*)s} {set SYNC_TIME $expect_out(1,string); exp_continue }
                -re {Last consensus protocol: ([-+=.:/_a-zA-Z0-9]+)} {set LAST_CONSENSUS_PROTOCOL $expect_out(1,string); exp_continue }
                -re {Next consensus protocol: ([-+=.:/_a-zA-Z0-9]+)} {set NEXT_CONSENSUS_PROTOCOL $expect_out(1,string); exp_continue }
                -re {Round for next consensus protocol: (\d+)} {set ROUND_FOR_NEXT_CONSENSUS_PROTOCOL $expect_out(1,string); exp_continue }
                -re {Next consensus protocol supported: (\w+)} {set NEXT_CONSENSUS_PROTOCOL_SUPPORTED $expect_out(1,string); exp_continue }
                -re {Genesis ID: (\w+)} {set GENESIS_ID $expect_out(1,string); exp_continue }
                -re {Genesis hash: ([A-Za-z0-9+/]+={0,2})} {set GENESIS_HASH $expect_out(1,string); exp_continue }
                -re {Catchpoint: ([0-9]*#[A-Z2-7]*)} { set CATCHPOINT $expect_out(1,string); exp_continue }
                eof { catch wait result; if { [lindex $result 3] != 0 } { ::AlgorandGoal::Abort "failed to wait for round : error code [lindex $result 3]"} }
            }
            log_user 1
            if { $BLOCK > -1 } {
                puts "node status check complete, current round is $BLOCK"
            } else {
                ::AlgorandGoal::Abort "failed to retrieve block round number"
            }

            # Check if the round number is reached
            if { $BLOCK >= $WAIT_FOR_ROUND_NUMBER } {
                puts "Reached Round number: $WAIT_FOR_ROUND_NUMBER"; break
            } else {
               puts "Current Round: '$BLOCK' is less than wait for round: '$WAIT_FOR_ROUND_NUMBER'"
               if { $LAST_ROUND >= $BLOCK } {
                   # no progress was made since last time we checked.
                   incr SLEEP_TIME
               } else {
                   # we've made progress since last time we checked.
                   if { $SLEEP_TIME > 0 } { incr SLEEP_TIME -1 }
                   set i 0
                   set LAST_ROUND $BLOCK
               }
               if { $i >= 10 } then { ::AlgorandGoal::Abort " Current Round $BLOCK did not reach $WAIT_FOR_ROUND_NUMBER   "; break;}
            }

            puts "sleep time $SLEEP_TIME"
            after [expr {int($SLEEP_TIME * 1000)}]
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in WaitForRound: $EXCEPTION"
    }
    return $BLOCK
}

# Generate report
proc ::AlgorandGoal::Report { TEST_PRIMARY_NODE_DIR } {
    if { [ catch {
        spawn goal report -d $TEST_PRIMARY_NODE_DIR
        expect {
            timeout { ::AlgorandGoal::Abort "goal report timed out"  }
            "source code available at https://github.com/algorand/go-algorand" {puts "goal -v ok"}
            -re {Genesis ID from genesis.json: *} {puts "genesis ID from genesis.json ok"}
            -re {Last committed block: (\d+)} {puts "status check ok"}
        }
    } EXCEPTION ] } {
    ::AlgorandGoal::Abort "ERROR in Report: $EXCEPTION"
    }
}

# List Participation keys
proc ::AlgorandGoal::ListParticipationKeys { TEST_PRIMARY_NODE_DIR } {
    if { [ catch {
        spawn goal account listpartkeys -d $TEST_PRIMARY_NODE_DIR
        expect {
            timeout { ::AlgorandGoal::Abort "goal ListParticipationKeys timed out"  }
            close
        }
    } EXCEPTION ] } {
    ::AlgorandGoal::Abort "ERROR in ListParticipationKeys: $EXCEPTION"
    }
}

# Add a participation key
proc ::AlgorandGoal::AddParticipationKey { ADDRESS FIRST_ROUND LAST_ROUND TEST_PRIMARY_NODE_DIR } {
    if { [ catch {
        spawn goal account addpartkey --address $ADDRESS --roundFirstValid $FIRST_ROUND --roundLastValid $LAST_ROUND -d $TEST_PRIMARY_NODE_DIR
        expect {
            timeout { ::AlgorandGoal::Abort "goal AddParticipationKey timed out"  }
            close
        }
    } EXCEPTION ] } {
    ::AlgorandGoal::Abort "ERROR in AddParticipationKey: $EXCEPTION"
    }
}

# Register online participation with a given account
proc ::AlgorandGoal::TakeAccountOnline { ADDRESS FIRST_ROUND LAST_ROUND TEST_PRIMARY_NODE_DIR } {
    # we need to set the timeout to more than one round, since it might take few rounds for the transaction to be accepted, transmitted, proposed, etc.
    set timeout 20

    if { [ catch {
       spawn goal account changeonlinestatus --address $ADDRESS --firstvalid $FIRST_ROUND --lastvalid $LAST_ROUND -d $TEST_PRIMARY_NODE_DIR
       expect {
           timeout { ::AlgorandGoal::Abort "goal TakeAccountOnline timed out"  }
           close
       }
   } EXCEPTION ] } {
   ::AlgorandGoal::Abort "ERROR in TakeAccountOnline: $EXCEPTION"
   }
}

# Stateful Teal App Procedures

# App Create with 0 arguments
proc ::AlgorandGoal::AppCreate0 { WALLET_NAME WALLET_PASSWORD ACCOUNT_ADDRESS APPROVAL_PROGRAM GLOBAL_BYTE_SLICES LOCAL_BYTE_SLICES CLEAR_PROGRAM DATA_DIR } {
    set timeout 60
    if { [ catch {
        set APP_ID "NOT SET"
        puts "calling goal app create"
        spawn goal app create --creator $ACCOUNT_ADDRESS --approval-prog $APPROVAL_PROGRAM --global-byteslices $GLOBAL_BYTE_SLICES --global-ints 0 --local-byteslices $LOCAL_BYTE_SLICES --local-ints 0 --clear-prog $CLEAR_PROGRAM -w $WALLET_NAME -d $DATA_DIR
        expect {
            timeout { abort "\n Failed to see expected output" }
            "Please enter the password for wallet '$WALLET_NAME':" {send "$WALLET_PASSWORD\r" ; exp_continue }
            -re {Created app with app index ([0-9]+)} {set APP_ID $expect_out(1,string) ;close  }
            eof {close; ::AlgorandGoal::Abort "app not created" }
        }
        puts "App ID $APP_ID"
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in AppCreate: $EXCEPTION"
    }
    return $APP_ID
}

# App Create with 1 argument
proc ::AlgorandGoal::AppCreate { WALLET_NAME WALLET_PASSWORD ACCOUNT_ADDRESS APPROVAL_PROGRAM APP_ARG GLOBAL_BYTE_SLICES LOCAL_BYTE_SLICES CLEAR_PROGRAM DATA_DIR } {
    set timeout 60
    if { [ catch {
        set APP_ID "NOT SET"
        puts "calling goal app create"
        spawn goal app create --creator $ACCOUNT_ADDRESS --approval-prog $APPROVAL_PROGRAM --global-byteslices $GLOBAL_BYTE_SLICES --global-ints 0 --local-byteslices $LOCAL_BYTE_SLICES --local-ints 0 --app-arg $APP_ARG --clear-prog $CLEAR_PROGRAM -w $WALLET_NAME -d $DATA_DIR
        expect {
            timeout { abort "\n Failed to see expected output" }
            "Please enter the password for wallet '$WALLET_NAME':" {send "$WALLET_PASSWORD\r" ; exp_continue }
            -re {Created app with app index ([0-9]+)} {set APP_ID $expect_out(1,string) ;close  }
            eof {close; ::AlgorandGoal::Abort "app not created" }
        }
        puts "App ID $APP_ID"
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in AppCreate: $EXCEPTION"
    }
    return $APP_ID
}

# App OptIn with 1 argument
proc ::AlgorandGoal::AppOptIn { APP_ID WALLET_NAME WALLET_PASSWORD ACCOUNT_ADDRESS APP_ARG1 DATA_DIR } {
    set timeout 60
    if { [ catch {
        puts "opting in account to app"
        spawn goal app optin --app-id $APP_ID --app-arg $APP_ARG1 -w $WALLET_NAME --from $ACCOUNT_ADDRESS -d $DATA_DIR
        expect {
            timeout { puts timeout; ::AlgorandGoal::Abort  "\n Failed to see expected output" }
            "Please enter the password for wallet '$WALLET_NAME':" {send "$WALLET_PASSWORD\r" ; exp_continue}
            "*committed in round*" {puts "optin successful"; close}
            eof {close; ::AlgorandGoal::Abort "optin failed" }
        }
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in AppOptIn: $EXCEPTION"
    }
}

# App Call with 1 argument
proc ::AlgorandGoal::AppCall { APP_ID WALLET_NAME WALLET_PASSWORD ACCOUNT_ADDRESS APP_ARG1 DATA_DIR } {
    set timeout 60
    if { [ catch {
        puts "app call with 1 arg: '$APP_ARG1'"
        spawn goal app call --app-id $APP_ID --app-arg $APP_ARG1 -w $WALLET_NAME --from $ACCOUNT_ADDRESS -d $DATA_DIR
        expect {
            timeout { puts timeout; ::AlgorandGoal::Abort  "\n Failed to see expected output" }
            "Please enter the password for wallet '$WALLET_NAME':" {send "$WALLET_PASSWORD\r" ; exp_continue}
            "*committed in round*" {puts "app call succeeded"; close}
            eof {close; ::AlgorandGoal::Abort "app call failed" }
        }
    } EXCEPTION ] } {
        ::AlgorandGoal::Abort "ERROR in AppCall: $EXCEPTION"
    }
}

# App Call with 2 arguments
proc ::AlgorandGoal::AppCall2 { APP_ID WALLET_NAME WALLET_PASSWORD ACCOUNT_ADDRESS APP_ARG1 APP_ARG2 DATA_DIR } {
  set timeout 60
  if { [ catch {
      puts "app call with 2 args: '$APP_ARG1' and '$APP_ARG2'"
      spawn goal app call --app-id $APP_ID --app-arg $APP_ARG1 --app-arg $APP_ARG2 -w $WALLET_NAME --from $ACCOUNT_ADDRESS -d $DATA_DIR
      expect {
          timeout { puts timeout; ::AlgorandGoal::Abort  "\n Failed to see expected output" }
          "Please enter the password for wallet '$WALLET_NAME':" {send "$WALLET_PASSWORD\r" ; exp_continue}
          "*committed in round*" {puts "app call succeeded"; close}
          eof {close; ::AlgorandGoal::Abort "app call failed" }
      }
  } EXCEPTION ] } {
     ::AlgorandGoal::Abort "ERROR in AppCall2: $EXCEPTION"
  }
}

# App Closeout with 1 argument
proc ::AlgorandGoal::AppCloseout { APP_ID WALLET_NAME WALLET_PASSWORD ACCOUNT_ADDRESS APP_ARG1 DATA_DIR } {
    set timeout 60
    if { [ catch {
        puts "calling goal app close out with first arg '$APP_ARG1'"
        spawn goal app closeout --app-id $APP_ID --app-arg $APP_ARG1 -w $WALLET_NAME --from $ACCOUNT_ADDRESS -d $DATA_DIR
        expect {
            timeout { puts timeout; ::AlgorandGoal::Abort  "\n Failed to see expected output" }
            "Please enter the password for wallet '$WALLET_NAME':" {send "$WALLET_PASSWORD\r" ; exp_continue }
            "*committed in round*" {puts "app closeout succeeded"; close}
            eof {close; ::AlgorandGoal::Abort "app closeout failed"}
        }
    } EXCEPTION ] } {
        ::AlgorandGoal::Abort "ERROR in AppCloseout: $EXCEPTION"
    }
}

# App Delete with 1 argument
proc ::AlgorandGoal::AppDelete { APP_ID WALLET_NAME WALLET_PASSWORD ACCOUNT_ADDRESS APP_ARG1 DATA_DIR } {
    set timeout 60
    if { [ catch {
        puts "call app delete with '$APP_ARG1'"
        spawn goal app delete --app-id $APP_ID --app-arg $APP_ARG1 -w $WALLET_NAME --from $ACCOUNT_ADDRESS -d $DATA_DIR
        expect {
            timeout { puts timeout; ::AlgorandGoal::Abort  "\n Failed to see expected output" }
            "Please enter the password for wallet '$WALLET_NAME':" {send "$WALLET_PASSWORD\r" ; exp_continue}
            "*committed in round*" {puts "app delete successful"; close}
            eof {close; ::AlgorandGoal::Abort "app delete failed" }
        }
    } EXCEPTION ] } {
        ::AlgorandGoal::Abort "ERROR in AppDelete: $EXCEPTION"
    }
}

# Compile teal program
proc ::AlgorandGoal::AppCompile {  INPUT_PROGRAM COMPILED_OUTPUT DATA_DIR } {
    set timeout 60
    if { [ catch {
        puts "calling goal clerk compile for $INPUT_PROGRAM"
        exec goal clerk compile ${INPUT_PROGRAM} -o ${COMPILED_OUTPUT} -d ${DATA_DIR}
    } EXCEPTION ] } {
       ::AlgorandGoal::Abort "ERROR in AppCompile: $EXCEPTION"
    }
}

# CheckEOF checks if there was an error, and aborts if there was an error
proc ::AlgorandGoal::CheckEOF { { ERROR_STRING "" } } {
    upvar spawn_id spawn_id
    catch { wait -i $spawn_id } result;
    if { [lindex $result 3] != 0 } {
        puts $ERROR_STRING
        puts "returned error code is [lindex $result 3]"
        exit 1
    }
}
