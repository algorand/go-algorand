// Code generated by gen.go; DO NOT EDIT.

package vpack

const (
	staticIdxMapMarker0  uint8 = 0xc0
	staticIdxMapMarker1  uint8 = 0xc1
	staticIdxMapMarker2  uint8 = 0xc2
	staticIdxMapMarker3  uint8 = 0xc3
	staticIdxMapMarker4  uint8 = 0xc4
	staticIdxMapMarker5  uint8 = 0xc5
	staticIdxMapMarker6  uint8 = 0xc6
	staticIdxCredField   uint8 = 0xd0
	staticIdxPfField     uint8 = 0xd1
	staticIdxRField      uint8 = 0xd2
	staticIdxPerField    uint8 = 0xd3
	staticIdxPropField   uint8 = 0xd4
	staticIdxDigField    uint8 = 0xd5
	staticIdxEncdigField uint8 = 0xd6
	staticIdxOperField   uint8 = 0xd7
	staticIdxOpropField  uint8 = 0xd8
	staticIdxRndField    uint8 = 0xd9
	staticIdxSndField    uint8 = 0xda
	staticIdxStepField   uint8 = 0xdb
	staticIdxSigField    uint8 = 0xdc
	staticIdxPField      uint8 = 0xdd
	staticIdxP1sField    uint8 = 0xde
	staticIdxP2Field     uint8 = 0xdf
	staticIdxP2sField    uint8 = 0xe0
	staticIdxPsField     uint8 = 0xe1
	staticIdxSField      uint8 = 0xe2

	// Constants for static index range bounds
	staticIdxStart uint8 = 0xc0
	staticIdxEnd   uint8 = 0xe2
)

var staticTable = createGeneratedStaticTable()

// createGeneratedStaticTable initializes the static table with common msgpack patterns
func createGeneratedStaticTable() [][]byte {
	t := make([][]byte, 256)

	// Basic entries
	t[staticIdxMapMarker0] = []byte{0x80}                                // Map with 0 items
	t[staticIdxMapMarker1] = []byte{0x81}                                // Map with 1 items
	t[staticIdxMapMarker2] = []byte{0x82}                                // Map with 2 items
	t[staticIdxMapMarker3] = []byte{0x83}                                // Map with 3 items
	t[staticIdxMapMarker4] = []byte{0x84}                                // Map with 4 items
	t[staticIdxMapMarker5] = []byte{0x85}                                // Map with 5 items
	t[staticIdxMapMarker6] = []byte{0x86}                                // Map with 6 items
	t[staticIdxCredField] = []byte{0xa4, 'c', 'r', 'e', 'd'}             // "cred" field
	t[staticIdxPfField] = []byte{0xa2, 'p', 'f'}                         // "pf" field
	t[staticIdxRField] = []byte{0xa1, 'r'}                               // "r" field
	t[staticIdxPerField] = []byte{0xa3, 'p', 'e', 'r'}                   // "per" field
	t[staticIdxPropField] = []byte{0xa4, 'p', 'r', 'o', 'p'}             // "prop" field
	t[staticIdxDigField] = []byte{0xa3, 'd', 'i', 'g'}                   // "dig" field
	t[staticIdxEncdigField] = []byte{0xa6, 'e', 'n', 'c', 'd', 'i', 'g'} // "encdig" field
	t[staticIdxOperField] = []byte{0xa4, 'o', 'p', 'e', 'r'}             // "oper" field
	t[staticIdxOpropField] = []byte{0xa5, 'o', 'p', 'r', 'o', 'p'}       // "oprop" field
	t[staticIdxRndField] = []byte{0xa3, 'r', 'n', 'd'}                   // "rnd" field
	t[staticIdxSndField] = []byte{0xa3, 's', 'n', 'd'}                   // "snd" field
	t[staticIdxStepField] = []byte{0xa4, 's', 't', 'e', 'p'}             // "step" field
	t[staticIdxSigField] = []byte{0xa3, 's', 'i', 'g'}                   // "sig" field
	t[staticIdxPField] = []byte{0xa1, 'p'}                               // "p" field
	t[staticIdxP1sField] = []byte{0xa3, 'p', '1', 's'}                   // "p1s" field
	t[staticIdxP2Field] = []byte{0xa2, 'p', '2'}                         // "p2" field
	t[staticIdxP2sField] = []byte{0xa3, 'p', '2', 's'}                   // "p2s" field
	t[staticIdxPsField] = []byte{0xa2, 'p', 's'}                         // "ps" field
	t[staticIdxSField] = []byte{0xa1, 's'}                               // "s" field

	return t
}
