// Code generated by gen.go; DO NOT EDIT.

package vpack

import (
	"fmt"
)

func parseVote(data []byte, c compressWriter) error {
	p := newParser(data)

	// Fixed size struct with 3 fields
	cnt, err := p.readFixMap()
	if err != nil {
		return fmt.Errorf("reading map for unauthenticatedVote: %w", err)
	}
	if cnt != 3 {
		return fmt.Errorf("expected fixed map size 3 for unauthenticatedVote, got %d", cnt)
	}
	c.writeStatic(staticIdxMapMarker3)

	for range 3 {

		key, err := p.readString()
		if err != nil {
			return fmt.Errorf("reading key for unauthenticatedVote: %w", err)
		}

		switch string(key) {
		case "cred":
			c.writeStatic(staticIdxCredField)

			// Fixed size struct with 1 fields
			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for UnauthenticatedCredential: %w", err)
			}
			if cnt != 1 {
				return fmt.Errorf("expected fixed map size 1 for UnauthenticatedCredential, got %d", cnt)
			}
			c.writeStatic(staticIdxMapMarker1)

			for range 1 {

				key, err := p.readString()
				if err != nil {
					return fmt.Errorf("reading key for UnauthenticatedCredential: %w", err)
				}

				switch string(key) {
				case "pf":
					c.writeStatic(staticIdxPfField)
					val, err := p.readBin80()
					if err != nil {
						return fmt.Errorf("reading pf: %w", err)
					}

					c.writeLiteralBin80(val)
				default:
					return fmt.Errorf("unexpected field in UnauthenticatedCredential: %q", key)
				}
			}

		case "r":
			c.writeStatic(staticIdxRField)

			// Variable size struct
			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for rawVote: %w", err)
			}
			if cnt < 1 || cnt > 5 {
				return fmt.Errorf("expected fixmap size for rawVote 1 <= cnt <= 5, got %d", cnt)
			}
			c.writeStatic(staticIdxMapMarker0 + cnt)

			for range cnt {

				key, err := p.readString()
				if err != nil {
					return fmt.Errorf("reading key for rawVote: %w", err)
				}

				switch string(key) {
				case "per":
					c.writeStatic(staticIdxPerField)
					valBytes, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading per: %w", err)
					}

					if err := c.writeDynamicVaruint(valBytes); err != nil {
						return fmt.Errorf("writing per: %w", err)
					}
				case "prop":
					c.writeStatic(staticIdxPropField)

					// Variable size struct
					cnt, err := p.readFixMap()
					if err != nil {
						return fmt.Errorf("reading map for proposalValue: %w", err)
					}
					if cnt < 1 || cnt > 4 {
						return fmt.Errorf("expected fixmap size for proposalValue 1 <= cnt <= 4, got %d", cnt)
					}
					c.writeStatic(staticIdxMapMarker0 + cnt)

					for range cnt {

						key, err := p.readString()
						if err != nil {
							return fmt.Errorf("reading key for proposalValue: %w", err)
						}

						switch string(key) {
						case "dig":
							c.writeStatic(staticIdxDigField)
							val, err := p.readBin32()
							if err != nil {
								return fmt.Errorf("reading dig: %w", err)
							}

							c.writeDynamicBin32(val)
						case "encdig":
							c.writeStatic(staticIdxEncdigField)
							val, err := p.readBin32()
							if err != nil {
								return fmt.Errorf("reading encdig: %w", err)
							}

							c.writeDynamicBin32(val)
						case "oper":
							c.writeStatic(staticIdxOperField)
							valBytes, err := p.readUintBytes()
							if err != nil {
								return fmt.Errorf("reading oper: %w", err)
							}

							if err := c.writeDynamicVaruint(valBytes); err != nil {
								return fmt.Errorf("writing oper: %w", err)
							}
						case "oprop":
							c.writeStatic(staticIdxOpropField)
							val, err := p.readBin32()
							if err != nil {
								return fmt.Errorf("reading oprop: %w", err)
							}

							c.writeDynamicBin32(val)
						default:
							return fmt.Errorf("unexpected field in proposalValue: %q", key)
						}
					}

				case "rnd":
					c.writeStatic(staticIdxRndField)
					valBytes, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading rnd: %w", err)
					}

					if err := c.writeDynamicVaruint(valBytes); err != nil {
						return fmt.Errorf("writing rnd: %w", err)
					}
				case "snd":
					c.writeStatic(staticIdxSndField)
					val, err := p.readBin32()
					if err != nil {
						return fmt.Errorf("reading snd: %w", err)
					}

					c.writeDynamicBin32(val)
				case "step":

					valBytes, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading step: %w", err)
					}
					// If we have special single-byte numeric values
					if len(valBytes) == 1 {
						switch valBytes[0] {
						case 1:
							c.writeStatic(staticIdxStepVal1Field)
							continue
						case 2:
							c.writeStatic(staticIdxStepVal2Field)
							continue
						case 3:
							c.writeStatic(staticIdxStepVal3Field)
							continue
						}
					}

					c.writeStatic(staticIdxStepField)
					if err := c.writeDynamicVaruint(valBytes); err != nil {
						return fmt.Errorf("writing step: %w", err)
					}
				default:
					return fmt.Errorf("unexpected field in rawVote: %q", key)
				}
			}

		case "sig":
			c.writeStatic(staticIdxSigField)

			// Fixed size struct with 6 fields
			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for OneTimeSignature: %w", err)
			}
			if cnt != 6 {
				return fmt.Errorf("expected fixed map size 6 for OneTimeSignature, got %d", cnt)
			}
			c.writeStatic(staticIdxMapMarker6)

			for range 6 {

				key, err := p.readString()
				if err != nil {
					return fmt.Errorf("reading key for OneTimeSignature: %w", err)
				}

				switch string(key) {
				case "p":
					c.writeStatic(staticIdxPField)
					val, err := p.readBin32()
					if err != nil {
						return fmt.Errorf("reading p: %w", err)
					}

					c.writeDynamicBin32(val)
				case "p1s":
					c.writeStatic(staticIdxP1sField)
					val, err := p.readBin64()
					if err != nil {
						return fmt.Errorf("reading p1s: %w", err)
					}

					c.writeLiteralBin64(val)
				case "p2":
					c.writeStatic(staticIdxP2Field)
					val, err := p.readBin32()
					if err != nil {
						return fmt.Errorf("reading p2: %w", err)
					}

					c.writeDynamicBin32(val)
				case "p2s":
					c.writeStatic(staticIdxP2sField)
					val, err := p.readBin64()
					if err != nil {
						return fmt.Errorf("reading p2s: %w", err)
					}

					c.writeLiteralBin64(val)
				case "ps":

					val, err := p.readBin64()
					if err != nil {
						return fmt.Errorf("reading ps: %w", err)
					}
					if val == [64]byte{} {
						c.writeStatic(staticIdxAllZeroPsField)
					} else {
						c.writeStatic(staticIdxPsField)
						c.writeLiteralBin64(val)
					}
				case "s":
					c.writeStatic(staticIdxSField)
					val, err := p.readBin64()
					if err != nil {
						return fmt.Errorf("reading s: %w", err)
					}

					c.writeLiteralBin64(val)
				default:
					return fmt.Errorf("unexpected field in OneTimeSignature: %q", key)
				}
			}

		default:
			return fmt.Errorf("unexpected field in unauthenticatedVote: %q", key)
		}
	}

	// Check for trailing bytes
	if p.pos < len(p.data) {
		return fmt.Errorf("unexpected trailing data: %d bytes remain unprocessed", len(p.data)-p.pos)
	}

	return nil
}
