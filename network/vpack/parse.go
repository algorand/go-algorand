// Code generated by gen.go; DO NOT EDIT.

package vpack

import (
	"fmt"
)

func parseVote(data []byte, c compressWriter) error {
	p := newParser(data)

	{ // Parse unauthenticatedVote
		cnt, err := p.readFixMap()
		if err != nil {
			return fmt.Errorf("reading map for unauthenticatedVote: %w", err)
		}
		// Assert unauthenticatedVote struct has 3 fields
		if cnt != 3 {
			return fmt.Errorf("expected fixed map size 3 for unauthenticatedVote, got %d", cnt)
		}
		c.writeStatic(staticIdxMapMarker3)

		// Required field for unauthenticatedVote: cred
		if err := p.expectString("cred"); err != nil {
			return err
		}
		c.writeStatic(staticIdxCredField)

		{ // Parse UnauthenticatedCredential
			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for UnauthenticatedCredential: %w", err)
			}
			// Assert UnauthenticatedCredential struct has 1 fields
			if cnt != 1 {
				return fmt.Errorf("expected fixed map size 1 for UnauthenticatedCredential, got %d", cnt)
			}
			c.writeStatic(staticIdxMapMarker1)

			// Required field for UnauthenticatedCredential: pf
			if err := p.expectString("pf"); err != nil {
				return err
			}
			if val, err := p.readBin80(); err != nil {
				return fmt.Errorf("reading pf: %w", err)
			} else {
				c.writeBin80(staticIdxPfField, val)
			}
		}

		// Required field for unauthenticatedVote: r
		if err := p.expectString("r"); err != nil {
			return err
		}
		c.writeStatic(staticIdxRField)

		{ // Parse rawVote
			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for rawVote: %w", err)
			}
			if cnt < 1 || cnt > 5 {
				return fmt.Errorf("expected fixmap size for rawVote 1 <= cnt <= 5, got %d", cnt)
			}
			c.writeStatic(staticIdxMapMarker0 + cnt)

			for range cnt {
				key, err := p.readString()
				if err != nil {
					return fmt.Errorf("reading key for rawVote: %w", err)
				}

				switch string(key) {
				case "per":
					val, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading per: %w", err)
					}
					if err := c.writeVaruint(staticIdxPerField, val); err != nil {
						return fmt.Errorf("writing per: %w", err)
					}
				case "prop":
					c.writeStatic(staticIdxPropField)

					{ // Parse proposalValue
						cnt, err := p.readFixMap()
						if err != nil {
							return fmt.Errorf("reading map for proposalValue: %w", err)
						}
						if cnt < 1 || cnt > 4 {
							return fmt.Errorf("expected fixmap size for proposalValue 1 <= cnt <= 4, got %d", cnt)
						}
						c.writeStatic(staticIdxMapMarker0 + cnt)

						for range cnt {
							key, err := p.readString()
							if err != nil {
								return fmt.Errorf("reading key for proposalValue: %w", err)
							}

							switch string(key) {
							case "dig":
								if val, err := p.readBin32(); err != nil {
									return fmt.Errorf("reading dig: %w", err)
								} else {
									c.writeBin32(staticIdxDigField, val)
								}
							case "encdig":
								if val, err := p.readBin32(); err != nil {
									return fmt.Errorf("reading encdig: %w", err)
								} else {
									c.writeBin32(staticIdxEncdigField, val)
								}
							case "oper":
								val, err := p.readUintBytes()
								if err != nil {
									return fmt.Errorf("reading oper: %w", err)
								}
								if err := c.writeVaruint(staticIdxOperField, val); err != nil {
									return fmt.Errorf("writing oper: %w", err)
								}
							case "oprop":
								if val, err := p.readBin32(); err != nil {
									return fmt.Errorf("reading oprop: %w", err)
								} else {
									c.writeBin32(staticIdxOpropField, val)
								}
							default:
								return fmt.Errorf("unexpected field in proposalValue: %q", key)
							}
						}
					}

				case "rnd":
					val, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading rnd: %w", err)
					}
					if err := c.writeVaruint(staticIdxRndField, val); err != nil {
						return fmt.Errorf("writing rnd: %w", err)
					}
				case "snd":
					if val, err := p.readBin32(); err != nil {
						return fmt.Errorf("reading snd: %w", err)
					} else {
						c.writeBin32(staticIdxSndField, val)
					}
				case "step":
					val, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading step: %w", err)
					}
					if err := c.writeVaruint(staticIdxStepField, val); err != nil {
						return fmt.Errorf("writing step: %w", err)
					}
				default:
					return fmt.Errorf("unexpected field in rawVote: %q", key)
				}
			}
		}

		// Required field for unauthenticatedVote: sig
		if err := p.expectString("sig"); err != nil {
			return err
		}
		c.writeStatic(staticIdxSigField)

		{ // Parse OneTimeSignature
			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for OneTimeSignature: %w", err)
			}
			// Assert OneTimeSignature struct has 6 fields
			if cnt != 6 {
				return fmt.Errorf("expected fixed map size 6 for OneTimeSignature, got %d", cnt)
			}
			c.writeStatic(staticIdxMapMarker6)

			// Required field for OneTimeSignature: p
			if err := p.expectString("p"); err != nil {
				return err
			}
			if val, err := p.readBin32(); err != nil {
				return fmt.Errorf("reading p: %w", err)
			} else {
				c.writeBin32(staticIdxPField, val)
			}

			// Required field for OneTimeSignature: p1s
			if err := p.expectString("p1s"); err != nil {
				return err
			}
			if val, err := p.readBin64(); err != nil {
				return fmt.Errorf("reading p1s: %w", err)
			} else {
				c.writeBin64(staticIdxP1sField, val)
			}

			// Required field for OneTimeSignature: p2
			if err := p.expectString("p2"); err != nil {
				return err
			}
			if val, err := p.readBin32(); err != nil {
				return fmt.Errorf("reading p2: %w", err)
			} else {
				c.writeBin32(staticIdxP2Field, val)
			}

			// Required field for OneTimeSignature: p2s
			if err := p.expectString("p2s"); err != nil {
				return err
			}
			if val, err := p.readBin64(); err != nil {
				return fmt.Errorf("reading p2s: %w", err)
			} else {
				c.writeBin64(staticIdxP2sField, val)
			}

			// Required field for OneTimeSignature: ps
			if err := p.expectString("ps"); err != nil {
				return err
			}
			if val, err := p.readBin64(); err != nil {
				return fmt.Errorf("reading ps: %w", err)
			} else {
				if val != [64]byte{} { // must always be empty
					return fmt.Errorf("expected empty array for ps, got %v", val)
				}
			}

			// Required field for OneTimeSignature: s
			if err := p.expectString("s"); err != nil {
				return err
			}
			if val, err := p.readBin64(); err != nil {
				return fmt.Errorf("reading s: %w", err)
			} else {
				c.writeBin64(staticIdxSField, val)
			}
		}

	}

	// Check for trailing bytes
	if p.pos < len(p.data) {
		return fmt.Errorf("unexpected trailing data: %d bytes remain unprocessed", len(p.data)-p.pos)
	}

	return nil
}
