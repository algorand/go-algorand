// go generate gen.go
// Code generated by gen.go; DO NOT EDIT.

package vpack

import (
	"fmt"
)

func parseVote(data []byte, c compressWriter) error {
	p := newParser(data)

	cnt, err := p.readFixMap()
	if err != nil {
		return fmt.Errorf("reading map for unauthenticatedVote: %w", err)
	}
	if cnt < 1 || cnt > 3 {
		return fmt.Errorf("expected fixmap size for unauthenticatedVote 1 <= cnt <= 3, got %d", cnt)
	}
	c.writeStatic(StaticIdxMapMarker0 + cnt)

	for range cnt {
		key, err := p.readString()
		if err != nil {
			return fmt.Errorf("reading key for unauthenticatedVote: %w", err)
		}

		switch string(key) {
		case "cred":
			c.writeStatic(StaticIdxCredField)

			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for UnauthenticatedCredential: %w", err)
			}
			if cnt < 1 || cnt > 1 {
				return fmt.Errorf("expected fixmap size for UnauthenticatedCredential 1 <= cnt <= 1, got %d", cnt)
			}
			c.writeStatic(StaticIdxMapMarker0 + cnt)

			for range cnt {
				key, err := p.readString()
				if err != nil {
					return fmt.Errorf("reading key for UnauthenticatedCredential: %w", err)
				}

				switch string(key) {
				case "pf":
					c.writeStatic(StaticIdxPfField)
					val, err := p.readBin80()
					if err != nil {
						return fmt.Errorf("reading pf: %w", err)
					}

					c.writeLiteralBin80(val)
				default:
					return fmt.Errorf("unexpected field in UnauthenticatedCredential: %q", key)
				}
			}

		case "r":
			c.writeStatic(StaticIdxRField)

			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for rawVote: %w", err)
			}
			if cnt < 1 || cnt > 5 {
				return fmt.Errorf("expected fixmap size for rawVote 1 <= cnt <= 5, got %d", cnt)
			}
			c.writeStatic(StaticIdxMapMarker0 + cnt)

			for range cnt {
				key, err := p.readString()
				if err != nil {
					return fmt.Errorf("reading key for rawVote: %w", err)
				}

				switch string(key) {
				case "per":
					c.writeStatic(StaticIdxPerField)
					valBytes, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading per: %w", err)
					}

					c.writeDynamicVaruint(valBytes)
				case "prop":
					c.writeStatic(StaticIdxPropField)

					cnt, err := p.readFixMap()
					if err != nil {
						return fmt.Errorf("reading map for proposalValue: %w", err)
					}
					if cnt < 1 || cnt > 4 {
						return fmt.Errorf("expected fixmap size for proposalValue 1 <= cnt <= 4, got %d", cnt)
					}
					c.writeStatic(StaticIdxMapMarker0 + cnt)

					for range cnt {
						key, err := p.readString()
						if err != nil {
							return fmt.Errorf("reading key for proposalValue: %w", err)
						}

						switch string(key) {
						case "dig":
							c.writeStatic(StaticIdxDigField)
							val, err := p.readBin32()
							if err != nil {
								return fmt.Errorf("reading dig: %w", err)
							}

							c.writeDynamicBin32(val)
						case "encdig":
							c.writeStatic(StaticIdxEncdigField)
							val, err := p.readBin32()
							if err != nil {
								return fmt.Errorf("reading encdig: %w", err)
							}

							c.writeDynamicBin32(val)
						case "oper":
							c.writeStatic(StaticIdxOperField)
							valBytes, err := p.readUintBytes()
							if err != nil {
								return fmt.Errorf("reading oper: %w", err)
							}

							c.writeDynamicVaruint(valBytes)
						case "oprop":
							c.writeStatic(StaticIdxOpropField)
							val, err := p.readBin32()
							if err != nil {
								return fmt.Errorf("reading oprop: %w", err)
							}

							c.writeDynamicBin32(val)
						default:
							return fmt.Errorf("unexpected field in proposalValue: %q", key)
						}
					}

				case "rnd":
					c.writeStatic(StaticIdxRndField)
					valBytes, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading rnd: %w", err)
					}

					c.writeDynamicVaruint(valBytes)
				case "snd":
					c.writeStatic(StaticIdxSndField)
					val, err := p.readBin32()
					if err != nil {
						return fmt.Errorf("reading snd: %w", err)
					}

					c.writeDynamicBin32(val)
				case "step":

					valBytes, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading step: %w", err)
					}
					// If we have special single-byte numeric values
					if len(valBytes) == 1 {
						switch valBytes[0] {
						case 1:
							c.writeStatic(StaticIdxStepVal1Field)
							continue
						case 2:
							c.writeStatic(StaticIdxStepVal2Field)
							continue
						case 3:
							c.writeStatic(StaticIdxStepVal3Field)
							continue
						}
					}

					c.writeStatic(StaticIdxStepField)
					c.writeDynamicVaruint(valBytes)
				default:
					return fmt.Errorf("unexpected field in rawVote: %q", key)
				}
			}

		case "sig":
			c.writeStatic(StaticIdxSigField)

			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for OneTimeSignature: %w", err)
			}
			if cnt < 1 || cnt > 6 {
				return fmt.Errorf("expected fixmap size for OneTimeSignature 1 <= cnt <= 6, got %d", cnt)
			}
			c.writeStatic(StaticIdxMapMarker0 + cnt)

			for range cnt {
				key, err := p.readString()
				if err != nil {
					return fmt.Errorf("reading key for OneTimeSignature: %w", err)
				}

				switch string(key) {
				case "p":
					c.writeStatic(StaticIdxPField)
					val, err := p.readBin32()
					if err != nil {
						return fmt.Errorf("reading p: %w", err)
					}

					c.writeDynamicBin32(val)
				case "p1s":
					c.writeStatic(StaticIdxP1sField)
					val, err := p.readBin64()
					if err != nil {
						return fmt.Errorf("reading p1s: %w", err)
					}

					c.writeLiteralBin64(val)
				case "p2":
					c.writeStatic(StaticIdxP2Field)
					val, err := p.readBin32()
					if err != nil {
						return fmt.Errorf("reading p2: %w", err)
					}

					c.writeDynamicBin32(val)
				case "p2s":
					c.writeStatic(StaticIdxP2sField)
					val, err := p.readBin64()
					if err != nil {
						return fmt.Errorf("reading p2s: %w", err)
					}

					c.writeLiteralBin64(val)
				case "ps":

					val, err := p.readBin64()
					if err != nil {
						return fmt.Errorf("reading ps: %w", err)
					}
					if val == [64]byte{} {
						c.writeStatic(StaticIdxAllZeroPsField)
					} else {
						c.writeStatic(StaticIdxPsField)
						c.writeLiteralBin64(val)
					}
				case "s":
					c.writeStatic(StaticIdxSField)
					val, err := p.readBin64()
					if err != nil {
						return fmt.Errorf("reading s: %w", err)
					}

					c.writeLiteralBin64(val)
				default:
					return fmt.Errorf("unexpected field in OneTimeSignature: %q", key)
				}
			}

		default:
			return fmt.Errorf("unexpected field in unauthenticatedVote: %q", key)
		}
	}

	return nil
}
