// Code generated by gen.go; DO NOT EDIT.

package vpack

import (
	"fmt"
)

func parseVote(data []byte, c compressWriter) error {
	p := newParser(data)

	cnt, err := p.readFixMap()
	if err != nil {
		return fmt.Errorf("reading map for unauthenticatedVote: %w", err)
	}

	if cnt != 3 {
		return fmt.Errorf("expected fixed map size 3 for unauthenticatedVote, got %d", cnt)
	}
	c.writeStatic(staticIdxMapMarker3)

	for range 3 {

		key, err := p.readString()
		if err != nil {
			return fmt.Errorf("reading key for unauthenticatedVote: %w", err)
		}

		switch string(key) {
		case "cred":
			c.writeStatic(staticIdxCredField)

			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for UnauthenticatedCredential: %w", err)
			}

			if cnt != 1 {
				return fmt.Errorf("expected fixed map size 1 for UnauthenticatedCredential, got %d", cnt)
			}
			c.writeStatic(staticIdxMapMarker1)

			for range 1 {

				key, err := p.readString()
				if err != nil {
					return fmt.Errorf("reading key for UnauthenticatedCredential: %w", err)
				}

				switch string(key) {
				case "pf":
					val, err := p.readBin80()
					if err != nil {
						return fmt.Errorf("reading pf: %w", err)
					}
					c.writeLiteralBin80(staticIdxPfField, val)
				default:
					return fmt.Errorf("unexpected field in UnauthenticatedCredential: %q", key)
				}
			}

		case "r":
			c.writeStatic(staticIdxRField)

			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for rawVote: %w", err)
			}

			if cnt < 1 || cnt > 5 {
				return fmt.Errorf("expected fixmap size for rawVote 1 <= cnt <= 5, got %d", cnt)
			}
			c.writeStatic(staticIdxMapMarker0 + cnt)

			for range cnt {
				key, err := p.readString()
				if err != nil {
					return fmt.Errorf("reading key for rawVote: %w", err)
				}

				switch string(key) {
				case "per":
					valBytes, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading per: %w", err)
					}
					if err := c.writeDynamicVaruint(staticIdxPerField, valBytes); err != nil {
						return fmt.Errorf("writing per: %w", err)
					}
				case "prop":
					c.writeStatic(staticIdxPropField)

					cnt, err := p.readFixMap()
					if err != nil {
						return fmt.Errorf("reading map for proposalValue: %w", err)
					}

					if cnt < 1 || cnt > 4 {
						return fmt.Errorf("expected fixmap size for proposalValue 1 <= cnt <= 4, got %d", cnt)
					}
					c.writeStatic(staticIdxMapMarker0 + cnt)

					for range cnt {
						key, err := p.readString()
						if err != nil {
							return fmt.Errorf("reading key for proposalValue: %w", err)
						}

						switch string(key) {
						case "dig":
							val, err := p.readBin32()
							if err != nil {
								return fmt.Errorf("reading dig: %w", err)
							}
							c.writeDynamicBin32(staticIdxDigField, val)
						case "encdig":
							val, err := p.readBin32()
							if err != nil {
								return fmt.Errorf("reading encdig: %w", err)
							}
							c.writeDynamicBin32(staticIdxEncdigField, val)
						case "oper":
							valBytes, err := p.readUintBytes()
							if err != nil {
								return fmt.Errorf("reading oper: %w", err)
							}
							if err := c.writeDynamicVaruint(staticIdxOperField, valBytes); err != nil {
								return fmt.Errorf("writing oper: %w", err)
							}
						case "oprop":
							val, err := p.readBin32()
							if err != nil {
								return fmt.Errorf("reading oprop: %w", err)
							}
							c.writeDynamicBin32(staticIdxOpropField, val)
						default:
							return fmt.Errorf("unexpected field in proposalValue: %q", key)
						}
					}

				case "rnd":
					valBytes, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading rnd: %w", err)
					}
					if err := c.writeDynamicVaruint(staticIdxRndField, valBytes); err != nil {
						return fmt.Errorf("writing rnd: %w", err)
					}
				case "snd":
					val, err := p.readBin32()
					if err != nil {
						return fmt.Errorf("reading snd: %w", err)
					}
					c.writeDynamicBin32(staticIdxSndField, val)
				case "step":
					valBytes, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading step: %w", err)
					}
					if err := c.writeDynamicVaruint(staticIdxStepField, valBytes); err != nil {
						return fmt.Errorf("writing step: %w", err)
					}
				default:
					return fmt.Errorf("unexpected field in rawVote: %q", key)
				}
			}

		case "sig":
			c.writeStatic(staticIdxSigField)

			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for OneTimeSignature: %w", err)
			}

			if cnt != 6 {
				return fmt.Errorf("expected fixed map size 6 for OneTimeSignature, got %d", cnt)
			}
			c.writeStatic(staticIdxMapMarker6)

			for range 6 {

				key, err := p.readString()
				if err != nil {
					return fmt.Errorf("reading key for OneTimeSignature: %w", err)
				}

				switch string(key) {
				case "p":
					val, err := p.readBin32()
					if err != nil {
						return fmt.Errorf("reading p: %w", err)
					}
					c.writeDynamicBin32(staticIdxPField, val)
				case "p1s":
					val, err := p.readBin64()
					if err != nil {
						return fmt.Errorf("reading p1s: %w", err)
					}
					c.writeLiteralBin64(staticIdxP1sField, val)
				case "p2":
					val, err := p.readBin32()
					if err != nil {
						return fmt.Errorf("reading p2: %w", err)
					}
					c.writeDynamicBin32(staticIdxP2Field, val)
				case "p2s":
					val, err := p.readBin64()
					if err != nil {
						return fmt.Errorf("reading p2s: %w", err)
					}
					c.writeLiteralBin64(staticIdxP2sField, val)
				case "ps":
					val, err := p.readBin64()
					if err != nil {
						return fmt.Errorf("reading ps: %w", err)
					}
					if val != [64]byte{} {
						return fmt.Errorf("expected empty array for ps, got %v", val)
					}
				case "s":
					val, err := p.readBin64()
					if err != nil {
						return fmt.Errorf("reading s: %w", err)
					}
					c.writeLiteralBin64(staticIdxSField, val)
				default:
					return fmt.Errorf("unexpected field in OneTimeSignature: %q", key)
				}
			}

		default:
			return fmt.Errorf("unexpected field in unauthenticatedVote: %q", key)
		}
	}

	// Check for trailing bytes
	if p.pos < len(p.data) {
		return fmt.Errorf("unexpected trailing data: %d bytes remain unprocessed", len(p.data)-p.pos)
	}

	return nil
}
