// Code generated by gen.go; DO NOT EDIT.

package vpack

import "fmt"

// voteValueType enumerates every value-bearing field (full path).
type voteValueType uint8

const (
	credPfVoteValue voteValueType = iota
	rPerVoteValue
	rPropDigVoteValue
	rPropEncdigVoteValue
	rPropOperVoteValue
	rPropOpropVoteValue
	rRndVoteValue
	rSndVoteValue
	rStepVoteValue
	sigP1sVoteValue
	sigP2VoteValue
	sigP2sVoteValue
	sigPVoteValue
	sigPsVoteValue
	sigSVoteValue
)

const (
	msgpFixstrCred   = "\xa4cred"
	msgpFixstrDig    = "\xa3dig"
	msgpFixstrEncdig = "\xa6encdig"
	msgpFixstrOper   = "\xa4oper"
	msgpFixstrOprop  = "\xa5oprop"
	msgpFixstrP      = "\xa1p"
	msgpFixstrP1s    = "\xa3p1s"
	msgpFixstrP2     = "\xa2p2"
	msgpFixstrP2s    = "\xa3p2s"
	msgpFixstrPer    = "\xa3per"
	msgpFixstrPf     = "\xa2pf"
	msgpFixstrProp   = "\xa4prop"
	msgpFixstrPs     = "\xa2ps"
	msgpFixstrR      = "\xa1r"
	msgpFixstrRnd    = "\xa3rnd"
	msgpFixstrS      = "\xa1s"
	msgpFixstrSig    = "\xa3sig"
	msgpFixstrSnd    = "\xa3snd"
	msgpFixstrStep   = "\xa4step"
)

func parseVote(data []byte, c compressWriter) error {
	p := newParser(data)

	{ // Parse unauthenticatedVote
		cnt, err := p.readFixMap()
		if err != nil {
			return fmt.Errorf("reading map for unauthenticatedVote: %w", err)
		}
		// Assert unauthenticatedVote struct has 3 fields
		if cnt != 3 {
			return fmt.Errorf("expected fixed map size 3 for unauthenticatedVote, got %d", cnt)
		}
		// Required field for unauthenticatedVote: cred
		if err := p.expectString("cred"); err != nil {
			return err
		}

		{ // Parse UnauthenticatedCredential
			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for UnauthenticatedCredential: %w", err)
			}
			// Assert UnauthenticatedCredential struct has 1 fields
			if cnt != 1 {
				return fmt.Errorf("expected fixed map size 1 for UnauthenticatedCredential, got %d", cnt)
			}
			// Required field for UnauthenticatedCredential: pf
			if err := p.expectString("pf"); err != nil {
				return err
			}
			if val, err := p.readBin80(); err != nil {
				return fmt.Errorf("reading pf: %w", err)
			} else {
				c.writeBin80(credPfVoteValue, val)
			}
		}

		// Required field for unauthenticatedVote: r
		if err := p.expectString("r"); err != nil {
			return err
		}

		{ // Parse rawVote
			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for rawVote: %w", err)
			}
			if cnt < 1 || cnt > 5 {
				return fmt.Errorf("expected fixmap size for rawVote 1 <= cnt <= 5, got %d", cnt)
			}
			for range cnt {
				key, err := p.readString()
				if err != nil {
					return fmt.Errorf("reading key for rawVote: %w", err)
				}
				switch string(key) {
				case "per":
					val, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading per: %w", err)
					}
					c.writeVaruint(rPerVoteValue, val)
				case "prop":

					{ // Parse proposalValue
						cnt, err := p.readFixMap()
						if err != nil {
							return fmt.Errorf("reading map for proposalValue: %w", err)
						}
						if cnt < 1 || cnt > 4 {
							return fmt.Errorf("expected fixmap size for proposalValue 1 <= cnt <= 4, got %d", cnt)
						}
						for range cnt {
							key, err := p.readString()
							if err != nil {
								return fmt.Errorf("reading key for proposalValue: %w", err)
							}
							switch string(key) {
							case "dig":
								if val, err := p.readBin32(); err != nil {
									return fmt.Errorf("reading dig: %w", err)
								} else {
									c.writeBin32(rPropDigVoteValue, val)
								}
							case "encdig":
								if val, err := p.readBin32(); err != nil {
									return fmt.Errorf("reading encdig: %w", err)
								} else {
									c.writeBin32(rPropEncdigVoteValue, val)
								}
							case "oper":
								val, err := p.readUintBytes()
								if err != nil {
									return fmt.Errorf("reading oper: %w", err)
								}
								c.writeVaruint(rPropOperVoteValue, val)
							case "oprop":
								if val, err := p.readBin32(); err != nil {
									return fmt.Errorf("reading oprop: %w", err)
								} else {
									c.writeBin32(rPropOpropVoteValue, val)
								}
							default:
								return fmt.Errorf("unexpected field in proposalValue: %q", key)
							}
						}
					}

				case "rnd":
					val, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading rnd: %w", err)
					}
					c.writeVaruint(rRndVoteValue, val)
				case "snd":
					if val, err := p.readBin32(); err != nil {
						return fmt.Errorf("reading snd: %w", err)
					} else {
						c.writeBin32(rSndVoteValue, val)
					}
				case "step":
					val, err := p.readUintBytes()
					if err != nil {
						return fmt.Errorf("reading step: %w", err)
					}
					c.writeVaruint(rStepVoteValue, val)
				default:
					return fmt.Errorf("unexpected field in rawVote: %q", key)
				}
			}
		}

		// Required field for unauthenticatedVote: sig
		if err := p.expectString("sig"); err != nil {
			return err
		}

		{ // Parse OneTimeSignature
			cnt, err := p.readFixMap()
			if err != nil {
				return fmt.Errorf("reading map for OneTimeSignature: %w", err)
			}
			// Assert OneTimeSignature struct has 6 fields
			if cnt != 6 {
				return fmt.Errorf("expected fixed map size 6 for OneTimeSignature, got %d", cnt)
			}
			// Required field for OneTimeSignature: p
			if err := p.expectString("p"); err != nil {
				return err
			}
			if val, err := p.readBin32(); err != nil {
				return fmt.Errorf("reading p: %w", err)
			} else {
				c.writeBin32(sigPVoteValue, val)
			}
			// Required field for OneTimeSignature: p1s
			if err := p.expectString("p1s"); err != nil {
				return err
			}
			if val, err := p.readBin64(); err != nil {
				return fmt.Errorf("reading p1s: %w", err)
			} else {
				c.writeBin64(sigP1sVoteValue, val)
			}
			// Required field for OneTimeSignature: p2
			if err := p.expectString("p2"); err != nil {
				return err
			}
			if val, err := p.readBin32(); err != nil {
				return fmt.Errorf("reading p2: %w", err)
			} else {
				c.writeBin32(sigP2VoteValue, val)
			}
			// Required field for OneTimeSignature: p2s
			if err := p.expectString("p2s"); err != nil {
				return err
			}
			if val, err := p.readBin64(); err != nil {
				return fmt.Errorf("reading p2s: %w", err)
			} else {
				c.writeBin64(sigP2sVoteValue, val)
			}
			// Required field for OneTimeSignature: ps
			if err := p.expectString("ps"); err != nil {
				return err
			}
			if val, err := p.readBin64(); err != nil {
				return fmt.Errorf("reading ps: %w", err)
			} else {
				if val != [64]byte{} {
					return fmt.Errorf("expected empty array for ps, got %v", val)
				}
			}
			// Required field for OneTimeSignature: s
			if err := p.expectString("s"); err != nil {
				return err
			}
			if val, err := p.readBin64(); err != nil {
				return fmt.Errorf("reading s: %w", err)
			} else {
				c.writeBin64(sigSVoteValue, val)
			}
		}

	}

	// Check for trailing bytes
	if p.pos < len(p.data) {
		return fmt.Errorf("unexpected trailing data: %d bytes remain unprocessed", len(p.data)-p.pos)
	}
	return nil
}
