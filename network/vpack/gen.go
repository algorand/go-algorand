// Copyright (C) 2019-2025 Algorand, Inc.
// This file is part of go-algorand
//
// go-algorand is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// go-algorand is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with go-algorand.  If not, see <https://www.gnu.org/licenses/>.

//go:build ignore

package main

import (
	"fmt"
	"go/format"
	"os"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"text/template"

	"github.com/algorand/go-algorand/agreement"
)

type fixstrItem struct {
	Const string // e.g. msgpFixstrPf
	Lit   string // e.g. "\xa2pf"
}

type codeGenerator struct {
	fixstrs  map[string]fixstrItem
	enums    []string
	enumSeen map[string]struct{}

	parseFns         map[reflect.Type]bool
	parseFuncDataMap map[reflect.Type]parseFuncData
}

type parseFuncData struct {
	TypeName      string
	MaxFieldCount int
	FixedSize     int
	Fields        []fieldData
}

type fieldData struct {
	CodecName string

	EnumConst   string // credPfVoteValue, ...
	FixstrConst string

	IsSubStruct   bool
	SubStructName string
	ArrayLen      int
	AlwaysEmpty   bool
	IsUint64Alias bool
}

func main() {
	gen := &codeGenerator{
		fixstrs:          make(map[string]fixstrItem),
		enumSeen:         make(map[string]struct{}),
		parseFns:         make(map[reflect.Type]bool),
		parseFuncDataMap: make(map[reflect.Type]parseFuncData),
	}

	if err := gen.analyzeType(reflect.TypeOf(agreement.UnauthenticatedVote{}), nil); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	if err := gen.emitFieldConsts(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	if err := gen.emitParser(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

// Reflection walk: gathers parse meta, enums, and fixstr literals
func (g *codeGenerator) analyzeType(t reflect.Type, path []string) error {
	if t.Kind() != reflect.Struct {
		return nil
	}
	if g.parseFns[t] { // only one parse fn per concrete type
		return nil
	}
	g.parseFns[t] = true

	fields := exportedCodecFields(t)
	sort.Slice(fields, func(i, j int) bool { return codecName(fields[i]) < codecName(fields[j]) })

	pf := parseFuncData{
		TypeName:      t.Name(),
		MaxFieldCount: len(fields),
	}

	if sf, ok := findStructField(t, "_struct"); ok {
		if sz, _ := strconv.Atoi(sf.Tag.Get("vpack_assert_size")); sz > 0 {
			pf.FixedSize = sz
		}
	}

	for _, f := range fields {
		cn := codecName(f)
		fd := fieldData{CodecName: cn}

		ft := f.Type
		curPath := append(path, cn)

		fix := g.getOrCreateFixstr(cn)
		fd.FixstrConst = fix

		if ft.Kind() == reflect.Struct {
			fd.IsSubStruct = true
			fd.SubStructName = ft.Name()
			// recurse with extended path
			if err := g.analyzeType(ft, curPath); err != nil {
				return err
			}
		} else {
			// value field â€“ needs enum & fixstr
			enum := pathToEnum(curPath)
			fd.EnumConst = enum

			if _, ok := g.enumSeen[enum]; !ok {
				g.enums = append(g.enums, enum)
				g.enumSeen[enum] = struct{}{}
			}

			fix := g.getOrCreateFixstr(cn)
			fd.FixstrConst = fix

			if ft.Kind() == reflect.Array {
				fd.ArrayLen = ft.Len()
			} else if ft.Kind() == reflect.Uint64 || ft.ConvertibleTo(reflect.TypeOf(uint64(0))) {
				fd.IsUint64Alias = true
			}
		}

		if strings.Contains(f.Tag.Get("vpack"), "alwaysempty") {
			fd.AlwaysEmpty = true
		}

		pf.Fields = append(pf.Fields, fd)
	}

	g.parseFuncDataMap[t] = pf
	return nil
}

func (g *codeGenerator) getOrCreateFixstr(name string) string {
	cn := "msgpFixstr" + title(name)
	if _, ok := g.fixstrs[cn]; ok {
		return cn
	}
	prefix := 0xa0 | len(name)
	lit := fmt.Sprintf(`\x%02x%s`, prefix, name)
	g.fixstrs[cn] = fixstrItem{Const: cn, Lit: lit}
	return cn
}

func (g *codeGenerator) emitFieldConsts() error {
	sort.Strings(g.enums)
	var enumBuf strings.Builder
	fmt.Fprintln(&enumBuf, "// voteValueType enumerates every value-bearing field (full path).")
	fmt.Fprintln(&enumBuf, "type voteValueType uint8")
	fmt.Fprintln(&enumBuf, "const (")
	for i, e := range g.enums {
		if i == 0 {
			fmt.Fprintf(&enumBuf, "\t%s voteValueType = iota\n", e)
		} else {
			fmt.Fprintf(&enumBuf, "\t%s\n", e)
		}
	}
	fmt.Fprintln(&enumBuf, ")")

	var fixBuf strings.Builder
	fmt.Fprintln(&fixBuf, "\nconst (")
	var names []string
	for n := range g.fixstrs {
		names = append(names, n)
	}
	sort.Strings(names)
	for _, n := range names {
		it := g.fixstrs[n]
		fmt.Fprintf(&fixBuf, "\t%s = \"%s\"\n", it.Const, it.Lit)
	}
	fmt.Fprintln(&fixBuf, ")")

	src := "// Code generated by gen.go; DO NOT EDIT.\n\npackage vpack\n\n" +
		enumBuf.String() + fixBuf.String() + "\n"

	out, err := format.Source([]byte(src))
	if err != nil {
		return err
	}
	return os.WriteFile("fields.go", out, 0o644)
}

func (g *codeGenerator) emitParser() error {
	header := `// Code generated by gen.go; DO NOT EDIT.

package vpack

import "fmt"

func parseVote(data []byte, c compressWriter) error {
	p := newParser(data)
`
	body, err := g.renderParseFunction("unauthenticatedVote")
	if err != nil {
		return err
	}
	footer := `
	// Check for trailing bytes
	if p.pos < len(p.data) {
		return fmt.Errorf("unexpected trailing data: %d bytes remain unprocessed", len(p.data)-p.pos)
	}
	return nil
}`

	src := header + body + footer
	out, err := format.Source([]byte(src))
	if err != nil {
		return err
	}
	return os.WriteFile("parse.go", out, 0o644)
}

const parseFuncTemplate = `
    { // Parse {{.TypeName}}
        cnt, err := p.readFixMap()
        if err != nil {
            return fmt.Errorf("reading map for {{.TypeName}}: %w", err)
        }
{{- if gt .FixedSize 0}}
        // Assert {{.TypeName}} struct has {{.FixedSize}} fields
        if cnt != {{.FixedSize}} {
            return fmt.Errorf("expected fixed map size {{.FixedSize}} for {{.TypeName}}, got %d", cnt)
        }
{{- else}}
        if cnt < 1 || cnt > {{.MaxFieldCount}} {
            return fmt.Errorf("expected fixmap size for {{.TypeName}} 1 <= cnt <= {{.MaxFieldCount}}, got %d", cnt)
        }
        for range cnt {
{{- end}}
{{- if eq .FixedSize 0}}
            key, err := p.readString()
            if err != nil {
                return fmt.Errorf("reading key for {{.TypeName}}: %w", err)
            }
            switch string(key) {
{{- end}}
{{- range $fd := .Fields}}
    {{- if gt $.FixedSize 0}}
        // Required field for {{$.TypeName}}: {{$fd.CodecName}}
        if err := p.expectString("{{$fd.CodecName}}"); err != nil {
            return err
        }
    {{- else}}
            case "{{$fd.CodecName}}":
    {{- end}}
    {{- if $fd.IsSubStruct}}
                {{ renderParseFunction $fd.SubStructName }}
    {{- else if $fd.IsUint64Alias}}
                val, err := p.readUintBytes()
                if err != nil {
                    return fmt.Errorf("reading {{$fd.CodecName}}: %w", err)
                }
                if err := c.writeVaruint({{$fd.EnumConst}}, val); err != nil {
                    return fmt.Errorf("writing {{$fd.CodecName}}: %w", err)
                }
    {{- else if gt $fd.ArrayLen 0}}
                if val, err := p.readBin{{$fd.ArrayLen}}(); err != nil {
                    return fmt.Errorf("reading {{$fd.CodecName}}: %w", err)
                } else {
        {{- if $fd.AlwaysEmpty}}
                    if val != [{{$fd.ArrayLen}}]byte{} {
                        return fmt.Errorf("expected empty array for {{$fd.CodecName}}, got %v", val)
                    }
        {{- else}}
                    c.writeBin{{$fd.ArrayLen}}({{$fd.EnumConst}}, val)
        {{- end}}
                }
    {{- else}}
                return fmt.Errorf("unsupported field {{$fd.CodecName}} in {{$.TypeName}}")
    {{- end}}
{{- end}}
{{- if eq .FixedSize 0}}
            default:
                return fmt.Errorf("unexpected field in {{.TypeName}}: %q", key)
            }
        }
{{- end}}
    }
`

func (g *codeGenerator) renderParseFunction(root string) (string, error) {
	var buf strings.Builder
	tmpl, err := template.New("parse").
		Funcs(template.FuncMap{
			"renderParseFunction": func(name string) string {
				s, err := g.renderParseFunction(name)
				if err != nil {
					panic(err)
				}
				return s
			},
		}).Parse(parseFuncTemplate)
	if err != nil {
		return "", err
	}

	var todo []reflect.Type
	for t, d := range g.parseFuncDataMap {
		if d.TypeName == root {
			todo = append(todo, t)
		}
	}
	for _, t := range todo {
		if err := tmpl.Execute(&buf, g.parseFuncDataMap[t]); err != nil {
			return "", err
		}
	}
	return buf.String(), nil
}

func exportedCodecFields(t reflect.Type) []reflect.StructField {
	var out []reflect.StructField
	for i := range t.NumField() {
		f := t.Field(i)
		if f.PkgPath == "" && codecName(f) != "" && codecName(f) != "-" {
			out = append(out, f)
		}
	}
	return out
}

func codecName(f reflect.StructField) string { return strings.Split(f.Tag.Get("codec"), ",")[0] }

func findStructField(t reflect.Type, name string) (reflect.StructField, bool) {
	for i := range t.NumField() {
		if f := t.Field(i); f.Name == name {
			return f, true
		}
	}
	return reflect.StructField{}, false
}

func title(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func pathToEnum(path []string) string {
	if len(path) == 0 {
		return ""
	}
	out := path[0]
	for _, seg := range path[1:] {
		out += title(seg)
	}
	return out + "VoteValue"
}
