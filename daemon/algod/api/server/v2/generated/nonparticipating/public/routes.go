// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9e5PbtpI4+lVQ+v2q/FhR42f2ZKpSeyd2nDMbx3F5Jjl7NvZNILIl4QwF8ACgRoqv",
	"v/stNAASJEGJmqedzF/2iCTQaDS6G/38OErFshAcuFajw4+jgkq6BA0S/6JpKkquE5aZvzJQqWSFZoKP",
	"Dv0zorRkfD4aj5j5taB6MRqPOF1C/Y75fjyS8O+SSchGh1qWMB6pdAFLagbWm8K8XY20TuYicUMc2SGO",
	"X44+bXlAs0yCUl0of+L5hjCe5mUGREvKFU3NI0XOmV4QvWCKuI8J40RwIGJG9KLxMpkxyDM18Yv8dwly",
	"E6zSTd6/pE81iIkUOXThfCGWU8bBQwUVUNWGEC1IBjN8aUE1MTMYWP2LWhAFVKYLMhNyB6gWiBBe4OVy",
	"dPjrSAHPQOJupcBW+N+ZBPgDEk3lHPTowzi2uJkGmWi2jCzt2GFfgipzrQi+i2ucsxVwYr6akB9LpckU",
	"COXk3asX5OnTp1+bhSyp1pA5IutdVT17uCb7+ehwlFEN/nGX1mg+F5LyLKnef/fqBc5/4hY49C2qFMQP",
	"y5F5Qo5f9i3AfxghIcY1zHEfGtRvvogcivrnKcyEhIF7Yl++0k0J57/VXUmpTheFYFxH9oXgU2IfR3lY",
	"8Pk2HlYB0Hi/MJiSZtBfHyVff/j4ePz40af/8+tR8r/uz+dPPw1c/otq3B0YiL6YllICTzfJXALF07Kg",
	"vIuPd44e1EKUeUYWdIWbT5fI6t23xHxrWeeK5qWhE5ZKcZTPhSLUkVEGM1rmmviJSclzw6bMaI7aCVOk",
	"kGLFMsjGhvueL1i6IClVdgh8j5yzPDc0WCrI+mgtvroth+lTiBID14XwgQv6fJFRr2sHJmCN3CBJc6Eg",
	"0WKHePISh/KMhAKlllVqP2FFThdAcHLzwApbxB03NJ3nG6JxXzNCFaHEi6YxYTOyESU5x83J2Rl+71Zj",
	"sLYkBmm4OQ05ag5vH/o6yIggbypEDpQj8vy566KMz9i8lKDI+QL0wsk8CaoQXAER039Bqs22//fJT2+I",
	"kORHUIrO4S1NzwjwVGSQTcjxjHChA9JwtIQ4NF/2rcPBFRPy/1LC0MRSzQuansUles6WLLKqH+maLcsl",
	"4eVyCtJsqRchWhAJupS8DyA74g5SXNJ1d9JTWfIU97+etqHLGWpjqsjpBhG2pOtvHo0dOIrQPCcF8Izx",
	"OdFr3qvHmbl3g5dIUfJsgJqjzZ4GglUVkLIZg4xUo2yBxE2zCx7G94OnVr4CcPwgveBUs+wAh8M6QjPm",
	"dJsnpKBzCEhmQn52zA2fanEGvCJ0Mt3go0LCiolSVR/1wIhTb9fAudCQFBJmLEJjJw4dhsHYdxwHXjod",
	"KBVcU8YhM8wZgRYaLLPqhSmYcPt9pyvFp1TBV8/6ZHz9dODuz0R717fu+KDdxpcSeyQjotM8dQc2rlk1",
	"vh9wPwznVmye2J87G8nmp0bazFiOkuhfZv88GkqFTKCBCC+bFJtzqksJh+/5Q/MXSciJpjyjMjO/LO1P",
	"P5a5Zidsbn7K7U+vxZylJ2zeg8wK1uiFCz9b2n/MeHF2rNfRe8VrIc7KIlxQ2ri4Tjfk+GXfJtsx9yXM",
	"o+q2G148Ttf+MrLvF3pdbWQPkL24K6h58Qw2Egy0NJ3hP+sZ0hOdyT/MP0WRm691MYuh1tCxE8loPnBm",
	"haOiyFlKDRLfucfmqWECYC8StH7jAAXq4ccAxEKKAqRmdlBaFEkuUponSlONI/1fCbPR4ej/HNT2lwP7",
	"uToIJn9tvjrBj4zKatWghBbFHmO8NaqP2sIsDIPGR8gmLNtDpYlxu4mGlJhhwTmsKNeT+srS4AfVAf7V",
	"zVTj22o7Ft+tK1gvwol9cQrKasD2xXuKBKgniFaCaEWFdJ6LafXD/aOiqDGIz4+KwuIDtUdgqJjBmimt",
	"HuDyaX2SwnmOX07I9+HYqIoLnm+McLCqhpENMye1nBSrbEtuDfWI9xTB7RRyYrbGo8Go+VdBcXitWIjc",
	"aD07acW8/Hf3bkhm5vdBH38ZJBbitp+48KLlMGfvOPhLcLm536KcLuE4c8+EHLW/vRjZmFHiBHMhWtm6",
	"n3bcLXisUHguaWEBdE+sLGUcL2n2JQvrJbnpQEYXhTk4wwGtIVQXPms7z0MUEiSFFgzf5iI9+ztViys4",
	"81M/Vvf44TRkATQDSRZULSajmJYRHq96tCFHzLyIF3wyDaaaVEu8quXtWFpGNQ2W5uCNqyUW9fgdMj2Q",
	"kbvLT/gfmhPz2Jxtw/rtsBNyigxM2ePsnAyZue3bC4KdybyAVghBlvaCT8ytey8oX9STx/dp0B59Z20K",
	"bofcInCHxPrKj8G3Yh2D4Vux7hwBsQZ1FfRhxkE1UsNSDYDvpYNM4P479FEp6aaLZBx7CJLNAo3qqvA0",
	"8FDim1lq4+zRVMiLcZ8WW+GkNjkTakYNmO+4hSR8tSwSR4oRs5V9oTVQ7eXbzjTaw8cw1sDCiabXgAVl",
	"Rr0KLDQHumosiGXBcrgC0l9Emf6UKnj6hJz8/ej54ye/PXn+lSHJQoq5pEsy3WhQ5L67mxGlNzk86K4M",
	"b0dlruOjf/XMGyqb48bGUaKUKSxp0R3KGkCtCmRfI+a9LtaaaMZVVwAOOZynYDi5RTuxtn0D2kumjIa1",
	"nF7JZvQhLKtnyYiDJIOdxLTv8uppNuES5UaWV3GVBSmFjNjX8IhpkYo8WYFUTES8KW/dG8S94dXbov27",
	"hZacU0XM3Gj6LTkqFBHK0ms+nO/boU/XvMbNVs5v1xtZnZt3yL40ke8tiYoUIBO95iSDaTlv3IRmUiwJ",
	"JRl+iDL6e9CoCpyyJZxouix+ms2u5qoocKDIlY0tQZmZiH3D6PUKUsFtJMSO25kbdQh62ojxJjrdD4DD",
	"yMmGp2hnvIpj239xXTKOTg+14WlwizUw5pDNG2R5+dtqHzrsVPdUBByDjtf4GA0dLyHX9JWQp7Ul8Hsp",
	"yuLKlbz2nEOXQ91inCklM9/6OzTj87wZfTM3sE9ia7yVBb3wx9etAaFHinzN5gsdXCveSiFmVw9jbJYY",
	"oPjAXspy8033avZGZIaZ6FJdgQpWD1ZzOEO3IV+jU1FqQgkXGeDmlyqunPXEa6CjGP3bOtT39MLes6Zg",
	"qCulpVltWRD03nbkRf1hQlN7QhNEjerxXVVOR/uWnc7GAuQSaLYhUwBOxNQ5iJzrChdJ0fWsvXrjVMMI",
	"v2jAVUiRglKQJc4wtRM0/54VHXoLnhBwBLiahShBZlReGtiz1U44z2CTYKCEIvd/+EU9uAV4tdA034FY",
	"fCeG3uqa77yAXaiHTb+N4NqTh2RHJRAvV4gWqM3moKEPhXvhpHf/2hB1dvHyaFmBRH/ctVK8n+RyBFSB",
	"es30flloy6In/M9db42GZzaMUy68YhUbLKdKJ7vYsnmpcQc3Kwg4YYwT48A9itdrqrT1ITOeoenLihOc",
	"xyphZop+gHuvIWbkX/wNpDt2auQgV6WqriOqLAohNWSxNXBYb5nrDayrucQsGLu682hBSgW7Ru7DUjC+",
	"Q5ZdiUUQ1ZWrxQVZdBeHDgkj5zdRVDaAqBGxDZAT/1aA3TAEqgcQpmpEW8JhqkU5VdzVeKS0KArDLXRS",
	"8uq7PjSd2LeP9M/1u13iorqW25kAhZFX7n0H+bnFrA1+W1BFHBxkSc+M7oFmEOvs7sJsDmOiGE8h2Ub5",
	"eMUzb4VHYOchLYu5pBkkGeR00x30Z/uY2MfbBsAdr6+7QkNio5jim15Tsg8a2TK0wPFUTHkk+ISk5gia",
	"q0BNIO7rHSNngGPHmJOjo3vVUDhXdIv8eLhsu9WREVEaroQ2O+7oAUF2HH0IwD14qIa+OCrw46S+e7an",
	"+CcoN0GlR+w/yQZU3xLq8fdaQI8N1QWIB+elxd5bHDjKNnvZ2A4+0ndkewy6b6nULGUF3nV+gM2VX/3a",
	"E0TdjCQDTVkOGQke2GtgEX5PbPxNe8yLXQUH2d664HeMb5Hl5EyhytME/gw2eOd+awM7A1PHVdxlI6Ma",
	"+UQ5QUB9uJhRwcNXYE1TnW+MoqYXsCHnIIGocrpkWtuA7eZVV4siCQeI+jW2zOiceDYo0u/AEK/iCQ4V",
	"LK+7FeORvRNsh++0dTFooMPdBQoh8gEWsg4yohAMivcghTC7zlzsuI8e9pTUANIxbfTgVuL/nmqgGVdA",
	"/ilKklKOV65SQ6XTCImKAiqQZgajglVzusiOGkOQwxLsTRKfPHzYXvjDh27PmSIzOPcJF+bFNjoePkQ7",
	"zluhdONwXYE91By344j4QIePEXzuFtLmKbsjC9zIQ3bybWvwyktkzpRSjnDN8i/NAFoncz1k7SGNDIuq",
	"wHEH+XKCoWPrxn0/Ycsyp/oqvFawonkiViAly2AnJ3cTM8G/W9H8p+ozTCaB1NBoCkmKKRADx4JT843N",
	"mth1N6yjydhyCRmjGvINKSSkYKP8jcqnKhgnxMb/pQvK56jpS1HOXQCaHQc5damsTUWWvDNEVBvSa56g",
	"dTrGuV3QsU/0MHoQUHMXa5u27c3jnFbzudyeISI1QF7b1B/1bo1HvVdVg9RVfVW1yGlmqwzg4g1FLcBP",
	"PfFAHwiizigtXXyF22JOgdnc67G110PHoOxOHITE1Q/7ouLMPTnfXIG2YgciEgoJCmVLaF9S9qmYhZlp",
	"TviojdKw7Jrg7ae/9Ry/d70XPcFzxiFZCg6baDI24/AjPoweJ5RvPR+jptH3bfvy0IC/BVZzniHUeFn8",
	"4m63T2jb1aReCXlVvkw74GC9fIDrcKef3E15UQcnzfOIT9DlrbQZgBpXefJMEqqUSBkqW8eZGtuD5tyI",
	"Lsmlif63VTTuFZy99rgt51eYEonGXcgLQkmaMzT9Cq60LFP9nlM0LgVLjUQt+Vt0v7nxhX8lbt+MmB/d",
	"UO85xYi1yuQUjbSYQcS+8grAWx1VOZ+D0q1LygzgPXdvMU5KzjTOtTTHJbHnpQCJoUMT++aSbsjM0IQW",
	"5A+QgkxL3VTbMS1LaZbnzhNnpiFi9p5TTXKgSpMfGT9d43DeW++PLAd9LuRZhYW4dJ8DB8VUEo+u+t4+",
	"xcBXt/yFC4LFNHr72PpuzPh17tYGbU91avj/e/+/Dn89Sv6XJn88Sr7+j4MPH599evCw8+OTT9988/81",
	"f3r66ZsH//V/YzvlYY8lDTnIj1+6K+3xS7y31M6bDuw3ZrhfMp5EiSwMw2jRFrmPCbKOgB40rVp6Ae+5",
	"XnNDSCuas8zwlouQQ1vCdM6iPR0tqmlsRMuK5de6523gElyGRJhMizVeWIvqBiTG0/PQm+gy7vC8zEpu",
	"t9Jr3zb7xAeGidm4SsG01VkOCebnLaiPanR/Pnn+1Whc59VVz0fjkXv6IULJLFvHsiczWMcuee6A4MG4",
	"p0hBNwp0nHsg7NEYOBuUEQ67hOUUpFqw4uY5hdJsGudwPqbfGYvW/JjbYHtzftA3uXEuDzG7ebi1BMig",
	"0ItY1YaGooZv1bsJ0IoXKaRYAR8TNoFJ21iTmfuii8bLgc6wegDePsWQ21B1DiyheaoIsB4uZJBFJEY/",
	"qPI4bv1pPHLCX135dcgNHIOrPWfliPR/a0Huff/dKTlwDFPds4m8dugg9TJylXbZRY1IIsPNbK0aq+S9",
	"5+/5S5gxzszzw/c8o5oeTKliqTooFchvaU55CpO5IIc+Yekl1fQ972haveWkglQxUpTTnKXkLLyQ1ORp",
	"S4R0R3j//leaz8X79x86QRXd64ObKspf7ASJUYRFqRNX4CCRcE5lzGmlqgR3HNlWMNk2q1WyRWktm76A",
	"ghs/zvNoUah2omt3+UWRm+UHZKhcGqfZMqK0kF4XMQqKhQb3941wgkHSc29XKRUo8vuSFr8yrj+Q5H35",
	"6NFTII3Mz9+dyDc0uSlgsHWlNxG3bVTBhdtrJay1pElB5zHf2Pv3v2qgBe4+6stLtHHkOcHPGhmnPqIe",
	"h6oX4PHRvwEWjr2z53BxJ/YrX8wqvgR8hFuI7xh1o/bYX3S/ghzUC29XK4+1s0ulXiTmbEdXpQyJ+52p",
	"atzMjZLlwygUm+Nt1ZUDmgJJF5CeuTotsCz0Ztz43EfqOEXTsw6mbAUfm0GGNSTQszAFUhYZdao45Zt2",
	"Mr8CrX088Ds4g82pqEtQ7JO930wmV30HFSk10C4NsYbH1o3R3nwXDoYX+6LwOdmYnOfJ4rCiC/9N/0G2",
	"Ku8VHOIYUTSSnfsQQWUEEZb4e1BwgYWa8S5F+rHlmVvG1Eq+SDUfz/uJe6W+PLnIrXA1aHW3z5eA5cDE",
	"uSJTavR24SpZ2YTpgIuVis6hR0MOnTsD05IbDiEcZJfci0o6MWsLtI68iYJsX07MmqOUAuaJIRW8zLTi",
	"9fxM1n/oPBNYoNIhbJqjmlQFNlqmQ2XDyWYr7vWBFidgkLxWODwYTYyEms2CKl9kC2uR+bM8SAe4xgIA",
	"28q+HAehZkHBsaqoi+e57XPauV264i++4osv8xJeLQeUbDEaPka3x7ZDcFSAMshhbhduX/aEUhcjqDfI",
	"wPHTbJYzDiSJRa0FZtBAzLg5wOjHDwmxFngyeIQYGQdgo18cByZvRHg2+XwfILkrpkD92OhRD/6GeN6X",
	"jeM2Ko8oDAtnPV6t1HMA6kIdK/nVCrjFYQjjY2LY3Irmhs25G189SKf6CKqtrVojLjLjQZ86u8UBYgXL",
	"Xmuyougiqwl1Jg90XKHbAvFUrBOb+BnVeKfrqaH3aGg7pqHGDqat83JPkalYY7QPihYbSr0Dln44PBjB",
	"DX/NFNIrftcnzS0w26bdrk3FqFAhyThzXkUuferEkKl7NJg+crkflG65EAAtY0ddB9ldfndeUpvqSVeY",
	"11JtXJck81lDsePfd4Siu9SDv64Vpiq28ratsUTtFM2glWadmUCFjBG9YRNdJ03XFaQgB7wUJA0lKjmL",
	"eU7N3QZQ4pz4zwLjBVazoXzzIIiEkjBnSkNtRPdxErdhnqRYRE+IWf/qdCFnZn3vhKjElHUj4oeNZd74",
	"CjCUeMak0gl6IKJLMC+9UnipfmVejetKzVgrW3KWZXHegNOewSbJWF7G6dXN+8NLM+2biiWqcor8lnEb",
	"sDLFEsnRCMwtU9sg3a0Lfm0X/Jpe2XqHnQbzqplYGnJpzvGFnIsW593GDiIEGCOO7q71onQLgwwyZ7vc",
	"MdCbAh//ZJv1tXOYMj/2zqgdn7/bJ6PsSNG1BAaDratg6CYyagnTQYXhbkprzxmgRcGydcsWakftvTHT",
	"vQwevi5bCwu4u26wHRgI7J6xrBoJqlmCr1bwba3oRgWcySDMnDYL5YUMIZyKKd/poIuoKutuF65OgeY/",
	"wOYX8y4uZ/RpPLqc6TSGazfiDly/rbY3imd0zVtTWsMTsifKaVFIsaJ54gzMfaQpxcqRJr7u7dE3zOri",
	"ZszT745ev3XgfxqP0hyoTCpVoXdV+F7xxazKVvvrOSC+krq583md3aqSweZXJcpCo/T5AlxJ6kAb7dTO",
	"rB0OwVF0RupZPEJop8nZ+UbsErf4SKCoXCS1+c56SJpeEbqiLPd2Mw9tTzQPLm5YAdYoVwgHuLR3JXCS",
	"JVfKbjqnO346aurawZPCubYUzV7auvCKCN52oWPM86ZwXvclxcqX1irSZU68XKIlIVE5S+M2Vj5Vhji4",
	"9Z2Zlwm+3KOMmhFL1uOK5SULxjKvDalt0wIymCOKTBUtr1Pjbipcz5+Ss3+XQFgGXJtHEk9l66BimRRn",
	"be+KU6M7dOdyA1sLfT38ZXSMsOprW+IhENsVjNBT1wH3ZXVl9gutLFLmh8AlsYfDP5yxIxK3OOsdfThq",
	"tsGLi6bHLWzR0+V/hjBsrfbd/YH85dWVn+2ZI9rvh6lkJsUfEL/n4fU4krDk69wyjHL5A8JEh7DLRYPF",
	"VNadum1RPXvvdvdpN6EVqhmk0EP1uPOBWw4LbnoLNeV2q20iSSPWLU4wYVTpgR2/JhgHcycSN6fnUxqr",
	"RmqUDAPTUe0AbtjStSD+Y497VWVb2NlJ4Euu3mU2Gb0AWecSdgvbXFBhsNMOVhVqzQCpNtQJxtb/lysR",
	"Gabk55TbLi7mO3uU3NcKrPHLfHUuJJaSUHGzfwYpW9I8rjlkadfEm7E5sw1KSgVBBww3kG3+ZKnIdRGp",
	"cogcao5n5NE4aMPjdiNjK6bYNAd847F9Y0oVcvLKEFV9YpYHXC8Uvv5kwOuLkmcSMr1QFrFKkEqpw+tN",
	"5byagj4H4OQRvvf4a3If3XaKreCBwaKTz6PDx1+j0dX+8SgmAFyDmW3cJEN28g/HTuJ0jH5LO4Zh3G7U",
	"STTr3naY62dcW06T/XTIWcI3Ha/bfZaWlNM5xCNFljtgst/ibqIhrYUXntn2SEpLsSFMx+cHTQ1/6ok+",
	"N+zPgkFSsVwyvXTOHSWWhp7q9hZ2Uj+c7bXkKhN7uPxD9JEW3kXUukTerNHUyrfYqtGT/YYuoYnWMaG2",
	"fkjO6ugFXy+dHPvyRFiquarQbHFj5jJLRzUHgxlmpJCMa7xYlHqW/I2kCyppatjfpA/cZPrVs0h56maZ",
	"VL4f4DeOdwkK5CqOetlD9l6HcN+S+1zwZGk4SvagzvYITmWvMzfutuvzHW4feqhSZkZJesmtbJAbDTj1",
	"pQiPbxnwkqRYrWcvetx7ZTdOmaWMkwctzQ79/O610zKWQsZqDtbH3WkcErRksMLYvfgmmTEvuRcyH7QL",
	"l4H+dj0PXuUM1DJ/lmMXgW9F5HbqS6ZXlnQXqx6xDvQdU/PAkMHUDTUmzfLUN89HryYKKu7p8obtrmPL",
	"PPF4wD/aiLhlcsENrH35diU9hBKU54+STFY9D3zslHwr1kMJp3UKPfF8BiiKoqRkefZLnfnZ6n4gKU8X",
	"UZ/Z1Hz4W92nrVqclYHR8oELyjnk0eGsvvmb10sjmvO/xNB5lowPfLfdkMEut7W4GvAmmB4oP6FBL9O5",
	"mSDEajOprgrazuciIzhPXauuPq7dRh5BufV/l6B0LEEJH9jAMbSNGnZgq30T4BneSCfke9uKeQGkUYgI",
	"b4K+UkQza7osckGzMVawOP3u6DWxs9pvbLchW218jheh5ipaNrGgDOewEGTfOCieHjF8nO3x2mbVSidV",
	"cfBYAqp5oy5fzlp+ArwihdiZkJdBU1Wbq2qGIFjARC7Nra4azepHSBPmP1rTdIHXvgZr7Sf54WXyPVWq",
	"oDVl1WKqqk2J587A7Srl20L5YyLM3fycKduBF1bQzHmtEsCd2cHnwDaXJ0vOLaVM9pByVSXKfdHugbMi",
	"0rsSopC1EL+n0m+7TOzbNeAEv4qWymq3IOj0pLQZlFXrIN9ZPaVccJZioaqYiHateof42QbU9Gobcv0R",
	"dyc0criijQ+qUDyHxd5WCJ4ROsR1Df3BU7Opljrsnxp7wi6oJnPQynE2yMa+f4ezNTKuwNUaxcbOAZ8U",
	"suG7RA4ZdYcnldtkTzLC1Juey+Mr8+yNMy1gTPoZ43iJcGhzip+1BmInUW1uHkyTuQDl1tPMP1a/mm8m",
	"mIqbwfrDxHcexTGs688s2/q5u0Mdea+38zKbd1+Yd12BpOrnRpSznfSoKNyk/d1dovqAXvNeBEe8l4l3",
	"HwXIrcYPR9tCblvDVVCeGkKDFTq7oUA53CGMqtNJq4uWUVotReEbxIaJRaskMB4B4zXjUPfFjQiINCoS",
	"cGPwvPZ8p1JJtVUBB/G0U6A5erhjDE1p59647FDt8lAGJbhGP0f/NtZNWnoYR/VCrbhRvqna8RrqDpSJ",
	"F9gH3CGy23IFtSqnRGWYtdBqwhJjHIZx+zZPTQHQPQZdnch+jrXS9pVEfYmo0zKbg05olsVKv36LTwk+",
	"JVmJmgOsIS2rEqFFQVKsu9IsRNOlNjdRKrgql1vm8i9ccrqgq1GEGsLOSn6HMdFlusF/Y/Ux+3fGBXrs",
	"HWroozqy/aovdUMnY1qvoelEsXkyHBMoUy6PjnrqixF6/f2VUnou5k1Abrj8xDYuF+5RjL99ZwRHWJ2h",
	"U/TVipaqeAIG9gnfixKvjVXab5MroSjrVIFFh1LV6267AaK/a90YhV9PeG9QdINa+Wo9lH1BvmlvTDrV",
	"LjtOU7KVBfVmHNkIIZtbhFDErbN9UUE2KMg87nw9TDPs6Nk6XvgwQKgPN+sC9IOPZSUFZc79XjOLLmZd",
	"1Hs3D2FIPGy9we1FuFjyXovdD6u+uG9fjA2ft7tanYFLmS8krJgovWPbRz75K6H9tdEjqoq8j66/a3jF",
	"qW7XHNprvD113QXsMt2d/IdfbJwcAa7l5jMw5XY2vdMvq6vtWvNU/QqpClMPKlTdkIpDChXGauI53bDR",
	"sWtHv7EOWb0cog50+4eNR8fZXgIzVldxZEeJHbt4N7D+slN1qSk8YoVQrK4PH2sTNjDE8BQ7fQVls7pj",
	"+fieFaQamwLUcQsSYJ8iWmayoPHoXfmpnut0FYnpqk5tKzXV7QSwQ8Z3ssGCjEZbRX0yvLDSURWdhnwa",
	"qyHPgbven808j8HR5rMZpJqtdmTf/WMBPMjsGnu7jO3hHSTjsSp6GYu37G91rAHalhy3FZ6giOKlwenL",
	"vTmDzT1FGtQQLes+9qL2InU7EAPIHRJDIkLFoj+sIdk55JmqKAOx4KOt7OdQV0Dr7QgV5JJecC5PkkZw",
	"1PmlW6aMt6QZNJf5dK+sawzE7UvQ63a06L9/vMQGIqrq1ujrfoS3dHLcrY547uqGYK5k5TvxFURA+d98",
	"YrSdJWdnEPasQk/VOZWZfyNqevFWnWSLPOpk1fluDG2gZ9XMrI6N7eZRReptYQR0mgujRiR9YeTNcNQq",
	"luOeskE3tvw7BtoauGYgXW8/1H9zoSDRwsfSboNjGypsZNGFkKB6a1xa4Horz7yrS+tgrV+KlWaoCygK",
	"F0gkLKmBTgYFcPrn3IbsF/a5TxzytV53Wpgqet3ddMBHRTPVQWJI9TPipOXuhKSLGJsY57Z/tIpVw+Eg",
	"m96QQoqsTK2ADg9GZZAbXGtqCyuJ2mnS7ipbd4Qgq/MMNgf2EuS7NfgdDIG2mpMFPaii0NrkKzW/qRjc",
	"8ysB7zYtV+NRIUSe9Dg7jrslfNoUf8bSM8iIkRQ+erCngw65jzb2ypt9vtj4kjVFARyyBxNCjriN1/aO",
	"7WYN6dbk/J7eNv8aZ81KW1XLGdUm73k88BXrXclLcjM/zHYepsCwuktOZQfZUSBm3VM+SNLzSD+pydBb",
	"edfV3O7xUxOVhSKmk9Tta3bEyVQhMnXnjzpMpqsd5Lk4T5CKkqr+V+zOYd5rMklf8bT+zGB7CkG8DVVO",
	"gG7IgmYkFVJCGn4RT3GwQC2FhCQXGH4T8wzOtNGHlhjXzEku5kQU5ppry+h5H0q0LU0w11W14LHpuhaC",
	"xDp8egoigHLpuQ5c+3IX3i1dcPbvsHO6iNhtcMP8bu3dRscR3N7dLwIwBxD6bpvVUaxLUHNd7X5Vfd3j",
	"tFiyNI7uLytapTfGJEa9MVS4ArQ2AQ5fwwMe8pTKOYmnp4tm4HSaxzw2xB0/56RBOjf/RQnWHpfMwDGX",
	"Hn4Wa3dL07PEqkQDpkc4bU6GLqWtWWtGqFtgiblN3kLPUhu+QXzm0/atiLWjipBatX7XLcsnevaQbdQL",
	"v93pbVsUToe6vqsy2AM5VABAvzO8AcMgl/i+YMyw5WdCI0g+ri4i40ZHZtZiw75EoWU3KbWGiAUQM3Yp",
	"wSUe2t6ErWZIBdULr5iY17vmAnP1BIVZgbajC1XWuOWNbK4xYlvjE0WSwwoaMQIuG7JMU1CKrSBsqmg/",
	"JhlAgSbn9kUo5vwOBU5LO3ZrTwL36RDsRtVli1i7U2SHLhzV3Nc8scdEDT1KBqIVy0rawJ+6RHu5vs5y",
	"EYnoYf0wjFPszSTii9vGInaGqyDNR88lj0erhMm4lZ0LZ8sqe7glwvpkq4Ke8/57YZcoa4VueGPGALHf",
	"rSFF4dgMx7g8TggORlQr0b5Xk5PVDl/UvtBLZduIrNOmMqpKKvBthsOaOF4bd99GRKO1hDIVGYCpmjdg",
	"cCfUwYPBa0u6IRmbzUBaX4/SlGdUZuHrjJMUpKbMXHw36uK3HgOtLGG88+JjODUO6plV7AqEZksLSL5x",
	"N8q+S8mAywQ69iIXCSu2tejroNnZlXi2CV2byxeG3fUQgcuTx6uXPayCo95LlvQM9pxHsT9g+zRYvcaZ",
	"hrXAWYdM8Wkrrf+EqMMD/zNneiu1W32vHQdpHVWWGD0N8nntLbebE3Xvsb5G0QtwxXvdZnrm5zbaGzWM",
	"ljr82mbe7o1hzSCHLdAEBSLMi5A5FdlB2YRvMjhU99T2rQrDddttIDxtWyuhxS/0lLV0siJBGaK2+N1B",
	"BQ2rUmc37ao/HeFjgRm7MOa9tKO2zSfdwYSjIqmHBzQvJGKGpxGJ0ApiDN6oxM+4HVbUFLkVmWML1rSU",
	"qDSe083u6ni12I1HZNuR/Z3SB5pUULuttgdK2a4e0eJz+6hjkTMea2zRLft19YuxqQa1M/T6luPcHfEF",
	"hG3yt9NbfXHxpBKhNco3saPjDfoXWGCfNjYgWPbKtqo6LdexQVGRVLPnweGiwieqVZKglecaD/psxXre",
	"hkelDZJdD3ZxIYgE8vvj34mEGbZpFOThQwT64cOxW/rvT5qPS8b1w4dRqRAPXb26iFX89kN8Sy9S4HcQ",
	"tXVjYSMHJOjIvZ2mwvrfdWEBaUOqMZzBX+nbJPZjfdUf1hvcf7ADvDBqLegO7h2IDpxbztD/sUJKsJRe",
	"Smgsf1cgnFtgbRsJtshdN7QG243BZnU29yWIclQvquDBvkb27RhDLPZt9Ns8j8Qm2huQbR0dEI45PHJF",
	"85vnKVgF/gjxAdm7/oiEMEAtRLJFpbpYeuxrOmjuIBjt6qbmbzEe8h9g9igq6d1Qjmt25DneX2luvWcz",
	"30d2BZyc45jW5P34KzJ15YMKCSlTbWPOuW/xVsVjYcdTl5K81jsCwHat8xehL0HGM28bJW/qdlHoIJrz",
	"GsL6iN4yU+k5uVEqj1Ffhywi+IvxqLCO7w5xcdbIsqgV9UCiCQlXnG0R5E3umW3RrVA8dHk2o8AInVJB",
	"d52DpXUDtxFBXa9tqO43WNnDXj5DMnziipn5HFOMbl5Du4bkIosjN4abN0Yxv/SVm7AlFXoqm7T2o2R5",
	"toswGnVq6lb0WInlN1cN61aa4f9mA567R9U1JL5EloZFTGStjcmDqYIKNAOKz7jPIqVmMJgoLSXTGyzS",
	"7Y0Y7LdoGtT3VUi9S8morNBO9mlxBlWZ9zoAv1Reun4vaI7yyBrHuZFCIp+Q79Z0WeTOxke+uTf9T3j6",
	"t2fZo6eP/3P6t0fPH6Xw7PnXjx7Rr5/Rx18/fQxP/vb82SN4PPvq6+mT7MmzJ9NnT5599fzr9Omzx9Nn",
	"X339n/cMHzIgW0BHviTk6H+So3wukqO3x8mpAbbGCS3YD7CxzakNGfu21zTFkwhLyvLRof/p//EnbJKK",
	"ZT28/3XkKs6NFloX6vDg4Pz8fBJ+cjDHiNtEizJdHPh5On2xj94eV65967fCHbXFWrw/0pPCET57993J",
	"KTl6ezypCWZ0OHo0eTR5bMYXBXBasNHh6Cn+hKdngft+4IhtdPjx03h0sACaY4KK+WMJWrLUP5JAs437",
	"vzqn8znIiesFbn5aPTnwasXBRxd5/MnMELXa2zpFQXGabotsl8WAxjgbk9BoOalcB8Rx1YjUuUd5huVj",
	"bDCvYXMV4o6zuuPWcc20fN1x24jl8NdINpgP/PDlsBttyl2QCFPkv09+ekOEJO5685amZ1XQCzme2Rqy",
	"UqwYViXJglI25suJp99/lyA3NX05zhc2GfF9JV30zFLNi2ZhhFqritm9Yu3IcWZDFgFhV3kCNeNCR1AA",
	"Sc2GDWt9lHz94ePzv30aDQAEk1YUYAna32me/07OGXa1Ro+oL+LuivSOIz0UUZse13Hn+EG9k2O0yVVP",
	"wzbZ1TvNekK/c8Hh975tcIBF94HmuXlRcIjtwQcskorEgmfuyaNHV9ZfvyqhZeNKqlE8SVxgoC5Dso+q",
	"Pv3nkhb2LPo2+xht6Wzl9qWJ4TvPrnChzQT4Sy+3PVxn0d/SDFsXg9J2KY+/2KUcc8wbMwKCWAH4aTx6",
	"/gXvzTE3PIfmBN8MKpB3Bc3P/IyLc+7fNMpPuVxSuUHVJuiv3irPR+cKHVTIIu3ZbnRUHn341Cv1DsKG",
	"sQcfG6lH2aVkYqdX9vHLHWLynurjnN3+Pa1+tOZ51W4UvX2u6S42QFUPJuT78Gvk3lgO1xabLSWHzGcO",
	"ealX1ff3XQNq2O6psFJwVGgH5uI7+X3b8vuoaexo9IiJAdM4BVth6sQuXFaAdoO7ghSjPYpLBp3tfO8M",
	"2xn2Av31rrXteeuuaWf6ELsK7mTUd7jrwV2fmhTAW2lMzY6+18+afaWKSpI0RMY1Mu4vXOn7keaGToLl",
	"tipC2sZJd8rgX0YZrDLa51Y7c70CL6ceYtfwg4++GdYVqISuGdgAZTC8VgffBrGl91vs5MHEdrYK37kY",
	"z3Ap7DvVPGxRdqfgfQYKXrf9XwyMuqnb7Sl1CMOi7g+4sxWh7+wXaiO+7+LgPoZfqBb3F0ZWr9pmIN2t",
	"sF2AfXaUMcesr42t/imVMIe0O/XrL61+VYVlLqWANRp4ulJFgRvrUta7tnWO6UoTaxYXCjgbJoEZhuKO",
	"8LiO9zYsxgZMu1BpNfY3Q3Sn2kuj3axx597YVbG+h/CC+u3m+OUu7eoLsvMM7hESkQLxvbluXhp1O7y7",
	"GbfDMN707NGzm4Mg3IU3QpNXKMWvmUNeK0uLk9W+LGwbRzqY2g5p27gSb7ElZBR157OAR1VV1cbBc/O2",
	"jdK4j9l0zaqyDybE92NTVXdZl4o+F4ZR+ZwaKuf2I8PrDDLIPf/nIY5/b0JeYQ6SVmMMNtOu9Si5x7g+",
	"fPzk6TP3iqTnNpar/d70q2eHR998416ru+/Ze07ndaXl4QLyXLgPnIzojmseHP7PP/93Mpnc28lWxfrb",
	"zRvbhuJz4a3jWAWIigD6dusL36TYbd03lNuFuhtx338r1lEpINZ3UujWpJDB/p9C+kybZOQuopUls1Go",
	"8gqlkT0m+8ijse80Z/hOJUwm5I1wNYPLnEoiZAbSteOel1RSrgGyiadULJOhbI3UNGeYNisJNhiWiWIZ",
	"1CV8qiT9QsIKY+SrojdNCHYzeoyk/WyZ/I90HWQtTysxrYVbMpo9l3TtW5xjE18h8advviGPxvXtJc/N",
	"AEmFmBhzXdL16AatfhWxDYo/b3YI3Rmgi2MPsSDV2k9V9SNsR/jX5txfrOZuyd1t7BVxzr0dP7VjJ7Qj",
	"uMq8Wy0IVrGzDdCxI/emrh9ktDyvQsVZnJlhqHHgM/YR7DRNRy+hbfTeHeI7I8ClWEmboPZkG5h1qg4+",
	"4r085Bmdc4tZc38td2ngO5Ji6Z1HgsxApwuXsNtCfYQ9+f6k/bxpyThbGigfja9dq8Fd7NbWChujZNSm",
	"yQ+pvRvkUqIDD2SEiH/yrcLMYzazJfF8Nc9T108CXVOuZlnVjcBevm1/EhfP7/N6C9rorrAbyhf15F2F",
	"DNFyFf7POwTvh+AOc/zO979HjLlF/Bki/v1VMiFvRJ027lqv/hldj9cp2a97QW8EB+tjN5qvpcU7d2ql",
	"dhjGYZHi64XY+0vVBO/CKsjBgqrFTj3k7+alHbrIEOltJvsiRfjfHZa2SBmztsnOYgj1aEOYs3nR1tps",
	"tmW7xVvMrfDTz/Bqcxsc62ZYDB5Sz2ecWsCvlulgCR5LzAdVR64+DhRvcjiYG2lRhaFF+xJOIRd8rj5P",
	"VrS13WQULxEqqdo/xns8/vXO7gus7mOuvDYC0tV7UoynQJRYgm2yzBRZMqVcsOSzR3+7OQg1W/q2NjzM",
	"Xb1l7vL80dObm/4E5IqlQE5hWQhJJcs35GdOV5Tl2IfhEtwOO1hW9de8NTjatBS9Tc26YGlYxOjiTLAR",
	"uvZRr1n2aTczDEpJ7skHGQ/4YFhEmRYFUHlxBrjbddXu1XL8MowObjRWrCpqRUAxKNozQP4/RgPtTpj2",
	"LmZO+JXcAuqrfzk24UJ3xWxcBccYLUDMDsl7/pCoBX3++MlvT55/5f988vyrHsuZmccV7enazuqBzGM7",
	"zBAD2hdtDrxarb3C7+FN7/Z+mzgesWwdbb1WN1PutOlwatk9RQq66e3PWOxoBh0OWzeGvvlih0qz6SJ6",
	"v/LXn6on0TH/troF24p8rofyXRPonuSJgM8YQqu7QVdY394Yeos22SLLqgPvTV9O6yQDK+g88mRL5tyq",
	"oqtv65Ka4B0VuFdsmmi5PZ0S2wOOA3d3IYUWqcht7EpZFELq6nSrySB1D/rcdg1tr49w91LmUqrTRVkc",
	"fMT/YIWvT3XiAdY+Vgd6zQ+wR8XBx60hAghibs66tGWTG3pptAlU95qMn9clml8J2Wk1tysEoHVixu1D",
	"ZPttYCxBRD+7Hu3sL63UbL3/tzb88ibtyIidA1zl1QU9FyraDQp/+1Q52zMkQsJ3LpjPa0G1UWTGeEZo",
	"sI2tu5uQNSO4ZsPIdS/6NuwsN+93ev4Fn7M3QpPjZWFb/EF2uegd0uZwXnpsFbf7KQZO9HdDfLoyP5T4",
	"PjCxsq7vFPB7OOSCVGzw01GJudFGVl+P7ftOkn/ekvyFLzncIMM7ufzlyGXpwynvRPDnL4KffrGruUZH",
	"zECR7CXRhcVwfRPfUyBHWsyjyaDlCt/mp8Grd3uV6pWQvr3FnRT/Qp0MdicHJy0NsdDsSmVyU15F6Oxn",
	"Bf0wO0OeRywNfQd1bHv96AUwLDojUob1w48zNbaH2Bkn3Cm+U3w+a8Un2Os7vefO9PCFmR56tBx362+2",
	"le9TNPZVgFZLkYGPOhGzmSvy1qf9NHvPGPJUmi4LYr+MajnojT1lSzgxb/5kp7hSEVuD3VKLWuAZZClI",
	"Bc/UAK+oG/WicgjduP0A3LgHtNoBD4tL/55cmGTfBTVkOpRA2shX2DPIF7tzyMhgRZa+efYlyfbgo/0X",
	"zWmFUJHVnHgC7mzMfbcttnqfHbcBIHmLSqjrL+2+EjPyyBbxKzlm6tTNASnPiJYbo6j6miUSaE7SRoR+",
	"BUf35Jz0npydV4HO6nrWFL8LiPqEXmU4ays76ocbPwAvKHck30WQFoQSDnOq2Qp83PrkLqP+wtLM5bNv",
	"YYBjQrPMnsZ6E2AFckNUOVVG1+HNQMt7qnle9mAYsC5AMiOiaV474O014cCmy28LqDyxb1xSaLV4kU3S",
	"l80oIC9ZXQq/mJEfWSrFUT4Xysd1qY3SsOy03nOf/tZTdNUbEroxYILnjEOyFDzWEO4nfPojPox9jSUH",
	"+j4+NQ/7vm3J2yb8LbCa8wyRyZfF72dy+i+Vq9FarYRCSHO7ndomtZb+9zxK/tBseNo9SRueBk4t9zAY",
	"KGwf1/j54GPjT1csw72pFqXOxHnwLd7sbdDPkDz5oFH1BSxprYbP6nptadfpQwrwEDsx1dNI66+gHXlv",
	"96+/aH6Ic7mERIKhm6lYgVSt69ldksifKklk8L7vxWNtq8tdHK1UV6uRvBEZ2HGbnWZj9Zm5yMB15Owq",
	"IlWwYzyw3kul+r1WqHNKy/lCk7IgWsSCqusPE5paJpvY6018wqAimr0E4XQLugJCc+xzSqYAnIipWXQt",
	"H3GRVGFNOh+Z7UI6o6pQAFchRQpKQZb4etS7QKv6nGIct96CJwQcAa5mIUqQGZWXBvZstRPOqk+4Ivd/",
	"+MVcmG8cXqsKbkesrYQVQW9VbcNpe12oh02/jeDak4dkRyUQrxpgIolYFjm4VJIICvfCSe/+tSHq7OLl",
	"0YK5FuyaKd5PcjkCqkC9Znq/LLRlkRj53QXxhX16ypaoiXHKhbcrxgbLqdLJLrZsXgrXoswKAk4Y48Q4",
	"cM+F8zVV+p3LKsywAo0VJziP1bHNFP0Ar/r60ZuRf6m60XfGTo085KpUVct6lykAWWwNHNZb5noD62ou",
	"TOv0Y1epCNbCt2vkPiwF4ztkBUW5CdWBN98MF1kc2h+pM1B0UdkAokbENkBO/FsBdkM3fg8gTNWItoSD",
	"RUZDypkKkQPlNqNLFIXhFjopefVdH5pO7NtH+uf63S5xUV3L7UyACtNEHOTnFrMKDbQLqoiDgyzpmcsk",
	"mbsmS12YzWFMMAM82Ub5aLI1b4VHYOchLYu5pBkkGeQ0Ykr52T4m9vG2AXDHPXkmK6EhmcJMSIhvek3J",
	"stdEVA0tcDwVUx4JPiGpOYLm8lwTiPt6x8gZ4Ngx5uTo6F41FM4V3SI/Hi7bbnWPWcqMYXbc0QOC7Dj6",
	"EIB78FANfXFU4MdJbT5oT/FPUG6CSo/Yf5INqL4l1OPvtYC2OS8UYA1J0WLvLQ4cZZu9bGwHH+k7sjED",
	"4hdp7G/HLl1j9ZemATW4AE4ucrk9OKdMJzMhrSKd0JkGuTMg/h+UeXe4cw1o4WoTEBzByU03DjL5sNWF",
	"4yIWBOLEhSGRrv/NTPVKyEElNpuFZCjTpOSa5UGZ8eqq/PkZDO+MAHdGgDsjwJ0R4M4IcGcEuDMC3BkB",
	"7owAd0aAOyPAnRHgr2sEuK2iuYnXOHwpMS540o5KJHdRiX+qIpOVrPJGCTRjnFOmXddMn+/vnlyuxq4G",
	"miMOWA79cdI2fPP0u6PXRIlSpkBSAyHjpMipuRvAWlc93JrdQX3fYtsI0jYepQqePiEnfz/ytfAWrmZb",
	"8937R67/t9KbHB64LgnAM6uK+nYJwA3SXbcE6mWC7/XmOt+xHGPMFfkO334JK8hFAdKW2SJalhGTzynQ",
	"/IXDzQ6Lzz/M5C5o9Xcz2u/jhqHJoW1JC6/n+7VSRajNXSQvg2zG32c0V/B7X0KjHW9Ji1i7tUryWVsQ",
	"cpNvRbZpnRCzawe4gc2zUVfEY5zKTaTeUjeZoE0aWhh+5Qira8z6dOV1G7tE2yWzXRQWU9clqOg53kbl",
	"0YKF1YZ1hrIpr7MWnYxi2ZrtKn2jCsAhIbCnmHBg94S8s9/dblV4hMgdsZqZfzaRg803K6aB75pbhGM9",
	"X2pUvkd89PTi2R8bws7KFAjTivjSj7vFy3i0TsxIc+CJY0DJVGSbpMG+Rg0plDFFlYLldLckCvmnazDs",
	"hI95sl1O3Y4YeRksbhtPDolmnTgG3MOdNxoG8+YKWziiY88Bxq+bRfex0RAE4vhTzKrU4n37Mr16ms0d",
	"47tjfMFpbGkEjLtSuW0mMrlGxic3suT9PO+7NaSlAS48yffRPI8+OVjrhmMzg2k5n2Oj5I6TziwNcDwm",
	"+C2xQrvcoVxwPwqyg1fNMy+b7t0erstdggzs+77G4QPcDso36M1YFpRvvM8XEsWWZW5xaHvMXS2jtdVs",
	"u5EA6I91xr8+s/Zbb/MLjLdO1DZ/t2gh51QRu7+QkZJnLneoU/N6zYdXDLFDn655zaa3Vgex642szs07",
	"RET4XW4mbStSgEz0mtsD1eykbmtr25M7uWsQ+9cQGzblG3oYbLdOdM0Qrkh6yICvofgIuoHUyXCNHiFo",
	"tehPHQlbg9g3rzR6pDN8M4ikNqk4JynkBaG+e38quNKyTPV7TtFJEyxs0g0w8dbofv72wr8S9xNG3Hhu",
	"qPecYnP3ynUT5XMziPgpXgF4NqrK+RyU4ZUhkcwA3nP3FuOk5OamJWZkyVIpEpuIas6Q0U8m9s0l3ZAZ",
	"1v8Q5A+QgkyNZA923RqMlWZ57iJazDREzN5zqkkOVGnyIzNc1gzniw9UoVygz4U8q7AQ7xQxBw6KqSRu",
	"fPnePsVmDG753siHBkv7uC6ifrNdGDzsLOuF/PilgZti7eKcKV0HQXRgvzEH+JLxJEpkpwsgLiasTVvk",
	"PlZMcwT0oOkd0gt4z42E04IgV6f6YuTQdvN0zqI9HS2qaWxEyxvk1zroinclXIZEmMyda+VPlJoZ0IF3",
	"X+LG22r0rb3f043SELnAM/O0RyDbp655V89L7pLQMIS1ysG4N04bIP95G79/uJ77okfjld0YuwN22VWz",
	"PRPizW/4mNBc8LmtQmhukAL3ifGi1BhYfZ1GOljRPBErkJJloAaulAn+3YrmP1WffRqPYA1poiVNIbFW",
	"g6FYOzXfWDrdJUiDJnXLJWSMasg3pJCQQmbrbTFF6sv2xFYsIOmC8jnKXCnK+cK+Zsc5BwlVPy9zv20P",
	"Ea93suaJrb3WhfGIWENlWJ4WaLqI9EdByWQu1J4SbDmJIVfmCCvAypp9N+jxqFdDNkhd1YFtFjlN/jBA",
	"/DcEeYCfeuKrKEV6R6131Hpr1Bor+Yeom7VsABZf4bZcs7Hougtc3qDt6Vaq396VkP+zl5D3HEgRSiRt",
	"aP3x3mVUEabJORb4mQIxgqdEm7drce5uyBNiGFJg37eVIJXrvJkuKOOuOkyVLoBwaNcdWPt2hNdiLrTM",
	"DO2EBh2QlpLpDd4TaMF+OwPz/w9G0VYgV/4KUcp8dDhaaF0cHhzkIqX5Qih9MPo0Dp+p1sMPFfwfvfZf",
	"SLYyN5pPHz79/wEAAP//ZuOMOkOAAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
