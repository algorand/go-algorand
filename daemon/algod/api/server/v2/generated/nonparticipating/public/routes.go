// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
