// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
