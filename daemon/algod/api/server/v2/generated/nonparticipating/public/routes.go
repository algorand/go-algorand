// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"as0BAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
