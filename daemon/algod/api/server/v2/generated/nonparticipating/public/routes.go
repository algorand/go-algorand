// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"vbQBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
