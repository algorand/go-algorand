// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/6ItPib2xAEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
