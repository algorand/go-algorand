// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{
	"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",
	"aEUBAA==",

}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
