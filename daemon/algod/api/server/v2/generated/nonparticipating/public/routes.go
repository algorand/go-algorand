// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/+WI1ln+3QEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
