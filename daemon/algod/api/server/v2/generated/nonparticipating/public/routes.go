// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"spWxaD59+PT/BwAA//8Ij4KMJIIBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
