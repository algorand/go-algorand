// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
