// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
