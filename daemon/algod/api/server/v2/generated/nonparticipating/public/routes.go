// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"4P/otf9CspWxaD59+PT/BwAA//9A/QVrLoIBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
