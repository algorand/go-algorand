// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
