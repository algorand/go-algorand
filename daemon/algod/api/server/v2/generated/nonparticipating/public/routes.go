// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9e5PbtpIo/lVQulvlx0oa23GyJ76V2t/ETnJm41dlJjl3N/aNIRKScIYCeABwRkqu",
	"v/uv0A2AIAlK1IzGj2T+STwiCTQaje5GP/8YZXJVSsGE0aMnf4xKquiKGabgL5rnimn4Z850pnhpuBSj",
	"J6NjQWiWyUoYUlazgmfknG2mo/GI26clNcvReCToio2ehEHGI8X+VXHF8tEToyo2HulsyVYUpzWGKfvt",
	"r8eT/3kw+frtH1/+7f1oPDKb0o6hjeJiMRqP1pOFnLgfZ1TzTE+P3fjvdz2lZVnwjNolTHieXlT9CuE5",
	"E4bPOVN9C2uOt219Ky74qlqNnjwIS+LCsAVTPWsqyxORs3XfoqLHVGtmetdjHw5YiR/joGuwg25dReOF",
	"jJpsWUouTGIlBJ4SfJxcQvT5tkXMpVpR034/Ij+gvYfjhw/e/69Aig/HX36RJkZaLKSiIp+EcZ+Gcckp",
	"vvd+jxf90zYCnkox54tKMU0ul8wsmSJmyYhiupRCMyJn/2SZIVyT/zp99ZJIRV4wremCvabZOWEikznL",
	"p+RkToQ0pFTygucsH5OczWlVGE2MhC8DffyrYmpTY9fBFWOSCUsLv47+qaUYjUcrvShpdj5620bT+/d2",
	"yKyoctZd1wk+IDTPuf2JFoQbttKEi8YCp+Rnzcg74E76nYXWDUnmVVE0jm3NwcjdRSFntCDaUMPGBGEf",
	"E2ay6b0peVEVhpcFIxe0qJgmGRVkxkgmVys60cyOYyzSnkU4UsxUSnCxIFIUm8a8J880oSInhcz8lBab",
	"bF0W0i59TgvN0tj16InRC2iI8YxrT+A3/ECVohv7tzabwu+a/bvgK54gqhd0bQ80EdVqxhSRc4vu5kr7",
	"6AFHjOHdyhEqLsxXj9tsoP51Rddd8M5UJTK7BRGARlGhaWbfAChzrsuCboCyV3T9zYOxA1wTWhSkZCK3",
	"m2XWQvctxc59sIUItk4g+mzJiH1CSrpgEZ6Rqo1/auQ5E+FwktkGHpWKXXBZ6fBRzzpg6sRComOoZCVS",
	"coLAA4fmHhGB3x5SPvwEI77f/kzzhXvUhvqUL842JSNzXsBh/2elTSDgSsO2LxnRJcus6MuJHcYiX/OF",
	"oKZS7Mkbcd/+RSbk1FCRU5XbX1b4E7CHU76wPxX403O54NkpX/TsQIA1xSY1fLbC/9nx0pzSrJOi/LmU",
	"51UZLyiLz4KllZNnfZSBY/aTRlo+HQe1DfbHjXW2PnnWJ9G2f2HWYSN7gOzFXUnti+dso5iFlmZz+N96",
	"DqRF5+r3EWp39mtTzlOoteTvhAmw1WNUX49rDv6Te2yfZlIYhppIxOOPQNY9+SNWXJUsmTIcB6VlOQH+",
	"PwH+b3/6N8Xmoyej/3VU69lH+Lk+iiZ/br86hY+sLqSYZXwTWpZ7jPEaJUT/Qbd8CI/6XCpyueTZkpgl",
	"t9IWNxHUXstpCnZBhZmO9jrJ72Pu8KsDot4K1FFwK1oMqHcvCL44Yxpo39057uiG5I0kLkjgWOqTu8dl",
	"WSMXnh+XJaJqTPicMA7qFFtzbfQ9wAytD1lTwk/JD/HYl7woUBGYMSd3WG7HRL7t+Li7/1jEwhrqEe9o",
	"Ajst1dTuWhcN+qTemMOQZ7iwKKZlpTJ8EJSNrZSW2iUYI6WDWHE0AYnWpcOfNUMSLOmCCxhqbPVaQVb0",
	"3DJuKiRsiiUnpoPCisSKYvKSm2UtOoPSNyVnTXHqsA6/NDfT6g+VZoTiGzUsJKuUlmo6Sqhan/3JSpEU",
	"sfREuVWaSMG1sVIyxlWgFTwd4e7foFp7mTsEjcJVdCkLq7jtJEn78t/duzHftL8P+viz55kx2vu5JZgB",
	"HFKBB+Iv8V2pxQq7nBC+sDzwuP3t1figHaWHA9pHh+Z9MV3tz/RahPapcLs/EYvq2/Mkc4KXyZIVcE1K",
	"c6QrEc0AWtiyiADzpaIlkrl7grcPLgitbRoA6zX1z4GqYRLm2NZZ4x2gujIz38lwk5CglbIJw7eFzM7/",
	"TvXyAId/5sfqHguYhiwZzZkiS6qXiTPVou16tCH0bV8EmiWzaKppWOJzudAHWGIh9+FqZfmUFoWdusvN",
	"WquFgQcd5KIg9mXCVtwYKwDQhrfgF0wg65mS72i2tLoFyWhRjGtjpiwnBbtgBZGKcCGYGhOzpKY+/DCy",
	"v97DOfImOhKtxhlCQQtUbC4VmFcUIysKwmnlbX7xN4G5arpibSXRCktZGQtjdN8+eeZXxy6YAJ4Uhgbw",
	"wxrBTBUPPrVzu0cws5C4OKoYWGedNTDv2kBjoO3btagV9RRS5WAdpsb+xhXJpMIhUPi7ye0/GFX1x0id",
	"d0vFJm4IRS+Y0rSwq2st6l4g30Odzh0nM6eGRifTUWHaDoGcA74DpZCphE3uVenszfaxVXAsJdXUw0FP",
	"AZ0m7AfIbIsqnMm+YPmWkWSFxnZS0ux8Lyif1pOn2cygk/cd2vfdFrpFhB06W/NcH2qbYLC+vWqeELRU",
	"ena0w2idWjvONQQBZ7IkyD5aICCngNEQIXJ9cLH2rVynYPpWrjsiTa7ZQXbCjjOY2X8r188cZFJ9Blf1",
	"mVwTYTnZjvv52Pu1gqCRtIj4m1rAQb2ajkxNUJERIsuAyCW1Msgozi5YvlNB9m6BNm3D7g0h628dJjTo",
	"Dw3vtF1E7UE8nkl1NX2t4zGu/aKE2lEjdXXcIkN4tSonjvslvJb4QmsgEszO29Ws9vApjDWwcGroDWBB",
	"21EPgYXmQIfGglyVvGAHYC7LpJo8o5p98Yic/v34y4ePfnv05VeWJEslF4quyGxjmCZ3nf2fgPvxXvLY",
	"gf6WHv2rx+E8N8ZNjYPmqBUtu0Oh/xtND/gase91sdZEM6w6ADhI5jCrPCDayU/43fvx6BmbVYtTZgwX",
	"C/1ayfnB5U1nhhR08NLrUlnVTTdjBZw+epTbV47Y2ih6VMKbTOQYEWHXwbW9Za9mByGqvo3P61ly4jAK",
	"jvDth2Lfbaqn2cRbpTaqOoRtiSklVVLJKZU0MpPFxGrSXCYE7Gv3BnFv+O0q278jtCCC7NzgGK9E3mME",
	"MmsxXEPAoc/WosbNVu0M15tYnZt3yL40kV/f80qmJmYtCFBnwzY1V3JFKMnhQ9DmfmAGNVy+YqeGrspX",
	"8/lhrNASBkooCHzFtJ2J4BtW9dAskyLXV1UH3FRDcNbGlvdxm36oHJpONyIDQ90hznK/7uRCAIjeiCwy",
	"NloYC5YvGrR6o0bFPkwhFHd0AlKLqefwGDyFz1hh6PdSndUXih+UrMqDs/P2nEOXQ91inC8yt996mz0X",
	"i4I17kILC/s0tcaPsqCnwayDawDogVif88XSRDf410regAxNzpICFB6g+a6w33SNeC9lbpmPqfQBVM96",
	"sJojWrqN+SCdycoQSoTMGWx+pdNKaU8wpT2oWaUUEybWc8FixDWZMUtdGa3saquSGJmSL/WHE5rhCZ0A",
	"anRP+FMI4cK3cLolvWCEForRfENmjAkiZ3bRdfQTLJJqe2s0Xq1zKvFQftsAtlQyY1qzfOI8Bjvh9e+h",
	"/DFbkAergVWEWYiWZE7Vzazg/GIn8OdsM3HhjXd//EXf+1QWYaShxY4tgHdSG9E2kHaXcg2YthFxG6KY",
	"lNEeiyfBqtiW6RTMsD5kXx97vdvfBrNDBDeEwAumINLuRo+Wn+QGiDLAf8MH60aWUJUTqwb2mh+s5mr3",
	"W1AhvW64Y4YwQUG1mewSKfalht3ELjXi4ikpAgP36JPPqTagBhIucrCQoyiEeVC3tFOM9gw2hSl7b2N2",
	"0l/8Raw7bWbFu9CVDrcyXZWlVIblqeWBYbV3rpdsHeaS82jscPVDA+iukfsQGI3v8OgMAV0DJxhhu4uD",
	"uA6rvmz2xXIDvhpH22A89W9FiI9zHXpg5LreAyQ3rlv0NpOyYFRgZLwsS8uhzKQS4bs+DJ7i28fm5/rd",
	"Lkmiow01lVwyDU48976D/BKRjgkCS6qJg8Mb0cHghaGzXZjtsZ5oLjI22XZe4BJs34oPzpWOe1UuFM3Z",
	"JGcF3SRcAviY4OM9CcOPDQRS2w+kYZMZ+GvTNFKfCR+HfrVZJUylU4o3gScks+fcXqNqUnNfX33SnMG0",
	"Kb7piPVOmAXASNKBHw+QhfSUGBFk/4U0lqwc0cFqnFS65lp6sBdmvREEwriT2hDQnv2/mXZzBwXsoPNv",
	"mO5beD31oZbdY/4H2d4QmC1R1pI2SRHRy5d3MMY+HtTji3hNleEZL+G6+iPbHPz23p4gGY1CcmYoL1hO",
	"ogd4ky/j7wmmJ7THvNptfpC5tQt+x96aWI6PfWsCf842YDZ5jZlOkbXqEOaIxKhW4FJBAFCfTWNvPPEr",
	"bE0zU2yc53ZDLpliRFczjAvqutCMLCfxAOlU1v4ZXchDMuBgawzGKQwVLS/lHsfb1nb4zlpXrgY63C2r",
	"lLJI2D/bJ76DjCQEgwKySCntrnNaFBtiQjqdp6QGkE5AQLxL0Gfu6AaaYQXkv2UFuZKWsivDgpImFWg+",
	"oCzbGay6GeZ0wcA1hljBVgxv8/Dk/v32wu/fd3vONZmzSwxqEvBiGx3374Mp7rXUpnG4DmDttsftJCF0",
	"wFcJiaAuzLnFU3aHEbqRh+zk69bgwcFpz5TWjnDt8q/NAFoncz1k7TGNDAuhhHEHue+aQXeddcO+n/JV",
	"VVBzCEclu6DFRF4wpXjOdnJyNzGX4rsLWrwKn70fj9iaZZZGMzbJIHl74FjszH6D+d4jSJ3m9gBjQtlQ",
	"gNgJfnWKH+24addRL3y1YjmnhhUbUiqWMcyetVqqDkudEkylypZULOAGpGS1cMHkOA4w/EqjJUxVojPE",
	"vqqYWYsJuDB0Mn0V3JY+Cd4qYYzam23b/4GXtUsaQEFhNEhoR9vT9gclXabjUe/F3+L7or74I96amfxX",
	"dSY29MMIaTU0A71ngE+rK3WRGG+jPXyWGG7GS1MPnYKyO3EUdl8/7Iu8P63KstgcQEnCgYhipWIaRFps",
	"BtT4VM7JC54peVwsZJB5eqMNW3WdN/jpbz3H9aer3IClKLhgk5UUbNOnvmhDz1mdVOGNsxC+h34m8gqG",
	"IdSQBpBjZ1JGbiHtTsB/u7oqmkHZuoRr2qxydlGrOGyYQfvoiqpzlhM5n9vJpsMNoW6RsI5ExC/CjqsE",
	"5mRXuVAMFBHLqexNLr4t+8WxtV9cjZQh69sDdNRptm3PC3h2NbbQpKgWNbTw1oRlCLu47gGA49jmq20v",
	"sv5eqkNFMOCAg+9rA6ICdobMuCmvGrtAiyLh7kfTTodD63EIueWKUK1lxkEJP8n12OVOYIQAJmW00P86",
	"JPYdgDm2x235taMkQnSSsKIklGQFBxeKFNqoKjNvBAUrarTURCCmN7z0m9yf+lfSNv6ECd4N9UZQCMIN",
	"ttVk0NWcJdjO94x5y7uuFgumTevyOmfsjXBvcUEqwQ3MtbLHZYLnpWQKoiGn+OaKbsjc0oSR5HemJDDS",
	"xnVuVWlDtOFF4Zzsdhoi528ENaRgVBvygouzNQznY3T8kRXMXEp1HrCwBx9bMME015N0FOkP+BRSohxO",
	"li49CgK48bGP16/LIY3s2ht1mv7v3f988uvx5H/o5PcHk6///ejtH4/f37vf+fHR+2+++X/Nn754/829",
	"//y31PZ52FMFOBzkJ8+c/ePkGVxyo+DzNuyfgrNrxcUkSZRxsFaLFsldKBHlCO5e06ZqluyNMGsB0pIW",
	"PKfmgOTTllqdA41HrEVljY1rmUg9Ava8al6DVZEEp2rx1xvRldsTbA1mire8lSHjOKM+OIBu4BRc7TlT",
	"Ict3fvjujBw5QtB3gFjc0FE5l8Tt0OXfNiKo7C7FaYlvxBvxjM3hri3Fkzcip4Ye4Wk6qjRT39KCioxN",
	"F5I88Sm9z6ihb0RHDPXWTIxS8qOiiSlOQVfptbx58ystFvLNm7edGI+ubuWmirmoO2ddE6SfcmL1BlmZ",
	"iSucNVHskqqUn8mXVXK5/PD1VjhQJ5EVGgh9YS43/nQolGWp2wV2uigqy8KiKCJV7WrEQBKPNjKkPVpm",
	"7jLHLQ28lC5gR9FLb06oNNPk3YqWv3Jh3pLJm+rBgy8ggbQuK/PO8UBLt5uSDTYq9BYAatsSYOGol0PA",
	"/qSki5Q/6s2bXw2jJVAIKBwruMUXBYHPmoXyXJYFDFUvIGTS77ElCNneWemw3FP8yleyTC8KHsGmNjP/",
	"r7WDUU2HK2/gjroQtDLLieUIyVVpewz8XvnyGHRhRY6PztB8ARcAvZSVXTIj2ZJl566YI1uVZjNufO6D",
	"iJws9gyHa7jyutTWObf4cwUPqzKnTpGhYtMuK6Yx0QQG/Ymds82ZxM+nAwtiRgVYo7JWuu/oAu1GsrZZ",
	"isaVC2GdzY8MELQsfQkoyBr2ZPEk0IX/pv9ov3aFJq99rFNE0ahS04cIqhKIQOLvQcEVFmrHuxbpp5bH",
	"RcaE4Rdswgq+4LMiwab/0fUZeVgtVSqWMX7hc9LDgJrwObG3oxmKY3djUlQswCZlBbHUtICEiGkyiAK0",
	"wyWjyswYNVtt4SIukuKhA4X8ElL+wWgytktga7vf3IARRLBLe8GDu7cMJidT6emVQtVwTSy/Iqj+8zrF",
	"f3qVS4RDeKKGqJf3YU/CfcHF/sXUCSDjc7C5LZS8tLtpAZS+WjGUJ4rkVKXpgg0VRw2L3MCCLg3vGgyy",
	"S/tJ6jty3lZrOjrGwEXg5xOLlyR3YPaJZQ9gxWyFj/q50T3rPDavomq1swIU6siUaUmHqoY5Uyz2AzbN",
	"xpgStbLqAWtiLT76S0ivhqPfMClfUVv8OIWQttUsPYkiG6npViT1YrrN2sdoz5kxIoX9wlcu9eVKfY3S",
	"0XiveqPjkUsfSe2dFKBF56xgC8SJ8wE4Oquri9W7aeF4hWZ7MkkFSUbGyEgzcXMwexG7T7yTYfAIqVMQ",
	"gQ1RCzAweSnjwy4W+wApXHU06scG2RX9zdKJmJjpYLVkWVqpz3s8gplnKbRZ0Fq3w8dhGMLFmFhOekEL",
	"570wjUE69THh7tOqhuniZu713YkGHjS3RtBO9lol6jNXWV+sePtlpG8Fe61hJtcTzDpPXq1m65k9E8lc",
	"EMiBTx1erFZ6R0MZCfARWQmHyQN7Q9cPmQcsCrFZcw1UDt/1qY0I3n6AbFfkU9SsgfScXS2QXZ8mezVg",
	"etTpPrK7GxWAPBBILQNm3fnCWXR22lma2lZXE6nF7ThU5A4pgClW03c4kzvZg9Gu8XQ82lIMts8El3h3",
	"UHlfX32U3G0X+sWS+D62LOLVwCqwruSuir5d+92hazj3Gv3R4B+qSnn4Pf8z0t4tPD22SgfvrZRYIZVM",
	"wfhHlGMR48YqY8CP3Zfp+xTvUbC6WN637Ynrd7B/+evWIeT5VgKODTi9lBsLmw9SY7VLldcpi4sfD0Ro",
	"XBW3zc8aQGzB6uv2LSyJ1mZUYxOvEdZSMtVqKl1vbRdtmhUMTFmTxsVwcp4Ks3jz5lfNQOk99Z9FhnrY",
	"PSo296JQWcUWXBtWe8d8BNyHd14Cs5qUSsp5/+pMqeZ2fT9JGTRlZKfwYWOZH3wFkNcy50qbCbgWk0uw",
	"L32vwRT8vX01fZNrxuVwjb7KvXkmQHTONpOcF1WalB1IPz6zEL0MqpeuZqDpcYGhiDNoX5SM3t/DuQ7w",
	"YNbHVgQ9RwQ9px8CP8MOln3VwqQs5TWn/0yOWIsXbuMsCVpOEVN3Q3tRuoXXRoU2uow2ksJR3NB0m9Oy",
	"cy5zP/bOUE1f7qNPC8aRkmuJCtKms4vlYsFyX2jTZYxjSTxX7q+QYlGXGrS/b6neOiVYRBVqoG4pn+py",
	"V1hf5kqjBRxoLju1IYC8Tr2F0q8wyYIJLOt0BWWpSCIuzpqBNyLT/ofl7Z2cmmRewVkrl6AO+Mc9DJsN",
	"21Mwmju7gGZ+fdsPbXe7HOrGfRkJjQrd2w8YDAgUx42OFJgO0fRwblqWPF+3PNc46qeoP9cfNpMNdrRV",
	"vGOFIrzvnHRHcNk6msk1sihnD4IjQTNXgSSvFHhBGxkE3XtbMJAMXPKPv5waqeiCOU/2BEG61hCwnH3Q",
	"EN1qNTEckyZyPp+z2IOrr+J9bADX8dPlA+i5h/K6bt5gE9lKlnvTVr2C3QhN01OCUvpihc66fnR/34hs",
	"wkHGtDr97ekMTxYZ+ZFtJr/QorIXIK50HVPtHNtNab4HTVysfmQbGHlnqLIFbMeugKXjJwYUmrL4hEc6",
	"6s1wRzc6NflWMk2bxsCdOk7v0oG2xrXd6j8atWBqmKR2mmcOdGzq0C4L6ZC9Ok1HS9mzxZrb0ib0XVs0",
	"xAAU3TziqThEHV1FtoXqOzujIhktPOHDYkfvx6PrxSl1WVgYccdOvA4SObkLEEWMcSuNYMU9N4SWpZIX",
	"tJi4+K4+XUPJC6drwOs+HOwDX6vSp+Lsu+Pnrx3478ejrGBUTYKFo3dV8F752awKDdTbxRA2wQg2YN4w",
	"jdeNCuIIsEtoeNEyonX64tXxftFBdRFh83SGw06+6UITcYlbQhRZGSIU60gKDFBsBiXSC8oLH7DgoR3q",
	"HcLlDrPiJ/lEPMC1gxsjl8K1x9L8dzaB0GjZE1ioA36dZHSh1NziEhJkEduI5TZtvPj2p/03vzfp5s2b",
	"Xy88OLVzEqMOQ3eURGCqvmLaQIcBphlIfQB3sG1A/isouZy+AwpXkBm4tYvepAdXTr+XqiE9Xfp1Mvrz",
	"5rRWe8NBPKYjXM5cSEtHV50S1GvfLd5ZhnX/fkxx9++PybvCPYgAhN9n7ne43N2/n4yySJodLR8Fq6Kg",
	"K3YvJBn1bsSHNYkIdjlMhzm+WAXFXfaTYaBQDOP06L502LtU3OEzd7+gXy+J0O6Jijcd0R0DM+QEnfal",
	"T4dMghX2I9dEinaxEEjnt6QF8tA1c8Kgle4REtUKgjgmuuBZOoJOzIBDCoyPty8TeHlwQIado+I9SRqi",
	"4tHo9jV9pfiB1kKiWZMI18mS5TV+Z9KxgErwf1WM8NxeLOecKRABLY3B389g1I7Wn7Z1uoHRjVkPP1TD",
	"t5/ta7/a4q5EIHtR1ev1fRY8kX79qU6De+YMxTN2eP6WfB9HSF5qQnLo0oXf7ySorXfO4BhOGoKcJ9pz",
	"Tef07b+suTbeuIfPhmww15O5kr+ztMoAfspEaSHvYOfgA/idiVRcQpt/hegbv9549l0EMtzO0Ucq17Zr",
	"+EWHvqlXkdxp9rDfRu9pwIj2u9+EodPtD9wm9F2a4+CtZjJaDw+DAxulVkDcjQ8ZpQJPKNbdaWRvps95",
	"nGx9hOPX59zB3ElQL+jljKZa3dm7q4Up2v5GcKuRxH/sN0iH0jE4O4nygcK7HIuRlkzVDqxuKfcr3kNx",
	"2sE30PrCCRQXXzXHGC5TaJkYphKXVEAsLnyHHNB9rRmGgtivLqWCAsQ6HYebs4yvkob5N29+zbNu9GTO",
	"F3Ym34RsblyMlBuIYJVjoKKc67Kgm1AryaHmZE4ejOsz63cj5xccLmLwxkN8Y0Y1yOUQlhE+sctjwiw1",
	"vP5owOvLSuSK5WapEbFakmArAI0zRJPPmLlkTJAH8N7Dr8ldCLrX/ILdSwsYp6ONnjz8GmIV8Y8HKRUp",
	"Z3NaFWYbk8+By/sItDRlQ2YCjmHZqhs1HY02V4z9zvrlyZbzhZ8OOV3wphNBu0/XigpqEZKCabUDJvwW",
	"9heiSVp4EegpYtoouSHcpOdnhlqO1VORwTJEBINkcrXixtfC0XJlKcyzVn/8/HDYvM81wvRw+YeQxlAm",
	"rvYf4ZZFVz1ZwpCZ8hJc/jFax4RiRemC1zlMvkc5OfGV86EzaB26CbiBpoUcM28g5wpapHFhwIJVmfnk",
	"b/bWrmhmGeK0D9zJ7KvHiQ6bzRZpYj/APzjeFdNMXaRRr3rI3ms57ltyV0gxWVmOkt+ry6JEp7I33yId",
	"I98Xut8z9LW1azvupJcAqwYB0oibX4sUxZYBr0mcYT17UejeK/vgtFqpNMHQyu7Qzz89d5rISqpUJ56a",
	"ATitpO4Q2rdJdsxr7oUqBu3CdaD/uAF2Xi2NVDd/upOXhcjDnbinhdJkVtP/5UXdvwMc7Zj73jJaSpUw",
	"zzpD4weOjN3PTNj252NEIjzrwdxgtMEoXaz0pExhTlT45mOEnLVBwj1vWEgfviPK3uNB179/H4C+f3/s",
	"VOV3j5qPkb3fvz88ajdtJrS/JlBzNVnTrq5rv01t9bcyYbTzXYZD6Jor95MwrCZl2VnUs3lMmq1cP7ze",
	"cZic370jodMHyKMGHrdx85H5K2xmnUXWzx+a/cOT5JOH51EaByXfyvVQImqJLU9PHz4JIb2RCfDw7JLX",
	"yCFbAv4dpne+I/+qmNrUZhBoV8MwnVV9eK6YIoGeLR9o9QRUdLqTJ6NSdoZURcfSjjpjhbQ38bgB4eAI",
	"oU+ZyrretdF4y15UvMh/qZ3rLcmrqMiWybj9mf3wN7zmRC9EFppsSYVgRfJrtAb85q0GCbvGP2XPsCsu",
	"0o/ajfAR9hakNVhNIPyUfnyLK24KO0GMombRvlAGqVjInMA8deeomvVPRwnEd/tsd+uAwLCryrjAbyiw",
	"4ho6zXkBIctpNz+8OVHU9EgNBen583pEdmH1MDS74OhMEcpXoJZouioLBofwgim6gE+lYK3PoaojjBy1",
	"hSK6tI/gTSgQJYmplCByPo+WwYThihWbMSmp1jjIA7sstoa5R08ePnjwYJjvFPA1YO2IV7/wV/XiHh7B",
	"K/jEdV7EhjV7gX8V6N/XVLfP5neJy7W//lfFtEmxWHiARRvA8W31Fmx9Hdq0T8kPUMPQEnqjRQsYfX2F",
	"+2bd4KosJM3HUJT/7Lvj5wRnxW8UA9RB6+0FWDibRyTpxBpeR9nXaOypbzd8nO3lteyqtZmEptipaqv2",
	"jbqXN29FmoHtM8bOlDxDs3OIV8JJCLR2UCuWRz240cwBxGH/YQzNlmDPnY62msx7urENbyHvOWDtDotS",
	"i0PDQuDgdhmuizw2kR8TaZZMXXKo3U4Nu2DNoq6hIrJzOPgir83VqkoIJJzpHtp5aE+47y544FC192Ej",
	"Scha+3Bt32Zd7QeKE+zbbP8UayUkU6Nanftb4RzYsmjtmx5NyQvnzMmokIJn0OwndcWAcq3D3MYD+iKl",
	"/bl65M5y4hgmSDkqYuGw6Nb/tpdlnvYUmYif2v1GwsE/DVu7JqwLZrTjgSwfgwGOF8w5ILnQTIXaC41y",
	"2lIlItqSKUghMuaA4f/jEVRc7LElf2+fvXS+B6grdc4F2BQdUt1NFx2IheYQRyAIN2QhmXarbabe6V/t",
	"N9OztQAQ3k6fywXPTvkCxsAIS6hOARHX3aGOffy1i3e27z6177reMeHnRqQgTurX/TbJQuoiI12Lz1r0",
	"oj8V0uYzACPkhvHj0bYQ49a0CpDLlgzZBQQ0shLkeYdsmFKpi/V39g6J9AZvEEyOTpYW5yIBxnMuvEM7",
	"XSsvS8oS2Bg4zT3f6UxRg5eOQRzvjNGiJ/UI6hZgRMR1h2p3wrEogTX6Ofq38WwtXBufHrYSXqhvF1Rs",
	"iD8UlrojpeQpLULiASpTTbu71c6cMoYx0JjM7NS7NFuxbH3is58b6NqZaxs+h25U+8qpvorEsypfMDOh",
	"eZ4qKvMtPCXw1CdvsjXLqtCEMaTyNls6dKnNTZRJoavVlrn8C9ecLueaas1WsyIRUfwsPGR52GEoVjfb",
	"EN+sZvjOuASDvRPsfTZBvl8fk27BgJT2bGl6ovliMhwTIFOuj4566qsRev39QSnd59Z/EqnzLS4X71GK",
	"v31nBUdcyr+TuoCiJVTahzQBCc99zcBQ7bnJlUCUdfpsQsQJbF5iy1rA+xeTgF/QoqeoReyVQvmKnpq+",
	"0hZZb+UWalyFS0NJzROGmDD6awRiYHnL89V13/aFjmPk+E06hxw+tiK935P6Y8NvilF9NUPp9ZdezaVZ",
	"E8G+Pk3XrqVrL6VFIbPBnMENc2w/6i/nLVcr1x0jEXV4sZJ5fBbiaDXG0owNA7ITGSNwsU0+g6tV8om6",
	"TI/WsI8Eohla2RDQ6JYwxiRYD54HBqeOJ4pMtg6z5HteQHO+/zp99XLUv5HRDnS31JXXT5qw+zYmZAW2",
	"yWMhG/jYwgOkKNL2b91jUofyW+nT4LrDJx98jwbCISBhKap93n4+dPAOASwkdo5L9dbpFgAa1dvhkR9R",
	"Q729yFFi6khRRbsjW+Lug0bP+hUSGkEPagzd0JGGNIBL9RpzNwVvgUVB40r+YQO2Tu+2DgN9NkQ57ODj",
	"/Xh0ku+lPqX61Y1wlBSDfc4XS/NtIbPzvzOaM4U9h1LXSew4tGL2GqqXvMTKnVLzuh97YQdzxf6XMNx0",
	"aMbR2ZK5wju+IENnLB8gfsEyA/356zBXxdjwOI4yvUQLgXcowisfIdRFMZaz0iy3KksYvF6aZd22mbmE",
	"Oq7JjDnXxQUTY8KnbNrOwcvrulukYHTujbBKSjOgr7m3tiAaY6BT9NXpkb9dDeyU1YuqRmIr8+nwRk3H",
	"IecB80cvqa6Lc7VKVgxOjZ/PWQZNMbZWOPzHkomo5N3Ym+4AlnlU8JCHLEho63JQi3YN67Zag1tBjfrW",
	"3SSkfcVHztnmjiYNGkp2ZA+Jw1fpEgHIQT+ubzyyo8Yv14GeAEE+zt816aj7sF2lUUhUAPSKYHgat+Kp",
	"Lgp6NWi8RnMFMOyne07aW3EQFNO+Aoqvsbh2JMr7b8rPmKG80C5oloaWFLE9iZx02+FfupYWUMsyeAt9",
	"cwum/W++Bi7OUvBz18UKEIa+2Uuqcv/GQSoRotzkaaDnYWZeJ351o3z2jcvBDMyskFYBmvQlvjYzsUKI",
	"8h2NseR1gTiAes6UYnnwCRZSs4mRPo1sj/qqLj10C/Ywiv5KeGtlLOyRCY0r6u2z8lPdbAZaxlLoq0Jd",
	"cH2MFaLYilroVdQAJm0G3bVDT/G5r9/iW4BuN6/24T2ci8nO8E2fWmjlTAvz8emaE6cc7M29GkVfrmCZ",
	"5UIwNfFO3Hb7F9GsRAqlq/Mqc73Io7MZrNeDS7xt4WZJo2bWXWXrChUVGzlnmyM0+7iyI2HHY6BRh0TQ",
	"o5rdLaI4qK1ap+BeHAS8j1shtZSymPR4Bk+6PWvah+GcZ9BDv6ozb6wWfKd5bOwk5C44pELMyOVy4zuy",
	"lCUTLL83JeRYYPajDx9pdiluTS7umG3zr2HWvMIuVM4CPX0j0mlk0A1KXZP7+WG28Lw+3qSZ5ZfXnB8H",
	"ucLsZi36YuQuoW1Us5f4dKh5oxvf0VKhIvJDKFIK1Ck6gp8CS0jcowgUnYmqI0F8ACXOgUx0IVNZBlcp",
	"jGOHSmMqngwAMkwMuK7WULjBkwhwQXY7KuC6x77Gq5yHnibXKXbr6sciE9d9ppH2zGGWJmecS8XiGSHO",
	"FGthh8w9KCUN/5hxo6jaXKUkbRNVKTNUL5Z3RkuGQMl6IXWwZBeHRSEvJ8DWJqEDW8ocYN/TTbHtexnX",
	"39mjPmNR2CX1jWk2ZElzkkmlWBZ/kU5hR6hWUrFJISEKMxXYMTf2krCCvFVBCrkgssxkzrBZYpqC+uaq",
	"hKCge7EolC2JAqQdKImA30R0PHBKK33RPTsBfW1nLxO/+Wf2GyzPUZcaxEVPMESgJ7+AaVfszmEIX+7C",
	"i2XxoNBU2yibVpHnfA10w1TqyM8hwWNM3BuokMQkBAefKkZWXGsEJdDSJS8KqI7B11FAQ4gHSqO2R3c+",
	"gTjoCw4Bb81KKahSl1Y6hvIyMQ84jQvNEbNUslosoxYMAU5/dVeVu9jHo/ysK4hJhAwZO8VjspLauGsx",
	"jlQvuQ4BvZtJYZQsiqYhD/X8hXP6vqDr4ywzz6U8n9Hs/B5cwoU0YaX52JeMaMfu1jOpVr3LYTcFsxYT",
	"IA+9u5I9vgdRrY6eB/POFvfrOB52WfIjMN/uZq67/RrH3YW119Xks+m70LEg1MgVz9LH7fOKfu2NWU1x",
	"r2QBSexUjlV24DXgA7EcC+FMwD27aGaCJlstHxPHI1xYB3Ai+09Q49vjkjlzPKhHhnb5jlOwJlmvGtgC",
	"ACDFQg+mUtjePFbSAsORCywMA0EpbUAHChyI/bsebHaEgwNl2LWA6kQjBwDvogVjjIU+MbJ5Jtf++b26",
	"EuiVgH+/ncobzKMvqPK0Ji2FYZW+UFcPR0g3e9gagXgGRT5mQ+MQtfcSDhT+EQD9kYkNGAbFJ+4Lxpzy",
	"AnoM9sh9sIGNo+u6y7GMRvc9X5GTZ7Ty3cLt2JVirnAUav+q6U4sqSUlGV7vWsRFztYMc7R+Z0pir+9x",
	"5M5iBbYCb1kUZDkp2AVrBGy6alYVaKH8gvlvdfiY5IyV4PFtG9pSkYhxJ9GW9cWtfRLFsg3BbtIcg4jF",
	"nSI7bC1Jy9BaTPCY6KFHyUJ0wfOKNvCn91U5mrZEe5QTqOpcHyb+ijl0mp9xBN8UVB/771OqjMfE22F8",
	"aG8WlEbdNga0MzK50n2nXqQDk+NSbcFRBLPlwa+NJF7zDV3SS9Fv1eySfH0TG7hPXIoIsd+tWQZajbsK",
	"sdxdhno8J67GE1C7YCzHC4P9JGHNXzJBhIz6ol9SHW4xdbFa/wNODC9x4S7aV/DR1/HD199ZAoMR3Som",
	"mW5jHMj6ejb+j3IStx7E3vFSNKKZS+XdYhrz1O2uHfCCrIqcCLufVveHPuJOijkuPiazyg9UFPISG53H",
	"V9RnzPtzkfq8i8mp5TyIZR8nPXZ1lNtWEB5liKzohkgF/7MX0n9VtODzDfAZBD80NtZLaknIOZAxisLF",
	"XduJt6tXYw+YN8RIPxWumw8dMxpuY0eJgLaC3HfGk2RFz1m8DRAggvwzM5Zx6moGRg0rslvb2cWCW7wv",
	"P7WieWwEgEK6mwZ38HXc7df/u05bjafy9S3Lgma+rb3r79fkM1YZCsRllmy1Pc25y9c8Cfi3IqJVvkxG",
	"fgVr6p6sK5Xz09eIrAF2dI1o9iE7zDL26ZxdVxzZkiA+aCmH3oXD5HB2lhR3U961uLi59IfZnWQF7L5l",
	"DAH/E9qVRnhFJ7PNNxHsXw+88iF2oVGIJwErmsFncj1RbK53BdKgHXwm1zXAOthuucgUoxrjjk5euWtr",
	"XeCZC3uNxqjd4FYNo+RszkXNarkoK5O4BUGdZ7GJEBZ7EwCtPb65Ph3DqqIXtHh1wZTied/G2dOD3Zfj",
	"hkjeg+K+TRhAgkTuDsB1fQOEfOraPh+/ZsU/NnPE2FltqMipyuPXuSAZU1ZrIJd0o6/uqgpeh13OKhrp",
	"Qs1qIZHbCkgbASk2ztt8TUdSAJAe0KM0wBMEQdoJLxAahozscfx0YfgsPEErup4UcgFZvz0HwtXxBtch",
	"XiClACM6anfD1u3n0fx3tn0a6LDiGJGRMOuQKbaf+1ewlXAJ/Vlws/Xko4WznYaNkc54MD1SxaJOz0Bi",
	"6Z7HVOa8K8wUZ897VdWXKfG0x6JNTIZEd6zqPbsI8RWu7EJsQh/eGLQZwpHKz0e7wgTsDXpLAgbTdV4B",
	"zVyEWNcQ1zFUIFLGrrrBnnY6tO57udQDHtbic2e9OW0I0LHj7NNNdXs9g0kpy0k2JLYVmzDlzsngIG3C",
	"2EMfkQuhZ90h7kaHtmSNmmiN/mT7NpTt7Y+2y1dWZttMBn1Gph6O3nRgyDnwMjjCaFqDXKtgihn7y7l3",
	"djeNaIFJEEoUyyoFRuZLutndZLOnuv7p34+/fPjot0dffkXsCyTnC6brng2tJpV1aCIXbavRhw1G7CzP",
	"pDfBVwtBxHnvpU97C5vizhpyW10XW+606NzHOp0QAKnk3G7nvyvtFYxTp0V8WtuVWuTBdyyFgpvfMyWL",
	"It0zJ+hVCfdLarciB4y9gZRMaa6NZYRN/yk3dVC2XoJxEaqiX2BtKCky5q3Pjgq46YnlSi2kL6YX+BnU",
	"YnA+J8LWZeF4FfqJtq3L3dPQvgdKI4TbzBgpZelUez4nKYggZ0tVLNjVndkU7OlRmG5gthiwmyJEF/ye",
	"Jr1j4W7Cck62c/tm23OT5vR2ExPqhT+UVyDNPu9Gf52Rq3CS2jHwyfCPROGUg3GNsNyb4BXJ+8GWrPDj",
	"TtREKBoyCLRugYwEeQAAPfnQjaTVKMkuqr2u0McA3gjvfm6rHy9qt/TOzBSAxH+wA7w4l7l+LyRTOHA+",
	"ctXqFwEp0VLe9lFCY/m70qM96w2CJNoiZzQxhmlkS7KrFkYJ8fppyDPvuZV00tGVlIbYm2lRJNLY0Y4D",
	"ZyomHHslUBe0+PBc43uutDkGfLD8p/7ErThtOUYyolIfvCDnczoIrChF+YNAJV5Dbv0/mN3ZpHR0szjH",
	"f0cGgkmIFhjtPQ8ecCbIJYyJgV0PvyIz186oVCzjuh1QcOlVmpBvyxSfu/hatjbt3N9rt0H6RZprHIe5",
	"jwciLyMnW4gccDDXR/0jM6ceDpA8LSlS7RBKAn8pXhc3sN8hdq7Z+uZqpZyiwo17lnLqtuYfujxYBwiv",
	"SrPuOgdL/QZuEwK/XtvQWmWDO+i8efOrmQ0pKJbudmM/hxpnB2l7c/2mNx+kwBmi0o3hIEkSVq1y76pe",
	"04qXjOo0NHfRqvs9ffGXiH47GlwK5pXA8UKDV8gV92xdzschikEK+9kT8kbcJ3pJ/d3C/fnoy69G4xET",
	"1couvn4+Go/c07epm1q+TuaV1oV0OjGirpvAHU1KuhmSzL6zdE4Sv3WloA+v0mjDZ+k73d/tnsHF1SUg",
	"nAhg9cBeUIK6+jm3BYC2EkPrsIYTgyRZlwcKW7GrUtAvfWXxsfR7T7ePFveteLEzSK7RiOX9eLTAImXQ",
	"neQ314vvw267h6CnXqBb+nXKgCFiEmttTB5NFRV1G9CQxX2W6JABmddZpbjZnFr8e7M7/+08VQzqh1Ce",
	"ydX8Ch54p/saec6EjzGrizlV2mvXP0hagPaJgQHC6pyymJLvsEOIE4vf3Jn9B/vib4/zB188/I/Z3x58",
	"+SBjj7/8+sED+vVj+vDrLx6yR3/78vED9nD+1dezR/mjx49mjx89/urLr7MvHj+cPf7q6/+4YyndgoyA",
	"+s4/T0b/Z3JcLOTk+PXJ5MwCW+OElvxHZvcGLGxzKFAISM1AxLIV5cXoif/p//OCcprJVT28/3Xk+l2O",
	"lsaU+snR0eXl5TT+5GgBNVAmRlbZ8sjPA7UsG/eV1ychLwhj/2BHa58TbGqo72ef/fTd6Rk5fn0yrQlm",
	"9GT0YPpg+hDqKZZM0JKPnoy+gJ/g9Cxh34+givaRds14jkLq6Ptx51lZYqse+2gRyoDav5aMFsAi7R8r",
	"ZhTP/CPFaL5x/9aXdLFgagoZY/jTxaMjf/c4+sPVlXlvAUsGG2BXlqj3hg9+LqtZwTOrobpqWeB1wqQe",
	"HTf8d/64So/JjBZUZMwnDogcwiKx7IrVcgLCT3KLaPz+pGZ2gEYfjTJ68mvKKtsBb+qJ1O5AREOhrlLN",
	"I8AGP0IeCa7xwPEsF3sw+frtH1/+7X0yGLsbl1UHNG592qmUv4YY+RCfRAsC/A6FVYTXKflZM/KOFsU7",
	"CPrw3zWi68Z9UZHjup4PfFDjFTNTwtPo8/odN7d7aULLUk/gqW7AErJkoxgiOU+NrcldTzrwEW10U9P3",
	"2hNCDN5VpsTgvdZkgAGc5kVVGB54ZGjOD8x0opkd1Y5zl00X03ESA+M0kPem5KU07InbMYvjd0IK9s5O",
	"IaRxs8wg8gwrV0NqHsLRbBeDH2LHqrKAmrxzWmjmCB369NWU7lAziik7iFCva9OisF9IaDSQWFX8a7yu",
	"pELejSPYAOu0BzlB8k/rJNFL1z4/jk+PItf/6/TVSyIVcTbQ1zQ7DwmyPlm6ThCPc6Xtl4ETtBDkFJ0Y",
	"Px4tLtN2pRdls+1CMJm8hf7gACgg9NGDB16mOftQRMtHjg9HMw1qMoVu7DCKB+cKA3VlHz76KRRNV7RE",
	"/n3s01zsVc8FEuBLU7upjw+40GZp92svtz1cZ9Hf0pwoV4EDlvLws13KicCUBavDoK71fjz68jPemxNh",
	"ZS4tCLyJyhqc465y8rM4F/JS+Dctp6lWK6o2oEWboAy0uyPShYboHdARkO1FRVfFYvT2fa+mdBRLrW0q",
	"VePFoz8aNQ3zaylc6PdvSMjdOliPHgBjYZa1++HucVlCDsNpeH5clq9RthE+J4wDi2Zrro0VmT/EXzfc",
	"9QgJeusbSW4OR77CajN6K+qdn1QIGwV4/lK64XHTts1zJgyfcywxnVpHg+a2LmdwL79EMsj2x7fSPqaa",
	"TuJtVLxw3ySj0OUl0tf2GAOP9AEbjV+v0C0CkSzAv1Pg3KJ1f7T2aYLRUoJSWDdC/zBCxTcWCDKwIexu",
	"UOR85nrtC1pYEoqW22r2ePLsVt/9S+m7ocj3AvXKsjyABuyzJHe9cvSHq0J9CH3XGWkGaLqxBSz6NrII",
	"3W1xnHtTctx+52psxZX23qnDYtbmX057xZrjO/VWRzWH1VgbibK7XrjVWvvVqzjXe5/U64ZOZX8f9PGf",
	"V029xeNeeqldxG6N9ArMv6NtOlFzY0LhT6llOqTd6pd/af0ydAa5loYZZ8EcuXJGkb55LcNq23DKTdAj",
	"mw1lIqYHdcugsA8e4XGd8QfOUkhlcklMeuyvvhB9gbdi3Kxx52LcVRB/YPEN/NvNybMhuuHnZhW8Ua9Z",
	"/WVSnKQ3+aaZctIH9dOH8UENY3KPHzz+cBDEu/BSGvK9zy348kPuwSF5Y5qs9uWF21jb0Uyud7E30eJv",
	"oWSuPfwNZheKpo+j5/ZtjA67C1VEZlSzrx77+8u9KfnWvVrXJXPxtAtpOZ7PPqdqgR9ZpmmRQe74P5/A",
	"+Hem5HuoqWD0GELaIVkTXuTCPHn46IvH7hVFLzFivP3e7KvHT46/+ca9ViouDMQT4bWn87o26smSFYV0",
	"Hzhh0x3XPnjyf/77f6bT6Z2d/Fmuv928tHz1T8ikx6lizoGS+rb9M9/t1OVb4Ab3b8GHDAr5Vq6T4kSu",
	"b8XZRxNnFvt/CjE2a5KRuxoH43GjXeIBxRoek30E29gJMsgw9WxJT8lL6RroVgVVWLwOugNosqioosIw",
	"lk89pUJ5AI01erOCQ10jRTRTF0xNNA8NOirFQoW1UrELSOmr69c3IHgj3ojXdMEFQrqSObOzY0sD1zCU",
	"io3PW5jLopCXkK4QFXRTtTXhCU48huTAsZ1+ztcutUmPLbzY8oOcCFI25x27etDaFaP15gpBtMQCEFDb",
	"D6INs0ppqSZQ0zwaZ0q+s3pAsHOGEs5RR08TjEWM5NRQ1yjUKM4uWA4IOZN+TPYkMGC7oAkGs7tMDItb",
	"Litdz0d1nRgZEOSFT407F8w1Ja99cVtsBxO+COkdVdBwQkAtJvWWdMHuRDMbSZjQlQIa8OU1Aj4zJbWG",
	"bzSWSUSiIcyenYxBH2doteZGg6JhGS3HREsyZ5dMhbHMkgrcY99cOOwUg4xYSzErqRiaq/63szUxzQSW",
	"Kojw6CxOYKFSrOAoIvnCMgdIjoFxYJO4rkvTDlBzIA3tz6/ivKDrKE0onGpoCAS7Ajb8FV0T6AJoiGZm",
	"jKWR1+Sbb8iDcW1NQLYwQbbQo1qs6HqU0CR2JaElf02sBQrWNdYTr8WSKNBwH3RAlTcG39XVyXGiqgpV",
	"Bbcs3Y/p6oBCVDj3lfFd5PpA7tOrD7J1Eit1HnX/UgMD33fFRpI5L0zEOGabKXkFtmjY1sul1MyRqzZU",
	"Gd8dBat7zvk6VGD0DKZvgfj6fkuMahgh0u2KXRR9q+J437T4dmraqGVLNykQSNnOBnwtsHVUWpxwrJ0b",
	"/t7qKlD4Vlx3dNxEi4r+Q6FccnsN5KCc3/5yCv3PDuu4C3rW0HK9zxyiZbJeYX2AEmomlKyXKtIkxk6Q",
	"0XP0zGB6gxPcXttx/RPgVIbePk3hj3sJvzVkXnzuq1pziFQiVHHGoSrM1hOYzEzf6Tlr6EKBJJv60BWz",
	"S3H3hjjMahtN6MtRG0T/6tfCz9a+GF8yDnUt2ztKp47Cid0mrpP8VocJinkDXaR0VZbFpu4fZM+ft8+k",
	"VVE7w1BfyOcSY3KjPhAIC0jZ3dt7dcsRbv0e1+JLbYLakwdBHQ599AfIz5gBdZgA1KjYyQCcIMY7T8/Z",
	"9xrc4Q7+AF2uX2EOOatxiTRyF/I2oWwvFOvfQPVvBdX1+RyqhN7zBgOncufuorNVycbhJ3bSPTXt2xi4",
	"WpUGWuy20oo30Kp+Q5vYR6W2ILqLqcRRfFW6hPCIBELvWN/aAogp0AOo3N7ZgbVRLBkZGWrEla5Y+GAo",
	"n9aTd3VUQMshguNuEbwfgjss/jt3yUGe4hbxZ8jb9ab7CXkp6zqDyO//lMFnN6mf3PSCXkrhzNb2MoC0",
	"eBtQF5SnWuj7srSx0eo6itSRL/21VZv6Oxal+kw1qhsQ6X9PFkxrSB2L2OnO2pn1aEOYta/IRhsq4PRj",
	"3s0+Cn/9BC9sH4ODfRiWg6UbHd9xaoI4LBOCys9IzEehbmIfR3puX470tNeuet5flDttI5g0qhKEE6pS",
	"0kQV7ulf8Dg/dR12ja9RipXHNRcZI1quaue4a2CGEP7tw0Fo+IrlRFZQPj0qUvORGc6XD774cNOfMnXB",
	"M0bO2KqUiipebMjPIvjnrsMAITIjdALwNvTu4SBcQABQs0J9FpfBvgZflIstAU/O2l/32HDF32RlmMLu",
	"Cq2G6bzDt1NWdGAYz+3UtyoffO23YWiXsKe0KAB/u0qNwsCDctuKAjeYrbgxkU8y9l1DBJbf7HFte5Pl",
	"pGAXrCC+Od241c4ERvbRAthtwVWwI9FqIgsHU2wuoWE4U8wbF1e+JF78TXDOQiPqRMw5EmtcDPnkmV8d",
	"BtDJeT10m6B9Kzs3+NTO7R7BzELi4qhiwMxjA2gj0qABdDsKLkzh2oG7ThlctVqX1M7hsmRU1R8jw7hb",
	"KjZxQyh6wZSmcHpbi7p3q85/Gur82gXzfSLKfNLVe13mf3XZ1Mi9+8Osef5+t+7eqT//53HTnLXqx588",
	"i/OjZSjA7PWKnsVYRO5ZkuHfU1aGD12MP+lCqgudd10xw6r233qXBjOUztnads/r6+7woUVPnSMeH3Qi",
	"2yrBRxVB5mOJoElLBjXR8vEkEnRDHEfhO6WSRmaywFDnqiylMqE3hJ4OuoixPjHXuIf1tyW5hihb81zv",
	"NIKfwVu3V6LaCn7m8ZYygzfPr041uR7akKGea8hd6UyWBO87LRA+KqO71bFTDK5lMf/cDeaml/QObD/P",
	"qMmWVXn0B/wDGlK8rwtfQINPfWTW4mihpH1ta8wm8NiC5ZYY4dOGySteCYyWjLx8Dp/XfUi/lyrSR36w",
	"3+1mnU2kjdtaAMxOILgzwVRvRm2+1Tb7XAutDb++Qz0xYue8hrpOUVP7QLtRd1tfqomLRcFSJHwbAPJp",
	"Laj2t8y5yAmNtrF1qZaqZgQ37HO56UV/DBfOh496+fIzPmcvpSEnq7JgKyYMy68XAU3aHM5Lj63idj/F",
	"wIn+bph0V+bHEt9nigRdZKeA/xNZ7m5l/Ccl458Gt1RMoLcS+/OR2Mofwlvh/OkL5y8+29XcYPTHQGF9",
	"BS9aU0DXd/Q9RXVHTXDWrZZJYZsDDi7l7VXq76XyXdlv5fufLh8J93hwLMsQq84u662b8hDJPp8U9MNs",
	"E0WRsE70HeFxCJfhUChZZhy6SJ7keuzictCg4c73rUr0SatE0V7fakS35orPzFzRo/84S0FRDFFB9lWN",
	"LlYyZ947K+dz17OgTy9qtle35KkNXZUEv5z2xrae8RU7tW++wikOKmJrsFtuyRZ4UF6PZVLk+qqlXtxU",
	"VxVO4LHqh+qDu0jDtnhYXN206ZXp+KeohnGHPEh7R7CLs+/a4JCRswuokTg9AC0f/YH/B7tcKXViNaee",
	"qjsbc9dtC7ahwHEbAJLXoJli1ST/lZyTB1jOqxKQcLzk2tU1pCInRm18HSRUiWlBskaiYYCje5xOe4/T",
	"1pvDWWp1PWtKXytkfWyvfa/YXouuR/tupYP/+MGPylPsBQ472kalkYQSwRbU8Avmowymt1WVriwMXU2j",
	"LaxyTGieu5KaYRPYBVMboquZtqqSaKaN3NHNk7UHa2HrkiluJTwtap8/3jKOsGTStlimU3zjmjKvxbWw",
	"UFMottgUzK6Mk5yTFzxT8rhYyBCNrDfasJVlGQ0h6j79raeQmrdQ7GUxkKLggk1WUrBNQjxjxSlDzxlZ",
	"siIns43vY+JyCewFrtLkFQxDqCENIONoOAMVFrHOYrSJUpBzttFkSS8YYevSci4yqwz+YM/zhhkyY1D9",
	"Tp1bXXs+t5MN1g/CImEdCU6FsOMqIe7XrnKhGCiMlmgvpIEaFe3FQZEZlC0BKUPWtwfoUPNr6/a8gGdX",
	"05WaFNWihhbemrAMUa+uewA+EfZ8reCn1moVK7F49AyLFiGD2pPXea62EVmX1W1EFjk63cMGPfb8fORj",
	"8etWQn1v/tH409W+c2/qZWVyeRnNAjYejHkdUqkKLle36cu9RBzhJ3XmwtNwublUtMSjVz/ErAe4mdYl",
	"r/7KCc3OXRenq7p0wAuoKd+4wN9mNf+pspoH7/teXBo1o12crtKHVTpfypzhuHUmqz36qa5zQubMKXBd",
	"XTOE0KYr9nq5Vr+HeOOazBjULqXVYmlIVRIjU9WA6w8nNEPWPMG7bnrCqA473ohhOtCqaKEYzTeoJMqZ",
	"XXQtYWGRVINK5hMDXaDwcC0sArZUMmNas3zidb5d8AbdMBTX7kMerAZWEWaBjgdU3cwKzi92An/ONhNX",
	"h/zuj7/oe5/KIlAX3b4FWC83sRHthOfuUq4B0zYibkMUkzLmV+NJgMxDuSoL5nIPE8i+PvZ6t78NZocI",
	"bgiBF0zxOb/ho+UnuQGiDPDf8MG6kSVU5cTqGV24n+LTM74CjVFQIb0xfMcMYYKCajPZJVLsS/GitV1q",
	"xMVTUgQG7rGHPKfagD5OuMihIiSKQpgHbw52in0tJjClVQ7wKpWY9Bd8mJo2s2Je6EoTN4LPC2R5annQ",
	"JaB3rpdsHeaC8ip+7JB4iFbsXSP3ITAa3+Gxt3MRdBToLg5s7NSZ1vbCcgO+GkfbYDz1b0WIj0NbemDk",
	"ut4DJDdoThPTWyjrOx5pI8vScigzqUT4rg+Dp/j2sfm5frdLklg4AzWVXDId54s6yC8R6Rr8E0uqiYPD",
	"d4SA9rlM6yTM9lhPoEjTZNt5AY+FfSs+OFc67lW5UDRnk5wVNGG2+hkfE3y8J2H4sYFAPKFPLqRhkxnU",
	"X0nTSH0m1FXMpGFWCVPplOINZkJNMnvOwVgYSM19ffVJcwbTpvimI9Y7YRYAI0kHfjxAFtJTn8n3QkL+",
	"oSO6yPR53bX0YC/MeiMIhHEntQWoPft/M+3mDgrYQeffMN238HrqQy27beKNZXtDYLZEWUvaJEVEL1/e",
	"wRj7eFDKivxZuuTaAYo3mFPbtKJHd/jpVewTR5eUm8lcKry3TOjcMLUzU+YflPuYF+fAM9LVdyIwgtMR",
	"3DggteLWyY5jOeeRk3+WRFwdLeivRx6SFReVwSeyMq4JkmI0W9o7Umxex5G4rktUKbagKi+Yhk4+XhGQ",
	"CktemZYyA0An0o+bRhu77u+l+sybKby9tTjdWpxuLU63Fqdbi9OtxenW4nRrcbq1ON1anG4tTrcWp1uL",
	"063F6a9qcfpYVe8mXkPzdWWFFJN2oPptnPqfqolCkL3eAAbWp0vKgQVGRWf67VJ7GPoMowXggBesP8cG",
	"A/rPvjt+TrSsVMZIJrH5f1lQe+liazN21jUyo5p99Tj0AgddgK7IbGPZilUY7AtfPCKnfz/2dZGXrktT",
	"8927xxhqSrTZFOyeaxTIRI4Kue8YyIRFumsYSL34yVwKO9qY5ryA/CRNvoO3n7ELVsiSKSxWC+1Cuxa9",
	"M0aLpw43Owx6/7CTuzSGd3a0d+OGUdOhbUVLfy3ya6WaUEyGJ8+i9Ph3c1po9q4vQx7HW9Fye6fRt8h9",
	"mTbfynzTOiF2145gA5tnIzRNnHFB1SZR9K+biNYmDSMtu3KE1TVivj9oAuEy2VusS2a7KCzZmB6aPKRH",
	"76Py1Dj1hnWGwhoK8xadjFLp/7EoXWKLOQfgoDqvkKyGe0J+wu8+blVXgMgdsZqZfzKBxs03A9OAd+2t",
	"yLGezzVPyyM+eXrh7I8tYedVxgg3mjiKGyBerEZoR1owMXEMaDKT+WbSYF+jhhTKuaZas9VstySK+Sec",
	"uCB87JPtcurjiJFn0eK28eSYaNYTx4B7uPPGsMG8OWALRnTsOcL4TbPoPjYag0Acf0rZ1lq8b1+mV0+z",
	"uWV8t4wvOo0tjYAL1yCpzUSmN8j41EZVop/nfbdmWWWBi0/yXfB7gFeVrU3DiZ6zWbVY2NtC180KTaJg",
	"PC7FR2KFuNyhXHA/CsLBf/JpMNetH9IerstdopIed32h3XuwHVRgPuyqpGJjdwPySCaar6oCcYht1g/L",
	"aLEnRKpjQG2d7LPgv/ZGycgY7URt83dEC7mkmuD+spxUInfJip1WBWsxvAQVDn22FjWb3lpuCtebWJ2b",
	"d4iI8LvcLPihScnUxKwFHqjGYQLvGCV4cj9qa4RbsfHhxAaWC2E9DLbbbaVmCAeSHiriayA+oo5idU5t",
	"o88YbWYCN56BRaM/Cy1uj4RvHjQ2qDN8M0SoNrc4fzMrSkJJVnDwRkuhjaoy80ZQcEhFC5t2w4e8Dbuf",
	"9z31r6TdpQlvphvqjaAQRBbcVEkeOGcJd8n3jHkWq6vFgmnLR2MCmjP2Rri3uCCVsLcwOScrnik5wax4",
	"e76s7jLFN1d0Q+ZQbEqS35mSUC4h3nW0JWvDi8LFK9lpiJy/EdSQglFtyAtuObAdzhe1CSGFzFxKdR6w",
	"sEe1ggUTTHM9SVtrfsCn0K/d4cRbBcHCiY/r3kXta1DdreL/3v3PJ78eT/6HTn5/MPn634/e/vH4/b37",
	"nR8fvf/mm//X/OmL99/c+89/S22fh53nvZCfPIPARKi4X3Adtxxtw/4pxA2suJgkifJsyYiLK2zTIrkL",
	"5Twdwd1ruqfMkr0RVloaSUBCUHNA8mm7kToHGo9Yi8oaG9fyNnkEDLpDHoRVkQSnuvXd/IlSxSM68J5T",
	"2HjsudLa+z39NA25zaB7bp9Ux6euw2jPS+4W0rC0tWqVuTfOGiBvdYJ8/mWDD38h9Wg82JW0O2CXXTUb",
	"qwLe/IaPCS2kWGCBJntFlbBPXJSVgSyBm7QCsgtaTOQFU4rnTA9cKZfiuwtavAqfvR+P2JplE6NoxiZo",
	"lhiKtTP7DdKpHYcLbjgtJnA1HwoQO8GvTvGjHfL7LISo8dWK5ZwaVmxIqVjGXOkrrkltFJhiIRaSLalY",
	"gKhXslos8TUc55IpFnrQ2nt4e4h9dQGzFhOsR9oF/9i1OY+LuTOaLRN9xkD2XdIACtayGnTrTzAbqDbd",
	"ZwQYj3oVeYvvizoMEfHW5EBX1Toa+kOEtBqaQ9Tsvj0kt4fkr3ZIUtV3AZ/zlkkFkRhv4w3b3m66APUH",
	"NOV9lOr0t81f/uzNXzxb0oQSRRt3nHQ/UqoJN+QSyqvNGLHyrgIXgmvy6owEkO4ZHXVXlFm7lrDZknLh",
	"anOFZBWAw165VytujO+RfiPWV2RmYHa16GBZpbjZwK2Ilvy3c2b//dZeKzRTF/7CVKli9GS0NKZ8cnRU",
	"yIwWS6nNEfRgqZ/p1sO3Af4//F2nVPzC3t/eA9hS8QUXVkZf0sWCqdrOOXo0fTB6//8HAAD//zjrPM7B",
	"3wEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
