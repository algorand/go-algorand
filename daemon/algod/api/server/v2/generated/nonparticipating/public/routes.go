// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/w8AAP//VkXxbcAwAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
