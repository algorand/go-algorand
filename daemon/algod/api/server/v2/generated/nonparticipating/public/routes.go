// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"fyHZymg0nz58+v8DAAD//4CSGiFPgAEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
