// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "lift-log-limits" -------------

	err = runtime.BindQueryParameter("form", true, false, "lift-log-limits", ctx.QueryParams(), &params.LiftLogLimits)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lift-log-limits: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"s9gLVAEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
