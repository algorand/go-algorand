// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
