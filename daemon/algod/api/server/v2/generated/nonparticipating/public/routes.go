// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"6yh0X/LQAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
