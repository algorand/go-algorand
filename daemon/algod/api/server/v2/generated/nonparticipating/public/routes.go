// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/xcAAP///kbN8kLLAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
