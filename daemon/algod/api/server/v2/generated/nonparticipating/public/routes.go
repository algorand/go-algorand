// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "unlimit-log" -------------

	err = runtime.BindQueryParameter("form", true, false, "unlimit-log", ctx.QueryParams(), &params.UnlimitLog)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unlimit-log: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"ZBdYpOvt+/8/AAD//8aiIyH7UwEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
