// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"1xbFPQEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
