// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
