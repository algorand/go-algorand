// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
