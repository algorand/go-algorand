// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
