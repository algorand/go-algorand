// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9+3fbtrIw+q9g6fvWyuMT5bzas+u7us51k7bbp0maFbvdZ58mt4HIkYRtCuAGQFtq",
	"bv73b2EAkCAJSpQt20nrnxKLJDAYDOaFeXwcpWJZCA5cq9Hhx1FBJV2CBol/0TQVJdcJy8xfGahUskIz",
	"wUeH/hlRWjI+H41HzPxaUL0YjUecLqF+x3w/Hkn4d8kkZKNDLUsYj1S6gCU1A+t1Yd6uRlolc5G4IY7s",
	"EMcvRp82PKBZJkGpLpQ/83xNGE/zMgOiJeWKpuaRIhdML4heMEXcx4RxIjgQMSN60XiZzBjkmZr4Rf67",
	"BLkOVukm71/SpxrERIocunA+F8sp4+ChggqoakOIFiSDGb60oJqYGQys/kUtiAIq0wWZCbkFVAtECC/w",
	"cjk6/G2kgGcgcbdSYOf435kE+AMSTeUc9Oj9OLa4mQaZaLaMLO3YYV+CKnOtCL6La5yzc+DEfDUhr0ql",
	"yRQI5eTtD8/J06dPvzELWVKtIXNE1ruqevZwTfbz0eEooxr84y6t0XwuJOVZUr3/9ofnOP+JW+DQt6hS",
	"ED8sR+YJOX7RtwD/YYSEGNcwx31oUL/5InIo6p+nMBMSBu6JfXmvmxLOf6u7klKdLgrBuI7sC8GnxD6O",
	"8rDg8008rAKg8X5hMCXNoL89Sr55//Hx+PGjT//rt6Pkf9yfXz39NHD5z6txt2Ag+mJaSgk8XSdzCRRP",
	"y4LyLj7eOnpQC1HmGVnQc9x8ukRW774l5lvLOs9pXho6YakUR/lcKEIdGWUwo2WuiZ+YlDw3bMqM5qid",
	"MEUKKc5ZBtnYcN+LBUsXJKXKDoHvkQuW54YGSwVZH63FV7fhMH0KUWLguhQ+cEGfLzLqdW3BBKyQGyRp",
	"LhQkWmwRT17iUJ6RUKDUskrtJqzI6QIITm4eWGGLuOOGpvN8TTTua0aoIpR40TQmbEbWoiQXuDk5O8Pv",
	"3WoM1pbEIA03pyFHzeHtQ18HGRHkTYXIgXJEnj93XZTxGZuXEhS5WIBeOJknQRWCKyBi+i9Itdn2/zr5",
	"+TURkrwCpegc3tD0jABPRQbZhBzPCBc6IA1HS4hD82XfOhxcMSH/LyUMTSzVvKDpWVyi52zJIqt6RVds",
	"WS4JL5dTkGZLvQjRgkjQpeR9ANkRt5Dikq66k57Kkqe4//W0DV3OUBtTRU7XiLAlXX37aOzAUYTmOSmA",
	"Z4zPiV7xXj3OzL0dvESKkmcD1Bxt9jQQrKqAlM0YZKQaZQMkbppt8DC+Gzy18hWA4wfpBaeaZQs4HFYR",
	"mjGn2zwhBZ1DQDIT8otjbvhUizPgFaGT6RofFRLOmShV9VEPjDj1Zg2cCw1JIWHGIjR24tBhGIx9x3Hg",
	"pdOBUsE1ZRwyw5wRaKHBMqtemIIJN9s7XSk+pQq+ftYn4+unA3d/Jtq7vnHHB+02vpTYIxkRneapO7Bx",
	"zarx/QD7MJxbsXlif+5sJJufGmkzYzlKon+Z/fNoKBUygQYivGxSbM6pLiUcvuMPzV8kISea8ozKzPyy",
	"tD+9KnPNTtjc/JTbn16KOUtP2LwHmRWsUYMLP1vaf8x4cXasV1G74qUQZ2URLihtGK7TNTl+0bfJdsxd",
	"CfOosnZDw+N05Y2RXb/Qq2oje4DsxV1BzYtnsJZgoKXpDP9ZzZCe6Ez+Yf4pitx8rYtZDLWGjp1IRveB",
	"cyscFUXOUmqQ+NY9Nk8NEwBrSND6jQMUqIcfAxALKQqQmtlBaVEkuUhpnihNNY70vyXMRoej/3VQ+18O",
	"7OfqIJj8pfnqBD8yKqtVgxJaFDuM8caoPmoDszAMGh8hm7BsD5Umxu0mGlJihgXncE65ntQmS4MfVAf4",
	"NzdTjW+r7Vh8t0ywXoQT++IUlNWA7Yv3FAlQTxCtBNGKCuk8F9Pqh/tHRVFjEJ8fFYXFB2qPwFAxgxVT",
	"Wj3A5dP6JIXzHL+YkB/DsVEVFzxfG+FgVQ0jG2ZOajkpVvmW3BrqEe8pgtsp5MRsjUeDUfP3QXFoVixE",
	"brSerbRiXv67ezckM/P7oI+/DBILcdtPXGhoOcxZGwd/CYyb+y3K6RKOc/dMyFH728uRjRklTjCXopWN",
	"+2nH3YDHCoUXkhYWQPfEylLG0UizL1lYr8hNBzK6KMzBGQ5oDaG69Fnbeh6ikCAptGD4Lhfp2d+pWuzh",
	"zE/9WN3jh9OQBdAMJFlQtZiMYlpGeLzq0YYcMfMiGvhkGkw1qZa4r+VtWVpGNQ2W5uCNqyUW9fgdMj2Q",
	"EdvlZ/wPzYl5bM62Yf122Ak5RQam7HF2lwyZsfatgWBnMi+gF0KQpTXwibG6d4LyeT15fJ8G7dH31qfg",
	"dsgtotqh0xXL1L62CQfr26tQQT1+YS06DUsVsdqqVVEp6Tq+djvXEAScioLkcA55GwTLsnA0ixCx2jtf",
	"+E6sYjB9J1YdniBWsJedMOOgXu2xuwW+Fw4yIbdjHscegnSzQKPLK2QPPFSBzCy1t/poKuTl2HGLz3JS",
	"++AJNaMG0mjcQhK+WhaJO5sRP559oTVQfe25mYu2h49hrIGFE02vAQvKjLoPLDQH2jcWxLJgOeyB9BdR",
	"KTilCp4+ISd/P/rq8ZPfn3z1tSHJQoq5pEsyXWtQ5L4zVonS6xwedFeG5mKZ6/joXz/zntvmuLFxlChl",
	"CktadIeyHmGrE9rXiHmvi7UmmnHVFYCDOCIY0WbRTuxlhwHtBVNG5VxO97IZfQjL6lky4iDJYCsx7bq8",
	"epp1uES5luU+bHuQUsio6Cqk0CIVeXIOUjERuV56494g7g2v7xft3y205IIqYuZGX3jJUcOKUJZe8eF8",
	"3w59uuI1bjZyfrveyOrcvEP2pYl871pVpACZ6BUnGUzLecM0nEmxJJRk+CHK6B9BW72FLeFE02Xx82y2",
	"H9tZ4EARG5YtQZmZiH3DaA0KUsFtaMgWc9WNOgQ9bcR4n6XuB8Bh5GTNU3S87uPY9lvyS8bxFkiteRqY",
	"9QbGHLJ5gyyvbr73ocNOdU9FwDHoeImP0fPzAnJNfxDytFb7fpSiLPau5LXnHLoc6hbjfEuZ+dY7FRif",
	"581wpLmBfRJb460s6Lk/vm4NCD1S5Es2X+jAznojhZjtH8bYLDFA8YG1UnPzTddWfS0yw0x0qfaggtWD",
	"1RzO0G3I1+hUlJpQwkUGuPmliitnPQEseHOOF/461Pf0whqeUzDUldLSrLYsCF5nd+RF/WFCU3tCE0SN",
	"6rnMq25h7Vt2OhsckUug2ZpMATgRU3dj5u7ycJEU7+K1V2+cahjhFw24CilSUAqyxHnqtoLm37OiQ2/A",
	"EwKOAFezECXIjMorA3t2vhXOM1gnGDmiyP2fflUPbgFeLTTNtyAW34mht/J7uGvRLtTDpt9EcO3JQ7Kj",
	"EoiXK0QL1GZz0NCHwp1w0rt/bYg6u3h1tJyDxAvKa6V4P8nVCKgC9Zrp/arQlkVPPKQzb42GZzaMUy68",
	"YhUbLKdKJ9vYsnmpYYObFQScMMaJceAexeslVdpeqjOeoS/QihOcxyphZop+gHvNEDPyr94C6Y6dGjnI",
	"Vakqc0SVRSGkhiy2Bg6rDXO9hlU1l5gFY1c2jxakVLBt5D4sBeM7ZNmVWARRXd09uaiT7uLwhsbI+XUU",
	"lQ0gakRsAuTEvxVgN4wJ6wGEqRrRlnCYalFOFYg2HiktisJwC52UvPquD00n9u0j/Uv9bpe4qK7ldiZA",
	"YSiae99BfmExa6MBF1QRBwdZ0jOje6AbxN7+d2E2hzFRjKeQbKJ8NPHMW+ER2HpIy2IuaQZJBjlddwf9",
	"xT4m9vGmAXDHa3NXaEhsWFd802tK9lE0G4YWOJ6KKY8En5DUHEFjCtQE4r7eMnIGOHaMOTk6ulcNhXNF",
	"t8iPh8u2Wx0ZEaXhudBmxx09IMiOow8BuAcP1dCXRwV+nNS2Z3uKf4JyE1R6xO6TrEH1LaEef6cF9PhQ",
	"XcR8cF5a7L3FgaNss5eNbeEjfUe2x6H7hkrNUlagrfMTrPdu+rUniN67kgw0ZTlkJHhgzcAi/J7YgKT2",
	"mJczBQf53rrgd5xvkeXkTKHK0wT+DNZoc7+xka6Bq2MftmxkVCOfKCcIqI+fMyp4+AqsaKrztVHU9ALW",
	"5AIkEFVOl0xrG8HeNHW1KJJwgOi9xoYZ3a1m9E5x4zXrCQ4VLK+7FeORtQk2w3faMgwa6HC2QCFEPsBD",
	"1kFGFIJBATCkEGbXmQum9+HUnpIaQDqmjVfalfi/pxpoxhWQf4qSpJSjyVVqqHQaIVFRQAXSzGBUsGpO",
	"F+pSYwhyWIK1JPHJw4fthT986PacKTKDC5+BYl5so+PhQ/TjvBFKNw7XHvyh5rgdR8QHXvgYweeskDZP",
	"2R5q4UYespNvWoNXt0TmTCnlCNcs/8oMoHUyV0PWHtLIsDATHHfQXU7jyr67btz3E7Ysc6r3cWsF5zRP",
	"xDlIyTLYysndxEzw789p/nP1GWbXQGpoNIUkxZyQgWPBqfnGppFssw3r8Dq2XELGqIZ8TQoJKdi0B6Py",
	"qQrGCbEBkemC8jlq+lKUcxeRZ8dBTl0q61ORJe8MEdWG9Ion6J2OcW4Xhe0zX4weBNTYYm3XtrU8Lmg1",
	"n0t2GiJSA+S1Xf3R263xqNdUNUg9r01Vi5xm+s4ALt5Q1AL81BMPvANB1BmlpYuvcFvMKTCbez2+9nro",
	"GJTdiYMYwfphX5igsZPz9R60FTsQkVBIUChbQv+Ssk/FLEzVc8JHrZWGZdcFbz/9vef4ve019ATPGYdk",
	"KTiso9npjMMrfBg9Tijfej5GTaPv27bx0IC/BVZzniHUeFX84m63T2j7qkn9IOS+7jLtgIP18gFXh1vv",
	"yd2Ul73gpHkeuRN0iTxtBqDGVeEAJglVSqQMla3jTI3tQXPXiC7rp4n+N1V48h7OXnvc1uVXmCOKzl3I",
	"C0JJmjN0/QqutCxT/Y5TdC4FS41ELXkrut/d+Ny/EvdvRtyPbqh3nGLEWuVyikZazCDiX/kBwHsdVTmf",
	"g9ItI2UG8I67txgnJWca51qa45LY81KAxNChiX1zSddkZmhCC/IHSEGmpW6q7ZinpjTLc3cTZ6YhYvaO",
	"U01yoEqTV4yfrnA4f1vvjywHfSHkWYWFuHSfAwfFVBKPrvrRPsVIYLf8hYsKxroC9rGPsqwTZ0dmmY1c",
	"+f/v/n8e/naU/A9N/niUfPN/Dt5/fPbpwcPOj08+ffvt/9/86emnbx/85/+O7ZSHPZZF5SA/fuFM2uMX",
	"aLfUlzcd2G/Mcb9kPIkSWRiG0aItch8zhh0BPWh6tfQC3nG94oaQzmnOMsNbLkMObQnTOYv2dLSoprER",
	"LS+WX+uO1sAVuAyJMJkWa7y0FtUNSIznK+JtoktBxPMyK7ndSq9923QcHxgmZuMqJ9WWqzkkmLC4oD6q",
	"0f355KuvR+M60bB6PhqP3NP3EUpm2SqWTprBKmbkuQOCB+OeIgVdK9Bx7oGwR2PgbFBGOOwSllOQasGK",
	"m+cUSrNpnMP5JAfnLFrxY24j2s35wbvJtbvyELObh1tLgAwKvYiVsWgoavhWvZsArXiRQopz4GPCJjBp",
	"O2syYy+6aLwc6AzLKaD1KYZYQ9U5sITmqSLAeriQQR6RGP204vmd8Fd7N4fcwDG42nNWF5H+by3IvR+/",
	"PyUHjmGqezaz2Q4d5KJGTGmXbtWIJDLczBbvsUreO/6Ov4AZ48w8P3zHM6rpwZQqlqqDUoH8juaUpzCZ",
	"C3LoM7heUE3f8Y6m1VtfK8idI0U5zVlKzkKDpCZPWzOlO8K7d7/RfC7evXvfCaromg9uqih/sRMkRhEW",
	"pU5cxYdEwgWVsUsrVWX848i2pMumWa2SLUrr2fQVJdz4cZ5Hi0K1M3+7yy+K3Cw/IEPl8lrNlhGlhfS6",
	"iFFQLDS4v6+FEwySXni/SqlAkQ9LWvzGuH5Pknflo0dPgTRSYT84kW9ocl3AYO9Kb2Zy26mCC7dmJay0",
	"pElB57G7sXfvftNAC9x91JeX6OPIc4KfNVJwfUQ9DlUvwOOjfwMsHDunE+LiTuxXvrpXfAn4CLcQ3zHq",
	"Rn1jf9n9CpJyL71drcTezi6VepGYsx1dlTIk7nemKvozN0qWD6NQbI7WqquPNAWSLiA9c4VrYFno9bjx",
	"uY/UcYqmZx1M2ZJGNqUOi2rgzcIUSFlk1KnilK/b1Q0UaO3jgd/CGaxPRV2TY5dyBs3setV3UJFSA+3S",
	"EGt4bN0Y7c134WBo2BeFT1LHbEVPFocVXfhv+g+yVXn3cIhjRNHI/u5DBJURRFji70HBJRZqxrsS6ceW",
	"Z6yMqZV8kfJGnvcT90ptPLnIrXA16HW3z5eA9dHEhSJTavR24Up72QzygIuVis6hR0MOL3cG5mk3LoRw",
	"kG1yLyrpxKwt0DryJgqyfTkxa45SCpgnhlTQmGnF6/mZ7P2hu5nAip0OYdMc1aQqsNEyHSobl2y2BGEf",
	"aHECBslrhcOD0cRIqNksqPJVx7A4mz/Lg3SAa6yIsKkOznEQahZUYKuq3Hie2z6nHevSVcPxJXB83ZvQ",
	"tBxQw8Zo+BjdHtsOwVEByiCHuV24fdkTSl2dod4gA8fPs1nOOJAkFrUWuEEDMePmAKMfPyTEeuDJ4BFi",
	"ZByAjffiODB5LcKzyee7AMlddQnqx8Yb9eBviOd92Thuo/KIwrBw1nOrlXoOQF2oYyW/WgG3OAxhfEwM",
	"mzunuWFzzuKrB+mUY0G1tVV8xUVmPOhTZzdcgFjBstOarCi6zGpCnckDHVfoNkA8FavEJn5GNd7pamro",
	"PRrajmmosYNpC9/cU2QqVhjtg6LFhlJvgaUfDg9GYOGvmEJ6xe/6pLkFZtO0m7WpGBUqJBnnzqvIpU+d",
	"GDJ1jwbTRy73g1o2lwKg5eyoC0M743erkdpUT7rCvJZq47pGm88aih3/viMU3aUe/HW9MFX1mTdtjSXq",
	"p2gGrTQL7wQqZIzoDZvoXtJ0r4IU5IBGQdJQopKz2M2psW0AJc6J/yxwXmB5H8rXD4JIKAlzpjTUTnQf",
	"J3Eb7kmKVQWFmPWvThdyZtb3VohKTNlrRPywscwbXwGGEs+YVDrBG4joEsxLPyg0qn8wr8Z1pWasla3B",
	"y7I4b8Bpz2CdZCwv4/Tq5v3phZn2dcUSVTlFfsu4DViZYs3oaATmhqltkO7GBb+0C35J97beYafBvGom",
	"loZcmnN8IeeixXk3sYMIAcaIo7trvSjdwCCDzNkudwz0puCOf7LJ+9o5TJkfe2vUjs/f7ZNRdqToWgKH",
	"wcZVMLwmMmoJ00HJ5W5Ka88ZoEXBslXLF2pH7bWY6U4OD1+oroUF3F032BYMoEr7FmYgIepCqB7Z6OhK",
	"XQoLFWJmd6MUTmTTe53/TVeaF5RV54hgoks4wVxpyf49rmMvG6UXm0uJ9C7ozloyrr9+1qXIysdvYBmy",
	"Gydx1/qJMTSaiA/MLVvKfMsmsB7DPSTPgD2HUzHlG3F0ybbKgdxGuadA859g/at5F5cz+jQeXc2RHaN8",
	"N+IWXL+pDlsUzxgoYR2bjXupHVFOi0KKc5onzt3fxyikOHeMAl/3twM3LHjilH36/dHLNw78T+NRmgOV",
	"SaW49a4K3yu+mFXZYpQ9B8QX+jcWuLegrGIfbH5VQS+8IrhYgKuYHtgGndKu9fVPcBTdlcEsHq+1lfe5",
	"myq7xA03VlBUF1a1M9XeVzXvqOg5Zbn3Ynpoe2KrcHHD6gNHuUI4wJXvuoIry2Sv7KZzuuOno6auLTwJ",
	"5/oZSyLFtRPuCiYhK3J3V00WdE85yjrAVR9MxaqWngNl8g9CNpi/C6yP3n15gd1mjHuR3Q6PPaFGvgtH",
	"W/GcEKQl8mH+wZzGhw/Do/bw4Zh8yN2DAED8fep+R2fRw4dRt2TU6jBMAo0KTpfwoAoS7N2ImzVROVwM",
	"E9BH50tEHcZ695NhRaH2Esuj+8Jh70Iyh8/M/ZJBDuan7Qk0rU236A6BGXKCTvoC6asYiaVt/KGI4O2Q",
	"IMzhMKSFzH5JsbSx9fJ2jxAvl+gZTVTO0vidEZ8qw165jQUwLxN8uce4NiOWrCe0hJcsGMu8NqRWVwvI",
	"YI4oMlW0XFiNu6lwx7vk7N8lEJYB1+aRRLnWEnXeOMBROwqpsYW6c7mB7Y1jPfxVbKawrHdbZ0QgNhtM",
	"YeRBB9wXlQvQL7TysNc2064BTOGMHca9IfjI0YejZhuMvWhGEAyzY4Y0gPOMztUX75kj2tCNqWQmxR8Q",
	"91uhuy+SgOkLmTOM2vsDQvMsbGPUYCmVt7ruS1fPvm27h9vGfRt/ZVvYL7qqnX4ZYRo/1btt5GWMXhUv",
	"E+iQ3GeEhVcXzci2HtaCxyuI5cCy1f5ak3J7nmz2YSNAOn4qw1SEAzt+fSodzJ30jZxeTGmsprexhQxM",
	"wfY2LmC1IP5jvwGqStGzs5MgAKl6l9kKJgXIOgG9Ww3tknaNnXawRVMbMEhRoekytkEjuRKRYUp+Qbnt",
	"hWa+s/zKfa3A3piYry6ExPpDKn5XnEHKljSPGzhZ2r0XzNic2TZfpYKgj5QbyLZQtFTkenFViacONccz",
	"8mgcNLNzu5Gxc6bYNAd847F9Y0oVisvq9qL6xCwPuF4ofP3JgNcXJc8kZHqhLGKVIJXtiUpeFfEwBX0B",
	"wMkjfO/xN+Q+xnoodg4PDBadEjQ6fPwN3tTZPx7FpKxr07aJZWfIs//heHacjjHYxY5hmKQbdRIt1WL7",
	"tPZLhw2nyX465Czhm06gbD9LS8rpHOLhhcstMNlvcTfx9qWFF57ZJoNKS7EmTMfnB00Nf+pJWTLsz4JB",
	"UrFcMr10EQFKLA091U2i7KR+ONux0NX393D5hxhYU/i4gpav64bNGLrsCTnG8KfXdAlNtI4JtUWnclaH",
	"vPmuI+TY17TDhgdVnwOLGzOXWTrqkhgBNyOFZFyj/6PUs+RvxiyWNDXsb9IHbjL9+lmkcUCztjbfDfAb",
	"x7sEBfI8jnrZQ/ZeZ3Hfkvtc8GRpOEr2oE4RDE5lbwRQPNajL+Bk89BDNV8zStJLbmWD3GjAqa9EeHzD",
	"gFckxWo9O9Hjziu7ccosZZw8aGl26Je3L52WsRQyVqi2Pu5O45CgJYNzDPiOb5IZ84p7IfNBu3AV6G/3",
	"utqrnIFa5s9y1BDwTqdNiV5Ghf/1lWtK3NG9e4LTbPRZ9c0NJ7BFnZZWQ2u4zR5/INJYkqiNPnyIQD98",
	"OHbK3IcnzceWST18GC/fFnUcmV9rLFzFrsNvY3v4nYi4cXyvlOoK3SWpRdxofazWPDBHeeqGGpNmX4qb",
	"l4X7CX+Oh7jET8G7d7/hE48H/KONiFs+8riBdRCfXUkPoQR9eaIkk1XPg+A6Sr4Tq6GE0+Kknng+AxT1",
	"oGSgkwlX0uk7FL103hr1ENCoGXUKuTCmUlhSPfRKfzl4Nosfb8B2yfLs17rARkuQSMrTRTQ0aWo+/L3u",
	"D1wt0bLKaJXmBeUc8uhw1kL73VtyEVvzX2LoPEvGB77b7ntll9taXA14E0wPlJ/QoJfp3EwQYrVZu6DK",
	"jcvnIiM4T10SuGaO3QZyQVebf5egdOxo4AMbn49XNob52qYqBHiGPpwJ+RGziA0sjXqP6DvxBbmaxWnK",
	"Ihc0G2OhsNPvj14SO6v9xna5tE1d5ug6aK4i6usdXqynalgZz0IdPs7mtDizaqWTqgdLrM6HeaPuEsNa",
	"AQDoVAixMyEvgmb+tiSIGYJgnTi5hCxo+WItCqQJ8x+tabpAR0lDkPWT/PBuRJ4qVdASvWptWpUAx3Nn",
	"4HYNiWw/ojERegHyginAvCM4h2ZpkarOjnPU+VIjzeXJknNLKZMddIqq4PeuaPfAWYXE33BGIWshfkcz",
	"2Tbz2rU50wl+Fa1I2u701OmFbgtVVC0rX/lu9pQLzlKsBxpTiLAMwrA7kwGlU+OXHWrkTmjkcEX7S1UZ",
	"Dw6LvR2nPCN0iOvePwZPzaZa6rB/ali5vgNz0MpxNsjGvk2a884zrsCVdDdEFPJJISMRFjGVI6luc3ck",
	"I8xw7nG3/GCevXbOOEz9O2MczW6HNqdmW/85drDXxlZnmswFKLeeZpkX9Zv5ZoIVTzJYvZ/4jvc4ho3p",
	"Mcu2AWzdoY58OJsLHzPvPjfvujqU1c+N2BQ76VFRuEn7m+jFO4eueC+CY0EU/lY7QG41fjjaBnLbGIeK",
	"8tQQGpxjCA0UKIc7hFE1lGt1bzUmgqUofIPYaPxoMSrGI2C8ZNzf58QFRBoVCbgxeF57vlOppNqqgIN4",
	"2inQvIqZaTM0pd2F4FWHalfhNCjBNfo5+rex7oXXwziqF2rFjfI18YfCUHegTDyneRXHGelsh1qVU6Iy",
	"TA5t9bqLMQ7DuH03zaYA2NJAd1x/jiVpd5VEffU+pmU2B53QLItV2P8OnxJ8SrISNQdYQVpWldiLgqRY",
	"3q5Z769LbW6iVHBVLjfM5V+44nRB88gINYQNLP0OYz7xdI3/7tLauIrg3Dmjw4drZrsVuexmqMS0XkPT",
	"iWLzZDgmUKZcHR311Jcj9Pr7vVJ6LuZNQG7DSdrD5cI9ivG3743gCItgdYJlrWipalRhYKrwPdDRbKyq",
	"qzS5EoqyTrF9vIKtWgpvdkP0Nwceo/DryaIKXd5Wvlo3cF8uVdqb+ke1K0KgKdnIgnoTu23gYsuJ3r3P",
	"6AtWtLGK+3M+u7VuRKiPI+8C9JNPUiEFZS5gpWYWXcy6MN9uuueQONp6g9uLcCl7vf7Rn8770ut8zVt8",
	"3m4eegauMlEh4ZyJ0oeC+IBMbxLaXxutOKsEx+j6o2HOt+187nWVn7omTnaZzib/6VcbvkuAa7n+DBzn",
	"nU3vtCXtarvWPVW/Qqr+H4P6gTSk4pB60LHSw043bDRG3dLWtUNWL4aoA902rePRcbaTwIyVrx7ZUWLH",
	"Lt50tb+6Z13RE49YIRSr2/DEurEOjHw+xYaqQXXS7lg+Iu4cUo29l+pIHwmwS61SM1nQ3/2uymePOV0F",
	"iLvinpsqenYbLm2R8Z2k+6BwhG1WMxlev/Koiue06SgXVGG1Z9tivZnAOTiNbDaDVLPzLUUO/rEAHiTQ",
	"j71fBmGZBTUPWJVUgTXydvc61gBtqkGwEZ6gVvWVwelLqj2D9T1FGtQQ7Z5TZRRdpjwaYgC5Q2JIRKhY",
	"vJR1JLsQFqYqykAs+PhE+znUhWZ7G28GJTsuOZcnSSM46jIeG6aMd/4bNJf5dKfiNpgf0FcHods4rN/+",
	"eIF92lTVFNuXVwutdHLcLUJ94cqzYUmK6u7EF2oD5X/z9WfsLDk7g7A1KN5UXVCZ+Teirhfv1Uk2yKNO",
	"8QLf9KoN9KyamdXR5N276khZU0zMSHNh1IikL7ulGcBdRT/dUzZMzXbZwdB0A9cMpGuhjPpvLhQkWvjo",
	"801wbEKFjcW7FBJUbylxC1xvgb+3dQVDbKlAsaAfdSF44QKJhCU10MmgzmD/nJuQ/dw+9xnBvqT+Vg9T",
	"Ra/bezv5PAKmOkgMqX5GnLTcnml8GWcT4xxk4m+e2kUHOcjmbUghRVamVkCHB6NyyA0u6bmBlUT9NGl3",
	"lS0bIcjYPYP1gTWCfFMsv4Mh0FZzsqAHxapam7xX95uKwT3fC3i36bkajwoh8qTnsuO4WymxTfFnLD2D",
	"jBhJ4eNtexoVkvvoY69usy8Wa18ZsCiAQ/ZgQsgRtxkO/mK72aqjNTm/pzfNv8JZs9IWL3VOtck7Hg8V",
	"x7Ki8orczA+zmYcpMKzuilPZQbbU4Vv1VGmU9CLStnMy1CrvXjW3WynWRGWhiOkkJ/bG6jke9JjjCPOx",
	"g8IBeJFJibvpIioXsZDMy+SMm6HimAonQ4A08CGpyxUUbvAoAqo2iVsChaoYobrDXB0n1FWP8lxcJHiM",
	"kqrObMzoMu+pppjwpfXr7wy9TSGIOKLKqRBrsqAZSYWUkIZfxNOiLFRLISHJBQYgxe5GZ9pohEvMheAk",
	"F3MiCmPo23rN/hYp2v+wM1fJOUWBDkG8RxQFNE3R+hTEfUOqb4ZOua/2krb4iV10Ym/ZekIiQbliJw5D",
	"9uUuvBs6PO5UKfl4hr4KhlEYzdxWqxeFfS5hxzaXLM+9KdvX6ZL8okoMlMHEBjPFM7IUxh5Gm8M3PPdD",
	"1cFH91PBtRR53nRPWGVt7nyur+jqKE31SyHOpjQ9e4AWDvbZ98lnY5/21w4Tq2eSrYo3A1tyni4iHkic",
	"xZ+6nftuOs6xc7u8AMwBHGu79/Uo1la0ua52g9u+dtNaLFkap+EvK+6qN1oqxhKipXRsxwqb/IyvIaMO",
	"hUN1zY4sqYtm4IZgY/vleJq7bkTmYf6Lulh7XDIDJyR6BFOXTzp5mqS9Ur8FAEJqM/J0KW2bi1AmV1xF",
	"zG0GL16WtgEdyMUxJuVqsJkR9g6UhisB1YmDqwC8b83QsS15ZGPqpmLlnz+oayJdCvhPm6k81ho4coor",
	"0nKdi339hB6OEA3V2RwZY9vFT4fGx1QtiQZK1ACA/oiZBgyD4mZ2BWNGWQ5ZQnWPcEdvxTiwuVyuRbvR",
	"HFOOk6fUCuwFEDN2KcHl89s+8a3GtAU1pCSq17s+RZ7BChQm29vumlRZD7j3xLsm9W2zUBRJDufQCCRy",
	"RQZKVO3YOYQN7u3HJAMo8F6q7S2JRciEsrxlQru1J0GMxRDsRm1qi1i7U2SLwRw171c8scdEDT1KBqJz",
	"lpW0gT91hVbf/V2+Ozp5YnVveyCGTPOLHeGtH+DIfx9TZTwm3g/jQzuzoDjqNjGgrRFzeKKip57HA+bC",
	"ChqVqx1ny6orOUviNd9QBb3g/a6pLsnX5s3wFvwBYr9fQYpaTTMi7Oo4ITgYUa3qOL0quKx2+PIuzluh",
	"4Y0k3DtezNRQgAy2tnDrCwi/joounMKOL2BrMW7UXqM1YzsPx/8d/xtjN2Q7kLGrbXeR0IJ7Af4uCQv2",
	"Vm50p9CySqD5yLexq9fWNspZEPO7pGsiJP5j7LV/lzRnszWeUAu+/4yoBTUk5C6v7K2qi6QzE29WTMYe",
	"MO8XEH4qu242dMxguLUZJQDaiEAipLsHWdIzCLcBL4wt50m1YTmqnC6ZUijsWtvZxYJbvM+5X9IstJGx",
	"8lezrZuvBWm+/n/qfKJwKl+wp8hpWrdpVnTZctXaflGeuPQClpsTzrrmsSeBqgdVTbTSJ5pmth6MxV9V",
	"/AE1EfzPlGlJ5XpD+OvWmIJYFDdqztvA7vTmQTV8b8vYpVlknbO7IVVv0FL2vQtDIxc6QOP1p6+atAV8",
	"W+3OV1i6CfxHi/L1LWMI+J8L3ntaGoXw2u5FN4DlRjJ6BFbrV52KVSJhprZd0lvHqjGEZZ3G7p2TjKcS",
	"qLJRC8c/O5OtrjnHuDEhbVxddS9UjZLBjPGaWTJelDpiAWDpOb4OEBa6pxGtPdcQfVqCUcPOaf7zOUjJ",
	"sr6NM6fDtlQJa357l7z7NmL8VzK1OwBTtfWDOW5Q51AFrxkBnrHZDKQNeVOa8ozKLHydcZKCNHKfXNC1",
	"uvzdh4FWlka/2HL7QQNtppl5HdyDIGlbQPK1u1i74s1EBSDd4xXFgKsFjK2MXCtYp4gWPTcJXRjiCf90",
	"leRijplPPQToivvh3Y81VgRHh63Vh3abR7E/YPM0WNfYHXwtcNYhU2w+Zz8j6tDg+YUzvfGkWW9aOxXN",
	"xgrag+Dpn8/rgGW7OV36j2UPnmJ4fSODsN0A2O+1DVyw80HPTUbTg9uzi3h161JPQ3etGn6T0bgdjuUo",
	"Whs2QdtWbQhJBlWH39LUhZR0nT4do9giZewyPHf0CVlPspcDPeDZroHubDWnra75zTjDdY3gTjsOUSGK",
	"JB0Sp2ZLn2fOoe0gbcLYQx+Bu7pn3dWVft3IulFyo9EVwGrKl1F3W10Jtt3LFOkmI7vPodHDQZvOcjFD",
	"XoZH2LpxMPugcl6M23kxTYdNxSQIJRLSUqJD84Kut/dt6Sm5efL3o68eP/n9yVdfE/MCydgcVF22tdX3",
	"pI5lYrztZ7nZ6KXO8nR8E3zGtEWcvynziSDVprizZrmt1dx4tOvLLp7QiACI9ffu9tu41F7hOHU48ue1",
	"XbFF7n3HYii4nj1zMZfxBRxxZ7+IGdnMM+qLEX/cI/zCKP8RIeW39hIL7PPH9mfsXoYea4fsZ0OFkRTk",
	"vdFetdzroLiolnm5VoaDQOumo0bIAwHoyTNrZAiFnU7rSorS+nbRC+wvzNpC7FV9kbY1IBoh8R9sAS9M",
	"HKvfq2J4HTi3XJLwVYWUYCnv+yihsfxtuWhugfXNY7BFztTVGmzfaVtYqbkvQaKhel7l7/Xotp00P2xr",
	"auybPI+kB1rrG89USDhGsZTnNL95roH9bo8QH5C97U8KCHPEQiRbVKrLVah6SQfNHeSD7W9q/gZTEv8B",
	"Zo+ics4N5S4dO9IMfSc0t+GbM5febYYkFzimDSp5/DWZuprXhYSUqfZlpr1xCqICz0GymQvgg5XekoO1",
	"bZ2/Cn0FMp75yAPyOriUEOj8qSGsj+gtM5Wekxul8hj1dcgigr8Yjwp75G0RF2eNQge1Lh5INCFhzwUP",
	"gtJFOxY86Hb/G7o8m9RvhE6poLvOwdK6gduIoK7XNrRax+AC1e/e/aanQ4psxItJm8+xysdeqkrvVFP6",
	"Gup7WBy5Mdy8MYr5ta/io61q2FNctLUfJcu3hhk0SsV+Go/mwEExhcVQf3cl3G9WlnoIbM5x96haWK9S",
	"KMEiJrLWxuTBVEER2AH1X91nkWqvmM+TlpLpNbbv824Y9nu0EsmPVVa7q4pQ3YA42afFGVQtVOsc+FJ5",
	"6fqjoDnKI3sxw40UEvmEfL+iyyJ3TkXy7b3pf8DTvz3LHj19/B/Tvz366lEKz7765tEj+s0z+vibp4/h",
	"yd++evYIHs++/mb6JHvy7Mn02ZNnX3/1Tfr02ePps6+/+Y97hg8ZkC2gvjbx4ei/k6N8LpKjN8fJqQG2",
	"xgkt2E9g9gZt5ZnA9lIGqSmeRFhSlo8O/U//rz9hk1Qs6+H9ryPXJmG00LpQhwcHFxcXk/CTgzkmvSZa",
	"lOniwM+DTX8a+sqb4yom2UZP4I7WPkjcVEcKR/js7fcnp+TozfGkJpjR4ejR5NHkseswyWnBRoejp/gT",
	"np4F7vuBI7bR4cdP49HBAmiONSLMH0vQkqX+kQSard3/1QWdz0FOMOzc/nT+5MCrFQcfXfLvJzND9NbG",
	"lgoO6sP6diZFOc1Z6svsMGXdiTYyWIXN2qyftVRjMrXt/HzwIc8wQMTm06qwpeVxZhBmPz+umZbvSGhb",
	"zh/+FinI4iPWfaO8MOQnCAb6r5OfXxMhiTNv3tD0rIrW9+kZdUpKmJ1hvpx4+v13CXJd05fjfGEDb+Dl",
	"0jARF/a/VPOiWZuw1qpiXp8Orv3MhiwCwq5S9WvGhXd8ASQ1Gzas9VHyzfuPX/3t02gAIFg3QgH2TfpA",
	"8/yDzYSBFUYEtuIexn0RKeM69Rs/qHdyjB6p6mnwef1Os6TvBy44fOjbBgdYdB9onpsXBYfYHrzHzj5I",
	"LHjmnjx65BmNU+MD6A7cmRrart1Xsba+5moUTxKXGKjLkOyjt1V1N0kLexbdE5vv57z99qWJ4TvP9rjQ",
	"Zg26Ky+3PVxn0d/RjEiX54hLefzFLuWY20g8I1isAPw0Hn31Be/NMTc8h+YE3wza5nUFzS/8jIsL7t80",
	"yk+5XFK5RtVGV7ywXSGfzhVesSGLtGc7KCDE56P3n3ql3kEYcnbwsVH9I7uSTLRRNo3+ElvE5D3Vxzm7",
	"vfHvHxUFRtydVM+PisJ24cRbZWAo/WDFlFYPJuTH8Gvk3pjqaDsklRKjhmp3ipF6VVNK3+qycXMatLeK",
	"Cu3AXXwnv29bfh81nR2N7tExYBqnYCNMndiVqwrQbnJDUOVj13DUqsKrUy0S1wRm4Bi+N/beOhwNSO63",
	"M72PmYJbGfUd7npw16cmBfBWGlPdXulmWLMvFllJkobIuEbG/YUrfa9obugkWG6rKYNtqX6nDP5llMGq",
	"qNzcamdFsQf1EGPiDz76Nvl7UAldd/kBymBoVgffBnHN91vs5MHEtmMP37kcz3BV5Laqeea9OwXvc1Dw",
	"bBm+baqdo+NbVerClJpdMlwa2oj5fdDHX7gW9xdGVq/aZiDdrrBdgn12lDHHrK+Nrf4plTCHtDv16y+t",
	"flW1Xa+kgIUBqgcuwzu4xrqS967tnWO60sSa9X0DzoZFEDDX2R7hcR3SbViMDRd2gcJq7C1DvE61RqPd",
	"rHHHbuyqWD9CaKB+tz5+sU27+oL8PIPbdEakQHxvrpuXRq8d3t7MtcMw3vTs0bObgyDchddCkx9Qil8z",
	"h7xWlhYnq11Z2CaOdDC1LeE3cSXeYktV2Szb6j3gUVV1xHHw3LxtozTuYzZls7HLgwnxDejrCgsuW3gu",
	"DKPyWUFUzu1HhtcZZJB7/s9DHP/ehPyAuW5ajTHYDCsp4YuM68PHT54+c69IemFjudrvTb9+dnj07bfu",
	"tUIyrjEewNo5ndeVlocLyHPhPnAyojuueXD43//8n8lkcm8rWxWr79avbSfIz4W3jmN12CoC6NutL3yT",
	"Yta676C/DXU3cn3/nVhFpYBY3UmhW5NCBvt/CukzbZKRM0QrT2ajV8QepZE9JrvIo7Fv9m74TiVMJuS1",
	"cG17ypxKW3sDC3sqMi+ppFwDZBNPqVjWSdk2JWnOME1cEgXyHGSiWFVAt5RQFYgoJJxjjHxderIBwXZG",
	"j5G0ny2Tf0VXQYr0tBLTWrglo9tzSVcE69BrokCPbXWqFfn2W/JoXFsveW4GSCrExJjrkq5GN+j1q4ht",
	"aMmVFw47Qm4P0MWxh3iQau2nqnpXmxp/dc79xWrultzdxu6Jc+588VNf7IR+BNccZ6MHwSp2Gmu0qrIo",
	"8nVdndNoeV6FirM4M8NQ58BnfEew1TUdNULb6L07xHdOgCuxkjZB7cg2MOtUHXxEuzzkGZ1zi1lzf63r",
	"0uDuSIqlvzwSZAY6XbiE3RbqI+xJuqTBft60ZJwtDZSPxteu1eAudmvLhr1JM2rT5Ie0vwlyKfECD2SE",
	"iH/23brNYzazBad9GwJfKQ6vplzN3qohoDW+bYtQF8/v83oL2mhwuB3K5/XkXYUM0bKP+887BO+G4A5z",
	"/N7VJLDHyy3izxDx703JhLwWddq4taD+lFeP1ynZr3tBrwUHe8duNF9Li3fXqZXaYRiHRYqvF2Ltl7rp",
	"z2VVkANfZ2ejHvJ389IWXWSI9MaaPV+iCP97tBpRQ8qYtU22FkOoRxvCnM2LttZ8szP6LVoxt8JPP0PT",
	"5jY41s2wGDykns84tYDvl+lgCR5LzAdVU+w+DvTSvBzoZW9cS/mB3EiLKgwNIrV/yBRywefq82RFm6gj",
	"jpcIldhKU7ZlRWf9k7/g2X3u+kn4ZtOu3pNiPAWixBLQZDA6OvY4sMGSzx797eYg1GzpO8vyMHf1lrnL",
	"V4+e3tz0JyDPWQrkFJaFkFSyfE1+4VXfiKtwO0Wo2/PQGxxhDozjbVOzLlgaFjG6PBNshK591CuWfdrO",
	"DINCijvyQcYDPhgW0aZFAVRengFuv7pqN5k8fhFGB4uq1IjflR5QDIp2DJD/P6OBfidMexczJ/xKbgH1",
	"1b8cm3Chu2I2roJjjBYgZofkHX9I1IL64pTuzydffd3jOTPzuKI9Xd9ZPZB5bIcZ4kD7ot2B+9XaK/we",
	"3vRu77aJ4xHLVtHu57AKSoc3m+A5teyeIgVd+zDaThGqIl6IstIGwmGXYNR4tWDFzRc7VJpN49VevflT",
	"NVM95t9VVrCtyGeU7+I2ityNR1oCZFDoxdbal/hWvZvgqmAy5are2wqFY8ImMLEF/OpuINkclLWoKcmB",
	"zqq2HkIMSZ4I+IwhNE8VAdbDhQyxSaP0gwVDkChv3jitkwysoPPIky2Zc6uKrr4tIzVBGxW4V2yaaLk9",
	"nRI79I+D6+5CCi1SkdvYlbIohNTV6VaTQeoe9F3bNbS9PsK9kjK3Ypna6kc7xbf24EhrUrb6Yvxopx5N",
	"MUdabFGXrMhXzzWEpZ2KgnSauBoQbpWv3TndYvys5XP70l1uupf09uyBS6lOF2Vx8BH/gxUJP9WJUlir",
	"XR3oFT/AnkoHHzeGNCFLzY1uIm2Z94YdHW0J3XXr4ed1SfkfhOz09N8WstRC2rgt9G1/KIx9irDH67Em",
	"/9JG2EZ/ZWvDr34FFxmxc16rPOCgy01Fu0GjAp/aa3tcRUj47sr481pQ7cSdMZ4RGmxjy9dU9aH1NsDf",
	"vthF34Zf+Obvyb/6gs/Za6HJ8bKwDf8hu1q0IWlzOC89Norb3RQDJ/q7IYldmR9KfB9IXekiWwX8DnZP",
	"UDoC/HRUYi0HI6uvx9y5k+SftyR/7kukN8jwTi5/OXJZ+vDvOxH8+Yvgp1/saq7x4nigSPaS6NJiuLbE",
	"dxTIHWXA+bBajoNN98poerdXqX4Q0rfjuZPiX+ilqN3JwUmWQzw02zyxbsp9hPp/VtAP8zPkecTT0HdQ",
	"x7Y3mV4AwyJZImXY7+A4U2N7iJ1zwp3iO8Xns1Z8gr2+03vuXA9fmOuhR8txVn+eD1E0dlWAzpciA3+x",
	"KmYzV5SyT/tp9soy5Kk0XRbEfhnVcuwlLFvCiXnzZzvFXkVsDXZLLWqBZ5ClIBU8UwOiONyol5VDeNHU",
	"D8CN32xWO+BhceUqJpcm2bdBzasOJZA28hX2OPPFOR0yMjgnhgAneyDbg4/2X3SnFUJFVnPiCbizMffd",
	"tthqo3bcBoDkDSqhrqO/+0rMyCNbdLTkmFlYNzOlPCNaro2i6mssSaA5SRsZRRUc3ZNz0ntytpoCndX1",
	"rCluC4j6hO4zgqGVzfnTjR+A55Q7ku8iSAtCCYc51ewc/JX/5K4CyKWlmau/sYEBjgnNMnsa602Ac5Br",
	"osqpMroObwaG31PN87IDw4BVAZIZEU3z+gLemgkHtrzHpjiiE/vGFYVWixfZoiKyGbXoJasrOSJm5BVL",
	"pTjK50L5OFS1VhqWnVah7tPfe4pEe0dCN2ZV8JxxSJaCxxpY/oxPX+HD2NdYIqXv41PzsO/blrxtwt8C",
	"qznPEJl8Vfx+Jqf/SoEurdVKKIQ01u3UNtW29L/jUfKHZs3T7kla8zS41HIPg4HCdpeNnw8+Nv50xX3c",
	"m2pR6kxcBN+iZW+DFIfU9Qga61/Ck9ZqUK+u15d2nXdIAR5iJ6Z6GmlVWD/s71b4F81nc1cuIZFgqHkq",
	"zkGqlnl2l9T2p0pqG7zvO/FY25p3G0cr1X41ktciAztuszN2rJ48Fxm4DsJdRaQKdownAnmpVL/XSs1I",
	"aTlfaFIWRItYEkj9YUJTy2QTa97EJwwqOFojCKdb0HMgNMe+zGQKwImYmkXX8hEXSRXW0PSZJC6kM6oK",
	"BXAVUqSgFGSJr5+/DbSqLzMGoOsNeELAEeBqFqIEmVF5ZWDPzrfCeQbrBE1cRe7/9KsxmG8cXqsKbkas",
	"rdwXQW9VHchpe12oh02/ieDak4dkRyUQrxpg4ptYFjm41LcICnfCSe/+tSHq7OLV0YK5YeyaKd5PcjUC",
	"qkC9Znq/KrRlkRj53QXxuX16ypaoiXHKhfcrxgbLqdLJNrZsXgrXoswKAk4Y48Q4cI/B+ZIq/dZlQWdY",
	"McuKE5zH6thmin6Aq078sZF/tQ9jY6dGHnJVKuJG8JlNkMXWwGG1Ya7XsKrmwjR0P3aVOmU9fNtG7sNS",
	"ML5DVtBEgFAd3Oab4SKLQ/8jdQ6KLiobQNSI2ATIiX8rwG54jd8DCFM1oi3hYFHkkHKmQuRAuc1AFUVh",
	"uIVOSl5914emE/v2kf6lfrdLXFTXcjsToMK0Ngf5hcWsQgftgiri4CBLeuYy3+auKVwXZnMYE6xYkWyi",
	"fHTZmrfCI7D1kJbFXNIMkgxyGnGl/GIfE/t40wC44548k3OhIZnCTEiIb3pNybLXRVQNLXA8FVMeCT4h",
	"qTmCxniuCcR9vWXkDHDsGHNydHSvGgrnim6RHw+Xbbe6xy1lxjA77ugBQXYcfQjAPXiohr48KvDjpHYf",
	"tKf4Jyg3QaVH7D7JGlTfEurxd1pA250XCrCGpGix9xYHjrLNXja2hY/0HdmYA/GLdPa3Y5euMXWu6UAN",
	"DMDJZYzbgwvKdDIT0irSCZ1pkFsD4v9Bmb8O90m5wtVSITiCk5tuHGTyYWsex0UsCMSJC0MiE3K6AAlG",
	"hlHymCwZL7V9Iko9tpVEJdB0YZT20LNqR8Lmiq7doIQ5lVmOjfdmldwUEoUR0y0Bj0BHsgybFr9Z9w9C",
	"DqpP3KzCRZkmJdcsD3o0VHb75+e9vPNI3Hkk7jwSdx6JO4/EnUfiziNx55G480jceSTuPBJ3Hom/rkfi",
	"toofJV7j8HUYueBJO0TyLkLyT1WgtxJV3kGC3okLyrTrOOxrD/T7LXZwBGmgOeKA5dAfs21DSU+/P3pJ",
	"lChlCiQ1EDJOipwa0wBWuup/2eys7Hu+2ya6tmkzVfD0CTn5+5GvI7pw9S6b794/sg3eiNLrHB64DjPA",
	"M6uJ+lYzwA3SXacZ6kWC75PpuoayHOPdFfke334B55CLAqQtUUi0LCON5k+B5s8dbrY4fP5hJncBtB/M",
	"aB/GDaeXQ9uSFl7N92ulilCbR0leBJmVH2Y0V/ChL7nSjrekRaxVZSX4rCsImcl3Ilu3TojZtQPcwObZ",
	"qKuJMk7lOlL7qZvY0CYNLQy7coTV9WV92nvN2y7RdslsG4XFtHUJKnqON1F5tNhrtWGdoWz67axFJ6NY",
	"5mi7wumoAnBQuT9MfrB7Qt7a7263uB9C5I5Yzcw/myjG5psV08B3jRHhWM+XmiHgER89vXj2x4awszIF",
	"wrQivmzudvEyHq0SM9IceOIYUDIV2TppsK9RQwplTFGlYDndLolC/umaszvhY55sllO3I0ZeBIvbxJND",
	"olkljgH3cOe1hsG8ucIWjujYc4Dx62bRfWw0BIE4/hRzKrV4365Mr55mfcf47hhfcBpbGgHjrsx4m4lM",
	"rpHxybUseT/P+34FaWmAC0/yffTO45UcrHTjkjWDaTmfY5P5zh2dWRrgeEzwW2KFdrlDueBuFGQHrxoP",
	"XzX1vD1cl7sE2eD3fb3FB7gdlK/xMmNZUL72V76QKLYsc4tD259zv4zWVgKPFY6ufX99Xu033uUX+G6d",
	"qG3+btFCLqgidn8hIyXPXB5Tp2L1ig+vXmKHPl3xmk1vrFRi1xtZnZt3iIjwu9xMIFekAJnoFbcHqnGY",
	"XF8Ce3Ind821/xpiw6afQw+D7dbYrxnCnqSHDPgaio+gk1KdmNfor0SbSYKNZ+jR6E9xCVsu2Tf3GljS",
	"Gb4ZX1K7W9z9KeQFoSTNGd6uCq60LFP9jlO8vwkWNunGnnhHdT/ve+5fiV8hRm743FDvOMUgo+pWJ8oD",
	"ZxC5wvgBwLNYVc7noAwfDQloBvCOu7cYJyU3VpiYkSVLpUhswqw5X0Z3mdg3l3RNZlinRJA/QAoyNVI/",
	"2HXrS1aa5bkLdjHTEDF7x6kmOVClyStmOLAZzhdJqELOQF8IeVZhId6BZw4cFFNJ3DHzo32KTW7c8r0D",
	"EJ2Z9nHdnOJmu9t42FnWC/nxC4xRwxrLOVO6jo/owH5jd+NLxpMokZ0ugLhwsTZtkftY2c0R0IPmxZFe",
	"wDtupJ8WBDk+1Zcjh/YNUOcs2tPRoprGRrQuivxaB5l/e+EyJMJk7q5d/kQppAEd+JtN3HhbNb+19zte",
	"sTRELvDMPO0RyPapa4rY85IzIBpOslbZGvfGaQPkjfcXX36xyP3bkh6Ne7MmuwN22VWz7R3izW/4mNBc",
	"8LmtlmisS4H7xHhRagwAv04HHpzTPBHnICXLQA1cKRP8+3Oa/1x99mk8ghWkiZY0hcR6FIZi7dR8Y+l0",
	"myANmn8ul5AxqiFfk0JCCpmtC8YUqQ3xia2sQNIF5XOUuVKU84V9zY5zARKqPonG9m0PEa/LsuKJrRHX",
	"hfGIWCdmWEYXaLqI9HFByWSMbU8JWaNF1EDkNSqA9lnX41GvhmyQel7HvFnkNPnDAPHfEOQBfuqJ91Ey",
	"9Y5a76j11qg1VpoQUTdr+QcsvsJtuWZH0nUX4rxBv9StVOm9K3X/Zy917zmQIpRI2tD64z3WqCJMkwss",
	"RDQFYgRPif5w17jOWciY2xYcdVexUrk2d+mCMu6q2FSZBAiHdl3XtW/zei2uRMvM0Ido0AFpKZleo51A",
	"C/b7GZj/vzeKtgJ57k2IUuajw9FC6+Lw4CAXKc0XQumD0adx+Ey1Hr6v4P/otf9CsnNj0Xx6/+n/BgAA",
	"//+Ly7CKlp8BAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
