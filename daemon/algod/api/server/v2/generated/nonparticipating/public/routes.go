// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"ReZ0AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
