// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
