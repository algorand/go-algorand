// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"mBCPnkwfHb37vwEAAP//MrApguO5AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
