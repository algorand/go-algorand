// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
