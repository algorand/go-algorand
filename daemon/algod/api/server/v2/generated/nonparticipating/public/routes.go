// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
