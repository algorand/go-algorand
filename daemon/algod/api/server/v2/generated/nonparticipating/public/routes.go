// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"nRuL5tP7T/83AAD//2UrnPtBngEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
