// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
