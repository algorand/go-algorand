// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
