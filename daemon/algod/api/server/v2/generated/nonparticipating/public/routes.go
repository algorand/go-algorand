// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
