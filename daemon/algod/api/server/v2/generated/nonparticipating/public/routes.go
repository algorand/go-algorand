// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"6f2n/xsAAP//jm+paJKfAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
