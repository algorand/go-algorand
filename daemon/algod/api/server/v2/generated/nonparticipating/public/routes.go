// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"XQEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
