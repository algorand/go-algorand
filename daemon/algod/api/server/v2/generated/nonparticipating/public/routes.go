// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"HOZ0AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
