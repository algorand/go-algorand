// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"3Gg+vv/4/wcAAP//CVDbW3OAAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
