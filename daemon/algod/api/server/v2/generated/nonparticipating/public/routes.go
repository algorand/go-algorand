// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"gQEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
