// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
