// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AgAA//9DScy3uswBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
