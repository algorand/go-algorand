// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
