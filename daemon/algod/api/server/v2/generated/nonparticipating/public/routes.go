// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
