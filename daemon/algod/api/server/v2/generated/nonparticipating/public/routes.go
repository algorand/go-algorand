// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//+txzF3VdAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
