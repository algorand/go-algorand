// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
