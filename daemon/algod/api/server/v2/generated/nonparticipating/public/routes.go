// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"a12Xz6V9AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
