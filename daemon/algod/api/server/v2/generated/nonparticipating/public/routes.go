// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
