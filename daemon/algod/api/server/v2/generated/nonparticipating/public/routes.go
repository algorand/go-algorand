// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
