// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
