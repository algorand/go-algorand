// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
