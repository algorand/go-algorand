// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Get the block header for the block on the given round.
	// (GET /v2/blocks/{round}/header)
	GetBlockHeader(ctx echo.Context, round uint64, params GetBlockHeaderParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetBlockHeader converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHeader(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockHeaderParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHeader(ctx, round, params)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/header", wrapper.GetBlockHeader, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"k+mjo/f/XwAAAP//Hy5EJPzKAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
