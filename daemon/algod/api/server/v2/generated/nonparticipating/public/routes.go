// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "unlimit-log" -------------

	err = runtime.BindQueryParameter("form", true, false, "unlimit-log", ctx.QueryParams(), &params.UnlimitLog)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unlimit-log: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"FDVRAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
