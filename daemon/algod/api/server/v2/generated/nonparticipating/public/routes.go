// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "lift-log-limits" -------------

	err = runtime.BindQueryParameter("form", true, false, "lift-log-limits", ctx.QueryParams(), &params.LiftLogLimits)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lift-log-limits: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
