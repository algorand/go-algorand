// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//2LuFwgjswEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
