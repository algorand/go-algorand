// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"ME7GgjyiAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
