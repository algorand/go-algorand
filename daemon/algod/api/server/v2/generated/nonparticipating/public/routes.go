// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
