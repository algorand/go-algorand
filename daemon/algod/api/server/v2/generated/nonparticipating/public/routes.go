// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"1Ev75B0TpWRnWDTxw+f/HwAA///UWJys6SIBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
