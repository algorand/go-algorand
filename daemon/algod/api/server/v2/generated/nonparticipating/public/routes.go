// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
