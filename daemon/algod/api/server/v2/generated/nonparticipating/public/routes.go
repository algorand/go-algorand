// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
