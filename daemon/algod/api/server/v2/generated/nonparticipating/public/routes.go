// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
