// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Fs2n95/+bwAAAP//ucPyqKybAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
