// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
