// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
