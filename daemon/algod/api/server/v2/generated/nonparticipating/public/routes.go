// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
