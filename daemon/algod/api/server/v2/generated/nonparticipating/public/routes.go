// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "unlimit-log" -------------

	err = runtime.BindQueryParameter("form", true, false, "unlimit-log", ctx.QueryParams(), &params.UnlimitLog)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unlimit-log: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"S+nt+/8/AAD//9NqUrIgTgEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
