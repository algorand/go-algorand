// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
