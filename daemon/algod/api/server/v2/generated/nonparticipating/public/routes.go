// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "lift-log-limits" -------------

	err = runtime.BindQueryParameter("form", true, false, "lift-log-limits", ctx.QueryParams(), &params.LiftLogLimits)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lift-log-limits: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
