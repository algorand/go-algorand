// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
