// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
