// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9fXPbtrI4/FUw+v1m8nJFOa+9p57p3MdNmh7fpmkmcXvuuU2eFiJXEo4pgAcAZal5",
	"8t2fwQIgQRKUKFuOk9Z/JRZJYLFYLPZ9P4xSsSwEB67V6PjDqKCSLkGDxL9omoqS64Rl5q8MVCpZoZng",
	"o2P/jCgtGZ+PxiNmfi2oXozGI06XUL9jvh+PJPy7ZBKy0bGWJYxHKl3AkpqB9aYwb1cjrZO5SNwQJ3aI",
	"0+ejj1se0CyToFQXyp94viGMp3mZAdGSckVT80iRC6YXRC+YIu5jwjgRHIiYEb1ovExmDPJMTfwi/12C",
	"3ASrdJP3L+ljDWIiRQ5dOJ+J5ZRx8FBBBVS1IUQLksEMX1pQTcwMBlb/ohZEAZXpgsyE3AGqBSKEF3i5",
	"HB3/OlLAM5C4WymwFf53JgH+gERTOQc9ej+OLW6mQSaaLSNLO3XYl6DKXCuC7+Ia52wFnJivJuTHUmky",
	"BUI5efPiGXn8+PHXZiFLqjVkjsh6V1XPHq7Jfj46HmVUg3/cpTWaz4WkPEuq99+8eIbzv3ULHPoWVQri",
	"h+XEPCGnz/sW4D+MkBDjGua4Dw3qN19EDkX98xRmQsLAPbEvH3RTwvlvdFdSqtNFIRjXkX0h+JTYx1Ee",
	"Fny+jYdVADTeLwympBn01wfJ1+8/PBw/fPDx//x6kvyv+/Pp448Dl/+sGncHBqIvpqWUwNNNMpdA8bQs",
	"KO/i442jB7UQZZ6RBV3h5tMlsnr3LTHfWta5onlp6ISlUpzkc6EIdWSUwYyWuSZ+YlLy3LApM5qjdsIU",
	"KaRYsQyyseG+FwuWLkhKlR0C3yMXLM8NDZYKsj5ai69uy2H6GKLEwHUpfOCCPl9k1OvagQlYIzdI0lwo",
	"SLTYcT35G4fyjIQXSn1Xqf0uK3K2AIKTmwf2skXccUPTeb4hGvc1I1QRSvzVNCZsRjaiJBe4OTk7x+/d",
	"agzWlsQgDTencY+aw9uHvg4yIsibCpED5Yg8f+66KOMzNi8lKHKxAL1wd54EVQiugIjpvyDVZtv/++1P",
	"r4iQ5EdQis7hNU3PCfBUZJBNyOmMcKED0nC0hDg0X/atw8EVu+T/pYShiaWaFzQ9j9/oOVuyyKp+pGu2",
	"LJeEl8spSLOl/grRgkjQpeR9ANkRd5Dikq67k57Jkqe4//W0DVnOUBtTRU43iLAlXX/zYOzAUYTmOSmA",
	"Z4zPiV7zXjnOzL0bvESKkmcDxBxt9jS4WFUBKZsxyEg1yhZI3DS74GF8P3hq4SsAxw/SC041yw5wOKwj",
	"NGNOt3lCCjqHgGQm5GfH3PCpFufAK0In0w0+KiSsmChV9VEPjDj1dgmcCw1JIWHGIjT21qHDMBj7juPA",
	"SycDpYJryjhkhjkj0EKDZVa9MAUTbtd3urf4lCr46knfHV8/Hbj7M9He9a07Pmi38aXEHsnI1WmeugMb",
	"l6wa3w/QD8O5FZsn9ufORrL5mbltZizHm+hfZv88GkqFTKCBCH83KTbnVJcSjt/x++YvkpC3mvKMysz8",
	"srQ//Vjmmr1lc/NTbn96KeYsfcvmPcisYI0qXPjZ0v5jxouzY72O6hUvhTgvi3BBaUNxnW7I6fO+TbZj",
	"7kuYJ5W2GyoeZ2uvjOz7hV5XG9kDZC/uCmpePIeNBAMtTWf4z3qG9ERn8g/zT1Hk5mtdzGKoNXTsrmQ0",
	"HzizwklR5CylBolv3GPz1DABsIoErd84wgv1+EMAYiFFAVIzOygtiiQXKc0TpanGkf6vhNnoePR/jmr7",
	"y5H9XB0Fk780X73Fj4zIasWghBbFHmO8NqKP2sIsDIPGR8gmLNtDoYlxu4mGlJhhwTmsKNeTWmVp8IPq",
	"AP/qZqrxbaUdi++WCtaLcGJfnIKyErB98Y4iAeoJopUgWlEgnediWv1w96Qoagzi85OisPhA6REYCmaw",
	"Zkqre7h8Wp+kcJ7T5xPyfTg2iuKC5xtzOVhRw9wNM3druVussi25NdQj3lEEt1PIidkajwYj5h+C4lCt",
	"WIjcSD07acW8/Hf3bkhm5vdBH38ZJBbitp+4UNFymLM6Dv4SKDd3W5TTJRxn7pmQk/a3lyMbM0qcYC5F",
	"K1v30467BY8VCi8kLSyA7om9SxlHJc2+ZGG9IjcdyOiiMAdnOKA1hOrSZ23neYhCgqTQguHbXKTnf6dq",
	"cYAzP/VjdY8fTkMWQDOQZEHVYjKKSRnh8apHG3LEzIuo4JNpMNWkWuKhlrdjaRnVNFiagzculljU43fI",
	"9EBGdJef8D80J+axOduG9dthJ+QMGZiyx9k5GTKj7VsFwc5kXkArhCBLq+ATo3XvBeWzevL4Pg3ao++s",
	"TcHtkFsE7pBYH/wYfCvWMRi+FevOERBrUIegDzMOipEalmoAfM8dZAL336GPSkk3XSTj2EOQbBZoRFeF",
	"p4GHN76ZpTbOnkyFvBz3abEVTmqTM6Fm1ID5jltIwlfLInGkGDFb2RdaA9Vevu1Moz18DGMNLLzV9Bqw",
	"oMyoh8BCc6BDY0EsC5bDAUh/EWX6U6rg8SPy9u8nTx8++u3R068MSRZSzCVdkulGgyJ3nW5GlN7kcK+7",
	"MtSOylzHR//qiTdUNseNjaNEKVNY0qI7lDWAWhHIvkbMe12sNdGMq64AHHI4z8Bwcot2Ym37BrTnTBkJ",
	"azk9yGb0ISyrZ8mIgySDncS07/LqaTbhEuVGlodQZUFKISP2NTxiWqQiT1YgFRMRb8pr9wZxb3jxtmj/",
	"bqElF1QRMzeafkuOAkWEsvSaD+f7duizNa9xs5Xz2/VGVufmHbIvTeR7S6IiBchErznJYFrOG5rQTIol",
	"oSTDD/GO/h40igJnbAlvNV0WP81mh1EVBQ4UUdnYEpSZidg3jFyvIBXcRkLs0M7cqEPQ00aMN9HpfgAc",
	"Rt5ueIp2xkMc237Fdck4Oj3UhqeBFmtgzCGbN8jy6tpqHzrsVHdUBByDjpf4GA0dzyHX9IWQZ7Ul8Hsp",
	"yuLgQl57zqHLoW4xzpSSmW+9Ds34PG9G38wN7JPYGm9kQc/88XVrQOiRIl+y+UIHasVrKcTs8DDGZokB",
	"ig+sUpabb7qq2SuRGWaiS3UAEawerOZwhm5DvkanotSEEi4ywM0vVVw464nXQEcx+rd1KO/phdWzpmCo",
	"K6WlWW1ZEPTedu6L+sOEpvaEJoga1eO7qpyO9i07nY0FyCXQbEOmAJyIqXMQOdcVLpKi61l78caJhhF+",
	"0YCrkCIFpSBLnGFqJ2j+PXt16C14QsAR4GoWogSZUXllYM9XO+E8h02CgRKK3P3hF3XvBuDVQtN8B2Lx",
	"nRh6KzXfeQG7UA+bfhvBtScPyY5KIP5eIVqgNJuDhj4U7oWT3v1rQ9TZxaujZQUS/XHXSvF+kqsRUAXq",
	"NdP7VaEti57wP6feGgnPbBinXHjBKjZYTpVOdrFl81JDBzcrCDhhjBPjwD2C10uqtPUhM56h6cteJziP",
	"FcLMFP0A96ohZuRfvAbSHTs19yBXparUEVUWhZAastgaOKy3zPUK1tVcYhaMXek8WpBSwa6R+7AUjO+Q",
	"ZVdiEUR15WpxQRbdxaFDwtzzmygqG0DUiNgGyFv/VoDdMASqBxCmakRbwmGqRTlV3NV4pLQoCsMtdFLy",
	"6rs+NL21b5/on+t3u8RFdX1vZwIURl659x3kFxazNvhtQRVxcJAlPTeyB5pBrLO7C7M5jIliPIVkG+Wj",
	"imfeCo/AzkNaFnNJM0gyyOmmO+jP9jGxj7cNgDteq7tCQ2KjmOKbXlOyDxrZMrTA8VRMeCT4hKTmCBpV",
	"oCYQ9/WOkTPAsWPMydHRnWoonCu6RX48XLbd6siIeBuuhDY77ugBQXYcfQjAPXiohr48KvDjpNY921P8",
	"E5SboJIj9p9kA6pvCfX4ey2gx4bqAsSD89Ji7y0OHGWbvWxsBx/pO7I9Bt3XVGqWsgJ1nR9gc3DVrz1B",
	"1M1IMtCU5ZCR4IFVA4vwe2Ljb9pjXk4VHGR764LfMb5FlpMzhSJPE/hz2KDO/doGdgamjkPospFRzf1E",
	"OUFAfbiYEcHDV2BNU51vjKCmF7AhFyCBqHK6ZFrbgO2mqqtFkYQDRP0aW2Z0TjwbFOl3YIhX8S0OFSyv",
	"uxXjkdUJtsN31lIMGuhwukAhRD7AQtZBRhSCQfEepBBm15mLHffRw56SGkA6po0e3Or6v6MaaMYVkH+K",
	"kqSUo8pVaqhkGiFRUEAB0sxgRLBqThfZUWMIcliC1STxyf377YXfv+/2nCkygwufcGFebKPj/n2047wW",
	"SjcO1wHsoea4nUauD3T4mIvPaSFtnrI7ssCNPGQnX7cGr7xE5kwp5QjXLP/KDKB1MtdD1h7SyLCoChx3",
	"kC8nGDq2btz3t2xZ5lQfwmsFK5onYgVSsgx2cnI3MRP8uxXNf6o+w2QSSA2NppCkmAIxcCw4M9/YrIld",
	"umEdTcaWS8gY1ZBvSCEhBRvlb0Q+VcE4ITb+L11QPkdJX4py7gLQ7DjIqUtlbSqy5J0hotKQXvMErdMx",
	"zu2Cjn2ih5GDgBpdrG3atprHBa3mc7k9Q67UAHltU3/UuzUe9aqqBqmrWlW1yGlmqwzg4g1BLcBPPfFA",
	"HwiizggtXXyF22JOgdnc67G110PHoOxOHITE1Q/7ouKMnpxvDiCt2IGIhEKCwrsltC8p+1TMwsw0d/mo",
	"jdKw7Jrg7ae/9Ry/N72KnuA545AsBYdNNBmbcfgRH0aPE95vPR+jpNH3bVt5aMDfAqs5zxBqvCp+cbfb",
	"J7TtalIvhDyUL9MOOFguH+A63Oknd1Ne1sFJ8zziE3R5K20GoMZVnjyThColUobC1mmmxvagOTeiS3Jp",
	"ov91FY17gLPXHrfl/ApTItG4C3lBKElzhqZfwZWWZarfcYrGpWCpkaglr0X3mxuf+Vfi9s2I+dEN9Y5T",
	"jFirTE7RSIsZROwrLwC81VGV8zko3VJSZgDvuHuLcVJypnGupTkuiT0vBUgMHZrYN5d0Q2aGJrQgf4AU",
	"ZFrqptiOaVlKszx3njgzDRGzd5xqkgNVmvzI+Nkah/Peen9kOegLIc8rLMRv9zlwUEwl8eiq7+1TDHx1",
	"y1+4IFhMo7ePre/GjF/nbm3Q9lSnhv+/d//r+NeT5H9p8seD5Ov/OHr/4cnHe/c7Pz76+M03/1/zp8cf",
	"v7n3X/83tlMe9ljSkIP89LlTaU+fo95SO286sH8yw/2S8SRKZGEYRou2yF1MkHUEdK9p1dILeMf1mhtC",
	"WtGcZYa3XIYc2jdM5yza09GimsZGtKxYfq17agNX4DIkwmRarPHSUlQ3IDGenofeRJdxh+dlVnK7lV76",
	"ttknPjBMzMZVCqatznJMMD9vQX1Uo/vz0dOvRuM6r656PhqP3NP3EUpm2TqWPZnBOqbkuQOCB+OOIgXd",
	"KNBx7oGwR2PgbFBGOOwSllOQasGKT88plGbTOIfzMf3OWLTmp9wG25vzg77JjXN5iNmnh1tLgAwKvYhV",
	"bWgIavhWvZsArXiRQooV8DFhE5i0jTWZ0RddNF4OdIbVA1D7FEO0oeocWELzVBFgPVzIIItIjH5Q5HHc",
	"+uN45C5/dXB1yA0cg6s9Z+WI9H9rQe58/90ZOXIMU92xibx26CD1MqJKu+yiRiSR4Wa2Vo0V8t7xd/w5",
	"zBhn5vnxO55RTY+mVLFUHZUK5Lc0pzyFyVyQY5+w9Jxq+o53JK3eclJBqhgpymnOUnIeKiQ1edoSId0R",
	"3r37leZz8e7d+05QRVd9cFNF+YudIDGCsCh14gocJBIuqIw5rVSV4I4j2wom22a1QrYorWXTF1Bw48d5",
	"Hi0K1U507S6/KHKz/IAMlUvjNFtGlBbSyyJGQLHQ4P6+Eu5ikPTC21VKBYr8vqTFr4zr9yR5Vz548BhI",
	"I/Pzd3flG5rcFDDYutKbiNs2quDCrVoJay1pUtB5zDf27t2vGmiBu4/y8hJtHHlO8LNGxqmPqMeh6gV4",
	"fPRvgIVj7+w5XNxb+5UvZhVfAj7CLcR3jLhRe+wvu19BDuqlt6uVx9rZpVIvEnO2o6tShsT9zlQ1buZG",
	"yPJhFIrNUVt15YCmQNIFpOeuTgssC70ZNz73kTpO0PSsgylbwcdmkGENCfQsTIGURUadKE75pp3Mr0Br",
	"Hw/8Bs5hcybqEhT7ZO83k8lV30FFSg2kS0Os4bF1Y7Q334WDoWJfFD4nG5PzPFkcV3Thv+k/yFbkPcAh",
	"jhFFI9m5DxFURhBhib8HBZdYqBnvSqQfW57RMqb25otU8/G8n7hXauXJRW6Fq0Gru32+BCwHJi4UmVIj",
	"twtXycomTAdcrFR0Dj0ScujcGZiW3HAI4SC77r3oTSdm7Qutc99EQbYvJ2bNUUoB88SQCiozrXg9P5P1",
	"HzrPBBaodAib5igmVYGNlulQ2XCy2Yp7faDFCRgkrwUOD0YTI6Fks6DKF9nCWmT+LA+SAa6xAMC2si+n",
	"QahZUHCsKurieW77nHa0S1f8xVd88WVeQtVyQMkWI+FjdHtsOwRHASiDHOZ24fZlTyh1MYJ6gwwcP81m",
	"OeNAkljUWmAGDa4ZNwcY+fg+IdYCTwaPECPjAGz0i+PA5JUIzyaf7wMkd8UUqB8bPerB3xDP+7Jx3Ebk",
	"EYVh4azHq5V6DkBdqGN1f7UCbnEYwviYGDa3orlhc07jqwfpVB9BsbVVa8RFZtzrE2e3OEDsxbLXmuxV",
	"dJnVhDKTBzou0G2BeCrWiU38jEq80/XU0Hs0tB3TUGMH09Z5uaPIVKwx2gevFhtKvQOWfjg8GIGGv2YK",
	"6RW/67vNLTDbpt0uTcWoUCHJOHNeRS594sSQqXskmD5yuRuUbrkUAC1jR10H2Sm/O5XUpnjSvczrW21c",
	"lyTzWUOx4993hKK71IO/rhWmKrbyui2xRO0UzaCVZp2ZQISMEb1hE10nTdcVpCAHVAqShhCVnMc8p0a3",
	"Abxx3vrPAuMFVrOhfHMviISSMGdKQ21E93ESN2GepFhET4hZ/+p0IWdmfW+EqK4p60bEDxvL/OQrwFDi",
	"GZNKJ+iBiC7BvPRCoVL9wrwal5WasVa25CzL4rwBpz2HTZKxvIzTq5v3h+dm2lcVS1TlFPkt4zZgZYol",
	"kqMRmFumtkG6Wxf80i74JT3YeoedBvOqmVgacmnO8YWcixbn3cYOIgQYI47urvWidAuDDDJnu9wxkJsC",
	"H/9km/W1c5gyP/bOqB2fv9t3R9mRomsJDAZbV8HQTWTEEqaDCsPdlNaeM0CLgmXrli3UjtqrMdO9DB6+",
	"LlsLC7i7brAdGAjsnrGsGgmqWYKvFvBtrehGBZzJIMycNQvlhQwhnIop3+mgi6gq624Xrs6A5j/A5hfz",
	"Li5n9HE8uprpNIZrN+IOXL+utjeKZ3TNW1NawxOyJ8ppUUixonniDMx9pCnFypEmvu7t0Z+Y1cXNmGff",
	"nbx87cD/OB6lOVCZVKJC76rwveKLWZWt9tdzQHwldaPzeZndipLB5lclykKj9MUCXEnqQBrt1M6sHQ7B",
	"UXRG6lk8Qminydn5RuwSt/hIoKhcJLX5znpIml4RuqIs93YzD21PNA8ublgB1ihXCAe4snclcJIlB2U3",
	"ndMdPx01de3gSeFcW4pmL21deEUEb7vQMeZ5Uziv+5Ji5UtrFekyJ14u0ZKQqJylcRsrnypDHNz6zszL",
	"BF/uEUbNiCXrccXykgVjmdeG1LZpARnMEUWmipbXqXE3Fa7nT8nZv0sgLAOuzSOJp7J1ULFMirO2d69T",
	"Izt053IDWwt9PfxVZIyw6mv7xkMgtgsYoaeuA+7zSmX2C60sUuaHwCWxh8M/nLFzJW5x1jv6cNRsgxcX",
	"TY9b2KKny/8MYdha7bv7A3nl1ZWf7Zkj2u+HqWQmxR8Q1/NQPY4kLPk6twyjXP6AMNEh7HLRYDGVdadu",
	"W1TP3rvdfdJNaIVqBin0UD3ufOCWw4Kb3kJNud1qm0jSiHWLE0wYVXpkx68JxsHcicTN6cWUxqqRGiHD",
	"wHRSO4AbtnQtiP/Y415V2RZ2dhL4kqt3mU1GL0DWuYTdwjaXFBjstINFhVoyQKoNZYKx9f/lSkSGKfkF",
	"5baLi/nOHiX3tQJr/DJfXQiJpSRU3OyfQcqWNI9LDlnaNfFmbM5sg5JSQdABww1kmz9ZKnJdRKocIoea",
	"0xl5MA7a8LjdyNiKKTbNAd94aN+YUoWcvDJEVZ+Y5QHXC4WvPxrw+qLkmYRML5RFrBKkEupQvamcV1PQ",
	"FwCcPMD3Hn5N7qLbTrEV3DNYdPfz6Pjh12h0tX88iF0ArsHMNm6SITv5h2MncTpGv6UdwzBuN+okmnVv",
	"O8z1M64tp8l+OuQs4ZuO1+0+S0vK6RzikSLLHTDZb3E30ZDWwgvPbHskpaXYEKbj84Omhj/1RJ8b9mfB",
	"IKlYLpleOueOEktDT3V7CzupH872WnKViT1c/iH6SAvvImopkZ/WaGrvt9iq0ZP9ii6hidYxobZ+SM7q",
	"6AVfL52c+vJEWKq5qtBscWPmMktHMQeDGWakkIxrVCxKPUv+RtIFlTQ17G/SB24y/epJpDx1s0wq3w/w",
	"T453CQrkKo562UP2XoZw35K7XPBkaThKdq/O9ghOZa8zN+626/Mdbh96qFBmRkl6ya1skBsNOPWVCI9v",
	"GfCKpFitZy963Htln5wySxknD1qaHfr5zUsnZSyFjNUcrI+7kzgkaMlghbF78U0yY15xL2Q+aBeuAv3N",
	"eh68yBmIZf4sxxSBb0VEO/Ul0ytLuotVj1gH+o6peWDIYOqGGpNmeepPz0cPEwUV93R5w3bXsWWeeDzg",
	"H21E3DC54AbWvny7kh5CCcrzR0kmq54HPnZKvhXroYTTOoWeeD4DFEVRUrI8+6XO/Gx1P5CUp4uoz2xq",
	"Pvyt7tNWLc7egdHygQvKOeTR4ay8+ZuXSyOS87/E0HmWjA98t92QwS63tbga8CaYHig/oUEv07mZIMRq",
	"M6muCtrO5yIjOE9dq64+rt1GHkG59X+XoHQsQQkf2MAxtI0admCrfRPgGWqkE/K9bcW8ANIoRISaoK8U",
	"0cyaLotc0GyMFSzOvjt5Seys9hvbbchWG5+jItRcRcsmFpThHBaC7BsHxdMjho+zPV7brFrppCoOHktA",
	"NW/U5ctZy0+AKlKInQl5HjRVtbmqZgiCBUzk0mh11WhWPkKaMP/RmqYLVPsarLWf5IeXyfdUqYLWlFWL",
	"qao2JZ47A7erlG8L5Y+JMLr5BVO2Ay+soJnzWiWAO7ODz4FtLk+WnFtKmexxy1WVKPdFuwfOXpHelRCF",
	"rIX4PYV+22Vi364Bb/GraKmsdguCTk9Km0FZtQ7yndVTygVnKRaqil3RrlXvED/bgJpebUOuP+LuhEYO",
	"V7TxQRWK57DY2wrBM0KHuK6hP3hqNtVSh/1TY0/YBdVkDlo5zgbZ2PfvcLZGxhW4WqPY2Dngk0I2fJfI",
	"IaPu8KRym+xJRph606M8vjDPXjnTAsaknzOOSoRDmxP8rDUQO4lqo3kwTeYClFtPM/9Y/Wq+mWAqbgbr",
	"9xPfeRTHsK4/s2zr5+4OdeK93s7LbN59Zt51BZKqnxtRznbSk6Jwk/Z3d4nKA3rNexEc8V4m3n0UILca",
	"PxxtC7ltDVfB+9QQGqzQ2Q0F3sMdwqg6nbS6aBmh1VIUvkFsmFi0SgLjETBeMg51X9zIBZFGrwTcGDyv",
	"Pd+pVFJtRcBBPO0MaI4e7hhDU9q5N646VLs8lEEJrtHP0b+NdZOWHsZRvVALbpRvqna8hroDYeIZ9gF3",
	"iOy2XEGpyglRGWYttJqwxBiHYdy+zVPzAugeg65MZD/HWmn73kR9iajTMpuDTmiWxUq/fotPCT4lWYmS",
	"A6whLasSoUVBUqy70ixE06U2N1EquCqXW+byL1xxuqCrUYQaws5Kfocx0WW6wX9j9TH7d8YFeuwdauij",
	"OrL9qi91QydjUq+h6USxeTIcE3inXB0d9dSXI/T6+4NSei7mTUA+cfmJbVwu3KMYf/vOXBxhdYZO0Vd7",
	"tVTFEzCwT/helKg2Vmm/Ta6EV1mnCiw6lKped9sNEP1d68Z4+fWE9wZFN6i9X62Hsi/IN+2NSafaZcdp",
	"SrayoN6MIxshZHOLEIq4dbYvKsgGBZnHna+HSYYdOVvHCx8GCPXhZl2AfvCxrKSgzLnfa2bRxayLeu/m",
	"IQyJh603uL0IF0vea7H7YdUX9+2LseHzdlerc3Ap84WEFROld2z7yCevEtpfGz2iqsj76Pq7hlec6mbN",
	"ob3G2zPXXcAu0+nkP/xi4+QIcC03n4Ept7PpnX5ZXWnXmqfqV0hVmHpQoerGrTikUGGsJp6TDRsdu3b0",
	"G+uQ1fMh4kC3f9h4dJrtdWHG6iqO7CixYxfvBtZfdqouNYVHrBCK1fXhY23CBoYYnmGnr6BsVncsH9+z",
	"glRjU4A6bkEC7FNEy0wWNB69LT/Vo05XkZiu6tS2UlPdTgA77vhONliQ0WirqE+GF1Y6qaLTkE9jNeQ5",
	"cNf7s5nnMTjafDaDVLPVjuy7fyyAB5ldY2+XsT28g2Q8VkUvY/GW/a2ONUDbkuO2whMUUbwyOH25N+ew",
	"uaNIgxqiZd3H/qq9TN0OxAByh8SQiFCx6A9rSHYOeaYqykAs+Ggr+znUFdB6O0IFuaSXnMuTpLk46vzS",
	"LVPGW9IMmst8ulfWNQbi9iXodTta9Osfz7GBiKq6Nfq6H6GWTk671REvXN0QzJWsfCe+gggo/5tPjLaz",
	"5Owcwp5V6Km6oDLzb0RNL96qk2y5jzpZdb4bQxvoWTUzq2Nju3lUkXpbGAGd5sKIEUlfGHkzHLWK5bij",
	"bNCNLf+OgbYGrhlI19sP5d9cKEi08LG02+DYhgobWXQpJKjeGpcWuN7KM2/q0jpY65dipRnqAorCBRIJ",
	"S2qgk0EBnP45tyH7mX3uE4d8rdedFqaKXnc3HfBR0Ux1kBhS/Yy423J3QtJljE2Mc9s/WsWq4XCQTW9I",
	"IUVWpvaCDg9GZZAbXGtqCyuJ2mnS7ipbOkKQ1XkOmyOrBPluDX4HQ6Ct5GRBD6ootDb5oOY3FYN7fhDw",
	"btJyNR4VQuRJj7PjtFvCp03x5yw9h4yYm8JHD/Z00CF30cZeebMvFhtfsqYogEN2b0LICbfx2t6x3awh",
	"3Zqc39Hb5l/jrFlpq2o5o9rkHY8HvmK9K3lFbuaH2c7DFBhWd8Wp7CA7CsSse8oHSXoR6Sc1GaqVd13N",
	"7R4/NVFZKGIySd2+ZkecTBUiU3f+qMNkutJBnouLBKkoqep/xXQO816TSfqKp/VnBttTCOJtqHIX6IYs",
	"aEZSISWk4RfxFAcL1FJISHKB4Tcxz+BMG3loiXHNnORiTkRh1FxbRs/7UKJtaYK5DtWCx6brWggS6/Dp",
	"KYgAyqXnOnDty114t3TB2b/DztkiYrfBDfO7tXcbHUdwe3e/CMAcQOi7bVYnsS5BzXW1+1X1dY/TYsnS",
	"OLq/rGiV3hiTGPXGUOEK0NoEOHwND3jIUyrnJJ6eLpqB02ke89gQd/yckwbp3PwXb7D2uGQGjrn08LNY",
	"u1uanidWJBowPcJpczJ0KW3NWjNC3QJLzG3yFnqW2vAN4jMft29FrB1VhNSq9btuWT7Rs4dso1747U5v",
	"26JwOtT1XZXBHsihAgD6neENGAa5xPcFY4YtPxMaQfJppYiMGx2ZWYsN+xKFlt2k1BoiFkDM2KUEl3ho",
	"exO2miEVVC+8YGJe75oLjOoJCrMCbUcXqqxxyxvZXGPEtsQniiSHFTRiBFw2ZJmmoBRbQdhU0X5MMoAC",
	"Tc5tRSjm/A4vnJZ07NaeBO7TIdiNissWsXanyA5ZOCq5r3lij4kaepQMRCuWlbSBP3WF9nJ9neUiN6KH",
	"9f0wTrE3k4gvbhuL2BmugjQfPZc8Hq0SJuNWdi6cLavs4ZYI65OtCnrB+/XCLlHWAt3wxowBYr9bQ4qX",
	"YzMc4+o4ITgYUa1E+15JTlY7fFn7Qi+VbSOyTpvKqCipwLcZDmvieGncfRu5Gq0llKnIAEzVvAGDO6EO",
	"HgxeW9INydhsBtL6epSmPKMyC19nnKQgNWVG8d2oy2s9BlpZwnin4mM4NQ7qmVVMBUKzpQUk3ziNsk8p",
	"GaBMoGMvokjYa1uLvg6anV2JZ5vQtVG+MOyuhwhcnjyqXvawCo5yL1nSc9hzHsX+gO3TYPUaZxrWAmcd",
	"MsXHrbT+E6IOD/zPnOmt1G7lvXYcpHVUWWL0NMjntbfcbk6XBmOhq2e2j1MYvtpui+D32lrN7HzQU+bR",
	"8c4Eeara4ocGFTRwSp0dsSsOdJixBWbswnr3lBasmE6zjPX1y16Aq2HsaLo5bWXbMeMM117N29tDeZNC",
	"FEk6xD2RQQ7mkFt9wcHahHKAV6pIdzDk6PXUww+ayomY4clEgrSXMgZyVFfRuB1i1Lx+K5LHdqxpKVGA",
	"vKCb3ZXy6is4Hp1tR/b6pQ86qaB2W2wPl7IdPqKF6PYRzSLnPdbkolsC7PCLsWkHtWP0+pbjXB/xBYQt",
	"87fTW63EeFKJ0Brlmxjb8Mb9SyywTzIbEDh7sK2qTst1bFD0eqp51ODQUeGT1ip22Mp5jQeAtuI+b8K7",
	"0gbJrgc7uhBEAvn94e9EwgxbNgpy/z4Cff/+2C3990fNxzZq4/796J0YD2Q9XPwqfvs+vqmXKfc7iN66",
	"kbGRIxL0595OVWE18LrMgLQB1hjc4BX8NpH9WCv+wzqF+w92gBfGsAW9wr070YFzw/n6P1ZICZbSSwmN",
	"5e8Ki3MLrC0lwRY55UNrsL0ZbI5nc1+CmEf1rAol7Gtr3444xNLfRtrN80ikotWHbCPpgHDM4ZErmn96",
	"roI14U8QH5C96Y9PCMPVQiRbVKrLJcu+pIPmDkLTDjc1f43Rkf8As0fRu94N5fhm50ZHbZbm1pc2811l",
	"V8DJBY5pDeAPvyJTV0yokJAy1TbtXPiGb1V0FvY/dQnKa70jHGzXOn8R+gpkPPOWUvKqbh6F7qI5ryGs",
	"j+gNM5Wekxul8hj1dcgigr8Yjwqr+u64Ls4bORe1qB7caELCgXMvgizKPXMvuvWKhy7P5heYS6dU0F3n",
	"4Nu6gdvIRV2vbaj0N1jcw84+Q/J94qKZ+RwTjg4io+0loV1DqpHFkRvDzRujmF/6ik/YAgs9dU5a+1Gy",
	"PNtFGI2qNXVjeqzL8purjXUjrfF/s+HP3aPq2hNfIWfDIiay1sbkwVRBPZoBpWjcZ5HCMxhalJaS6Q2W",
	"7PZmDPZbNCnq+yrA3iVoVDZpd/dpcQ5V0fc6HL9U/nb9XtAc7yNrKufmFhL5hHy3pssid6Yu8s2d6X/C",
	"4789yR48fvif0789ePoghSdPv37wgH79hD78+vFDePS3p08ewMPZV19PH2WPnjyaPnn05KunX6ePnzyc",
	"Pvnq6/+8Y/iQAdkCOvIFIkf/k5zkc5GcvD5NzgywNU5owX6AjW1VbcjYN8GmKZ5EWFKWj479T/+PP2GT",
	"VCzr4f2vI1d/brTQulDHR0cXFxeT8JOjOcbfJlqU6eLIz9Ppkn3y+rRy9FsvFu6oLd3ivZOeFE7w2Zvv",
	"3p6Rk9enk5pgRsejB5MHk4dmfFEApwUbHY8e4094eha470eO2EbHHz6OR0cLoDmmq5g/lqAlS/0jCTTb",
	"uP+rCzqfg5y4zuDmp9WjIy9WHH1wccgfzQxRG76tWhSUquk2zHY5DWiOsxEKjQaUyvVDHFdtSZ2zlGdY",
	"TMaG9ho2VyHuNKv7b53WTMtXIbdtWY5/jeSG+TAQXxy70bTchYwwRf777U+viJDEqTevaXpehcCQ05mt",
	"KCvFimGNkiwobGO+nHj6/XcJclPTl+N8YcsR32XSxdIs1bxolkmopaqY5SvWnBxnNmQREHaVNVAzLnQL",
	"BZDUbNiw1gfJ1+8/PP3bx9EAQDCFRQEWpP2d5vnv5IJhj2v0j/qS7q5k7zjSURGl6XEdhY4f1Ds5Rqtc",
	"9TRsml2906wu9DsXHH7v2wYHWHQfaJ6bFwWH2B68x5KpSCx45h49eHCwbvtVQS0bZVKN4kniEgN1GZJ9",
	"VHXtv5C0sGfRN93H2EtnLbcvTQzfeXLAhTbT4a+83PZwnUV/SzNsZAxK26U8/GKXcsoxi8xcEMRegB/H",
	"o6df8N6ccsNzaE7wzaAeefei+Zmfc3HB/ZtG+CmXSyo3KNoE3dZbxfroXKGLClmkPduN/sqj9x97b72j",
	"sH3s0YdGIlJ2pTux0zn79PmOa/KO6uOc3W4+re605nnVfBR9na4FL7ZDVfcm5Pvwa+TeWBzXlp4tJYfM",
	"5xH5W6+q9u97CNSw3VFh3eDopR2Yi2/v75u+v0+axo5Gx5gYMI1TsBWmjtv4qhdoN9QrSDjao9Rk0OfO",
	"d9KwfWIv0W3vWpugt3RNO9P7mCq4k1Hf4q4Hd31iUgBvJTE1+/teP2v2dSuqm6RxZVwj4/7Chb4faW7o",
	"JFhuqz6kbaN0Kwz+ZYTBKr99bqUz1znwauIh9hA/+uBbYx1AJHStwQYIg6FaHXwbRJrebbGTexPb5yp8",
	"53I8wyW07xTzsGHZrYD3GQh43WaAMTDqFm83J9QhDIu6W+DOxoS+z18ojfgujIO7Gn6hUtxfGFm9YpuB",
	"dLfAdgn22RHGHLO+Nrb6pxTCHNJuxa+/tPhVlZm5kgDWaOfpChcFbqwrWe/a1jmmK0msWWoo4GyYEmYY",
	"ijvC4zri27AYGzLtgqXV2GuG6E61SqPdrHFHb+yKWN9DqKB+uzl9vku6+oLsPIM7hkRugfjeXDcvjbod",
	"3nwat8Mw3vTkwZNPB0G4C6+EJi/wFr9mDnmtLC1OVvuysG0c6Whq+6Vt40q8xZaQUdR90AIeVdVYGwfP",
	"zds2SuMu5tY1a8zemxDfnU1VvWZdYvpcGEbls2qonNuPDK8zyCB3/J/HOP6dCXmBGVhajTHYTLtGpOQO",
	"4/r44aPHT9wrkl7YWK72e9OvnhyffPONe63uxWf1nM7rSsvjBeS5cB+4O6I7rnlw/D///N/JZHJnJ1sV",
	"6283r2xTis+Ft45j9SAqAujbrS98k2Laum8vtwt1n8R9/61YR28Bsb69hW7sFjLY/1PcPtMmGTlFtLJk",
	"NspWHvA2ssdkn/to7PvOGb5TXSYT8kq4CsJlTiURMgPpmnPPSyop1wDZxFMqFs1QtmJqmjNMGpYE2w3L",
	"RLEM6oI+Vcp+IWGFMfJVCZwmBLsZPUbSfrZM/ke6DtJ2p9U1rYVbMpo9l3TtG55jS18h8advviEPxrX2",
	"kudmgKRCTIy5Lul69AmtfhWxDYo/b/YL3Rmgi2MPsSDV0k9VAyRsTvjX5txfrORuyd1t7IE4596On9qx",
	"E9oRXJ3erRYEK9jZdujYn3tTVxMyUp4XoeIszsww1DjwGfsIdpqmo0poG723h/jWCHAlVtImqD3ZBmad",
	"qqMPqJeHPKNzbjFr7q/lLg18R1IsvfNIkBnodOESdluoj7An3620nzctGWdLA+WD8bVLNbiL3UpbYZuU",
	"jNo0+SGVeINcSnTggYwQ8U++cZh5zGa2QJ6v7Xnmukuga8pVMKt6E1jl23YrcfH8Pq+3oI1eC7uhfFZP",
	"3hXIEC2H8H/eIng/BHeY43e+Gz5izC3izxDx71XJhLwSddq4a8T6Z3Q9XufNft0LeiU4WB+7kXwtLd66",
	"UyuxwzAOixRfL8TqL1VLvEuLIEcLqhY75ZC/m5d2yCJDbm8z2Rd5hf/dYWnLLWPWNtlZDKEebQhzNi/a",
	"ypvNJm03qMXcCD/9DFWbm+BYn4bF4CH1fMaJBfywTAdL8FhiPqr6c/VxoHjLw8HcSIsqDC3apXAKueBz",
	"9Xmyoq3NJ6N4iVBJ1Qwy3vHxr3d2n2F1H6Py2ghIV+9JMZ4CUWIJtuUyU2TJlHLBkk8e/O3TQajZ0je5",
	"4WHu6g1zl6cPHn+66d+CXLEUyBksCyGpZPmG/MzpirIcuzJcgdthP8uq/pq3BkdbmKK3qVkXLA2LGF2e",
	"CTZC1z7oNcs+7maGQTHJPfkg4wEfDEsq06IAKi/PAHe7rtqdW06fh9HBjTaLVUWtCCgGRXsGyP/HaKDd",
	"CdPexcxdfiW3gPrqX45NuNBdMRtXwTFGChCzY/KO3ydqQZ8+fPTbo6df+T8fPf2qx3Jm5nFFe7q2s3og",
	"89gOM8SA9kWbAw8rtVf4Pf7Uu73fJo5HLFtHG7HVrZU7TTucWHZHkYJuers1FjtaQ4fD1m2iP32xQ6XZ",
	"dBHVr7z6U3UoOuXfVlqwrcjnOirftoTuSZ4I+IwhtLo3dIX17W2it0iTLbKs+vF+auW0TjKwF51Hnmzd",
	"OTcq6OqbUlIT1FGBe8GmiZabkymxWeA4cHcXUmiRitzGrpRFIaSuTreaDBL3oM9t15D2+gh3L2EupTpd",
	"lMXRB/wPVvj6WCceYO1jdaTX/Ag7Vhx92BoigCDm5qxLWza5IZdGW0J11WT8vC7R/ELITuO5XSEArRMz",
	"bh8i230DYwki8tn1SGd/aaFmq/7f2vCrm7QjI3YOcJVXF3RdqGg3KPztU+VsB5EICd+6YD6vBdVGkRnj",
	"GaHBNrZ0NyFrRnDNhpHrXvRN2Fk+vd/p6Rd8zl4JTU6XhW34B9nVondIm8P522PrdbufYOCu/m6IT/fO",
	"D298H5hYWdd3XvB7OOSCVGzw01GJudHmrr4e2/ftTf553+TPfMnhBhne3stfzr0sfTjl7RX8+V/Bj7/Y",
	"1VyjI2bglexvoktfw7UmvueFHGk4jyaDlit8m58GVe/2KtULIX17i9tb/At1MtidHJy0NMRCsyuVyU15",
	"iNDZzwr6YXaGPI9YGvoO6tj2+tELYFh0RqQM64efZmpsD7EzTrhTfCv4fNaCT7DXt3LPrenhCzM99Eg5",
	"TutvNpnvEzT2FYBWS5GBjzoRs5kr8tYn/TR7zxjyVJouC2K/jEo56I09Y0t4a978yU5x0Cu2BrslFrXA",
	"M8hSkAqeqQFeUTfqZe8hdOP2A/DJPaDVDnhYXPr35NIk+yaoIdOhBNJGvsKeQb7YnUNGBiuy9N2jr0i2",
	"Rx/sv2hOK4SKrOatJ+DOxtx122Kr99lxGwCS1yiEug7T7isxIw9sEb+SY6ZO3RyQ8oxouTGCqq9ZIoHm",
	"JG1E6FdwdE/O296Ts1MV6KyuZ01xXUDUJ/SQ4ayt7KgfPvkBeEa5I/kugrQglHCYU81W4OPWJ7cZ9Ze+",
	"zVw++xYGOCY0y+xprDcBViA3RJVTZWQd3gy0vKOa52UPhgHrAiQzVzTNawe8VROObLr8toDKt/aNK15a",
	"LV5kk/RlMwrI36wuhV/MyI8sleIknwvl47rURmlYdlrvuU9/6ym66g0J3RgwwXPGIVkKHmsI9xM+/REf",
	"xr7GkgN9H5+Zh33ftu7bJvwtsJrzDLmTr4rfz+T0XylXo7VaCYWQRrud2ia1lv73PEr+0Gx42j1JG54G",
	"Ti33MBgobB/X+PnoQ+NPVyzDvakWpc7ERfAtavY26GdInnzQqPoSlrRWw2d1vba06/QhBXiInZjqaaT1",
	"V9COvLf71180P8S5XEIiwdDNVKxAqpZ6dpsk8qdKEhm873vxWNvqchdHK9VhJZJXIgM7brPTbKw+MxcZ",
	"uI6cXUGkCnaMB9b7W6l+rxXqnNJyvtCkLIgWsaDq+sOEppbJJla9iU8YVESzShBOt6ArIDTHPqdkCsCJ",
	"mJpF1/cjLpIqrEnnI7NdSGdUFArgKqRIQSnIEl+PehdoVZ9TjOPWW/CEgCPA1SxECTKj8srAnq92wln1",
	"CVfk7g+/GIX5k8NrRcHtiLWVsCLoraptOGmvC/Ww6bcRXHvykOyoBOJFA0wkEcsiB5dKEkHhXjjp3b82",
	"RJ1dvDpaMNeCXTPF+0muRkAVqNdM71eFtiwSc393QXxmn56xJUpinHLh7YqxwXKqdLKLLZuXwrUos4KA",
	"E8Y4MQ7co3C+pEq/cVmFGVagsdcJzmNlbDNFP8Crvn70ZuRfqm70nbFTcx9yVaqqZb3LFIAstgYO6y1z",
	"vYJ1NRemdfqxq1QEa+HbNXIfloLxHbKCotyE6sCbb4aLLA7tj9QZKLqobABRI2IbIG/9WwF2Qzd+DyBM",
	"1Yi2hINFRkPKmQqRA+U2o0sUheEWOil59V0fmt7at0/0z/W7XeKiur63MwEqTBNxkF9YzCo00C6oIg4O",
	"sqTnLpNk7posdWE2hzHBDPBkG+Wjyda8FR6BnYe0LOaSZpBkkNOIKeVn+5jYx9sGwB335JmshIZkCjMh",
	"Ib7pNSXLXhNRNbTA8VRMeCT4hKTmCBrluSYQ9/WOkTPAsWPMydHRnWoonCu6RX48XLbd6h6zlBnD7Lij",
	"BwTZcfQhAPfgoRr68qjAj5PafNCe4p+g3ASVHLH/JBtQfUuox99rAW1zXniBNW6KFntvceAo2+xlYzv4",
	"SN+RjRkQv0hjfzt26RqrvzQNqIECOLmMcnt0QZlOZkJaQTqhMw1yZ0D8Pyjz7nDnGtDC1SYgOIK7N904",
	"yOTDVheOi1gQiLsuDIl0/W9mqhdCDiqx2SwkQ5kmJdcsD8qMV6ry52cwvDUC3BoBbo0At0aAWyPArRHg",
	"1ghwawS4NQLcGgFujQC3RoC/rhHgpormJl7i8KXEuOBJOyqR3EYl/qmKTFZ3lTdKoBnjgjLtumb6fH/3",
	"5Go1djXQHHHAcuiPk7bhm2ffnbwkSpQyBZIaCBknRU6NbgBrXfVwa3YH9X2LbSNI23iUKnj8iLz9+4mv",
	"hbdwNdua7949cf2/ld7kcM91SQCeWVHUt0sAbpDuuiVQfyf4Xm+u8x3LMcZcke/w7eewglwUIG2ZLaJl",
	"GTH5nAHNnznc7LD4/MNM7oJWfzej/T5uGJoc2pa08HK+XytVhNrcRfI8yGb8fUZzBb/3JTTa8Za0iLVb",
	"q24+awtCbvKtyDatE2J27Qg3sHk26op4jFO5idRb6iYTtElDC8OvHGF1jVkfD163sUu0XTLbRWExcV2C",
	"ip7jbVQeLVhYbVhnKJvyOmvRySiWrdmu0jeqABwSAnuGCQd2T8gb+93NVoVHiNwRq5n5ZxM52HyzYhr4",
	"rtEiHOv5UqPyPeKjpxfP/tgQdlamQJhWxJd+3H29jEfrxIw0B544BpRMRbZJGuxr1LiFMqaoUrCc7r6J",
	"Qv7pGgy7y8c82X5P3cw18jxY3DaeHBLNOnEMuIc7bzQM5s0VtnBEx54DjF83i+5joyEIxPGnmFWpxfv2",
	"ZXr1NJtbxnfL+ILT2JIIGHelcttMZHKNjE9uZMn7ed53a0hLA1x4ku+ieR59crDWDcdmBtNyPsdGyR0n",
	"nVka4HhM8BtihXa5Q7ngfhRkB6+aZ1413bs9XJe7BBnYd32Nw3u4HZRv0JuxLCjfeJ8vJIoty9zi0PaY",
	"OyyjtdVsu5EA6I91xr8+s/Zrb/MLjLfuqm3+btFCLqgidn8hIyXPXO5Qp+b1mg+vGGKHPlvzmk1vrQ5i",
	"1xtZnZt3yBXhd7mZtK1IATLRa24PVLOTuq2tbU/u5LZB7F/j2rAp39DDYLt1omuGcKDbQwZ8Da+PoBtI",
	"nQzX6BGCVov+1JGwNYh986DRI53hm0EktUnFOUkhLwj13ftTwZWWZarfcYpOmmBhk26AibdG9/O3Z/6V",
	"uJ8w4sZzQ73jFJu7V66bKJ+bQcRP8QLAs1FVzuegDK8MiWQG8I67txgnJTealpiRJUulSGwiqjlDRj6Z",
	"2DeXdENmWP9DkD9ACjI1N3uw69ZgrDTLcxfRYqYhYvaOU01yoEqTH5nhsmY4X3ygCuUCfSHkeYWFeKeI",
	"OXBQTCVx48v39ik2Y3DL90Y+NFjax3UR9U/bhcHDzrJeyE+fG7gp1i7OmdJ1EEQH9k/mAF8ynkSJ7GwB",
	"xMWEtWmL3MWKaY6A7jW9Q3oB77i54bQgyNWpvhw5tN08nbNoT0eLahob0fIG+bUOUvEOwmVIhMnculb+",
	"RKmZAR149yVuvK1G39r7Pd0ojSsXeGae9lzI9qlr3tXzklMSGoawVjkY98ZZA+Q/b+P399ejL3o0Hkxj",
	"7A7YZVfN9kyIN7/hY0Jzwee2CqHRIAXuE+NFqTGw+jqNdLCieSJWICXLQA1cKRP8uxXNf6o++zgewRrS",
	"REuaQmKtBkOxdma+sXS66yINmtQtl5AxqiHfkEJCCpmtt8UUqZXtia1YQNIF5XO8c6Uo5wv7mh3nAiRU",
	"/byMftseIl7vZM0TW3utC+MJsYbKsDwt0HQR6Y+CN5NRqD0l2HISQ1TmCCvAypp9GvR41CshG6Su6sA2",
	"i5wmfxhw/Tcu8gA/9cSHKEV6S6231Hpj1Bor+Yeom7VsABZf4bZcs7HougtcfkLb041Uv70tIf9nLyHv",
	"OZAilEjakPrjvcuoIkyTCyzwMwViLp4Sbd6uxbnTkCfEMKTAvm8rQSrXeTNdUMZddZgqXQDh0K47sPbt",
	"CK/FXGiZGdoJDTogLSXTG9QTaMF+Owfz//dG0FYgV16FKGU+Oh4ttC6Oj45ykdJ8IZQ+Gn0ch89U6+H7",
	"Cv4PXvovJFsZjebj+4//fwAAAP//UcOmFFGAAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
