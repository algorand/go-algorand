// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/0/AeDRQkgEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
