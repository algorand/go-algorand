// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"ldUBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
