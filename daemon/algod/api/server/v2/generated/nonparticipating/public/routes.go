// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"DYVk55ij+v3H/x8AAP//+gygK7NHAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
