// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
