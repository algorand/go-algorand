// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"qt9//P8BAAD//0vKaWunRwEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
