// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
