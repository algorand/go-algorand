// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
