// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
