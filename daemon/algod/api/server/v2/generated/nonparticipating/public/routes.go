// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get a list of applications held by an account.
	// (GET /v2/accounts/{address}/applications)
	AccountApplicationsInformation(ctx echo.Context, address basics.Address, params AccountApplicationsInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get a list of assets held by an account, inclusive of asset params.
	// (GET /v2/accounts/{address}/assets)
	AccountAssetsInformation(ctx echo.Context, address basics.Address, params AccountAssetsInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationsInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationsInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationsInformationParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationsInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetsInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetsInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetsInformationParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetsInformation(ctx, address, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications", wrapper.AccountApplicationsInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets", wrapper.AccountAssetsInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
