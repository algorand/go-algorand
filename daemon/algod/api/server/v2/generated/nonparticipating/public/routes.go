// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
