// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
