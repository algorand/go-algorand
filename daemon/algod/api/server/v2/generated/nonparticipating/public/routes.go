// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
