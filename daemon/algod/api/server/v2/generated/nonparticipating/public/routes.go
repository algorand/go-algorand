// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9e5PbtpI4+lVQ+v2q/FhR42f2ZKpSeye2kzMbx3F5Jjl7NvZNILIl4QwF8ACgRoqv",
	"v/stNAASJEGJmqedzF/2iCTQaDQa/e6Po1QsC8GBazU6/DgqqKRL0CDxL5qmouQ6YZn5KwOVSlZoJvjo",
	"0D8jSkvG56PxiJlfC6oXo/GI0yXU75jvxyMJ/y6ZhGx0qGUJ45FKF7CkZmC9Kczb1UjrZC4SN8SRHeL4",
	"5ejTlgc0yyQo1YXyJ55vCONpXmZAtKRc0dQ8UuSc6QXRC6aI+5gwTgQHImZELxovkxmDPFMTv8h/lyA3",
	"wSrd5P1L+lSDmEiRQxfOF2I5ZRw8VFABVW0I0YJkMMOXFlQTM4OB1b+oBVFAZbogMyF3gGqBCOEFXi5H",
	"h7+OFPAMJO5WCmyF/51JgD8g0VTOQY8+jGOLm2mQiWbLyNKOHfYlqDLXiuC7uMY5WwEn5qsJ+bFUmkyB",
	"UE7effeCPH369GuzkCXVGjJHZL2rqmcP12Q/Hx2OMqrBP+7SGs3nQlKeJdX77757gfOfuAUOfYsqBfHD",
	"cmSekOOXfQvwH0ZIiHENc9yHBvWbLyKHov55CjMhYeCe2JevdFPC+W91V1Kq00UhGNeRfSH4lNjHUR4W",
	"fL6Nh1UANN4vDKakGfTXR8nXHz4+Hj9+9On//HqU/K/78/nTTwOX/6IadwcGoi+mpZTA000yl0DxtCwo",
	"7+LjnaMHtRBlnpEFXeHm0yWyevctMd9a1rmieWnohKVSHOVzoQh1ZJTBjJa5Jn5iUvLcsCkzmqN2whQp",
	"pFixDLKx4b7nC5YuSEqVHQLfI+cszw0NlgqyPlqLr27LYfoUosTAdSF84II+X2TU69qBCVgjN0jSXChI",
	"tNhxPfkbh/KMhBdKfVep/S4rcroAgpObB/ayRdxxQ9N5viEa9zUjVBFK/NU0JmxGNqIk57g5OTvD791q",
	"DNaWxCANN6dxj5rD24e+DjIiyJsKkQPliDx/7roo4zM2LyUocr4AvXB3ngRVCK6AiOm/INVm2//75Kc3",
	"REjyIyhF5/CWpmcEeCoyyCbkeEa40AFpOFpCHJov+9bh4Ipd8v9SwtDEUs0Lmp7Fb/ScLVlkVT/SNVuW",
	"S8LL5RSk2VJ/hWhBJOhS8j6A7Ig7SHFJ191JT2XJU9z/etqGLGeojakipxtE2JKuv3k0duAoQvOcFMAz",
	"xudEr3mvHGfm3g1eIkXJswFijjZ7GlysqoCUzRhkpBplCyRuml3wML4fPLXwFYDjB+kFp5plBzgc1hGa",
	"MafbPCEFnUNAMhPys2Nu+FSLM+AVoZPpBh8VElZMlKr6qAdGnHq7BM6FhqSQMGMRGjtx6DAMxr7jOPDS",
	"yUCp4JoyDplhzgi00GCZVS9MwYTb9Z3uLT6lCr561nfH108H7v5MtHd9644P2m18KbFHMnJ1mqfuwMYl",
	"q8b3A/TDcG7F5on9ubORbH5qbpsZy/Em+pfZP4+GUiETaCDC302KzTnVpYTD9/yh+Ysk5ERTnlGZmV+W",
	"9qcfy1yzEzY3P+X2p9diztITNu9BZgVrVOHCz5b2HzNenB3rdVSveC3EWVmEC0obiut0Q45f9m2yHXNf",
	"wjyqtN1Q8Thde2Vk3y/0utrIHiB7cVdQ8+IZbCQYaGk6w3/WM6QnOpN/mH+KIjdf62IWQ62hY3clo/nA",
	"mRWOiiJnKTVIfOcem6eGCYBVJGj9xgFeqIcfAxALKQqQmtlBaVEkuUhpnihNNY70fyXMRoej/3NQ218O",
	"7OfqIJj8tfnqBD8yIqsVgxJaFHuM8daIPmoLszAMGh8hm7BsD4Umxu0mGlJihgXnsKJcT2qVpcEPqgP8",
	"q5upxreVdiy+WypYL8KJfXEKykrA9sV7igSoJ4hWgmhFgXSei2n1w/2joqgxiM+PisLiA6VHYCiYwZop",
	"rR7g8ml9ksJ5jl9OyPfh2CiKC55vzOVgRQ1zN8zcreVuscq25NZQj3hPEdxOISdmazwajJh/FRSHasVC",
	"5Ebq2Ukr5uW/u3dDMjO/D/r4yyCxELf9xIWKlsOc1XHwl0C5ud+inC7hOHPPhBy1v70Y2ZhR4gRzIVrZ",
	"up923C14rFB4LmlhAXRP7F3KOCpp9iUL6yW56UBGF4U5OMMBrSFUFz5rO89DFBIkhRYM3+YiPfs7VYsr",
	"OPNTP1b3+OE0ZAE0A0kWVC0mo5iUER6verQhR8y8iAo+mQZTTaolXtXydiwto5oGS3PwxsUSi3r8Dpke",
	"yIju8hP+h+bEPDZn27B+O+yEnCIDU/Y4OydDZrR9qyDYmcwLaIUQZGkVfGK07r2gfFFPHt+nQXv0ytoU",
	"3A65ReAOifWVH4NvxToGw7di3TkCYg3qKujDjINipIalGgDfSweZwP136KNS0k0XyTj2ECSbBRrRVeFp",
	"4OGNb2apjbNHUyEvxn1abIWT2uRMqBk1YL7jFpLw1bJIHClGzFb2hdZAtZdvO9NoDx/DWAMLJ5peAxaU",
	"GfUqsNAc6KqxIJYFy+EKSH8RZfpTquDpE3Ly96Pnj5/89uT5V4YkCynmki7JdKNBkftONyNKb3J40F0Z",
	"akdlruOjf/XMGyqb48bGUaKUKSxp0R3KGkCtCGRfI+a9LtaaaMZVVwAOOZynYDi5RTuxtn0D2kumjIS1",
	"nF7JZvQhLKtnyYiDJIOdxLTv8uppNuES5UaWV6HKgpRCRuxreMS0SEWerEAqJiLelLfuDeLe8OJt0f7d",
	"QkvOqSJmbjT9lhwFighl6TUfzvft0KdrXuNmK+e3642szs07ZF+ayPeWREUKkIlec5LBtJw3NKGZFEtC",
	"SYYf4h39PWgUBU7ZEk40XRY/zWZXoyoKHCiisrElKDMTsW8YuV5BKriNhNihnblRh6CnjRhvotP9ADiM",
	"nGx4inbGqzi2/YrrknF0eqgNTwMt1sCYQzZvkOXltdU+dNip7qkIOAYdr/ExGjpeQq7pd0Ke1pbA76Uo",
	"iysX8tpzDl0OdYtxppTMfOt1aMbneTP6Zm5gn8TWeCsLeuGPr1sDQo8U+ZrNFzpQK95KIWZXD2Nslhig",
	"+MAqZbn5pquavRGZYSa6VFcggtWD1RzO0G3I1+hUlJpQwkUGuPmligtnPfEa6ChG/7YO5T29sHrWFAx1",
	"pbQ0qy0Lgt7bzn1Rf5jQ1J7QBFGjenxXldPRvmWns7EAuQSabcgUgBMxdQ4i57rCRVJ0PWsv3jjRMMIv",
	"GnAVUqSgFGSJM0ztBM2/Z68OvQVPCDgCXM1ClCAzKi8N7NlqJ5xnsEkwUEKR+z/8oh7cArxaaJrvQCy+",
	"E0NvpeY7L2AX6mHTbyO49uQh2VEJxN8rRAuUZnPQ0IfCvXDSu39tiDq7eHm0rECiP+5aKd5PcjkCqkC9",
	"Znq/LLRl0RP+59RbI+GZDeOUCy9YxQbLqdLJLrZsXmro4GYFASeMcWIcuEfwek2Vtj5kxjM0fdnrBOex",
	"QpiZoh/gXjXEjPyL10C6Y6fmHuSqVJU6osqiEFJDFlsDh/WWud7AuppLzIKxK51HC1Iq2DVyH5aC8R2y",
	"7EosgqiuXC0uyKK7OHRImHt+E0VlA4gaEdsAOfFvBdgNQ6B6AGGqRrQlHKZalFPFXY1HSouiMNxCJyWv",
	"vutD04l9+0j/XL/bJS6q63s7E6Aw8sq97yA/t5i1wW8LqoiDgyzpmZE90Axind1dmM1hTBTjKSTbKB9V",
	"PPNWeAR2HtKymEuaQZJBTjfdQX+2j4l9vG0A3PFa3RUaEhvFFN/0mpJ90MiWoQWOp2LCI8EnJDVH0KgC",
	"NYG4r3eMnAGOHWNOjo7uVUPhXNEt8uPhsu1WR0bE23AltNlxRw8IsuPoQwDuwUM19MVRgR8nte7ZnuKf",
	"oNwElRyx/yQbUH1LqMffawE9NlQXIB6clxZ7b3HgKNvsZWM7+Ejfke0x6L6lUrOUFajr/ACbK1f92hNE",
	"3YwkA01ZDhkJHlg1sAi/Jzb+pj3mxVTBQba3Lvgd41tkOTlTKPI0gT+DDercb21gZ2DquApdNjKquZ8o",
	"JwioDxczInj4CqxpqvONEdT0AjbkHCQQVU6XTGsbsN1UdbUoknCAqF9jy4zOiWeDIv0ODPEqnuBQwfK6",
	"WzEeWZ1gO3ynLcWggQ6nCxRC5AMsZB1kRCEYFO9BCmF2nbnYcR897CmpAaRj2ujBra7/e6qBZlwB+aco",
	"SUo5qlylhkqmERIFBRQgzQxGBKvmdJEdNYYghyVYTRKfPHzYXvjDh27PmSIzOPcJF+bFNjoePkQ7zluh",
	"dONwXYE91By348j1gQ4fc/E5LaTNU3ZHFriRh+zk29bglZfInCmlHOGa5V+aAbRO5nrI2kMaGRZVgeMO",
	"8uUEQ8fWjft+wpZlTvVVeK1gRfNErEBKlsFOTu4mZoK/WtH8p+ozTCaB1NBoCkmKKRADx4JT843Nmtil",
	"G9bRZGy5hIxRDfmGFBJSsFH+RuRTFYwTYuP/0gXlc5T0pSjnLgDNjoOculTWpiJL3hkiKg3pNU/QOh3j",
	"3C7o2Cd6GDkIqNHF2qZtq3mc02o+l9sz5EoNkNc29Ue9W+NRr6pqkLqqVVWLnGa2ygAu3hDUAvzUEw/0",
	"gSDqjNDSxVe4LeYUmM29Hlt7PXQMyu7EQUhc/bAvKs7oyfnmCqQVOxCRUEhQeLeE9iVln4pZmJnmLh+1",
	"URqWXRO8/fS3nuP3rlfREzxnHJKl4LCJJmMzDj/iw+hxwvut52OUNPq+bSsPDfhbYDXnGUKNl8Uv7nb7",
	"hLZdTeo7Ia/Kl2kHHCyXD3Ad7vSTuykv6uCkeR7xCbq8lTYDUOMqT55JQpUSKUNh6zhTY3vQnBvRJbk0",
	"0f+2isa9grPXHrfl/ApTItG4C3lBKElzhqZfwZWWZarfc4rGpWCpkaglr0X3mxtf+Ffi9s2I+dEN9Z5T",
	"jFirTE7RSIsZROwr3wF4q6Mq53NQuqWkzADec/cW46TkTONcS3NcEnteCpAYOjSxby7phswMTWhB/gAp",
	"yLTUTbEd07KUZnnuPHFmGiJm7znVJAeqNPmR8dM1Due99f7IctDnQp5VWIjf7nPgoJhK4tFV39unGPjq",
	"lr9wQbCYRm8fW9+NGb/O3dqg7alODf9/7//X4a9Hyf/S5I9Hydf/cfDh47NPDx52fnzy6Ztv/r/mT08/",
	"ffPgv/5vbKc87LGkIQf58Uun0h6/RL2ldt50YL8xw/2S8SRKZGEYRou2yH1MkHUE9KBp1dILeM/1mhtC",
	"WtGcZYa3XIQc2jdM5yza09GimsZGtKxYfq17agOX4DIkwmRarPHCUlQ3IDGenofeRJdxh+dlVnK7lV76",
	"ttknPjBMzMZVCqatznJIMD9vQX1Uo/vzyfOvRuM6r656PhqP3NMPEUpm2TqWPZnBOqbkuQOCB+OeIgXd",
	"KNBx7oGwR2PgbFBGOOwSllOQasGKm+cUSrNpnMP5mH5nLFrzY26D7c35Qd/kxrk8xOzm4dYSIINCL2JV",
	"GxqCGr5V7yZAK16kkGIFfEzYBCZtY01m9EUXjZcDnWH1ANQ+xRBtqDoHltA8VQRYDxcyyCISox8UeRy3",
	"/jQeuctfXbk65AaOwdWes3JE+r+1IPe+f3VKDhzDVPdsIq8dOki9jKjSLruoEUlkuJmtVWOFvPf8PX8J",
	"M8aZeX74nmdU04MpVSxVB6UC+S3NKU9hMhfk0CcsvaSavucdSau3nFSQKkaKcpqzlJyFCklNnrZESHeE",
	"9+9/pflcvH//oRNU0VUf3FRR/mInSIwgLEqduAIHiYRzKmNOK1UluOPItoLJtlmtkC1Ka9n0BRTc+HGe",
	"R4tCtRNdu8svitwsPyBD5dI4zZYRpYX0sogRUCw0uL9vhLsYJD33dpVSgSK/L2nxK+P6A0nel48ePQXS",
	"yPz83V35hiY3BQy2rvQm4raNKrhwq1bCWkuaFHQe8429f/+rBlrg7qO8vEQbR54T/KyRceoj6nGoegEe",
	"H/0bYOHYO3sOF3div/LFrOJLwEe4hfiOETdqj/1F9yvIQb3wdrXyWDu7VOpFYs52dFXKkLjfmarGzdwI",
	"WT6MQrE5aquuHNAUSLqA9MzVaYFloTfjxuc+UscJmp51MGUr+NgMMqwhgZ6FKZCyyKgTxSnftJP5FWjt",
	"44HfwRlsTkVdgmKf7P1mMrnqO6hIqYF0aYg1PLZujPbmu3AwVOyLwudkY3KeJ4vDii78N/0H2Yq8V3CI",
	"Y0TRSHbuQwSVEURY4u9BwQUWasa7FOnHlme0jKm9+SLVfDzvJ+6VWnlykVvhatDqbp8vAcuBiXNFptTI",
	"7cJVsrIJ0wEXKxWdQ4+EHDp3BqYlNxxCOMiuey9604lZ+0Lr3DdRkO3LiVlzlFLAPDGkgspMK17Pz2T9",
	"h84zgQUqHcKmOYpJVWCjZTpUNpxstuJeH2hxAgbJa4HDg9HESCjZLKjyRbawFpk/y4NkgGssALCt7Mtx",
	"EGoWFByrirp4nts+px3t0hV/8RVffJmXULUcULLFSPgY3R7bDsFRAMogh7lduH3ZE0pdjKDeIAPHT7NZ",
	"zjiQJBa1FphBg2vGzQFGPn5IiLXAk8EjxMg4ABv94jgweSPCs8nn+wDJXTEF6sdGj3rwN8TzvmwctxF5",
	"RGFYOOvxaqWeA1AX6ljdX62AWxyGMD4mhs2taG7YnNP46kE61UdQbG3VGnGRGQ/6xNktDhB7sey1JnsV",
	"XWQ1oczkgY4LdFsgnop1YhM/oxLvdD019B4Nbcc01NjBtHVe7ikyFWuM9sGrxYZS74ClHw4PRqDhr5lC",
	"esXv+m5zC8y2abdLUzEqVEgyzpxXkUufODFk6h4Jpo9c7gelWy4EQMvYUddBdsrvTiW1KZ50L/P6VhvX",
	"Jcl81lDs+Pcdoegu9eCva4Wpiq28bUssUTtFM2ilWWcmECFjRG/YRNdJ03UFKcgBlYKkIUQlZzHPqdFt",
	"AG+cE/9ZYLzAajaUbx4EkVAS5kxpqI3oPk7iNsyTFIvoCTHrX50u5Mys750Q1TVl3Yj4YWOZN74CDCWe",
	"Mal0gh6I6BLMS98pVKq/M6/GZaVmrJUtOcuyOG/Aac9gk2QsL+P06ub94aWZ9k3FElU5RX7LuA1YmWKJ",
	"5GgE5papbZDu1gW/tgt+Ta9svcNOg3nVTCwNuTTn+ELORYvzbmMHEQKMEUd313pRuoVBBpmzXe4YyE2B",
	"j3+yzfraOUyZH3tn1I7P3+27o+xI0bUEBoOtq2DoJjJiCdNBheFuSmvPGaBFwbJ1yxZqR+3VmOleBg9f",
	"l62FBdxdN9gODAR2z1hWjQTVLMFXC/i2VnSjAs5kEGZOm4XyQoYQTsWU73TQRVSVdbcLV6dA8x9g84t5",
	"F5cz+jQeXc50GsO1G3EHrt9W2xvFM7rmrSmt4QnZE+W0KKRY0TxxBuY+0pRi5UgTX/f26BtmdXEz5umr",
	"o9dvHfifxqM0ByqTSlToXRW+V3wxq7LV/noOiK+kbnQ+L7NbUTLY/KpEWWiUPl+AK0kdSKOd2pm1wyE4",
	"is5IPYtHCO00OTvfiF3iFh8JFJWLpDbfWQ9J0ytCV5Tl3m7moe2J5sHFDSvAGuUK4QCX9q4ETrLkStlN",
	"53THT0dNXTt4UjjXlqLZS1sXXhHB2y50jHneFM7rvqRY+dJaRbrMiZdLtCQkKmdp3MbKp8oQB7e+M/My",
	"wZd7hFEzYsl6XLG8ZMFY5rUhtW1aQAZzRJGpouV1atxNhev5U3L27xIIy4Br80jiqWwdVCyT4qzt3evU",
	"yA7dudzA1kJfD38ZGSOs+tq+8RCI7QJG6KnrgPuyUpn9QiuLlPkhcEns4fAPZ+xciVuc9Y4+HDXb4MVF",
	"0+MWtujp8j9DGLZW++7+QF55deVne+aI9vthKplJ8QfE9TxUjyMJS77OLcMolz8gTHQIu1w0WExl3anb",
	"FtWz9253n3QTWqGaQQo9VI87H7jlsOCmt1BTbrfaJpI0Yt3iBBNGlR7Y8WuCcTB3InFzej6lsWqkRsgw",
	"MB3VDuCGLV0L4j/2uFdVtoWdnQS+5OpdZpPRC5B1LmG3sM0FBQY77WBRoZYMkGpDmWBs/X+5EpFhSn5O",
	"ue3iYr6zR8l9rcAav8xX50JiKQkVN/tnkLIlzeOSQ5Z2TbwZmzPboKRUEHTAcAPZ5k+WilwXkSqHyKHm",
	"eEYejYM2PG43MrZiik1zwDce2zemVCEnrwxR1SdmecD1QuHrTwa8vih5JiHTC2URqwSphDpUbyrn1RT0",
	"OQAnj/C9x1+T++i2U2wFDwwW3f08Onz8NRpd7R+PYheAazCzjZtkyE7+4dhJnI7Rb2nHMIzbjTqJZt3b",
	"DnP9jGvLabKfDjlL+KbjdbvP0pJyOod4pMhyB0z2W9xNNKS18MIz2x5JaSk2hOn4/KCp4U890eeG/Vkw",
	"SCqWS6aXzrmjxNLQU93ewk7qh7O9llxlYg+Xf4g+0sK7iFpK5M0aTe39Fls1erLf0CU00Tom1NYPyVkd",
	"veDrpZNjX54ISzVXFZotbsxcZuko5mAww4wUknGNikWpZ8nfSLqgkqaG/U36wE2mXz2LlKdulknl+wF+",
	"43iXoECu4qiXPWTvZQj3LbnPBU+WhqNkD+psj+BU9jpz4267Pt/h9qGHCmVmlKSX3MoGudGAU1+K8PiW",
	"AS9JitV69qLHvVd245RZyjh50NLs0M/vXjspYylkrOZgfdydxCFBSwYrjN2Lb5IZ85J7IfNBu3AZ6G/X",
	"8+BFzkAs82c5pgh8KyLaqS+ZXlnSXax6xDrQd0zNA0MGUzfUmDTLU988H72aKKi4p8sbtruOLfPE4wH/",
	"aCPilskFN7D25duV9BBKUJ4/SjJZ9TzwsVPyrVgPJZzWKfTE8xmgKIqSkuXZL3XmZ6v7gaQ8XUR9ZlPz",
	"4W91n7ZqcfYOjJYPXFDOIY8OZ+XN37xcGpGc/yWGzrNkfOC77YYMdrmtxdWAN8H0QPkJDXqZzs0EIVab",
	"SXVV0HY+FxnBeepadfVx7TbyCMqt/7sEpWMJSvjABo6hbdSwA1vtmwDPUCOdkO9tK+YFkEYhItQEfaWI",
	"ZtZ0WeSCZmOsYHH66ug1sbPab2y3IVttfI6KUHMVLZtYUIZzWAiybxwUT48YPs72eG2zaqWTqjh4LAHV",
	"vFGXL2ctPwGqSCF2JuRl0FTV5qqaIQgWMJFLo9VVo1n5CGnC/Edrmi5Q7Wuw1n6SH14m31OlClpTVi2m",
	"qtqUeO4M3K5Svi2UPybC6ObnTNkOvLCCZs5rlQDuzA4+B7a5PFlybillssctV1Wi3BftHjh7RXpXQhSy",
	"FuL3FPptl4l9uwac4FfRUlntFgSdnpQ2g7JqHeQ7q6eUC85SLFQVu6Jdq94hfrYBNb3ahlx/xN0JjRyu",
	"aOODKhTPYbG3FYJnhA5xXUN/8NRsqqUO+6fGnrALqskctHKcDbKx79/hbI2MK3C1RrGxc8AnhWz4LpFD",
	"Rt3hSeU22ZOMMPWmR3n8zjx740wLGJN+xjgqEQ5tTvCz1kDsJKqN5sE0mQtQbj3N/GP1q/lmgqm4Gaw/",
	"THznURzDuv7Msq2fuzvUkfd6Oy+zefeFedcVSKp+bkQ520mPisJN2t/dJSoP6DXvRXDEe5l491GA3Gr8",
	"cLQt5LY1XAXvU0NosEJnNxR4D3cIo+p00uqiZYRWS1H4BrFhYtEqCYxHwHjNONR9cSMXRBq9EnBj8Lz2",
	"fKdSSbUVAQfxtFOgOXq4YwxNaefeuOxQ7fJQBiW4Rj9H/zbWTVp6GEf1Qi24Ub6p2vEa6g6EiRfYB9wh",
	"sttyBaUqJ0RlmLXQasISYxyGcfs2T80LoHsMujKR/Rxrpe17E/Ulok7LbA46oVkWK/36LT4l+JRkJUoO",
	"sIa0rEqEFgVJse5KsxBNl9rcRKngqlxumcu/cMnpgq5GEWoIOyv5HcZEl+kG/43Vx+zfGRfosXeooY/q",
	"yParvtQNnYxJvYamE8XmyXBM4J1yeXTUU1+M0Ovvr5TSczFvAnLD5Se2cblwj2L87ZW5OMLqDJ2ir/Zq",
	"qYonYGCf8L0oUW2s0n6bXAmvsk4VWHQoVb3uthsg+rvWjfHy6wnvDYpuUHu/Wg9lX5Bv2huTTrXLjtOU",
	"bGVBvRlHNkLI5hYhFHHrbF9UkA0KMo87Xw+TDDtyto4XPgwQ6sPNugD94GNZSUGZc7/XzKKLWRf13s1D",
	"GBIPW29wexEulrzXYvfDqi/u2xdjw+ftrlZn4FLmCwkrJkrv2PaRT14ltL82ekRVkffR9XcNrzjV7ZpD",
	"e423p667gF2m08l/+MXGyRHgWm4+A1NuZ9M7/bK60q41T9WvkKow9aBC1Y1bcUihwlhNPCcbNjp27eg3",
	"1iGrl0PEgW7/sPHoONvrwozVVRzZUWLHLt4NrL/sVF1qCo9YIRSr68PH2oQNDDE8xU5fQdms7lg+vmcF",
	"qcamAHXcggTYp4iWmSxoPHpXfqpHna4iMV3VqW2lprqdAHbc8Z1ssCCj0VZRnwwvrHRURachn8ZqyHPg",
	"rvdnM89jcLT5bAapZqsd2Xf/WAAPMrvG3i5je3gHyXisil7G4i37Wx1rgLYlx22FJyiieGlw+nJvzmBz",
	"T5EGNUTLuo/9VXuRuh2IAeQOiSERoWLRH9aQ7BzyTFWUgVjw0Vb2c6groPV2hApySS84lydJc3HU+aVb",
	"poy3pBk0l/l0r6xrDMTtS9DrdrTo1z9eYgMRVXVr9HU/Qi2dHHerI567uiGYK1n5TnwFEVD+N58YbWfJ",
	"2RmEPavQU3VOZebfiJpevFUn2XIfdbLqfDeGNtCzamZWx8Z286gi9bYwAjrNhREjkr4w8mY4ahXLcU/Z",
	"oBtb/h0DbQ1cM5Cutx/Kv7lQkGjhY2m3wbENFTay6EJIUL01Li1wvZVn3tWldbDWL8VKM9QFFIULJBKW",
	"1EAngwI4/XNuQ/YL+9wnDvlarzstTBW97m464KOimeogMaT6GXG35e6EpIsYmxjntn+0ilXD4SCb3pBC",
	"iqxM7QUdHozKIDe41tQWVhK106TdVbZ0hCCr8ww2B1YJ8t0a/A6GQFvJyYIeVFFobfKVmt9UDO75lYB3",
	"m5ar8agQIk96nB3H3RI+bYo/Y+kZZMTcFD56sKeDDrmPNvbKm32+2PiSNUUBHLIHE0KOuI3X9o7tZg3p",
	"1uT8nt42/xpnzUpbVcsZ1SbveTzwFetdyUtyMz/Mdh6mwLC6S05lB9lRIGbdUz5I0vNIP6nJUK2862pu",
	"9/ipicpCEZNJ6vY1O+JkqhCZuvNHHSbTlQ7yXJwnSEVJVf8rpnOY95pM0lc8rT8z2J5CEG9DlbtAN2RB",
	"M5IKKSENv4inOFiglkJCkgsMv4l5BmfayENLjGvmJBdzIgqj5toyet6HEm1LE8x1VS14bLquhSCxDp+e",
	"ggigXHquA9e+3IV3Sxec/TvsnC4idhvcML9be7fRcQS3d/eLAMwBhL7bZnUU6xLUXFe7X1Vf9zgtliyN",
	"o/vLilbpjTGJUW8MFa4ArU2Aw9fwgIc8pXJO4unpohk4neYxjw1xx885aZDOzX/xBmuPS2bgmEsPP4u1",
	"u6XpWWJFogHTI5w2J0OX0tasNSPULbDE3CZvoWepDd8gPvNp+1bE2lFFSK1av+uW5RM9e8g26oXf7vS2",
	"LQqnQ13fVRnsgRwqAKDfGd6AYZBLfF8wZtjyM6ERJB9Xisi40ZGZtdiwL1Fo2U1KrSFiAcSMXUpwiYe2",
	"N2GrGVJB9cILJub1rrnAqJ6gMCvQdnShyhq3vJHNNUZsS3yiSHJYQSNGwGVDlmkKSrEVhE0V7cckAyjQ",
	"5NxWhGLO7/DCaUnHbu1J4D4dgt2ouGwRa3eK7JCFo5L7mif2mKihR8lAtGJZSRv4U5doL9fXWS5yI3pY",
	"PwzjFHszifjitrGIneEqSPPRc8nj0SphMm5l58LZssoebomwPtmqoOe8Xy/sEmUt0A1vzBgg9tUaUrwc",
	"m+EYl8cJwcGIaiXa90pystrhi9oXeqlsG5F12lRGRUkFvs1wWBPHS+Pu28jVaC2hTEUGYKrmDRjcCXXw",
	"YPDakm5IxmYzkNbXozTlGZVZ+DrjJAWpKTOK70ZdXOsx0MoSxjsVH8OpcVDPrGIqEJotLSD5xmmUfUrJ",
	"AGUCHXsRRcJe21r0ddDs7Eo824SujfKFYXc9RODy5FH1sodVcJR7yZKewZ7zKPYHbJ8Gq9c407AWOOuQ",
	"KT5tpfWfEHV44H/mTG+ldivvteMgraPKEqOnQT6vveV2c6LuPdbXKNqWgwBfwreyYqBY6jlhPfDlQ1gz",
	"yGELMPi4BgfXer0AxQJ7T22XqzC4t900wp8Ea1O0uwE9RTDdzZLgjaO2eOlBBe2tUmdl7QpLnavKAjN2",
	"Qc97yVJtC1G6g2VHL7AejtFUX8QMzy6SrL22MdSjuqzG7SCk5gVdHQps2JqWEkXMc7rZXUuvvqTj8dt2",
	"ZK+B+rCUCmq31fb4KdsDJFqqbh/hLcIRYm0wukXCrn4xNjGhdp1e33KccyS+gLCp/nZ6q9UcTyoRWqN8",
	"Ezs63vx/gQX2yW4DQmuvbKuq03IdGxS9wC5WO3YQaN0wywg2g2bP2yNfwtLSdc66tNG66Cn32mKbX/xY",
	"a5HD2k77D3aAFwZEBY2nvW/KgXPLyd8/VkgJlvKhjxIay98VY+UWWKvdwRY5SVZrsIX+bcJgc1+CADr1",
	"oopL6+uR3g5fwzrSRnTK80jYmxWubVfigHDMPSlXNL/50DUsMH6E+IDsXb+zO4x9CpFsUakulnn5mg6a",
	"O4hzurqp+VsMtfsHmD2KXgtuKKfPd5g/qkY0t46ZmW9RugJOznFMa019/BWZuso0hYSUqbad4Nx3D6tC",
	"fbCZpst2XesdsUW71vmL0Jcg45k3u5E3dSci9D3MeQ1hfURvman0nNwolceor0MWEfzFeFRYInbHdXHW",
	"COCvpbrgRhMSrjiQP9BE9gzk7xa/Hbo8G6xuLp1SQXede2lR2y7qem1Ds1C6yN3WrmZI8ki8C5X5HLNX",
	"LEKwhRtBUMnvj38nEmbYo1mQhw9xgocPx+7V3580H5vj/PBhVMm7sbwViyM3hps3RjG/9FUysNn6PUUz",
	"WvtRsjzbRRiNEih1l3Ms8vGbK7R0K33Wf7OxtN2j6nrdXiIBwCImstbG5MFUQXGTAXVN3GeRKiYYp5KW",
	"kukN1n/2Gi/7LZph830Vre2i/SsDp7v7tDiDqoJ4HdtdKn+7fi9ojveRtbtycwuJfEJeremyyMEdlG/u",
	"Tf8Tnv7tWfbo6eP/nP7t0fNHKTx7/vWjR/TrZ/Tx108fw5O/PX/2CB7Pvvp6+iR78uzJ9NmTZ189/zp9",
	"+uzx9NlXX//nPcOHDMgW0JGvNjj6n+Qon4vk6O1xcmqArXFCC/YDbGzfY0PGvqMyTfEkwpKyfHTof/p/",
	"/AmbpGJZD+9/HbliZqOF1oU6PDg4Pz+fhJ8czDGYM9GiTBcHfp5Oy+Wjt8eV19i6RHBHbR0Q7+rypHCE",
	"z969OjklR2+PJzXBjA5HjyaPJo/N+KIATgs2Ohw9xZ/w9Cxw3w8csY0OP34ajw4WQHPMfTB/LEFLlvpH",
	"Emi2cf9X53Q+BzlxbabNT6snB16sOPjoglo/mRmiBmFbAieoe9LtvuwC5NFyY93djW6GyjXXG1c9Lp3n",
	"jWdYmcTGiRo2VyHuOKubOR3XTMuXtLY9Pg5/jSQa+ZgCX2m50QHbxR8wRf775Kc3REji1Ju3ND2r4inI",
	"8cyWJ5VixbDgRRZUSTFfTjz9/rsEuanpy3G+sH+Fb1noAjOWal40c+5rqSpmJIl1usaZDVkEhF2FoNeM",
	"C30MASQ1Gzas9VHy9YePz//2aTQAEMyHUIDVTX+nef47OWfYMBmdbb4+uKv/Oo6050NpelyHNOMH9U6O",
	"0YBTPQ07MFfvNEvV/M4Fh9/7tsEBFt0HmufmRcEhtgcfsP4mEgueuSePHl1Z6/aqOpMNWahG8SRxgYG6",
	"DMk+qlrAn0ta2LPoO7hjIJ8zrNqXsGH9sytcaDO3+tLLbQ/XWfS3NMOuuKC0XcrjL3YpxxxTkswFQewF",
	"+Gk8ev4F780xNzyH5gTfDIpbdy+an/kZF+fcv2mEn3K5pHKDok3QurtV+Y3OFXozkEXas91o1jv68Kn3",
	"1jsIe5EefGxktWSXuhM7bZiPX+64Ju+pPs7ZbQ3TanVqnledLNE15Pq5Ym9N9WBCvg+/Ru6NlVZtHdNS",
	"csh8Uoq/9arS8b4gfQ3bPRUWoY1e2oG5+O7+vu37+6hp7Gi0H4kB0zgFW2HquMUve4F244aC7JU96hYG",
	"TdOajfYv0LrtWjtqt3RNO9OHmCq4k1Hf4a4Hd31iUgBvJTE1m8VeP2v2RRCqm6RxZVwj4/7Chb4faW7o",
	"JFhuq9ig7clzJwz+ZYTBKll6bqUz14bucuIhNqQ++Oj7LF2BSOj6TA0QBkO1Ovg2CFu832InDya2aVL4",
	"zsV4hsuO3inmYferOwHvMxDwup3lYmDU/cJuT6hDGBZ167mdXe5807hQGvEt/Qa3yPtCpbi/MLJ6xTYD",
	"6W6B7QLssyOMOWZ9bWz1TymEOaTdiV9/afGrqllyKQGs0RvSVcEJ3FiXst61rXNMV5JYs25NwNkwv8gw",
	"FHeEx3VwsGExNrrWxdWqsdcM0Z1qlUa7WeOO3tgVsb6HUEH9dnP8cpd09QXZeQa3n4jcAvG9uW5eGnU7",
	"vLsZt8Mw3vTs0bObgyDchTdCk+/wFr9mDnmtLC1OVvuysG0c6WBqm29t40q8xZaQUdRNtQIeVRXsGgfP",
	"zds2SuM+Jmo1C5Y+mBDf6ktVjUtdlvNcGEblEzConNuPDK8zyCD3/J+HOP69CfkOE1a0GmOwmXZdLck9",
	"xvXh4ydPn7lXJD23sVzt96ZfPTs8+uYb91rd2M3qOZ3XlZaHC8hz4T5wd0R3XPPg8H/++b+TyeTeTrYq",
	"1t9u3tgOB58Lbx3HigtUBNC3W1/4JsW0dd+rbBfqbsR9/61YR28Bsb67hW7tFjLY/1PcPtMmGTlFtLJk",
	"NmogXuFtZI/JPvfR2DcxM3ynukwm5I1w5WjLnEoiZAbSdXqel1RSrgGyiadUrMCgbPnNNGeYYykJ9q6V",
	"iWIZ1NVhqvzvQsIKY+SreipNCHYzeoyk/WyZ/I90HZSonFbXtBZuyWj2XNK1756N/WGFxJ+++YY8Gtfa",
	"S56bAZIKMTHmuqTr0Q1a/SpiGxR/3mw+uTNAF8ceYkGqpZ+qoETY6e6vzbm/WMndkrvb2CvinHs7fmrH",
	"TmhHcEVft1oQrGBne2tjs+dNXZrGSHlehIqzODPDUOPAZ+wj2GmajiqhbfTeHeI7I8ClWEmboPZkG5h1",
	"qg4+ol4e8ozOucWsub+WuzTwHUmx9M4jQWag04VL2G2hPsKefOvLft60ZJwtDZSPxtcu1eAudss2hT03",
	"MmrT5IeUdQ1yKdGBBzJCxD/5LlTmMZvZamu+UOSpa1WArinm2+pXHfXtTMTVStKiyus1u7gXlC/qybsC",
	"GaLlKvyfdwjeD8Ed5vjKt1ZHjLlF/Bki/r0qmZA3ok4bd109/4yux+u82a97QW8EB+tjN5KvpcU7d2ol",
	"dhjGYZHi64VY/aXqr3ZhEeQAu+/vkkP+blv0b5VFhtzeZrIv8gr/u8PSllvGrG2ysxhCPdoQ5mxetGUc",
	"mx2/blGLuRV++hmqNrfBsW6GxeAh9XzGiQX8apkOluCxxHxQNXvq40Dx/nmDuZEWVRhatOXdFHLB5+rz",
	"ZEVbOxlG8RKhkqqzYLx94F/v7L7A6j5G5bURkK7ek2I8BaLEEmz/XqbIkinlgiWfPfrbzUGo2dJ3TOFh",
	"7uotc5fnj57e3PQnIFcsBXIKy0JIKlm+IT9zuqIsxxL/l+B22Byxqr/mrcHRfpjobWrWBUvDIkYXZ4KN",
	"0LWPes2yT7uZYVB3cE8+yHjAB8P6vLQogMqLM8Ddrqt2G5Djl2F0cKNnX1VRKwKKQdGeAfL/MRpod8K0",
	"dzFzl1/JLaC++pdjEy50V8zGVXCMkQLE7JC85w+JWtDnj5/89uT5V/7PJ8+/6rGcmXlc0Z6u7aweyDy2",
	"wwwxoH3R5sCrldor/B7e9G7vt4njEcvW0a5edZ/eTgcIJ5bdU6Sgm97Wf8WOPsPhsHXP4Zsvdqg0my6i",
	"+pVXf6p2N8f820oLthX5XHveu/7CPckTAZ8xhFY3Gq6wvr3n8BZpskWWVXPXm1ZO6yQDe9F55MnWnXOr",
	"gq6+LSU1QR0VuBdsmmi5PZkSO8+NA3d3IYUWqcht7EpZFELq6nSrySBxD/rcdg1pr49w9xLmUqrTRVkc",
	"fMT/YIWvT3XiAdY+Vgd6zQ+w/cHBx60hAghipPW9lUuj/YW6avKAzvu7QgBaJ2bcPkS2lQPGEkTks+uR",
	"zv7SQs1W/b+14Zc3aUdG7BzgKq8uKNBf0W5Q+Nunytl2FBESvnPBfF4Lqo0iM8YzQoNtbOluQtaM4JoN",
	"I9e96Nuws9y83+n5F3zO3ghNjpeF7R4H2eWid0ibw/nbY+t1u59g4K7+bohP984Pb3wfmFhZ13de8Hs4",
	"5IJUbPDTUYm50eauvh7b991N/nnf5C98yeEGGd7dy1/OvSx9OOXdFfz5X8FPv9jVXKMjZuCV7G+iC1/D",
	"tSa+54Uc6V6OJoOWK3ybnwZV7/Yq1XdC+vYWd7f4F+pksDs5OGlpiIVmVyqTm/IqQmc/K+iH2RnyPGJp",
	"6DuoY9vrRy+AYdEZkTKsH36cqbE9xM444U7xneDzWQs+wV7fyT13pocvzPTQI+U4rb/ZsbxP0NhXAFot",
	"RQY+6kTMZq7IW5/00+w9Y8hTabosiP0yKuWgN/aULeHEvPmTneJKr9ga7JZY1ALPIEtBKnimBnhF3agX",
	"vYfQjdsPwI17QKsd8LC49O/JhUn2XVBDpkMJpI18hT2DfLE7h4wMVmTpOjNflmwPPtp/0ZxWCBVZzYkn",
	"4M7G3HfbYqv32XEbAJK3KIS6ZsTuKzEjj2wRv5Jjpk7dHJDyjGi5MYKqr1kigeYkbUToV3B0T85J78nZ",
	"qQp0VtezprguIOoTepXhrK3sqB9u/AC8oNyRfBdBWhBKOMypZivwceuTu4z6C99mLp99CwMcE5pl9jTW",
	"mwArkBuiyqkysg5vBlreU83zsgfDgHUBkpkrmua1A96qCQc2XX5bQOWJfeOSl1aLF9kkfdmMAvI3q0vh",
	"FzPyI0ulOMrnQvm4LrVRGpad1nvu0996iq56Q0I3BkzwnHFIloLHGsL9hE9/xIexr7HkQN/Hp+Zh37et",
	"+7YJfwus5jxD7uTL4vczOf2XytVorVZCIaTRbqe2Sa2l/z2Pkj80G552T9KGp4FTyz0MBgrbxzV+PvjY",
	"+NMVy3BvqkWpM3EefIuavQ36GZInHzSqvoAlrdXwWV2vLe06fUgBHmInpnoaaf0VtCPv7f71F80PcS6X",
	"kEhci/4VSNVSz+6SRP5USSKD930vHmtbXe7iaKW6WonkjcjAjtvsNBurz8xFBq4jZ1cQqYId44H1/laq",
	"32uFOqe0nC80KQuiRSyouv4woallsolVb+ITBhXRrBKE0y3oCgjNsc8pmQJwIqZm0fX9iIukCmvS+chs",
	"F9IZFYUCuAopUlAKssTXo94FWtXnFOO49RY8IeAIcDULUYLMqLw0sGernXBWfcIVuf/DL0ZhvnF4rSi4",
	"HbG2ElYEvVW1DSftdaEeNv02gmtPHpIdlUC8aICJJGJZ5OBSSSIo3AsnvfvXhqizi5dHC+ZasGumeD/J",
	"5QioAvWa6f2y0JZFYu7vLogv7NNTtkRJjFMuvF0xNlhOlU52sWXzUrgWZVYQcMIYJ8aBexTO11Tpdy6r",
	"MMMKNPY6wXmsjG2m6Ad41deP3oz8S9WNvjN2au5DrkpVtax3mQKQxdbAYb1lrjewrubCtE4/dpWKYC18",
	"u0buw1IwvkNWUJSbUB14881wkcWh/ZE6A0UXlQ0gakRsA+TEvxVgN3Tj9wDCVI1oSzhYZDSknKkQOVBu",
	"M7pEURhuoZOSV9/1oenEvn2kf67f7RIX1fW9nQlQYZqIg/zcYlahgXZBFXFwkCU9c5kkc9dkqQuzOYwJ",
	"ZoAn2ygfTbbmrfAI7DykZTGXNIMkg5xGTCk/28fEPt42AO64J89kJTQkU5gJCfFNrylZ9pqIqqEFjqdi",
	"wiPBJyQ1R9AozzWBuK93jJwBjh1jTo6O7lVD4VzRLfLj4bLtVveYpcwYZscdPSDIjqMPAbgHD9XQF0cF",
	"fpzU5oP2FP8E5Sao5Ij9J9mA6ltCPf5eC2ib88ILrHFTtNh7iwNH2WYvG9vBR/qObMyA+EUa+9uxS9dY",
	"/aVpQA0UwMlFlNuDc8p0MhPSCtIJnWmQOwPi/0GZd4c714AWrjYBwRHcvenGQSYftrpwXMSCQNx1YUik",
	"638zU30n5KASm81CMpRpUnLN8qDMeKUqf34GwzsjwJ0R4M4IcGcEuDMC3BkB7owAd0aAOyPAnRHgzghw",
	"ZwT46xoBbqtobuIlDl9KjAuetKMSyV1U4p+qyGR1V3mjBJoxzinTrmumz/d3Ty5XY1cDzREHLIf+OGkb",
	"vnn66ug1UaKUKZDUQMg4KXJqdANY66qHW7M7qO9bbBtB2sajVMHTJ+Tk70e+Ft7C1Wxrvnv/yPX/VnqT",
	"wwPXJQF4ZkVR3y4BuEG665ZA/Z3ge725zncsxxhzRV7h2y9hBbkoQNoyW0TLMmLyOQWav3C42WHx+YeZ",
	"3AWt/m5G+33cMDQ5tC1p4eV8v1aqCLW5i+RlkM34+4zmCn7vS2i04y1pEWu3Vt181haE3ORbkW1aJ8Ts",
	"2gFuYPNs1BXxGKdyE6m31E0maJOGFoZfOcLqGrM+XXndxi7RdslsF4XFxHUJKnqOt1F5tGBhtWGdoWzK",
	"66xFJ6NYtma7St+oAnBICOwpJhzYPSHv7He3WxUeIXJHrGbmn03kYPPNimngu0aLcKznS43K94iPnl48",
	"+2ND2FmZAmFaEV/6cff1Mh6tEzPSHHjiGFAyFdkmabCvUeMWypiiSsFyuvsmCvmnazDsLh/zZPs9dTvX",
	"yMtgcdt4ckg068Qx4B7uvNEwmDdX2MIRHXsOMH7dLLqPjYYgEMefYlalFu/bl+nV02zuGN8d4wtOY0si",
	"YNyVym0zkck1Mj65kSXv53mv1pCWBrjwJN9H8zz65GCtG47NDKblfI6NkjtOOrM0wPGY4LfECu1yh3LB",
	"/SjIDl41z7xsund7uC53CTKw7/sahw9wOyjfoDdjWVC+8T5fSBRblrnFoe0xd7WM1laz7UYCoD/WGf/6",
	"zNpvvc0vMN66q7b5u0ULOaeK2P2FjJQ8c7lDnZrXaz68Yogd+nTNaza9tTqIXW9kdW7eIVeE3+Vm0rYi",
	"BchEr7k9UM1O6ra2tj25k7sGsX+Na8OmfEMPg+3Wia4ZwhXdHjLga3h9BN1A6mS4Ro8QtFr0p46ErUHs",
	"m1caPdIZvhlEUptUnJMU8oJQ370/FVxpWab6PafopAkWNukGmHhrdD9/e+FfifsJI248N9R7TrG5e+W6",
	"ifK5GUT8FN8BeDaqyvkclOGVIZHMAN5z9xbjpORG0xIzsmSpFIlNRDVnyMgnE/vmkm7IDOt/CPIHSEGm",
	"5mYPdt0ajJVmee4iWsw0RMzec6pJDlRp8iMzXNYM54sPVKFcoM+FPKuwEO8UMQcOiqkkbnz53j7FZgxu",
	"+d7IhwZL+7guon6zXRg87Czrhfz4pYGbYu3inCldB0F0YL8xB/iS8SRKZKcLIC4mrE1b5D5WTHME9KDp",
	"HdILeM/NDacFQa5O9cXIoe3m6ZxFezpaVNPYiJY3yK91kIp3JVyGRJjMnWvlT5SaGdCBd1/ixttq9K29",
	"39ON0rhygWfmac+FbJ+65l09LzkloWEIa5WDcW+cNkD+8zZ+/3A9+qJH45VpjN0Bu+yq2Z4J8eY3fExo",
	"LvjcViE0GqTAfWK8KDUGVl+nkQ5WNE/ECqRkGaiBK2WCv1rR/Kfqs0/jEawhTbSkKSTWajAUa6fmG0un",
	"uy7SoEndcgkZoxryDSkkpJDZeltMkVrZntiKBSRdUD7HO1eKcr6wr9lxzkFC1c/L6LftIeL1TtY8sbXX",
	"ujAeEWuoDMvTAk0Xkf4oeDMZhdpTgi0nMURljrACrKzZp0GPR70SskHqqg5ss8hp8ocB13/jIg/wU098",
	"FaVI76j1jlpvjVpjJf8QdbOWDcDiK9yWazYWXXeByxu0Pd1K9du7EvJ/9hLyngMpQomkDak/3ruMKsI0",
	"OccCP1Mg5uIp0ebtWpw7DXlCDEMK7Pu2EqRynTfTBWXcVYep0gUQDu26A2vfjvBazIWWmaGd0KAD0lIy",
	"vUE9gRbstzMw//9gBG0FcuVViFLmo8PRQuvi8OAgFynNF0Lpg9GncfhMtR5+qOD/6KX/QrKV0Wg+ffj0",
	"/wcAAP//jzpQiJ5+AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
