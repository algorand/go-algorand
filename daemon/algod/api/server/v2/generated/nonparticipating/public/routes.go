// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"u/8bAAD//721XkMgwwEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
