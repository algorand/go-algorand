// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"tZ5z9Gj6YPT+/wUAAP//+NzwegjNAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
