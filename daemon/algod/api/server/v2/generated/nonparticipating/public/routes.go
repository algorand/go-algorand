// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9fXPbtrI4/FUw+v1m8nJFOa+9p57p3MdN2h7fJmkmdnvuuU2eFiJXEo4pgAcAbal5",
	"8t2fwQIgQRKUKFu2k9Z/JRZJYLFYLPZ9P45SsSwEB67V6PDjqKCSLkGDxL9omoqS64Rl5q8MVCpZoZng",
	"o0P/jCgtGZ+PxiNmfi2oXozGI06XUL9jvh+PJPy7ZBKy0aGWJYxHKl3AkpqB9bowb1cjrZK5SNwQR3aI",
	"45ejTxse0CyToFQXyp94viaMp3mZAdGSckVT80iRC6YXRC+YIu5jwjgRHIiYEb1ovExmDPJMTfwi/12C",
	"XAerdJP3L+lTDWIiRQ5dOF+I5ZRx8FBBBVS1IUQLksEMX1pQTcwMBlb/ohZEAZXpgsyE3AKqBSKEF3i5",
	"HB3+OlLAM5C4Wymwc/zvTAL8AYmmcg569GEcW9xMg0w0W0aWduywL0GVuVYE38U1ztk5cGK+mpDXpdJk",
	"CoRy8u77F+Tp06dfm4UsqdaQOSLrXVU9e7gm+/nocJRRDf5xl9ZoPheS8iyp3n/3/Quc/8QtcOhbVCmI",
	"H5Yj84Qcv+xbgP8wQkKMa5jjPjSo33wRORT1z1OYCQkD98S+vNdNCee/1V1JqU4XhWBcR/aF4FNiH0d5",
	"WPD5Jh5WAdB4vzCYkmbQXx8lX3/4+Hj8+NGn//PrUfK/7s/nTz8NXP6LatwtGIi+mJZSAk/XyVwCxdOy",
	"oLyLj3eOHtRClHlGFvQcN58ukdW7b4n51rLOc5qXhk5YKsVRPheKUEdGGcxomWviJyYlzw2bMqM5aidM",
	"kUKKc5ZBNjbc92LB0gVJqbJD4HvkguW5ocFSQdZHa/HVbThMn0KUGLguhQ9c0OeLjHpdWzABK+QGSZoL",
	"BYkWW64nf+NQnpHwQqnvKrXbZUVOF0BwcvPAXraIO25oOs/XROO+ZoQqQom/msaEzchalOQCNydnZ/i9",
	"W43B2pIYpOHmNO5Rc3j70NdBRgR5UyFyoByR589dF2V8xualBEUuFqAX7s6ToArBFRAx/Rek2mz7f5/8",
	"9IYISV6DUnQOb2l6RoCnIoNsQo5nhAsdkIajJcSh+bJvHQ6u2CX/LyUMTSzVvKDpWfxGz9mSRVb1mq7Y",
	"slwSXi6nIM2W+itECyJBl5L3AWRH3EKKS7rqTnoqS57i/tfTNmQ5Q21MFTldI8KWdPXNo7EDRxGa56QA",
	"njE+J3rFe+U4M/d28BIpSp4NEHO02dPgYlUFpGzGICPVKBsgcdNsg4fx3eCpha8AHD9ILzjVLFvA4bCK",
	"0Iw53eYJKegcApKZkJ8dc8OnWpwBrwidTNf4qJBwzkSpqo96YMSpN0vgXGhICgkzFqGxE4cOw2DsO44D",
	"L50MlAquKeOQGeaMQAsNlln1whRMuFnf6d7iU6rgq2d9d3z9dODuz0R71zfu+KDdxpcSeyQjV6d56g5s",
	"XLJqfD9APwznVmye2J87G8nmp+a2mbEcb6J/mf3zaCgVMoEGIvzdpNicU11KOHzPH5q/SEJONOUZlZn5",
	"ZWl/el3mmp2wufkptz+9EnOWnrB5DzIrWKMKF362tP+Y8eLsWK+iesUrIc7KIlxQ2lBcp2ty/LJvk+2Y",
	"uxLmUaXthorH6corI7t+oVfVRvYA2Yu7gpoXz2AtwUBL0xn+s5ohPdGZ/MP8UxS5+VoXsxhqDR27KxnN",
	"B86scFQUOUupQeI799g8NUwArCJB6zcO8EI9/BiAWEhRgNTMDkqLIslFSvNEaapxpP8rYTY6HP2fg9r+",
	"cmA/VwfB5K/MVyf4kRFZrRiU0KLYYYy3RvRRG5iFYdD4CNmEZXsoNDFuN9GQEjMsOIdzyvWkVlka/KA6",
	"wL+6mWp8W2nH4rulgvUinNgXp6CsBGxfvKdIgHqCaCWIVhRI57mYVj/cPyqKGoP4/KgoLD5QegSGghms",
	"mNLqAS6f1icpnOf45YT8EI6Norjg+dpcDlbUMHfDzN1a7harbEtuDfWI9xTB7RRyYrbGo8GI+fugOFQr",
	"FiI3Us9WWjEv/929G5KZ+X3Qx18GiYW47ScuVLQc5qyOg78Eys39FuV0CceZeybkqP3t5cjGjBInmEvR",
	"ysb9tONuwGOFwgtJCwuge2LvUsZRSbMvWVivyE0HMroozMEZDmgNobr0Wdt6HqKQICm0YPg2F+nZ36la",
	"7OHMT/1Y3eOH05AF0AwkWVC1mIxiUkZ4vOrRhhwx8yIq+GQaTDWplriv5W1ZWkY1DZbm4I2LJRb1+B0y",
	"PZAR3eUn/A/NiXlszrZh/XbYCTlFBqbscXZOhsxo+1ZBsDOZF9AKIcjSKvjEaN07Qfminjy+T4P26Dtr",
	"U3A75BaBOyRWez8G34pVDIZvxapzBMQK1D7ow4yDYqSGpRoA30sHmcD9d+ijUtJ1F8k49hAkmwUa0VXh",
	"aeDhjW9mqY2zR1MhL8d9WmyFk9rkTKgZNWC+4xaS8NWySBwpRsxW9oXWQLWXbzPTaA8fw1gDCyeaXgMW",
	"lBl1H1hoDrRvLIhlwXLYA+kvokx/ShU8fUJO/n70/PGT3548/8qQZCHFXNIlma41KHLf6WZE6XUOD7or",
	"Q+2ozHV89K+eeUNlc9zYOEqUMoUlLbpDWQOoFYHsa8S818VaE8246grAIYfzFAwnt2gn1rZvQHvJlJGw",
	"ltO9bEYfwrJ6low4SDLYSky7Lq+eZh0uUa5luQ9VFqQUMmJfwyOmRSry5BykYiLiTXnr3iDuDS/eFu3f",
	"LbTkgipi5kbTb8lRoIhQll7x4XzfDn264jVuNnJ+u97I6ty8Q/aliXxvSVSkAJnoFScZTMt5QxOaSbEk",
	"lGT4Id7RP4BGUeCULeFE02Xx02y2H1VR4EARlY0tQZmZiH3DyPUKUsFtJMQW7cyNOgQ9bcR4E53uB8Bh",
	"5GTNU7Qz7uPY9iuuS8bR6aHWPA20WANjDtm8QZZX11b70GGnuqci4Bh0vMLHaOh4Cbmm3wt5WlsCf5Ci",
	"LPYu5LXnHLoc6hbjTCmZ+dbr0IzP82b0zdzAPomt8VYW9MIfX7cGhB4p8hWbL3SgVryVQsz2D2Nslhig",
	"+MAqZbn5pquavRGZYSa6VHsQwerBag5n6Dbka3QqSk0o4SID3PxSxYWznngNdBSjf1uH8p5eWD1rCoa6",
	"Ulqa1ZYFQe9t576oP0xoak9ogqhRPb6ryulo37LT2ViAXALN1mQKwImYOgeRc13hIim6nrUXb5xoGOEX",
	"DbgKKVJQCrLEGaa2gubfs1eH3oAnBBwBrmYhSpAZlVcG9ux8K5xnsE4wUEKR+z/+oh7cArxaaJpvQSy+",
	"E0NvpeY7L2AX6mHTbyK49uQh2VEJxN8rRAuUZnPQ0IfCnXDSu39tiDq7eHW0nINEf9y1Uryf5GoEVIF6",
	"zfR+VWjLoif8z6m3RsIzG8YpF16wig2WU6WTbWzZvNTQwc0KAk4Y48Q4cI/g9YoqbX3IjGdo+rLXCc5j",
	"hTAzRT/AvWqIGfkXr4F0x07NPchVqSp1RJVFIaSGLLYGDqsNc72BVTWXmAVjVzqPFqRUsG3kPiwF4ztk",
	"2ZVYBFFduVpckEV3ceiQMPf8OorKBhA1IjYBcuLfCrAbhkD1AMJUjWhLOEy1KKeKuxqPlBZFYbiFTkpe",
	"fdeHphP79pH+uX63S1xU1/d2JkBh5JV730F+YTFrg98WVBEHB1nSMyN7oBnEOru7MJvDmCjGU0g2UT6q",
	"eOat8AhsPaRlMZc0gySDnK67g/5sHxP7eNMAuOO1uis0JDaKKb7pNSX7oJENQwscT8WER4JPSGqOoFEF",
	"agJxX28ZOQMcO8acHB3dq4bCuaJb5MfDZdutjoyIt+G50GbHHT0gyI6jDwG4Bw/V0JdHBX6c1Lpne4p/",
	"gnITVHLE7pOsQfUtoR5/pwX02FBdgHhwXlrsvcWBo2yzl41t4SN9R7bHoPuWSs1SVqCu8yOs9676tSeI",
	"uhlJBpqyHDISPLBqYBF+T2z8TXvMy6mCg2xvXfA7xrfIcnKmUORpAn8Ga9S539rAzsDUsQ9dNjKquZ8o",
	"JwioDxczInj4CqxoqvO1EdT0AtbkAiQQVU6XTGsbsN1UdbUoknCAqF9jw4zOiWeDIv0ODPEqnuBQwfK6",
	"WzEeWZ1gM3ynLcWggQ6nCxRC5AMsZB1kRCEYFO9BCmF2nbnYcR897CmpAaRj2ujBra7/e6qBZlwB+aco",
	"SUo5qlylhkqmERIFBRQgzQxGBKvmdJEdNYYghyVYTRKfPHzYXvjDh27PmSIzuPAJF+bFNjoePkQ7zluh",
	"dONw7cEeao7bceT6QIePuficFtLmKdsjC9zIQ3bybWvwyktkzpRSjnDN8q/MAFonczVk7SGNDIuqwHEH",
	"+XKCoWPrxn0/Ycsyp3ofXis4p3kizkFKlsFWTu4mZoJ/d07zn6rPMJkEUkOjKSQppkAMHAtOzTc2a2Kb",
	"blhHk7HlEjJGNeRrUkhIwUb5G5FPVTBOiI3/SxeUz1HSl6KcuwA0Ow5y6lJZm4oseWeIqDSkVzxB63SM",
	"c7ugY5/oYeQgoEYXa5u2reZxQav5XG7PkCs1QF7b1B/1bo1HvaqqQep5rapa5DSzVQZw8YagFuCnnnig",
	"DwRRZ4SWLr7CbTGnwGzu9dja66FjUHYnDkLi6od9UXFGT87Xe5BW7EBEQiFB4d0S2peUfSpmYWaau3zU",
	"WmlYdk3w9tPfeo7fu15FT/CccUiWgsM6mozNOLzGh9HjhPdbz8coafR921YeGvC3wGrOM4Qar4pf3O32",
	"CW27mtT3Qu7Ll2kHHCyXD3AdbvWTuykv6+CkeR7xCbq8lTYDUOMqT55JQpUSKUNh6zhTY3vQnBvRJbk0",
	"0f+2isbdw9lrj9tyfoUpkWjchbwglKQ5Q9Ov4ErLMtXvOUXjUrDUSNSS16L7zY0v/Ctx+2bE/OiGes8p",
	"RqxVJqdopMUMIvaV7wG81VGV8zko3VJSZgDvuXuLcVJypnGupTkuiT0vBUgMHZrYN5d0TWaGJrQgf4AU",
	"ZFrqptiOaVlKszx3njgzDRGz95xqkgNVmrxm/HSFw3lvvT+yHPSFkGcVFuK3+xw4KKaSeHTVD/YpBr66",
	"5S9cECym0dvH1ndjxq9zt9Zoe6pTw//f+/91+OtR8r80+eNR8vV/HHz4+OzTg4edH598+uab/6/509NP",
	"3zz4r/8b2ykPeyxpyEF+/NKptMcvUW+pnTcd2G/McL9kPIkSWRiG0aItch8TZB0BPWhatfQC3nO94oaQ",
	"zmnOMsNbLkMO7Rumcxbt6WhRTWMjWlYsv9YdtYErcBkSYTIt1nhpKaobkBhPz0Nvosu4w/MyK7ndSi99",
	"2+wTHxgmZuMqBdNWZzkkmJ+3oD6q0f355PlXo3GdV1c9H41H7umHCCWzbBXLnsxgFVPy3AHBg3FPkYKu",
	"Feg490DYozFwNigjHHYJyylItWDFzXMKpdk0zuF8TL8zFq34MbfB9ub8oG9y7VweYnbzcGsJkEGhF7Gq",
	"DQ1BDd+qdxOgFS9SSHEOfEzYBCZtY01m9EUXjZcDnWH1ANQ+xRBtqDoHltA8VQRYDxcyyCISox8UeRy3",
	"/jQeuctf7V0dcgPH4GrPWTki/d9akHs/fHdKDhzDVPdsIq8dOki9jKjSLruoEUlkuJmtVWOFvPf8PX8J",
	"M8aZeX74nmdU04MpVSxVB6UC+S3NKU9hMhfk0CcsvaSavucdSau3nFSQKkaKcpqzlJyFCklNnrZESHeE",
	"9+9/pflcvH//oRNU0VUf3FRR/mInSIwgLEqduAIHiYQLKmNOK1UluOPItoLJplmtkC1Ka9n0BRTc+HGe",
	"R4tCtRNdu8svitwsPyBD5dI4zZYRpYX0sogRUCw0uL9vhLsYJL3wdpVSgSK/L2nxK+P6A0nel48ePQXS",
	"yPz83V35hibXBQy2rvQm4raNKrhwq1bCSkuaFHQe8429f/+rBlrg7qO8vEQbR54T/KyRceoj6nGoegEe",
	"H/0bYOHYOXsOF3div/LFrOJLwEe4hfiOETdqj/1l9yvIQb30drXyWDu7VOpFYs52dFXKkLjfmarGzdwI",
	"WT6MQrE5aquuHNAUSLqA9MzVaYFlodfjxuc+UscJmp51MGUr+NgMMqwhgZ6FKZCyyKgTxSlft5P5FWjt",
	"44HfwRmsT0VdgmKX7P1mMrnqO6hIqYF0aYg1PLZujPbmu3AwVOyLwudkY3KeJ4vDii78N/0H2Yq8ezjE",
	"MaJoJDv3IYLKCCIs8feg4BILNeNdifRjyzNaxtTefJFqPp73E/dKrTy5yK1wNWh1t8+XgOXAxIUiU2rk",
	"duEqWdmE6YCLlYrOoUdCDp07A9OSGw4hHGTbvRe96cSsfaF17psoyPblxKw5SilgnhhSQWWmFa/nZ7L+",
	"Q+eZwAKVDmHTHMWkKrDRMh0qG042W3GvD7Q4AYPktcDhwWhiJJRsFlT5IltYi8yf5UEywDUWANhU9uU4",
	"CDULCo5VRV08z22f04526Yq/+IovvsxLqFoOKNliJHyMbo9th+AoAGWQw9wu3L7sCaUuRlBvkIHjp9ks",
	"ZxxIEotaC8ygwTXj5gAjHz8kxFrgyeARYmQcgI1+cRyYvBHh2eTzXYDkrpgC9WOjRz34G+J5XzaO24g8",
	"ojAsnPV4tVLPAagLdazur1bALQ5DGB8Tw+bOaW7YnNP46kE61UdQbG3VGnGRGQ/6xNkNDhB7sey0JnsV",
	"XWY1oczkgY4LdBsgnopVYhM/oxLvdDU19B4Nbcc01NjBtHVe7ikyFSuM9sGrxYZSb4GlHw4PRqDhr5hC",
	"esXv+m5zC8ymaTdLUzEqVEgyzpxXkUufODFk6h4Jpo9c7gelWy4FQMvYUddBdsrvViW1KZ50L/P6VhvX",
	"Jcl81lDs+Pcdoegu9eCva4Wpiq28bUssUTtFM2ilWWcmECFjRG/YRNdJ03UFKcgBlYKkIUQlZzHPqdFt",
	"AG+cE/9ZYLzAajaUrx8EkVAS5kxpqI3oPk7iNsyTFIvoCTHrX50u5Mys750Q1TVl3Yj4YWOZN74CDCWe",
	"Mal0gh6I6BLMS98rVKq/N6/GZaVmrJUtOcuyOG/Aac9gnWQsL+P06ub98aWZ9k3FElU5RX7LuA1YmWKJ",
	"5GgE5oapbZDuxgW/sgt+Rfe23mGnwbxqJpaGXJpzfCHnosV5N7GDCAHGiKO7a70o3cAgg8zZLncM5KbA",
	"xz/ZZH3tHKbMj701asfn7/bdUXak6FoCg8HGVTB0ExmxhOmgwnA3pbXnDNCiYNmqZQu1o/ZqzHQng4ev",
	"y9bCAu6uG2wLBlCkfQczkBA1IVSPbHR0JS6Fdfkws7tRCiey6b3G/6YpzV+UVaOEYKJLGMFcJcX+Pa5j",
	"LxuVBptL2SYYVWZ8M90QhJ/ErecnRpdo4jbQqGxx7i14Zj26eUiBAQcOp2LKt5boUmaV5riNOE+B5j/C",
	"+hfzLi5n9Gk8upqtOkbcbsQtuH5bnaconjEWwtouG66nHVFOi0KKc5onzqLfxwukOHe8AF/3DoAbvlvi",
	"R+b0u6NXbx34n8ajNAcqk0o2610Vvld8Mauy5RV7DogvXW+UbK8kWdk92PyqJlzoBbhYgKsBHoj/nWKl",
	"tYcnOIrOKzCLh2RtZW/OGWWXuMEpBUXlk6rtpdYl1XRD0XPKcm+o9ND2hE/h4oZVvI1yhXCAK7uzAq9k",
	"sld20znd8dNRU9cWnhTOtaFK+dIW4ldE8HbMAgaZrwsX5rCkWGrUmqG6zImXSzTdJCpnadyozafKEAe3",
	"zkrzMsGXe6R/M2LJenzfvGTBWOa1IcWEWkAGc0SRqaL1jGrcTYWTHUrO/l0CYRlwbR5JPJWtg+qlFxy1",
	"c50aYa07lxvYukTq4a8i1IVldts3HgKxWaILXaMdcF9WNgq/0MoEWAt1u0ZYhDN2rsQN0RGOPhw122jR",
	"RdPFGfZE6vI/Qxi2OP72hkxeuHP1fnvmiDZYYiqZSfEHxBVrtEdEMsR8YWGGYUV/QCg/hm1FGiymMqfV",
	"faLq2bdt93DhvW/jryys+0VXtYwvI6nHT/Xwjdwglat4qTKHxz4pMTSfNqNrergHnqDAn4yVYr1rhXJ7",
	"ZGwGVCNIM37wwnDoAzt+ffAczJ0Q8pxeTGmsjK4R1gxMwQ42nEBaEP+xx7Gq0oTs7CQIgqjeZbaKQgGy",
	"ToLtVmS6pOBlpx0sctUSFhJNKFuNreM6VyIyTMkvKLfth8x3liW5rxVYq6356kJIrIGi4v6qDFK2pHlc",
	"AsvSrm8iY3NmO+uUCoLWLW4g27XMUpFrf1MlvznUHM/Io3HQP8rtRsbOmWLTHPCNx/aNKVV4I1YW1OoT",
	"szzgeqHw9ScDXl+UPJOQ6YWyiFWCVMIxqomV13UK+gKAk0f43uOvyX30Nyt2Dg8MFp2cMzp8/DV6C+wf",
	"j2IXqeuMtIkrZ8iW/+HYcpyO0eFuxzB80I06iZaLsK0R+y+ADafJfjrkLOGb7s7YfpaWlNM5xEOclltg",
	"st/ibqIFuIUXntm+XkpLsSZMx+cHTQ1/6kmbMOzPgkFSsVwyvXReSSWWhp7qvix2Uj+cbRLmSmp7uPxD",
	"dO4X3rfZUsZv1tpv5YTYqjEE4w1dQhOtY0Jt4Zuc1WE3vtA/OfZ1tbDGeFVa3OLGzGWWjuIiRuHMSCEZ",
	"16iglXqW/I2kCyppatjfpA/cZPrVs0hd9WZ9X74b4DeOdwkK5Hkc9bKH7L1Y4r4l97ngydJwlOxBnaYU",
	"nMreKIS4v7nP6b156KHCrRkl6SW3skFuNODUVyI8vmHAK5JitZ6d6HHnld04ZZYyTh60NDv087tXTspY",
	"ChkrllkfdydxSNCSwTkGncY3yYx5xb2Q+aBduAr0t+sy8yJnIJb5sxxVBM6Xv3jzdm+yiRHhf3nt+oB2",
	"ZO+eABkbAVN9c8NJNNFYOiuhYfwpwVWT3x//TqRRFlEaffgQgX74cOyEud+fNB9bJvXwYbyEVNQ2ZH6t",
	"sbATK2yX2DDfxvbwWxGx1Ph+DZUbzyXKRCxlfazWPDBHeeqGGpNmbfybvwv3E4IZd7PHT8H797/iE48H",
	"/KONiFs+8riBdSCRXUkPoQS9QaIkk1XPgwAfSr4Vq6GE0+Kknng+AxT1oGSDHWlXjPR5Xcnxy5AuDU6m",
	"kAujHoWlnENj85eDW7Po8QYMlyzPfqkT+1uXh6Q8XURDIqbmw9/qNpzVEi17jFaHXVDOIY8OZ7Wy37z2",
	"FtEv/yWGzrNkfOC77X47drmtxdWAN8H0QPkJDXqZzs0EIVabOdNVTk4+FxnBeepSpDVD7PZpCrpp/LsE",
	"pWMiAT6wccHoiTEM1zZzIMAztNtMyA+20/4CSKPOHNpLfCGgZlGMssgFzcZYoOj0u6NXxM5qv7HN5Gwz",
	"iTmaC5qriJpwhxcJqfrCxbPfho+zOR3HrFrppOr9EKsvYN6ou1OwllcSDQkhdibkZdAz25YiMEMQrE8l",
	"l5AFrSasFoE0Yf6jNU0XaBxpXF79JD+8C4qnShV0Hq46CFalh/HcGbhdIxTbB2VMhF6AvGDKNliHc2iW",
	"NKjqezjjnC9x0FyeLDm3lDLZQY6oCg3vinYPnBVCvOMyClkL8TuqxraJ0K5NYU7wq2glxHaHmU7LYZsg",
	"X3WGe+2bRlMuOEuxDmFMCHKd2Ie4QgaUbIw7ONTIndDI4Yr2takirR0WezvdeEboENd1KwZPzaZa6rB/",
	"amz5vaCazEErx9kgG/v2TM4iz7gCV0oa+/YHfFLIRqREFQHWbb1bOWl3JCPMrOwxsXxvnr1xBjhMOTpj",
	"HFVthzYnWlubOTaK1kY/Z5rMBSi3nmZ5CfWr+WaClRYyWH2Y+MbSOIYNNDDLtlE13aGOfIyNi2kx774w",
	"77r6d9XPjSQWO+lRUbhJ+5t3ReUBveK9CI6IQIl3VgfIrcYPR9tAbhuD4/A+NYQG5xhaAwXewx3CqBpZ",
	"tZokGrXAUhS+QWwUcLQIDuMRMF4xDnXb88gFkUavBNwYPK8936lUUm1FwEE87RRobk0WEYamtHMCXnWo",
	"dvU/gxJco5+jfxvrHlw9jKN6oRbcKF9X3dYNdQfCxAuaV8FlkY5aKFU5ISrDpLRWj60Y4zCM23fxa14A",
	"PZaUhkxkP8dSmLveRH11BqZlNged0CyLVfb+Fp8SfEqyEiUHWEFaVhWgi4KkWFarWWesS21uolRwVS43",
	"zOVfuOJ0QdO6CDWEjfP8DmMe43SN/8bKH/fvjAsr2zmS3MeQZbsV1+tGxsekXkPTiWLzZDgm8E65Ojrq",
	"qS9H6PX3e6X0XMybgNyGYbSHy4V7FONv35mLIyy+06npba+WqjYOhhEL32oY1caqqkOTK+FV1inyjW7X",
	"qpXpZjNEf1PSMV5+PdkboZnb3q/W9NuXw5H2phxR7ZKfNSUbWVBvQqmNR2wZzrs+jL4YRBuCuD+Ds1vr",
	"RoT64NYuQD/6yHlSUOaCVGpm0cWsS2rqppkNib6vN7i9CJcq1GsT/fG8L63H19rE5+2mhWfgKqIUEs6Z",
	"KH34h4+z9Cqh/bXRArBKrIquv2vaxqlu1+Dcax4/dc1j7DKdTv7jLzYqlwDXcv0ZGMs7m95ph9iVdq15",
	"qn6FVH0HBvUhaNyKQ+rQxkqeOtmw0ZBxSzvJDlm9HCIOdNtDjkfH2U4XZqxs7siOEjt28WaP/VUF60qC",
	"eMQKoVjd/iPWBXJgQPMpNnIMqiJ2x/JRcOeQauz5Ukf3SIBdaiSayYK+0nfVBXvU6Sru2xUV3FRJsNvo",
	"Zcsd30n2DRLWbZOMyfC6eUdVDCfyaSx2PwfuWjs3s8oG57bMZpBqdr4lufofC+BB4u7Y22UQllmQa82q",
	"XAmszbW71bEGaFPu80Z4ghq5VwanL9PvDNb3FGlQQ7Rrx9hftZcpy4QYQO6QGBIRKhYjZQ3JLmyFqYoy",
	"EAs+JtF+DnWBy96Gf0GpgEvO5UnSXBx1+YANU8Y7jg2ay3y6U1ENDPvvy7/uNizq1z9eYn8oVTXj9WWd",
	"Qi2dHHeL3164slCYCl/5TnyBKFD+N1/3ws6SszMIWxKip+qCysy/ETW9eKtOsuE+6iRN+2Y7baBn1cys",
	"jiDvZm1GyilivkWaCyNGJH1JK82g7Sri6Z6yoWm2uweGoxu4ZiBd61aUf3OhINHCR5xvgmMTKmz83aWQ",
	"oHpLGFvgeguLvasrp2Epd4qFxKgLuwsXSCQsqYFOBvXN+ufchOwX9rlPU/SlvLdamCp63d5TxucOMNVB",
	"Ykj1M+Juy+3pj5cxNjHOQSbe89QudsZBNr0hhRRZmdoLOjwYlUFucCnBDawkaqdJu6ts6QhBDvkZrA+s",
	"EuSb8fgdDIG2kpMFPSiS09rkvZrfVAzu+V7Au03L1XhUCJEnPc6O426FtjbFn7H0DDJibgofY9vTII3c",
	"Rxt75c2+WKx9RbKiAA7ZgwkhR9xmNXjHdrNFQGtyfk9vmn+Fs2alLZrojGqT9zweHo7lDOUVuZkfZjMP",
	"U2BY3RWnsoNsqf+16qkOJ+lFpF3gZKhW3nU1t1u41URloYjJJHV3si1xMlWITN3YqQ6T6UoHeS4uEqSi",
	"pCrvGNM5zHtNJukLWtefGWxPIYi3ocpdoGuyoBlJhZSQhl/EE4EsUEshIckFht/EPIMzbeShJUb/c5KL",
	"ORGFUXNtlVTvQ4l2HevMVXJO8TqDINohhgGapqh6CeI+IdUnQ2fcV083W47ArjmxLqae6iugXPkBhyD7",
	"chfeDW3Vdm/ZdrqIWIoQc54+du7L5kh853ZKAZgDjtZ2K9lRrO1cc13tBoh97Ui1WLI0ju4vKz6mN6ol",
	"Rr0xVLiK5jYxFV9DlhJyscodiqeni2bgdJrHfETEHT/nFkI6N//FO7M9LpmBY2c9HDTWP52mZ4kVwgZM",
	"j3DaXCldSlsE3YxQ91QUc5tUib6sNnyD+MynzVsR628YIbVq/a79ok/A7iHbqN9/s5vd9rydDnW2V30V",
	"BnKoAIB+93sDhkFO+F3BmGEP6YRGkHxcqT7jRot/1mLDvuatZTcptaaPBRAzdinBJQTbZret7noF1Qsv",
	"CpnXuwYKo+yCwmxd2yKMKmtO82Y912m3LWOKIsnhHBpRCS5LucSrkp1D2KXXfkwygAKN3G3VK+ZuDy+c",
	"ljzu1p4EDtsh2I0K6BaxdqfIFuk7qiuseGKPiRp6lAxE5ywraQN/6gr9SvtblUZFnGFtaX+2n3pe4T6P",
	"3bJ+/R+GcZ+dGU8cYZvYztagGzxH0bPO4zE3YeJ9Za3D2bLKqm8Ju+YWqqAXvF+77RJ6LSQO36YAsd+t",
	"IMULtxlUcnWcEByMqFZRjV7pUFY7fHkrydUp1xPtkTKqh+FFG6h3E/F2ejRHxV4Fvsd+WJ/M6yru28g1",
	"bu3ETEUGYKrmYxj6CnVoZfDakq5JxmYzkNYTpjTlGZVZ+DrjJAWpKePkgq7V5XVCA60sYbxVLTS3Cg7q",
	"GWtMQUSjrgUkXzt9+4oqWwUgfqH2o7wNULrQ5RpRuKx4o0Vf6+oODPE8ILoyajEGRPYQoKvzgUqxZUCC",
	"o35AlvQMdpxHsT9g8zRYxcwZ7bXAWYdM8WnjOfsJUYdM7GfO9MaTZuXidoSqdSHag+Dpn8/rOAa7OV36",
	"jwUVn9oGimFgcbsfkd9ra8+080FPfWV3HyR4T6gNEQKggs6JqbPwdsWmzgVjgRm7gOsdpSqrztAsY1Yc",
	"iXc3x+YBjqab01ZWNzPOcOOyzwrvhagQRZIOcRtlkINhL1arcpA2YRzgLSzSLVdB9MLt4QZNFU7M8Fwi",
	"OVoxAwNsqst13A79agoUFcFjF/S0lChmX9D19nqptVARj5q3I3st3AcDVVC7DbZHS9nGWtFypLsIsJHT",
	"Hust1S0Euf/F2HSQ2mF9fctxLqn4Ao64U+SwY+gmeqtVPU8qEVqjfB1jGt7pcokF9smaAwKa97ZV1Wm5",
	"jg3afDnFNaKYANKWNLwQgvl5KBI1g1ZUOXWXWldGqZ3fdpCA8VoBwtx6U+AwY+7asz9Xc6sFNdfyhBzl",
	"ShAFXuDSa3KvI0/dM1juVdrQ4AkQgTKErSPoWLtGSjkXOgaqhzCq0qF7tOc68nAYFhnU2Q6RJn3OfWbr",
	"XwmZ+Vu8Mpzgf6ZMSyrXl+5sWSf3x3JZMPzAVyrbshhbRNJXNbuJpURrXcZa4dFVsm1PvHzoZf+waFN8",
	"tya9kugQtA2Yr4HQvt5v16hmttAWXVsIwochbCgybwQ/zPclChnsLrzGyfQ0tIsbaWRzPvwG6vat+fZE",
	"1zuGPPYl3m/kLa1uZ3sDeoM0vqkTVYOubxCmnr5gIUi2BdgNsKxGNZUIrNaQMRWrRMJMbVMdAvBrkFUV",
	"aMh4KoEqG4R3/JPT7DewrY0nYQDDctX1alA2zNVLwMMY8aA5NhDjUPY7ZJ4NBLZ9Gkt6Q6axPcv66aJ/",
	"LqOF1Vxz00yxG6AuJlBtXAO/IRI6kEbvhMv1Chp0wLp5V5FThgD0JFQ0QuHDVmJ1mTBp0/cwdNY7c9q3",
	"yuvaybM18g8h8R9sAS/MkKjfq4LVHDi3XG/rdYWUYCm9lNBY/rakC7fA2isWbJEz3moNtrGjrSDS3Jcg",
	"o0a9qBJVeqxGnXwW7BsmOB6obh6MtSejuhcSjjlc8pzmN5/Lgg3ljhAfkL3rj34NkyFCJFtUqsuVYnlF",
	"B80dJD7sb2r+FnNv/gFmj6IWCzeUc4117BLoDaC5jdSauTxGMyS5wDFtsMPjr8jUFXQtJKRMtV1uF75b",
	"fBX7D5LNXCINrPSWZINt6/xF6CuQ8cx7xcmbQLwV6M6oIayP6C0zlZ6TG6XyGPV1yCKCvxiPCjvUbLku",
	"zhoZvbXBMbjRhIQ9Z/YGNTp2zOzt9t4ZujybvWounVJBd52Db+sGbiMXdb22oWnpg6uvYlvgIdnk8Uqp",
	"5nNMZ99LydSdCqZeQyK7xZEbw80bo5hf+kqb2fJdPVX0WvtRsjzbqieFNRE/jUdz4KCYwqp/v7n6xDd7",
	"l3oIbHJd96haWK+SEWwRE1lrY/JgqqDa4YBCh+6zSFlDDFxPS8n0GttPeSMm+y2acv9Dlb7p0n8rn767",
	"+7Q4g6qBWZ3sWSp/u/4gaI73kQ014OYWEvmEfLeiyyJ37jryzb3pf8LTvz3LHj19/J/Tvz16/iiFZ8+/",
	"fvSIfv2MPv766WN48rfnzx7B49lXX0+fZE+ePZk+e/Lsq+dfp0+fPZ4+++rr/7xn+JAB2QLqi3Aejv4n",
	"OcrnIjl6e5ycGmBrnNCC/Qhmb9DrMRPYO8UgNcWTCEvK8tGh/+n/8SdskoplPbz/deRqgI8WWhfq8ODg",
	"4uJiEn5yMMfsrkSLMl0c+Hmwo0VDXnl7XAV12ugi3FFbGNBHonlSOMJn7747OSVHb48nNcGMDkePJo8m",
	"j834ogBOCzY6HD3Fn/D0LHDfDxyxjQ4/fhqPDhZAc0yGNn8sQUuW+kcSaLZ2/1cXdD4HOcG4XfvT+ZMD",
	"L1YcfHRZbp/MDNE4BFsTMyiE6K0JdWNe53xAp6KNRlVhsyFFbIfwMXF9xX1gHM+wVKFNHDNsrkLccVY3",
	"7z6umZbvqGV7uh7+Gqk84EN+faMnmyPiqro40yVT5L9PfnpDhCROvXlL07Mq3Jkcz2xXDynOGVbAy4Ky",
	"iebLiafff5cg1zV9Oc4Xts8EXi4NE3Fx00s1L5pFuGqpKua/6+Daz2zIIiDsKie1ZlwYtRJAUrNhw1of",
	"JV9/+Pj8b59GAwDBBGkF6K75neb57+SC5TmBFcattezh44ZgFdjlx3WOI35Q7+QYfYvV0+Dz+p1m7crf",
	"ueDwe982OMCi+0Dz3LwoOMT24AOazZFY8Mw9efTIMxonxgfQHbgzNbRZqi/Xas3E1SieJC4xUJch2Ufv",
	"qjJGkhb2LLonNrPH+fztSxPDd57tcaHNYktXXm57uM6iv6UZkS6jCZfy+ItdyjHHGgXmgiD2Avw0Hj3/",
	"gvfmmBueQ3OCbwY9oboXzc/8jIsL7t80wk+5XFK5RtFGV7ywXQqazhUG2iCLtGc7qJTB56MPn3pvvYPQ",
	"G3PwsZHmnl3pTrTdyxptq7dck/dUH+fsdqa9f1QUdVtqfH5UFLbFHMZrAcPbD1ZMafVgQn4Iv0bujQ1K",
	"bPuPUnLIfJa6v/Wqjmu+j1sN2z0V9m6JXtqBufju/r7t+/uoaexodD+NAdM4BRth6rgprnqB9sRrDOtZ",
	"HO/Z7rsZQpa4Lgc7turfW/uOAY4dO9OHmCq4lVHf4a4Hd31iUgBvJTHVnTJuhjX7qmjVTdK4Mq6RcX/h",
	"Qt9rmhs6CZbbqj5uWwLfCYN/GWGwqp40t9KZ64J/NfEQPekHH32b5z2IhK478gBhMFSrg2+DTJ37LXby",
	"YGJ7DYfvXI5nuHJJW8U8bL59J+B9BgJet7F9DIy6XfntCXVhoOIuoaQNacT3Hh/cof8LleL+wsjqFdsM",
	"pNsFtkuwz44w5pj1tbHVP6UQ5pB2J379pcWvqojhlQSwMNXowJXFDNxYV7Leta1zTFeSWLOQZcDZMFXf",
	"MBR3hMd13pphMTbxy6V8qbHXDNGdapVGu1njjt7YFbF+gFBB/XZ9/HKbdPUF2XkG96OL3ALxvbluXhp1",
	"O7y7GbfDMN707NGzm4Mg3IU3QpPv8Ra/Zg55rSwtTla7srBNHOlgavsdb+JKvMWWbDpe1cc44FFVBd9x",
	"8Ny8baM07mPaXLODwYMJ8d2VFVm6il+uCNFcGEblc4OpnNuPDK8zyCD3/J+HOP69Cfkes8i1GmOwGVb5",
	"wRcZ14ePnzx95l6R9MLGcrXfm3717PDom2/ca3U/dKvndF5XWh4uIM+F+8DdEd1xzYPD//nn/04mk3tb",
	"2apYfbt+Y1uefS68dRyr/VURQN9ufeGbFNPWfXvobai7Eff9t2IVvQXE6u4WurVbyGD/T3H7TJtk5BTR",
	"ypLZKIq+x9vIHpNd7qOx72ps+E51mUzIG+H6U5Q5lTYvDysjKjIvqaRcA2QTT6lYIE3ZevxpzrDwiSQK",
	"5DnIRLEM6uKNVcmjQsI5xshX5Q6bEGxn9BhJ+9ky+dd0FWSGTatrWgu3ZDR7LumKYMFlTRTosUGb+emb",
	"b8ijca295LkZIKkQE2OuS7oa3aDVryK2oemYL6vu9dsDdHHsIRakWvqparOFra//2pz7i5XcLbm7jd0T",
	"59zZ8VM7dkI7gusCsdGCYAU7zM0kqiyKfF1XjjRSnheh4izOzDDUOPAZ+wi2mqajSmgbvXeH+M4IcCVW",
	"0iaoHdkGZp2qg4+ol4c8o3NuMWvur+UuDXxHUiy980iQGeh04RJ2W6iPsCffC7+fNy0ZZ0sD5aPxtUs1",
	"uIvdCqhhE76M2jT5IX0eglxKdOCBjBDxT74trXnMZrYYsq/jfurKQKFrylWWrTpfWeXb9sJz8fw+r7eg",
	"jU5e26F8UU/eFcgQLfvwf94heDcEd5jjd64mgT1ebhF/hoh/r0om5I2o08Zdm/8/o+vxOm/2617QG8HB",
	"+tiN5Gtp8c6dWokdhnFYpPh6IVZ/qRouX1oEOVhQtdgqh/zdvLRFFhlye5vJvsgr/O8OSxtuGbO2ydZi",
	"CPVoQ5izedFWRG+2AL5FLeZW+OlnqNrcBse6GRaDh9TzGScW8P0yHSzBY4n5oOr+2seB4g21B3MjLaow",
	"tGgP7CnkwpVp/PxY0cbW5lG8RKikajUe7yf+1zu7L7C6j1F5bQSkq/ekGE+BKLEEVBmMjL5kSrlgyWeP",
	"/nZzEGq29C0UeZi7esvc5fmjpzc3/QnIc5YCOYVlISSVLF+Tnzk9pyzHDlxX4HbYLb2qv+atwdEG+eht",
	"atYFS8MiRpdngo3QtY96xbJP25lhUCJ5Rz7IeMAHw2rJtCiAysszwO2uq3aXvuOXYXRwo4l3VVErAopB",
	"0Y4B8v8xGmh3wrR3MXOXX8ktoL76l2MTLnRXzMZVcIyRAsTskLznD4la0OePn/z25PlX/s8nz7/qsZyZ",
	"eVzRnq7trB7IPLbDDDGgfdHmwP1K7RV+D296t3fbxPGIZatom19YBU05mg3anFh2T5GCrnt7gfe01a+k",
	"gXDYJRgxXi1YcfPFDpVm00VUv/LqT9WN8ph/W2nBtiKfEb6L2yhyNx5pCZBBoRdba1/iW/VugquCyZTr",
	"42IrFI4Jm8DEFvCr/PyQYcdto1FTkgOdVX2NhRiSPBHwGUNonioCrIcLGaKTRukHC4YgUd68clonGdiL",
	"ziNPtu6cWxV09W0pqQnqqMC9YNNEy+3JlNiKehy4uwsptEhFbmNXyqIQUlenW00GiXvQ57ZrSHt9hLuT",
	"MJdSnS7K4uAj/gcrfH2qEw+w9rE60Ct+gC0nDj5uDBFAEHNz1qUtm9yQS6PtP7tqMn5el2j+XshOk+Ft",
	"IQCtEzNuHyLbPgNjCSLy2fVIZ39poWaj/t/a8KubtCMjdg5wlVcX9I6qaDco/O1T5WwXtAgJ37lgPq8F",
	"1UaRGeMZocE2tnQ3IWtGcM2Gkete9G3YWW7e7/T8Cz5nb4Qmx8vCNneG7GrRO6TN4fztsfG63U0wcFd/",
	"N8Sne+eHN74PTKys61sv+B0cckEqNvjpqMTcaHNXX4/t++4m/7xv8he+5HCDDO/u5S/nXpY+nPLuCv78",
	"r+CnX+xqrtERM/BK9jfRpa/hWhPf8ULuCAOuLWjLFb7JT4Oqd3uV6nshfXuLu1v8C3Uy2J0cnLQ0xEKz",
	"LZXJTbmP0NnPCvphdoY8j1ga+g7q2Pb60QtgWHRGpAzrhx9namwPsTNOuFN8J/h81oJPsNd3cs+d6eEL",
	"Mz30SDlO67fN9rcJGrsKQOdLkYGPOhGzmSvy1if9NHvPGPJUmi4LYr+MSjnojT1lSzgxb/5kp9jrFVuD",
	"3RKLWuAZZClIBc+GtMd0o172HkI3bj8AN+4BrXbAw+LSvyeXJtl3QQ2ZDiWQNvIV9gzyxe4cMjI4J4YA",
	"J3sg24OP9l80pxVCRVZz4gm4szH33bbY6n123AaA5C0KobYMoP9KzMgjW8Sv5JipUzcHpDwjWq6NoOpr",
	"lkigOUkbEfoVHN2Tc9J7craqAp3V9awprguI+oTuM5y1lR31440fgBe21T/uUxtBWhBKOMypZufg49Yn",
	"dxn1l77NXD77BgY4JjTL7GmsNwHOQa6JKqfKyDq8GWh5TzXPyw4MA1YFSGauaJrXDnirJhzYdPlNAZUn",
	"9o0rXlotXmST9GUzCsjfrC6FX8zIa5ZKcZTPhfJxXWqtNCw7rffcp7/1FF31hoRuDJjgOeOQLAWPNYT7",
	"CZ++xoexr2076J6PT83Dvm9b920T/hZYzXmG3MlXxe9ncvqvlKvRWq2EQkij3U5tk1pL/zseJX9o1jzt",
	"nqQ1TwOnlnsYDBS2j2v8fPCx8acrluHeVItSZ+Ii+BY1exv0MyRPPmhUfQlLWqvhs7peW9p1+pACPMRO",
	"TPU00voraEfe2/3rL5of4lwuIZFg6GYqzkGqlnp2lyTyp0oSGbzvO/FY2+pyG0cr1X4lkjciAztus9Ns",
	"rD4zFxm4jpxdQaQKdowH1vtbqX6vFeqc0nK+0KQsiBaxoOr6w4SmlskmVr2JTxhURLNKEE63oOdAaI59",
	"TskUgBMxNYuu70dcJFVYk85HZruQzqgoFMBVSJGCUpAlvh71NtCqPqcYx6034AkBR4CrWYgSZEbllYE9",
	"O98KZ9UnXJH7P/5iFOYbh9eKgpsRaythRdBbVdtw0l4X6mHTbyK49uQh2VEJxIsGmEgilkUOLpUkgsKd",
	"cNK7f22IOrt4dbRgrgW7Zor3k1yNgCpQr5nerwptWSTm/u6C+MI+PWVLlMQ45cLbFWOD5VTpZBtbNi+F",
	"a1FmBQEnjHFiHLhH4XxFlX7nsgozrEBjrxOcx8rYZop+gM/7+tGbkX+putF3xk7NfchVqaqW9S5TALLY",
	"GjisNsz1BlbVXJjW6ceuUhGshW/byH1YCsZ3yAqKchOqA2++GS6yOLQ/Umeg6KKyAUSNiE2AnPi3AuyG",
	"bvweQJiqEW0JB4uMhpQzFSIHym1GlygKwy10UvLquz40ndi3j/TP9btd4qK6vrczASpME3GQX1jMKjTQ",
	"LqgiDg6ypGcuk2Tumix1YTaHMcEM8GQT5aPJ1rwVHoGth7Qs5pJmkGSQ04gp5Wf7mNjHmwbAHffkmZwL",
	"DckUZkJCfNNrSpa9JqJqaIHjqZjwSPAJSc0RNMpzTSDu6y0jZ4Bjx5iTo6N71VA4V3SL/Hi4bLvVPWYp",
	"M4bZcUcPCLLj6EMA7sFDNfTlUYEfJ7X5oD3FP0G5CSo5YvdJ1qD6llCPv9MC2ua88AJr3BQt9t7iwFG2",
	"2cvGtvCRviMbMyB+kcb+duzSNVZ/aRpQAwVwchnl9uCCMp3MhLSCdEJnGuTWgPh/UObd4c41oIWrTUBw",
	"BHdvunGQyYetLhwXsSAQd10YEun638xU3ws5qMRms5AMZZqUXLM8KDNeqcqfn8HwzghwZwS4MwLcGQHu",
	"jAB3RoA7I8CdEeDOCHBnBLgzAtwZAf66RoDbKpqbeInDlxLjgiftqERyF5X4pyoyWd1V3iiBZowLyrTr",
	"munz/d2Tq9XY1UBzxAHLoT9O2oZvnn539IooUcoUSGogZJwUOTW6Aax01cOt2R3U9y22jSBt41Gq4OkT",
	"cvL3I18Lb+FqtjXfvX/k+n8rvc7hgeuSADyzoqhvlwDcIN11S6D+TvC93lznO5ZjjLki3+HbL+EcclGA",
	"tGW2iJZlxORzCjR/4XCzxeLzDzO5C1r93Yz2+7hhaHJoW9LCy/l+rVQRanMXycsgm/H3Gc0V/N6X0GjH",
	"W9Ii1m6tuvmsLQi5ybciW7dOiNm1A9zA5tmoK+IxTuU6Um+pm0zQJg0tDL9yhNU1Zn3ae93GLtF2yWwb",
	"hcXEdQkqeo43UXm0YGG1YZ2hbMrrrEUno1i2ZrtK36gCcEgI7CkmHNg9Ie/sd7dbFR4hckesZuafTeRg",
	"882KaeC7RotwrOdLjcr3iI+eXjz7Y0PYWZkCYVoRX/px+/UyHq0SM9IceOIYUDIV2TppsK9R4xbKmKJK",
	"wXK6/SYK+adrMOwuH/Nk8z11O9fIy2Bxm3hySDSrxDHgHu681jCYN1fYwhEdew4wft0suo+NhiAQx59i",
	"VqUW79uV6dXTrO8Y3x3jC05jSyJg3JXKbTORyTUyPrmWJe/ned+tIC0NcOFJvo/mefTJwUo3HJsZTMv5",
	"HBsld5x0ZmmA4zHBb4kV2uUO5YK7UZAdvGqeedV07/ZwXe4SZGDf9zUOH+B2UL5Gb8ayoHztfb6QKLYs",
	"c4tD22Nuv4zWVrPtRgKgP9YZ//rM2m+9zS8w3rqrtvm7RQu5oIrY/YWMlDxzuUOdmtcrPrxiiB36dMVr",
	"Nr2xOohdb2R1bt4hV4Tf5WbStiIFyESvuD1QzU7qtra2PbmTuwaxf41rw6Z8Qw+D7daJrhnCnm4PGfA1",
	"vD6CbiB1MlyjRwhaLfpTR8LWIPbNvUaPdIZvBpHUJhXnJIW8INR3708FV1qWqX7PKTppgoVNugEm3hrd",
	"z99e+FfifsKIG88N9Z5TbO5euW6ifG4GET/F9wCejapyPgdleGVIJDOA99y9xTgpudG0xIwsWSpFYhNR",
	"zRky8snEvrmkazLD+h+C/AFSkKm52YNdtwZjpVmeu4gWMw0Rs/ecapIDVZq8ZobLmuF88YEqlAv0hZBn",
	"FRbinSLmwEExlcSNLz/Yp9iMwS3fG/nQYGkf10XUb7YLg4edZb2QH780cFOsXZwzpesgiA7sN+YAXzKe",
	"RInsdAHExYS1aYvcx4ppjoAeNL1DegHvubnhtCDI1am+HDm03Tyds2hPR4tqGhvR8gb5tQ5S8fbCZUiE",
	"ydy5Vv5EqZkBHXj3JW68rUbf2vsd3SiNKxd4Zp72XMj2qWve1fOSUxIahrBWORj3xmkD5D9v4/cP16Mv",
	"ejTuTWPsDthlV832TIg3v+FjQnPB57YKodEgBe4T40WpMbD6Oo10cE7zRJyDlCwDNXClTPDvzmn+U/XZ",
	"p/EIVpAmWtIUEms1GIq1U/ONpdNtF2nQpG65hIxRDfmaFBJSyGy9LaZIrWxPbMUCki4on+OdK0U5X9jX",
	"7DgXIKHq52X02/YQ8XonK57Y2mtdGI+INVSG5WmBpotIfxS8mYxC7SnBlpMYojJHWAFW1uzToMejXgnZ",
	"IPW8DmyzyGnyhwHXf+MiD/BTT7yPUqR31HpHrbdGrbGSf4i6WcsGYPEVbss1G4uuu8DlDdqebqX67V0J",
	"+T97CXnPgRShRNKG1B/vXUYVYZpcYIGfKRBz8ZRo83Ytzp2GPCGGIQX2fVsJUrnOm+mCMu6qw1TpAgiH",
	"dt2BtW9HeC3mQsvM0E5o0AFpKZleo55AC/bbGZj/fzCCtgJ57lWIUuajw9FC6+Lw4CAXKc0XQumD0adx",
	"+Ey1Hn6o4P/opf9CsnOj0Xz68On/DwAA//9hAcGdjpABAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
