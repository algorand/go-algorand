// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context, params GetSupplyParams) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSupplyParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx, params)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
