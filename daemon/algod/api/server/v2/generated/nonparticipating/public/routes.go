// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "lift-log-limits" -------------

	err = runtime.BindQueryParameter("form", true, false, "lift-log-limits", ctx.QueryParams(), &params.LiftLogLimits)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lift-log-limits: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
