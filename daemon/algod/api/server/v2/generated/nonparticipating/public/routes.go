// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
