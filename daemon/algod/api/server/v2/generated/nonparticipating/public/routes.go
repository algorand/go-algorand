// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Get the block header for the block on the given round.
	// (GET /v2/blocks/{round}/header)
	GetBlockHeader(ctx echo.Context, round uint64, params GetBlockHeaderParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Returns the proposer address. Proposer address can only be set in dev mode.
	// (GET /v2/devmode/blocks/proposer)
	GetBlockProposerAddress(ctx echo.Context) error
	// Given a proposer address, adds the proposer to every subsequent block header's prp field.
	// (POST /v2/devmode/blocks/proposer/{address})
	SetBlockProposerAddress(ctx echo.Context, address string) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetBlockHeader converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHeader(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockHeaderParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHeader(ctx, round, params)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetBlockProposerAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockProposerAddress(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockProposerAddress(ctx)
	return err
}

// SetBlockProposerAddress converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockProposerAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockProposerAddress(ctx, address)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/header", wrapper.GetBlockHeader, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/devmode/blocks/proposer", wrapper.GetBlockProposerAddress, m...)
	router.POST(baseURL+"/v2/devmode/blocks/proposer/:address", wrapper.SetBlockProposerAddress, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
