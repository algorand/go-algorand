// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get boxes for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", ctx.QueryParams(), &params.Prefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter prefix: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "values" -------------

	err = runtime.BindQueryParameter("form", true, false, "values", ctx.QueryParams(), &params.Values)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter values: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"1ezQAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
