// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
