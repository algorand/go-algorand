// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"+fTh0/8fAAD//6Banry0iwEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
