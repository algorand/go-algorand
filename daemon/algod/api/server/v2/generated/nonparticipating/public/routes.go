// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get a list of applications held by an account.
	// (GET /v2/accounts/{address}/applications)
	AccountApplicationsInformation(ctx echo.Context, address basics.Address, params AccountApplicationsInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get a list of assets held by an account, inclusive of asset params.
	// (GET /v2/accounts/{address}/assets)
	AccountAssetsInformation(ctx echo.Context, address basics.Address, params AccountAssetsInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationsInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationsInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationsInformationParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationsInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetsInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetsInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetsInformationParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetsInformation(ctx, address, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications", wrapper.AccountApplicationsInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets", wrapper.AccountAssetsInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9e5PbtpIo/lVQulvlx0oa23GyJ/5Van8TO8mZjV/lmeTc3dg3gUhIwhkK4AHAGSm5",
	"/u630A2AIAlK1IzGj2T+STwiCTQaje5GP/8YZXJVSsGE0aMnf4xKquiKGabgL5rnimn4Z850pnhpuBSj",
	"J6NjQWiWyUoYUlazgmfknG2mo/GI26clNcvReCToio2ehEHGI8X+VXHF8tEToyo2HulsyVYUpzWGKfvt",
	"L8eT/3kw+frdH1/+7f1oPDKb0o6hjeJiMRqP1pOFnLgfZ1TzTE+P3fjvdz2lZVnwjNolTHieXlT9CuE5",
	"E4bPOVN9C2uOt219Ky74qlqNnjwIS+LCsAVTPWsqyxORs3XfoqLHVGtmetdjHw5YiR/joGuwg25dReOF",
	"jJpsWUouTGIlBJ4SfJxcQvT5tkXMpVpR034/Ij+gvYfjhw/e/69Aig/HX36RJkZaLKSiIp+EcZ+Gcckp",
	"vvd+jxf90zYCnkox54tKMU0ul8wsmSJmyYhiupRCMyJn/2SZIVyT/zp99ZJIRV4wremCvabZOWEikznL",
	"p+RkToQ0pFTygucsH5OczWlVGE2MhC8DffyrYmpTY9fBFWOSCUsLv4z+qaUYjUcrvShpdj5610bT+/d2",
	"yKyoctZd1wk+IDTPuf2JFoQbttKEi8YCp+QnzchvwJ30bxZaNySZV0XROLY1ByN3F4Wc0YJoQw0bE4R9",
	"TJjJpvem5EVVGF4WjFzQomKaZFSQGSOZXK3oRDM7jrFIexbhSDFTKcHFgkhRbBrznjzThIqcFDLzU1ps",
	"snVZSLv0OS00S2PXoydGL6AhxjOuPYHf8ANVim7s39psCr9r9u+Cr3iCqF7QtT3QRFSrGVNEzi26myvt",
	"owccMYZ3K0eouDBfPW6zgfrXFV13wTtTlcjsFkQAGkWFppl9A6DMuS4LugHKXtH1Nw/GDnBNaFGQkonc",
	"bpZZC923FDv3wRYi2DqB6LMlI/YJKemCRXhGqjb+qZHnTITDSWYbeFQqdsFlpcNHPeuAqRMLiY6hkpVI",
	"yQkCDxyae0QEfntI+fAGRny//ZnmC/eoDfUpX5xtSkbmvIDD/s9Km0DAlYZtXzKiS5ZZ0ZcTO4xFvuYL",
	"QU2l2JO34r79i0zIqaEipyq3v6zwJ2APp3xhfyrwp+dywbNTvujZgQBrik1q+GyF/7PjpTmlWSdF+XMp",
	"z6syXlAWnwVLKyfP+igDx+wnjbR8Og5qG+yPG+tsffKsT6Jt/8Ksw0b2ANmLu5LaF8/ZRjELLc3m8L/1",
	"HEiLztXvI9Tu7NemnKdQa8nfCRNgq8eovh7XHPyNe2yfZlIYhppIxOOPQNY9+SNWXJUsmTIcB6VlOQH+",
	"PwH+b3/6N8Xmoyej/3VU69lH+Lk+iiZ/br86hY+sLqSYZXwTWpZ7jPEaJUT/Qbd8CI/6XCpyueTZkpgl",
	"t9IWNxHUXstpCnZBhZmO9jrJ72Pu8IsDot4K1FFwK1oMqHcvCL44Yxpo39057uiG5I0kLkjgWOqTu8dl",
	"WSMXnh+XJaJqTPicMA7qFFtzbfQ9wAytD1lTwk/JD/HYl7woUBGYMSd3WG7HRL7t+Li7/1jEwhrqEe9o",
	"Ajst1dTuWhcN+qTemMOQZ7iwKKZlpTJ8EJSNrZSW2iUYI6WDWHE0AYnWpcOfNEMSLOmCCxhqbPVaQVb0",
	"3DJuKiRsiiUnpoPCisSKYvKSm2UtOoPSNyVnTXHqsA6/NDfT6g+VZoTiGzUsJKuUlmo6Sqhan/3JSpEU",
	"sfREuVWaSMG1sVIyxlWgFTwd4e7foFp7mTsEjcJVdCkLq7jtJEn78t/duzHftL8P+viz55kx2vu5JZgB",
	"HFKBB+Iv8V2pxQq7nBC+sDzwuP3t1figHaWHA9pHh+Z9MV3tz/RahPapcLs/EYvq2/Mkc4KXyZIVcE1K",
	"c6QrEc0AWtiyiADzpaIlkrl7grcPLgitbRoA6zX1z4GqYRLm2NZZ4x2gujIz38lwk5CglbIJw7eFzM7/",
	"TvXyAId/5sfqHguYhiwZzZkiS6qXiTPVou16tCH0bV8EmiWzaKppWOJzudAHWGIh9+FqZfmUFoWdusvN",
	"WquFgQcd5KIg9mXCVtwYKwDQhrfgF0wg65mS72i2tLoFyWhRjGtjpiwnBbtgBZGKcCGYGhOzpKY+/DCy",
	"v97DOfImOhKtxhlCQQtUbC4VmFcUIysKwmnlbX7xN4G5arpibSXRCktZGQtjdN8+eeZXxy6YAJ4Uhgbw",
	"wxrBTBUPPrVzu0cws5C4OKoYWGedNTDv2kBjoO3btagV9RRS5WAdpsb+xhXJpMIhUPi7ye0/GFX1x0id",
	"d0vFJm4IRS+Y0rSwq2st6l4g30Odzh0nM6eGRifTUWHaDoGcA74DpZCphE3uVenszfaxVXAsJdXUw0FP",
	"AZ0m7AfIbIsqnMm+YPmWkWSFxnZS0ux8Lyif1pOn2cygk/cd2vfdFrpFhB06W/NcH2qbYLC+vWqeELRU",
	"ena0w2idWjvONQQBZ7IkyD5aICCngNEQIXJ9cLH2rVynYPpWrjsiTa7ZQXbCjjOY2X8r188cZFLtxjyM",
	"PQTpdoGCrpgG6dbwndpZav/W8Uyqq2kTHX9m7bUj1I4aKVPjFpLg1aqcuLOZ8KnhC62BSDCKblcC2sOn",
	"MNbAwqmhN4AFbUc9BBaaAx0aC3JV8oIdgPSXSSVuRjX74hE5/fvxlw8f/froy68sSZZKLhRdkdnGME3u",
	"Ous0AefYveTFCbSL9OhfPfZe1Oa4qXHQWLKiZXco9M7ixRhfI/a9LtaaaIZVBwAHcURmRRuinbzB796P",
	"R8/YrFqcMmPsJfi1kvODc8PODCno4KXXpbKKhW56sp22dJTbV47Y2ih6VMKbTOTor7fr4NreAVezgxBV",
	"38bn9Sw5cRgFN+32Q7HvNtXTbOKtUhtVHcLywZSSKimCSyWNzGQxsXoelwnbxWv3BnFv+O0q278jtOSS",
	"amLnBrdtJfIeE4VZi+HyC4c+W4saN1slGK43sTo375B9aSK/voWUTE3MWhCgzoblZK7kilCSw4ega/zA",
	"DOpffMVODV2Vr+bzw9hIJQyUMPHwFdN2JoJvWO1Hs0yKXO+05ngfdguZbqohOGtjy3tgTT9UDk2nG5GB",
	"GekQZ7nf+uUc1ERvRBaZwiyMBcsXDVq9UZNXH6YQijs6AanF1HN4DH6sZ6ww9Hupzmp19wclq/Lg7Lw9",
	"59DlULcY5ynL7bfeoszFomANTX1hYZ+m1vhRFvQ0GB1wDQA9EOtzvlia6H75WskbkKHJWVKAwgM0LhX2",
	"m66J6aXMLfMxlT6A6lkPVnNES7cxH6QzWRlCiZA5g82vdFop7Qn1swc1q5RiwsR6LtgzuCYzZqkro5Vd",
	"bVUSI1Pypf5wQjM8oRNAje4JzgkBRvgWTrekF4zQQjGab8iMMUHkzC66js2BRVJNSqs7O7XOqcRD+W0D",
	"2FLJjGnN8omzZ++E17+H8sdsQR6sBlYRZiFakjlVN7OC84udwJ+zzcQF39398Wd971NZhJGGFju2AN5J",
	"bUTbfNddyjVg2kbEbYhiUkZrIZ4Eq2JbplMww/qQfX3s9W5/G8wOEdwQAi+YgjiwGz1afpIbIMoA/w0f",
	"rBtZQlVOrBrYa36wmqvdb0GF9LrhjhnCBAXVZrJLpNiXGnYTu9SIi6ekCAzco08+p9qAGki4yMF+i6IQ",
	"5kHd0k4x2jMUEqbsvY3ZSX/2F7HutJkV70JXOtzKdFWWUhmWp5YHPuveuV6ydZhLzqOxw9UPw2d2jdyH",
	"wGh8h0dnCIA/qAkeaufz7i4Oog6s+rLZF8sN+GocbYPx1L8VIT6OxO+Bket6D5DcuG7R20zKglGBcduy",
	"LC2HMpNKhO/6MHiKbx+bn+p3uySJbiDUVHLJNLiY3PsO8ktEOoavL6kmDg4fnwAGLwzs7MJsj/VEc5Gx",
	"ybbzApdg+1Z8cK503KtyoWjOJjkr6CYRbYGPCT7ekzD82EAgtf1AGjaZgTcxTSP1mfBR0lebVcJUOqV4",
	"E3hCMnvO7TWqJjX39dUnzRlMm+KbjljvhFkAjCQd+PEAWUhPiRFB9l9IY8nKER2sxkmla66lB3th1htB",
	"IIw7qQ0B7dn/m2k3d1DADjr/hum+hddTH2rZPeZ/kO0NgdkSZS1pkxQRvXx5B2Ps40E9vojXVBme8RKu",
	"qz+yzcFv7+0JkrESJGeG8oLlJHqAN/ky/p5g8Hx7zKvd5geZW7vgd+ytieX4yKwm8OdsA2aT15iHE1mr",
	"DmGOSIxqBS4VBAD1uR72xhO/wtY0M8XGxf1uyCVTjOhqhlErXReakeUkHiCdaNk/o3PIJ93hWyMETmGo",
	"aHmpyEO8bW2H76x15Wqgw92ySimLhP2zfeI7yEhCMChciJTS7jqnRbEhJiR7eUpqAOkEBERjBH3mjm6g",
	"GVZA/ltWkMlnKbsyLChpUoHmA8qyncGqm2FOF6paY4gVbMXwNg9P7t9vL/z+fbfnXJM5u8SQGwEvttFx",
	"/z6Y4l5LbRqH6wDWbnvcThJCB3yVkKbognBbPGV3kJsbechOvm4NHhyc9kxp7QjXLv/aDKB1MtdD1h7T",
	"yLAAPxh3kPuuGRLWWTfs+ylfVQU1h3BUsgtaTOQFU4rnbCcndxNzKb67oMWr8Nn78YitWWZpNGOTDFKL",
	"B47Fzuw3mI08gsRebg8wpjsNBYid4Fen+NGOm3Ydt8xXK5ZzalixIaViGcPcTqul6rDUKcFEn2xJxQJu",
	"QEpWCxfqjOMAw680WsJUJTpD7KuKmbWYgAtDJ5MrwW3pU7StEsaovdm2/R94WbukARQURoOEdrQ9bX9Q",
	"0mU6HvVe/C2+L+qLP+KtmWd+VWdiQz+MkFZDM9B7Bvi0ulIXifE22sNnieFmvDT10CkouxNHQeH1w764",
	"8NOqLIvNAZQkHIgoViqmQaTFZkCNT+WcvOCZksfFQgaZpzfasFXXeYOf/tpzXN9c5QYsRcEFm6ykYJs+",
	"9UUbes7qkH9vnIUQWvQzkVcwDKGGNIAcO5MycgtpdwL+29VV0QzK1iVc02aVs4taxWHDDNpHV1Sds5zI",
	"+dxONh1uCHWLhHUk4lERdlwlMCe7yoVioIhYTmVvcvFt2S+Orf3iaqQMWd8eoKNOs217XsCzq7GFJkW1",
	"qKGFtyYsQ9jFdQ8AHMc2X217kfX3Uh0qggEHHHxfGxAVsDNkxk151dgFWhQJdz+adjocWo9DwD1XhGot",
	"Mw5K+Emuxy6yHyMEMGWghf7XIe3sAMyxPW7Lrx2luKGThBUloSQrOLhQpNBGVZl5KyhYUaOlJgIxveGl",
	"3+T+1L+StvEnTPBuqLeCQhBusK0mg67mLMF2vmfMW951tVgwbVqX1zljb4V7iwtSCW5grpU9LhM8LyVT",
	"EA05xTdXdEPmliaMJL8zJYGRNq5zq0obog0vCudkt9MQOX8rqCEFo9qQF1ycrWE4H6Pjj6xg5lKq84CF",
	"PfjYggmmuZ6ko0h/wKeQsONwsnTJO5DHgo99NHldrGdk196oIvR/7v7nk1+OJ/9DJ78/mHz970fv/nj8",
	"/t79zo+P3n/zzf9t/vTF+2/u/ee/pbbPw54qD+EgP3nm7B8nz+CSG+XgtGH/FJxdKy4mSaKMg7VatEju",
	"QgEjR3D3mjZVs2RvhVkLkJa04Dk1BySfttTqHGg8Yi0qa2xcy0TqEbDnVfMarIokOFWLv96IrtyeYGsw",
	"U7zlrfwNxxn1wQF0A6fgas+ZClm+88N3Z+TIEYK+A8Tiho6KjSRuhy47tBFBZXcpTpp7K96KZ2wOd20p",
	"nrwVOTX0CE/TUaWZ+pYWVGRsupDkiU84fUYNfSs6Yqi3ol+UMB6V9EtxCrpKr+Xt219osZBv377rxHh0",
	"dSs3VcxF3TnrmiD9lBOrN8jKTFxZp4lil1Sl/Ey+6I/LNIevt8KBOoms0EDoy0a58adDoSxL3S7/0kVR",
	"WRYWRRGpalfBxG4r0UaGpDzLzF1es6WBl9IF7Ch66c0JlWaa/Lai5S9cmHdk8rZ68OALSG+si5785nig",
	"pdtNyQYbFXrL07RtCbBw1MshYH9S0kXKH/X27S+G0RIoBBSOFdzii4LAZ80ybi7LAoaqFxDyvPfYEoRs",
	"75xpWO4pfuXrLKYXBY9gU5t56dfawajiwJU3cEfVAlqZ5cRyhOSqtD0Gfq988Qa6sCLHR2dovoALgF7K",
	"yi6ZkWzJsnNXapCtSrMZNz73QUROFnuGwzVceV3i5Zxb/LlyfFWZU6fIULFpF73SmGgCg75h52xzJvHz",
	"6cByjVF50Kjoku47ukC7kaxtFkpxxSxYZ/MjAwQtS1+gCHJaPVk8CXThv+k/2q9dGcRrH+sUUTRqqPQh",
	"gqoEIpD4e1BwhYXa8a5F+qnlcZExYfgFm7CCL/isSLDpf3R9Rh5WS5WKZYxf+IzpMKAmfE7s7WiG4tjd",
	"mBQVC7BJWUEsNS0gIWKaDKIA7XDJqDIzRs1WW7iIS3h46EAhv4SEdDCajO0S2NruNzdgBBHs0l7w4O4t",
	"g8nJVHp6pVA1XBPLrwiq/7xOQJ9e5RLhEJ6ocOnlfdiTcF9wsX8xdQLI+BxsbgslL+1uWgClr6ULxXMi",
	"OVVpumBDxVHDIjew3EjDuwaD7NJ+kvqOnLfVmo6OMXAR+PnE4iXJHZh9YtkDWDFb4aN+bnTPOo/Nq6iW",
	"6qwAhToyZVrSoaphzhSL/YBNszGmRK2sesCaWIuP/pJqf/QbJuUraosfp0zPtoqaJ1FkIzXdepleTLdZ",
	"+xjtOTNGpLBf+Lqavpimr6A5Gu9VDXM8cukjqb2TArTonBVsgThxPgBHZ3Xtq3o3LRyv0GxPJqkgycgY",
	"GWkmbg5mL2L3iXcyDB4hdQoisCFqAQYmL2V82MViHyCFq91F/dggu6K/WToREzMdrJYsSyv1eY9HMPMs",
	"hTbLLet2+DgMQ7gYE8tJL2jhvBemMUineiPcfVq1Gl3czL2+O9HAg+bWCNrJXqtEfeYq64sVb7+M9K1g",
	"rzXM5HqCWefJq9VsPbNnIpkLAjnwqcOLtTTvaDKTa/QRWQmHyQN7Q9cPmQcsCrFZcw1UDt/1qY0I3n6A",
	"bFfkU9SsgfScXS2QXZ8mezVgetTpPrK7G5UnPBBILQNm3ZfBWXR22lma2lZXE6nF7TjUiw4pgClW03c4",
	"kzvZg9Gu8XQ82lKqtM8El3h3UPFZXxuT3G2XocWC7T62LOLVwCqw6uGuerNd+92hKwz3Gv3R4B9qHnn4",
	"Pf8z0t4tPD22CtvurZRYIZVMwfhHlGMR48YqY8CP3Zfp+xTvUbC6WN63KYerxr9/cebWIeT5VgKODTi9",
	"lBsLmw9SAbRLldcp2oofD0RoXLO1zc8aQGzB6uv2LSyJ1mZUYxOvEdZSMtVqKl1vbRdtmhUMTFmTxsVw",
	"cp4Ks3j79hfNQOk99Z9FhnrYPSo296JQWcUWXBtWe8d8BNyHd14Cs5qUSsp5/+pMqeZ2fW+kDJoyslP4",
	"sLHMD74CyGuZc6XNBFyLySXYl77XYAr+3r6avsk143K4Rl/l3jwTIDpnm0nOiypNyg6kH59ZiF4G1UtX",
	"M9D0uMBQxBk010lG7+/hXAd4MOtjK4KeI4Ke0w+Bn2EHy75qYVKW8prTfyZHrMULt3GWBC2niKm7ob0o",
	"3cJro0IbXUYbSeEobmi6zWnZOZe5H3tnqKYv99GnBeNIybVE5VLT2cVysWC5LwPpMsaxJJ4rtllIsagL",
	"jdrft9QWnRIs8QkVOrcU93S5K6wvc6XRoAw0l53aEEBep95CYVKYZMEElnW6grJUJBEXZ83AG5Fp/8Py",
	"9k5OTTKv4KyVS1AH/OMehs2G7SkYzZ1dQDO/vu2HtrtdDnXjvoyERv3o7QcMBgSK40ZHCkyHaHo4Ny1L",
	"nq9bnmsc9VPUn+sPm8kGO5r+3bFCEd53TrojuGwdzeQaWZSzB8GRoJmrQJJXCrygjQyC7r0tGEgGLvnH",
	"n0+NVHTBnCd7giBdawhYzj5oiG61mhiOSRM5n89Z7MHVV/E+NoDr+OnyAfTcQ3ldN2+wiWwly71pq17B",
	"boSm6SlBKX2xQmddP7q/b0Q24SBjWn3o9nSGJ4uM/Mg2k59pUdkLEFe6jql2ju2mNN+DJi5WP7INjLwz",
	"VNkCtmNXwNLxhgGFpiw+4ZGOOgfc0Y0+Qr7RSdOmMXCnjtO7dKCtcU2h+o9GLZgaJqmd5pkDHZs6tMtC",
	"OmSvTtPRUvZssea2tAl91xYNMQBFN494Kg5RR1eRbaH6zs6oSEYLT/iw2NH78eh6cUpdFhZG3LETr4NE",
	"Tu4CRBFj3EojWHHPDaFlqeQFLSYuvqtP11Dywuka8LoPB/vA16r0qTj77vj5awf++/EoKxhVk2Dh6F0V",
	"vFd+NqtCA/V2MYQtGoINmDdM43UZ/TgC7BLaMbSMaJ2ubXW8X3RQXUTYPJ3hsJNvutBEXOKWEEVWhgjF",
	"OpICAxSbQYn0gvLCByx4aId6h3C5w6z4ST4RD3Dt4MbIpXDtsTT/nU0gNFr2BBbqgF8nGV0oNbe4hARZ",
	"xDZiuU0bL759s//m9ybdvH37y4UHp3ZOYtRh6N2RCEzVV0wb6DDANAOpD+AOtg3IfwUll9N3QOEKMgO3",
	"dtGb9ODK6fdSNaSnS79ORn/enNZqbziIx3SEy5kLaenoqlOCeu1vi98sw7p/P6a4+/fH5LfCPYgAhN9n",
	"7ne43N2/n4yySJodLR8Fq6KgK3YvJBn1bsSHNYkIdjlMhzm+WAXFXfaTYaBQDOP06L502LtU3OEzd7+g",
	"Xy+J0O6Jijcd0R0DM+QEnfalT4dMghV2y9ZEinaxEEjnt6QF8tC1GsKgle4REtUKgjgmuuBZOoJOzIBD",
	"CoyPty8TeHlwQIado+I9SRqi4tHo9jV9pfiB1kKiWZMI18mS5TV+Z9KxgErwf1WM8NxeLOecKRABLY3B",
	"389g1I7Wn7Z1uoHRjVkPP1TDt5/ta7/a4q5EIHtR1ev1fRY8kX79qT54e+YMxTN2eP6WfB9HSF5qQnLo",
	"0oXf7ySorXfO4BhOGoKcJ9pzTef07b+suSbTuIfPhmww15O5kr+ztMoAfspEaSHvYOfgA/idiVRcQpt/",
	"hegbv9549l0EMtzO0Ucq17Zr+EWHrp5Xkdxp9rDfRu9pwIj2u9+EodPtD9wm9F2a4+CtZjJaDw+DAxul",
	"VkDcjQ8ZpQJPKNbdaWRvps95nGx9hOPX59zB3ElQL+jljKYasdm7q4Up2v5GcKuRxH/sN0iH0jE4O4ny",
	"gcK7HIuRlkzVDqxuKfcr3kNx2sE30PrCCRQXXzXHGC5TaJkYphKXVEAsLnyHHNB9rRmGgtivLqWCAsQ6",
	"HYebs4yvkob5t29/ybNu9GTOF3Ym38J6blyMlBuIYJVjoKKc67Kgm1AryaHmZE4ejOsz63cj5xccLmLw",
	"xkN8Y0Y1yOUQlhE+sctjwiw1vP5owOvLSuSK5WapEbFakmArAI0zRJPPmLlkTJAH8N7Dr8ldCLrX/ILd",
	"SwsYp6ONnjz8GmIV8Y8HKRUpZ3NaFWYbk8+By/sItDRlQ2YCjmHZqhs1HY02V4z9zvrlyZbzhZ8OOV3w",
	"phNBu0/XigpqEZKCabUDJvwW9heiSVp4EegpYtoouSHcpOdnhlqO1VORwTJEBINkcrXixtfC0XJlKcyz",
	"Vn/8/HDYBd61afRw+YeQxlAmrvYf4ZZFVz1ZwpCZ8hJc/jFax4RiRemC1zlMvoM2OfGV86FvZR26Cbix",
	"c9mlg5oKKU1zUiouDFiwKjOf/M3e2hXNLEOc9oE7mX31ONH/sdkiTewH+AfHu2KaqYs06lUP2Xstx31L",
	"7gopJivLUfJ7dVmU6FT25lukY+T7Qvd7hr62dm3HnfQSYNUgQBpx82uRotgy4DWJM6xnLwrde2UfnFYr",
	"lSYYWtkd+unNc6eJrKRKdeKpGYDTShQzirMLyNFOb5Id85p7oYpBu3Ad6D9ugJ1XSyPVzZ/u5GUh8nAn",
	"7mmhNJnV9H9+UffvAEc75r63jJZSJcyzztD4gSNj9zMTtv35GJEIz3owNxhtMEoXKz0pU5gTFb75GCFn",
	"bZBwzxsW0oe/EWXv8aDr378PQN+/P3aq8m+Pmo+Rvd+/PzxqN20mtL8mUHM1WdOurmu/TW31tzJhtPNd",
	"hkPomiv3kzCsJmWZFakzN8aYNFu5fni94zA5v3tHQqcPkEcNPG7j5iPzV9jMOousnz80u1snyScPz6M0",
	"Dkq+leuhRNQSW56ePgEU9aBkoFUQVtLp3p2M2tgZchSRrR11xgppb6pxg77BETSf0S5Y1Iy37EXFi/zn",
	"2vnckkyKimyZjGuf2Q9/xWtA9EJkwciWVAhWJL/G2/Kv/laduPf/U/YMu+Ii/ajdKB5hb0Fag9UEwk/p",
	"x7e44qawE8Qoaha1C2WCioXMCcxTd1aqWeN0lEB8tw91t04GDLuqjAuMhgIkruHRnBcQ0pt2g8ObE0VN",
	"D1dVkL4+r0dkF1ZPQbMEjs4UoXwFYlvTVVkwOIQXTNEFfCoFa30OVQ9h5KhtEtGlfQRvQgElSUylBJHz",
	"ebQMJgxXrNiMSUm1xkEe2GWxNcw9evLwwYMHw3yLgK8Ba0e8+oW/qhf38AhewSeuMyE2dNkL/KtA/76m",
	"un02v0tcrj30vyqmTYrFwgMsagCOYSvXsTV0aGM+JT9AjT9L6I0WJmAU9RXgm3V1q7KQNB9D0fqz746f",
	"E5wVv1EMUAetqRdgAWwekaSTZ3idYV/DsKf+2/BxtpefsqvWZhKaRqeqkdo36l7XvBWJBbbBGDtT8gzN",
	"siGeBych0PpArVge9ahGMwAQh/2HMTRbgr1zOtpqUu7pVja8xbrngLW7KEq9DQ39gIPbZbgu69hkfUyk",
	"WTJ1yaG2OTXsgjWLnoaKwc4g74ugNlerKiGQcKZ7aK+hfd++u+CBQ9XXh1UkIWvtw7V9f3U1HEje37cZ",
	"/SnWEkimDrU627fCHbClz9o3BZqSF87ZkVEhBc+gGU5KBYdypsPcqgP6BqX9nXrkznLiGCb76YciDw6L",
	"vR32Pcs87SnCED+1+42Eg38atnZNShfMaMcDWT4GAxUvmHPQcaGZCrUJGuWmpUpEfCVTdELkyAHD48cj",
	"qEjYY2v93j576WzzUHfpnAuwuTmkupsgOtgKzcHPLgg3ZCGZdqttpqbpX+w307O1ABDeTZ/LBc9O+QLG",
	"wAhEqN4AEcndoY59fLKLB7bvPrXvut4q4edGJB1O6tf9LslC6iIcXYvIWvSiPxXy5TPkIuSG8ePRthDj",
	"1rQDkMuWDNkFBPyxEuR5h2yYUqmL53f2yor0Bm8QTB5Olt7mIgHGcy68wzddSy5LyhLYGDjNPd/pTFGD",
	"l45BHO+M0aInNQfy+jFi4LpDtTvFWJTAGv0c/dt4thauzU0PWwkv1LcLKjbEHwpL3ZFS8pQWITAflamm",
	"XdpqZ04ZwxhhTPZ16l2arVi2PvHZwQ107cxFDZ9Dt6Z95VRfxd5ZlS+YmdA8TxVd+RaeEnjqkxvZmmVV",
	"aFIYUl2bLQ+61OYmyqTQ1WrLXP6Fa06Xc021ZqtZkYi4fRYesjzsMBRzm22Ib+YyfGdcAP7eCeg+2j7f",
	"r89HN6E+pT1bmp5ovpgMxwTIlOujo576aoRef39QSve5559EanmLy8V7lOJv31nBEZe674T2o2gJlegh",
	"jF7Cc19TL1RDbnIlEGWdPpQQkQGbl9iyFvD+xSTgF7ToKfoQe21QvqIno6/0Q9Zb2YQaVwHSUFLzhCEm",
	"jP4aehh43fIMdd2bfaHVGFl9k84Th4+tSO/3NP7Y8Cti1FvNUHr9iVdz+dVEsK/Pz7Uz6dpLaVHIbDBn",
	"cMMc24/6y13L1cp1j0hE5V2sZB6fhTiai7E0Y8OA5URGBVxsk8/gapV8oi7TozXsI4Fohlb+AzS6JYwx",
	"SdSD54HBqeOJIpOtwyz5nhfQvO6/Tl+9HPVvZLQD3S115eeTJuy+jQlZc23yWMgGPrbwACmKtP1b95jU",
	"oTxV+jS47unJB9+jgXAISFiqaZ+3nw8dvEMAC4md1VK9Z7oFckb1dnjkR9RQby9ylJg6UlTR7liWuPug",
	"0bN+hYRGyYMaJzd0pCEN0lK9uNxNwVtgUdC4knjYoKzT26zDQJ8NUQ47+Hg/Hp3ke6lPqX5uIxwlxWCf",
	"88XSfFvI7PzvjOZMYU+e1HUSO/KsmL2G6iUvsbKl1LzuV17YwVwx/CUMNx2akXO2ZK4wjS9Y0BnLB1Bf",
	"sMxA//o6DFQxNjzOoUwv0ULgHYrwykcIBVGM5aw0y63KEgZ3l2ZZtzVmLuGMazJjznVxwcSY8CmbtnPU",
	"8rouFSkYnXsjrJLSDOj77a0tiMYY6BR9dXrIb1cDO2XnoqqK2Op7OryR0XHICcD8ykuq6+JVrZIOg1PH",
	"53OWQdOIrRUA/7FkIioJN/amO4BlHhUE5CFLENqeHNSiXcO6rRbfVlCjvm43CWlfcY5ztrmjSYOGkh3L",
	"Q2LtVbooAHLQj+sbc+yogct1oCdAkI+Dd00s6j5lV2mkERXIvCIYnsateKqLZl4NGq/RXAEM++mek/ZW",
	"5APFtK/A4GssPh2J8v6b8jNmKC+0CyqloWVDbE8iJ9128Zeu5QPUegzeQt/8gWn/m68Ri7MU/Nx1eQKE",
	"oW/2kqrcv3GQSn0oN3ka6HmYmdeJUd0on33jcjBDMSukVYAmfYmhzUylEMJ7R2OsdV1ADaCeM6VYHnyC",
	"hdRsYqRPs9qj/qhLn9yCPYwyvxLeWhH9e2QK44p6+5C8qZuxQEtVCn1HqAs+j7FCFFtRC72KGqSkzaC7",
	"dugpPvf1TXyLzO3m1T68h3Oxu4O/T72zcqaF+fh0zYlTDvbmXo2iKFewzHIhmJp4J267PYpoVuqE0s55",
	"lble3dHZDNbrwSXQtnCzpFEz666ydYWKinGcs80Rmn1cWY6w4zHQqEMi6FFN6xZRHNRWrVNwLw4C3set",
	"IFpKWUx6PIMn3Z4u7cNwzjPoMV/VmSlWC77TPDZ2EnIXHFIhZuRyufEdS8qSCZbfmxJyLDA70IePNLv4",
	"tiYXd8y2+dcwa15hlyZngZ6+Fek0K+iWpK7J/fwwW3heH2/SzPLLa86Pg1xhdrMWfTFyl9BWqdlrezrU",
	"vNGN72ipUBH5IRQpBeoUHcFPgSUk7lEEirJE1YMgPoAS50AmupCpKPyrFI6xQ6UxFU8GABkmBlxXayjc",
	"4EkEuCC7HRVi3WNfA1XOQ8+P6xSDdfVVkYnrPtNIe+YwS5MzzqVi8YwQZ4q1okNmG5Rahn/MuFFUba5S",
	"srWJqpQZqhfLO6MlQ6BkvZA6WLKLw6KQlxNga5PQoSxlDrDv6abY9r1+6+/sUZ+xKOyS+sYtG7KkOcmk",
	"UiyLv0ineCNUK6nYpJAQhZkK7Jgbe0lYQV6nIIVcEFlmMmfYTDBNQX1zVUJQ0L1YFMqWRAHSDpQMwG8i",
	"Oh44pZW+6J6dgL62s9eH3/wz+w2Wr6hL8eGiJxgi0JNfwLQrBucwhC934cWycVCIqW2UTavIc74GumEq",
	"deTnxKiKjYl7AxWSmITg4FPFyIprjaAEWrrkRQHVI/g6CmgI8UBp1PbozicQB33BIeCtWUkEVerSSsdQ",
	"fiXmAadxITZilkpWi2XUoiDA6a/uqnIX+3iUn3QFMYmQImqneExWUht3LcaR6iXXIaB3MymMkkXRNOSh",
	"nr9wTt8XdH2cZea5lOczmp3fg0u4kCasNB/7kgrt2N16JtWqBznspmDWYgLkoXdXesf3IKrV0fNg3tni",
	"fh3Hwy5LfgTmu93Mdbdf47i7sPa6mnw2fRc6FoQaueJZ+rh9XtGvvTGrKe6VLLCInbyxCg28BnwglmMh",
	"nAm4ZxfNTNBkK+Jj4niEC+sATmT/CWp8e1wyZ44H9cjQLt9xCtYk61UDWwAApFgIwVQK23/HSlpgOHKB",
	"hVMgKKUN6ECBA7F/14PNjnBwoAy7FlCdaOQA4F20YIyxECZGNs/k2j+/V1fKvBLw77dTeYN59AVVntak",
	"pTCs0hey6uEI6WYIWyMQz6AIxmxoHKL2XsKBwj8CoD8ysQHDoPjEfcGYU15AD74euQ82sHF0XXc5ltHo",
	"vicqcvKMVr6bth27UswVVkLtXzXdiSW1pCTD612LuMjZmmGO1u9MSeyFPY7cWazAVtkti4IsJwW7YI2A",
	"TVftqQItlF8w/60OH5OcsRI8vm1DWyoSMe602bK+uLVPoli2IdhNmmMQsbhTZIetJWkZWosJHhM99ChZ",
	"iC54XtEG/vS+KkfTlmiPcgJVnevDxF8xh07zE47gm2bqY/99SpXxmHg3jA/tzYLSqNvGgHZGJle679SL",
	"dGByXMosOIpgtjz4tZHEa76hS3op+q2aXZKvb2ID94lLESH2uzXLQKtxVyGWu8tQj+fE1UACaheM5Xhh",
	"sJ8krPlLJoiQUd/wS6rDLaYu5up/wInhJS7cRfsKPvo6fvj6O0tgMKJbxRbTbX4DWV/Pxv9RTuLWg9g7",
	"XopGNHOpvFtMY5663bUDXpBVkRNh99Pq/tBn20kxx8XHZFb5gYpCXmIj8PiK+ox5fy5Sn3cxObWcB7Hs",
	"46THrs5w2wrCowyRFd0QqeB/9kL6r4oWfL4BPoPgh8a/ekktCTkHMkZRuLhrO/F29WrsAfOGGOmnwnXz",
	"oWNGw23sKBHQVpD7znGSrOg5i7cBAkSQf2bGMk5dzcCoYUV2azu7WHCL9+WZVjSPjQBQaHbT4A6+zrn9",
	"+v+r01bjqXz9x7KgmW/77vrfNfmMVYYCcZklW21Pc+7yNU8C/q2IaJUvk5FfwZq6J+tK5fz0NepqgN1p",
	"o9/pUXatZezTWbquOLIlQXzQUg69C4fJ4ewsKe42vGtxcfPlD7M7yQrRfcsYAv4ntCuN8IpOZptvste/",
	"HnjlQ+xCoxBPAlY0g8/keqLYXO8KpEE7+Eyua4B1sN1ykSlGNcYdnbxy19a6ADIX9hqNUbvBrRpGydmc",
	"i5rVclFWJnELgjrIYhMhLPYmAFp7fHN9OoZVRS9o8eqCKcXzvo2zpwe7E8cNg7wHxX2bMIAEidwdgOv6",
	"Bgj51LV9Pn7Nin9sdoixs9pQkVOVx69zQTKmrNZALulGX91VFbwOu5xVNNKFmtVCIrcVkDYCUmyct/ma",
	"jqQAID2gR2mAJwiCtBNeIDQMGdnj+OnC8Fl4glZ0PSnkArJ+ew6Eq3MNrkO8QEoBRnTU7oat28+j+e9s",
	"+zTQgcQxIiNh1iFTbD/3r2Ar4RL6k+Bm68lHC2c7DRsjnfFgeqSKRZ2egcTSPY+pzHlXmCnOnveqqi9T",
	"4mmPRZuYDInuWNV7dhHiK1zZhdiEPrxxZjOEI5Wfj3aFCdgb9JYEDKbrvAKauQixriGuY6hApIxddYM9",
	"7XRo3fdyqQc8MKRod9ab04YAHTvOPt1Gt9czmJSynGRDYluxSVHunAwO0iaMPfQRuRB61h3ibnRo29Wo",
	"idbo37Vvw9Xe/mG7fGVlts1k0Gdk6uHoTQeGnAMvgyOMpjXItQqmmLG/nHtnd9OIFpgEoUSxrFJgZL6k",
	"m91NKHuqz5/+/fjLh49+ffTlV8S+QHK+YLruadBq4liHJnLRthp92GDEzvJMehN8tRBEnPde+rS3sCnu",
	"rCG31XUx4k4Ly32s0wkBkErO7XbGu9JewTh1WsSntV2pRR58x1IouPk9U7Io0j1lgl6VcL+kditywNgb",
	"SMmU5tpYRtj0n3JTB2XrJRgXoWr4BdaGkiJj3vrsqICbnliu1EL6YnqBn0EtBudzImxdFo5XoZ9o27rc",
	"PQ3te6A0QrjNjJFSlk6153OSgghytlTFgl3dmU3Bnh6F6QZmiwG7KUJ0we9p0jsW7iYs52Q7t2+2BTdp",
	"Tm83MaFe+EN5BdLs82701xm5CiepHQOfDP9IFE45GNcIy70JXpG8H2zJCj/uRE2EoiGDQOsWyEiQBwDQ",
	"kw/dSFqNkuyi2uQKfQzgjfDu57b68aJ2S+/MTAFI/Ac7wItzmev3QjKFA+cjF/Z+EZASLeVdHyU0lr8r",
	"Pdqz3iBIoi1yRhNjmEa2JLtqYZQQr5+GPPOeW0knHV1JaYi9mRZFIo0d7ThwpmLCsVcCdUGLD881vudK",
	"m2PAB8vf9CduxWnLMZIRlfrgBTmf00FgRSnKHwQq8Rpy6//B7M4mpaObxTn+OzIQTEK0wGjvefCAM0Eu",
	"YUwM7Hr4FZm5dj+lYhnX7YCCS6/ShHxbpvjcxdeytWnn/l67TdDP0lzjOMx9PBB5GTnZQuSAg7k+6h+Z",
	"OfVwgORpSZFqh1AS+EvxurjB+w6xc83WMFcr5RQVbtyzlFO3df3Q5cE6QHhVmnXXOVjqN3CbEPj12obW",
	"KhvcYebt21/MbEhBsXQ3GPs51Dg7SFuY6zeF+SAFzhCVbgwHSZKwapV7V/WaVrxkVKehuYtW3e/pG79E",
	"9NvR4FIwrwSOFxqgQq64Z+tyPg5RDFLYz56Qt+I+0Uvq7xbuz0dffjUaj5ioVnbx9fPReOSevkvd1PJ1",
	"Mq+0LqTTiRF13QTuaFLSzZBk9p2lc5L4rSsFfXiVRhs+S9/p/m73DC6uLgHhRACrB/aCEtTVz7ktALSV",
	"GFqHNZwYJMm6PFDYil2Vgn7uK4uPpd97un20uG/Fi51Bco1GLO/HowUWKYPuJL+6XnUfdts9BD31At3S",
	"r1MGDBGTWGtj8miqqKjbgIYs7rNEhwzIvM4qxc3m1OLfm935r+epYlA/hPJMruZX8MA73dfIcyZ8jFld",
	"zKnSXrv+QdICtE8MDBBW55TFlHyHHUKcWPzmzuw/2Bd/e5w/+OLhf8z+9uDLBxl7/OXXDx7Qrx/Th19/",
	"8ZA9+tuXjx+wh/Ovvp49yh89fjR7/OjxV19+nX3x+OHs8Vdf/8cdS+kWZATUd/55Mvrfk+NiISfHr08m",
	"ZxbYGie05D8yuzdgYZtDgUJAagYilq0oL0ZP/E//vxeU00yu6uH9ryPXD3K0NKbUT46OLi8vp/EnRwuo",
	"gTIxssqWR34eqGXZuK+8Pgl5QRj7Bzta+5xgU0N9P/vszXenZ+T49cm0JpjRk9GD6YPpQ6inWDJBSz56",
	"MvoCfoLTs4R9P4Iq2kfaNeM5Cqmj78edZ2WJrXrso0UoA2r/WjJaAIu0f6yYUTzzjxSj+cb9W1/SxYKp",
	"KWSM4U8Xj4783ePoD1dX5r0FLBlsgF1Zot4bPvi5rGYFz6yG6qplgdcJk3p03BDf+eMqPSYzWlCRMZ84",
	"IHIIi8SyK1bLCQg/yS2i8fuTmtkBGn00yujJLymrbAe8qSdSuwMRDYW6SjWPABv8CHkkuMYDx7Nc7MHk",
	"63d/fPm398lg7G5cVh3QuPVpp1L+GmLkQ3wSLQjwOxRWEV6n5CfNyG+0KH6DoA//XSO6btwXFTmu6/nA",
	"BzVeMTMlPI0+r99xc7uXJrQs9QSe6gYsIUs2iiGS89TYmtz1pAMf0UY3NX2vPSHE4F1lSgzea00GGMBp",
	"XlSF4YFHhub1wEwnmtlR7Th32XQxHScxME4DeW9KXkrDnrgdszj+TUjBfrNTCGncLDOIPMPK1ZCah3A0",
	"28Xgh9ixqiygJu+cFpo5Qv9XxdSmpnSHmlFM2UGEel2bFoX9QkKjgcSq4l/jdSUV8m4cwQZYpz3ICZJ/",
	"WieJXrr28nF8ehS5/l+nr14SqYizgb6m2XlIkPXJ0nWCeJwrbb8MnKCFIKfoxPjxaHGZtiu9KJttF4LJ",
	"5B30zwZAAaGPHjzwMs3ZhyJaPnJ8OJppUJMpdGOHUTw4VxioK/vw0ZtQNF3REvn3sU9zsVc9F0iAL03t",
	"pj4+4EKbpd2vvdz2cJ1Ff0tzolwFDljKw892KScCUxasDoO61vvx6MvPeG9OhJW5tCDwJiprcI67yslP",
	"4lzIS+HftJymWq2o2oAWbYIy0O6OSBcaondAR0C2FxVdFYvRu/e9mtJRLLV61abnUp5DiHCkBcUyLUS/",
	"341kMlYTBrbqK/KFFei47fq9aZ+yFDkF9V9McXrhwjPrS75Lr4RiHiDv+wQAxE43+P9AW1Dy12SQHFtb",
	"HQubWTq4UKcJZn+81YU8QFclpFTsgstKh496lmCHSK2gNu13DWQ9imYrPcypXpGu5dI4ybwqih4F0Wfu",
	"e2UT4RoTZrLpYC2rqfTU9QJSGiLGwNdnaahy5NayXTm6sqpzXeWgvyxqIy59nyqEEYfwqYypdVh6mgBJ",
	"JtiuxtLRlqC5oJjODnmuK3qOAYuouzoR64naJccCnYfCDe5kRBaOxnlwjA9+aW45BNpre+Fx+r6HhWSV",
	"0j1BPQdqOX69kr4IRKLVQJ9y1sPVg84Wxa8UHKNzYlzVaQi+NIWv3XfDalxnPS9oYaG3F7Gay9+k9vXx",
	"1aUb1W9S263JkhVYg1U0qjQeTOs5+qNRoDm/lvUIgxgbJ3u3QanHqAFjxYKH3D0uS0jIPA3Pj8vyNV7U",
	"rZLFOHAqtuba2Pv/D/HXjdhDhARDDxsZ+w5HnlU1Q9GdxjZEYfuL6WvHTUc9z5kwfM6xX0ZqHQ2a27qc",
	"wY2JE5mt2x/fmi62aSeTqBLzvhnToWVdZHzaYww80p++iB9we75F641oTkFbwhdn7EMJFd8lKcjAhrC7",
	"QZHzmRvpOspiu3P1ybNb491fyngXOpYsUK8sywMotqHkw3BDXsPF1q/awci3VrhbK9yNqVydqit7WYKi",
	"qiifkgnoT2S3aXOArRYbdE2nLu+3Zpo/i5mmb49dEy1I0vbvOVfQoUTc0R+uJdQh7DUuYmKApSaWldG3",
	"saugpTHfm5Lj9jtXU4tdn62dNhgsofSXs75gA7CddhdHNYe1uDSqVu164dbqMkwF2KcOWsMmYH8f9PGf",
	"18xyi8e9NZvdFpUrMP+OtcSJmhsTCn9KK4lD2q195C9tHwltOq+lPsYlKY5cbeEolvxajsG244+boEc2",
	"u7tGTA8iNqDKLh7hcV1+ByKXoa6Iqyiix950G8WH4GaNO4bdroL4A4styN9uTp4N0Q0/N6/WjYaw1l8m",
	"xUl6kz/4jfdbmpM3HyYgdBiTe/zg8YeDIN6Fl9KQ732i/2d7406T1b68cBtrO5rJ9S72JtohS75/jT38",
	"DWYXOpiNo+f2bUzVugslPWdUs68e+/vLvSn51r1aFwl3sXsLSYu6FBxVC/zIMk2LDHLH//kExr8zJd9D",
	"gUOjxxBTBZWT4EUuzJOHj7547F5R9BLTt9vvzb56/OT4m2/ca6XiwkByD157Oq9ro54sWVFI94ETNt1x",
	"7YMn//u//2c6nd7ZyZ/l+tvNS8tX/4RMepzqrBQoqW/bP/PdTtrYcYP7t+BDZmh8K9dJcSLXt+Lso4kz",
	"i/0/hRibNcnIXY2D8zMu/nFIscb0voJt7AQZlHsKUmlKXkqCQFQFVVhJHlr1abKoqKLCMJZPPaVCrT6N",
	"XqSs4FBkWBHN1AVTE81Dt8xKsVDuvFTsAurr1M3kGhDslhhQXuPPLy1e0HXkk50FxaH2ypKTOVnRNYHu",
	"5oZoZsbY8mVNvvmGPBjXF7OisANMAoZTXHpF14dy5R7WYBroe2jPgmcOj1LtrjAAYw8xo9WaW2idVV+T",
	"/urC4rO9deDBcBt7IGa9t++u9s3FxhT09Ww3o6AuaaDRo67KstjULf6sYum1tjRXtTMMtZB8Lp6nG7WM",
	"gLMgdRtv79UtR7i1hlyLL7UJak8eBKWy9NEfYKCIGVCHCUAZqZ0MwDm2UB3pOfvKVRA83MEP1Su3POut",
	"yx3KSsRVTMldKK3ggzawkpjVmTKrbsyhkPc9aJozC70voUBynUefVp5w+ImdNKVERf2Lbz3j/Yoe0GK3",
	"22W8gTnFgslNfS1doS+qhgk+X6YSR/FV6VJpIxII7d199ykgpkAPcN/xJhAsX2bJyMhQxrV0/TwGQ/m0",
	"nryrowJaDuEyv0XwfgjusPjvXHVq5CluEX+G0hr+Qj8hL2VdChj5/Z/SJX2T+slNL+ilFAxjL+xlAGnx",
	"1s0elKda6PvK8XilAwXlWorUka/OuVWb+jvWjfxMNaobEOl/T9Y0bUgdi9jpzvLW9WhDmLUvmkobKuD0",
	"Y97NPgp//QQvbB+Dg30YloPVlR3fcWqCOCwTguYMSMxHobRxH0d6bl+O9LTXrsDtX5Q7bSOYNKoShBMK",
	"R9NEo4zpX/A4P3VN8I0vI47NQTQXGSNarhjcKqwa73qMIoR/+3AQGr5iOZEVdDiJ6sh9ZIbz5YMvPtz0",
	"p0xd8IyRM7YqpaKKFxvykwjN7q/DADWhbs9jG3r3cBAuwC3YbCKTxZ0qrsEX5WKLG9RZ++s2WK4+q6wM",
	"U9gAqdGOMVTVivh2yooODOO5nfpW5YOv/TYMbeT5lBYF4G+Xrw4GHhTxXhS4wWzFjanbgscSmHxHs2XY",
	"7HFte5PlpGAXrCC+f+y41XEMRvYpstgQyZU/I9FqIgsHU2wuFQTNKOaNiytfTy3+JuRXarpiqUg0JNa4",
	"X8HJM786dKvLeT10m6B9t1k3+NTO7R7BzELi4qhiwMxjA2izvlwMNFVxKL+op8A29L6ZFVet7mJ11FNZ",
	"Mqrqj5Fh3C0Vm7ghFL1gSlM4va1F3btV5z8NdX7t2ll+Isp80tV7XeZ/ddnUiMj/w6x5/n637t5pEfPn",
	"cdOctVq8nDyLs6Zk6JHg9YqexVhE7pmo+e8pK8OH7peTdCHVvUi6rphhjXVuvUuDGUrnbG275/U1YPp4",
	"Wf7xQbe71jxLH1UEmY8lgiYtGdREy8eTSNCweByF75RKGpnJAqP2qrKUyoT2TXo66CLGeisXxPew/s5h",
	"1xBla57rnUbwM3jr9kpUW8HPPN5SZvDm+dWN5oB79kyq5xpyVzqTJcH7TguEj8robnXsFINrWcw/d4O5",
	"6SW9A9vPM2qyZVUe/QH/gJ5R7+t0WOjBrY/MWhwtlLSvbY3ZxOowLLfECJ82TF7xSmC0ZOTlc/i8bhX+",
	"vVSRPvKD/W4362wibdzWAmB2AsGdCaZ6M2rzrbbZ51pobfj1HeqJETvntV27CqwunnajBvS+gAMXi4Kl",
	"SPg2AOTTWlDtb5lzkRMabWPrUi1VzQhu2Ody04v+GC6cDx/18uVnfM5eSkNOVmXBVkwYll+zAlubw3np",
	"sVXc7qcYONHfDZPuyvxY4vtMkaCL7BTwfyLL3a2M/6Rk/NPglooJ9FZifz4SW/lDeCucP33h/MVnu5ob",
	"jP4YKKyv4EVrCuj6jr6nqO6oCc661TIpbHPAwaW8vUr9vVRv3Kpu5fufLh8J93hwLMsQq84u662b8hDJ",
	"Pp8U9MNsE0WRsE70HeFxCJfhUD5RZhwaPZ/keuzictCg4c73rUr0SatE0V7fakS35orPzFzRo/84S0FR",
	"DFFB9lWNLlYyZ947K+dzV8m4Ty9y/YgrpZgwxJKnNnRVEvxy2hvbesZX7NS++QqnOKiIrcFuuSVb4Flk",
	"aZZJkeuddZN9FZqWcHJTXVU4gceqH6oP7iIN2+JhcSWAplem4zdRZcMOeZD2jmALYF/L2SEjZxfEUuX0",
	"ALR89Af+H+xypdSJ1Zx6qu5szF23LVicGsdtAEheg2aKVa79V3JOHmCN6kpAwvGSa1fPkYqcGLXxLWxR",
	"JaYFyRqJhgGO7nE67T1OW28OZ6nV9awpfa2Q9bG99r3iSmWfWungP37wo/KUCnc4uqg0klAi2IIafsF8",
	"lMH0tqrSlYWhq2m0hVWOCc1zPLf1JrALpjZEVzNtVSXRTBu5o5snaw/WwtYlU9xKeFrUPn+8ZRxhyaRt",
	"sUyn+MY1ZV6La2GhJsVKxbTdpIZgdmWc5Jy84JmSx8VChmhkvdGGrSzLaAhR9+mvPY0JvIViL4uBFAUX",
	"bLKSgm0S4hkrThl6zurWOK4OOV7L7AWu0uQVDEOoIQ0g42g4s5SakUv4b7SJUpBzttFkSS8YYevSci4y",
	"qwz+YM/zhhkyY9DASp1bXXs+t5MN1g/CImEdCU6FsOMqIe7XrnKhGCiMlmgvpIEaFe3FQZEZlC0BKUPW",
	"twfoUPNr6/a8gGdX05WaFNWihhbemrAMUa+uewA+EfZ8reCn1moVK6Uydfs6ZFB78jrP1TYi67K6jcgi",
	"R6d72KDHnp+PfCx+3WCg780/Gn+62nfuTb2sTC4vo1nAxoMxr0MqVcHl6jZ9uZeII/ykzlx4Gi43l4qW",
	"ePTqh5j1ADfTuuTVXzmh2bnr4nRVlw54wZRuXeBvs5r/VFnNg/d9Ly6NmtEuTlfpwyqdL2XOcNw6k9Ue",
	"/VQvGiFz5hS4rq4ZQmjTHbC8XKvfQ7xxTWYMapfSarE0pCqJkam+ofWHE5oha57gXTc9YVQiGW/EMB1o",
	"VbRQjOYbVBLlzC66lrCwSKpBJfOJgS5QeLgWFgFbKpkxrVk+8TrfLniDbgipiGYL8mA1sIowC9GSzKm6",
	"mRWcX+wE/pxtJmAZ0eTujz/re5/KIlAX3b4FWC83sRHthOfuUq4B0zYibkMUkzLmV+NJgMxDuSoL5nIP",
	"E8i+PvZ6t78NZocIbgiBF0zxOb/ho+UnuQGiDPDf8MG6kSVU5cTqGV24n+LTM74CjVFQIb0xfMcMYYKC",
	"ajPZJVLsS/GitV1qxMVTUgQG7rGHPKfagD5OuMihIiSKQpgHbw52in0tJjClVQ7wKpWY9Gd8mJo2s2Je",
	"6EoTN4LPC2R5annQ6Lt3rpdsHeaC8ip+7JB4iFbsXSP3ITAa3+ExaodEqAnNL12j8O7iwMZOnWltLyw3",
	"4KtxtA3GU/9WhPg4tKUHRq7rPUBygz4LMb2Fsr7jkTayLC2HMpNKhO/6MHiKbx+bn+p3uySJhTNQU8kl",
	"03G+qIP8EpGuwT+xpJo4OHxTd2iqh92MuzDbYz2BIk2TbecFPBb2rfjgXOm4V+VC0ZxNclbQhNnqJ3xM",
	"8PGehOHHBgLxhD65kIZNZlB/JU0j9ZlQVzGThlklTKVTijeYCTXJ7DkHY2EgNff11SfNGUyb4puOWO+E",
	"WQCMJB348QBZSE99Jt8LCfmHjugi0+d119KDvTDrjSAQxp3UFqD27P/NtJs7KGAHnX/DdN/C66kPtey2",
	"iTeW7Q2B2RJlLWmTFBG9fHkHY+zjQSkr8mfpkmsHKN5gTm3Tih7d4adXsU8cXVJuJnOp8N4yoXPD1M5M",
	"mX9Q7mNenAPPSFfficAITkdw44DUihsqOo7lnEdO/lkScXW0rFCm5CFZcVEZfCIrM8aC4YrRbGnvSLF5",
	"HUeCttuuRJViC6ryAvouz4MiIBWWvDItZQaATqQfN402dt3fS/WZN1N4d2txurU43Vqcbi1OtxanW4vT",
	"rcXp1uJ0a3G6tTjdWpxuLU63Fqdbi9Nf1eL0sareTbyG5uvKCikm7UD12zj1P1UThSB7vQEMrE+XlAML",
	"jIrO9Nul9jD0GUYLwAEvWH+ODQb0n313/JxoWamMkcxCyAUpC2ovXWxtQjP5GdXsq8c+Cxx1Abois41l",
	"K1ZhsC988Yic/v3Y10Veui5NzXfvHmOoKdFmU7B7rlEgEzkq5L5jIBMW6a5hIPXixzeddy34eQH5SZp8",
	"B28/YxeskCVTWKwW2oV2LXpnjBZPHW52GPT+YSd3aQy/2dF+GzeMmg5tK1r6a5FfK9WEYjI8eRalx/82",
	"p4Vmv/VlyON4K1pu7zT6Drkv0+ZbmW9aJ8Tu2hFsYPNshKaJMy6o2iSK/nUT0dqkYaRlV46wukbM9wdN",
	"IFwme4t1yWwXhaVuJtjkIT16H5Wnxqk3rDMU1lCYt+hklEr/j0XpElvMOQAH1XmFZDXcE/IGv/u4VV0B",
	"InfEamb+yQQaN98MTAPetbcix3o+1zwtj/jk6YWzP7aEnVcZI9xo4ihugHixGqEdacHExDGgyUzmm0mD",
	"fY0aUijnmmrNVrPdkijmn3DigvCxT7bLqY8jRp5Fi9vGk2OiWU8cA+7hzhvDBvPmgC0Y0bHnCOM3zaL7",
	"2GgMAnH8KWVba/G+fZlePc3mlvHdMr7oNLY0Ai5cg6Q2E5neIONTG1WJfp733ZpllQUuPsl3we8BXlW2",
	"Ng0nes5m1WJhbwtdNys0iYLxuBQfiRXicodywf0oCAd/49Ngrls/pD1cl7tEJT3u+kK792A7qMB82FVJ",
	"xcbuBuSRTDRfVQXiENusH5bRYk+IVMeA2jrZZ8F/7Y2SkTHaidrm74gWckk1wf1lOalE7pIVO60K1mJ4",
	"CSoc+mwtaja9tdwUrjexOjfvEBHhd7lZ8EOTkqmJWQs8UI3DBN4xSvDkftTWCLdi48OJDSwXwnoYbLfb",
	"Ss0QDiQ9VMTXQHxEHcXqnNpGnzHazARuPAOLRn8WWtweCd88aGxQZ/hmiFBtbnH+ZlaUhJKs4OCNlkIb",
	"VWXmraDgkIoWNu2GD3kbdj/ve+pfSbtLE95MN9RbQSGILLipkjxwzhLuku8Z8yxWV4sF05aPxgQ0Z+yt",
	"cG9xQSphb2FyTlY8U3KCWfH2fFndZYpvruiGzKHYlCS/MyWhXEK862hL1oYXhYtXstMQOX8rqCEFo9qQ",
	"F9xyYDucL2oTQgqZuZTqPGBhj2oFCyaY5nqSttb8gE+hX7vDibcKgoUTH9e9i9rXoLpbxf+5+59Pfjme",
	"/A+d/P5g8vW/H7374/H7e/c7Pz56/803/7f50xfvv7n3n/+W2j4PO897IT95BoGJUHG/4DpuOdqG/VOI",
	"G1hxMUkS5dmSERdX2KZFchfKeTqCu9d0T5kleyustDSSgISg5oDk03YjdQ40HrEWlTU2ruVt8ggYdIc8",
	"CKsiCU5167v5E6WKR3TgPaew8dhzpbX3e/ppGnKbQffcPqmOT12H0Z6X3C2kYWlr1Spzb5w1QN7qBPn8",
	"ywYf/kLq0XiwK2l3wC67ajZWBbz5DR8TWkixwAJN9ooqYZ+4KCsDWQI3aQVkF7SYyAumFM+ZHrhSLsV3",
	"F7R4FT57Px6xNcsmRtGMTdAsMRRrZ/YbpFM7DhfccFpM4Go+FCB2gl+d4kc75PdZCFHjqxXLOTWs2JBS",
	"sYy50ldck9ooMMVCLCRbUrEAUa9ktVjiazjOJVMs9KC19/D2EPvqAmYtJliPtAv+sWtzHhdzZzRbJvqM",
	"gey7pAEUrGU16NafYDZQbbrPCDAe9SryFt8XdRgi4q3Jga6qdTT0hwhpNTSHqNl9e0huD8lf7ZCkqu8C",
	"PuctkwoiMd7GG7a93XQB6g9oyvso1elvm7/82Zu/eLakCSWKNu446X6kVBNuyCWUV5sxYuVdBS4E1+TV",
	"GQkg3TM66q4os3YtYbMl5cLV5grJKgCHvXKvVtwY3yP9RqyvyMzA7GrRwbJKcbOBWxEt+a/nzP77nb1W",
	"aKYu/IWpUsXoyWhpTPnk6KiQGS2WUpsj6MFSP9Oth+8C/H/4u06p+IW9v70HsKXiCy6sjL6kiwVTtZ1z",
	"9Gj6YPT+/wUAAP//psDgLSLlAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
