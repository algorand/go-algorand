// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"V3SxYKoxIR49mT46evd/AwAA//+i458bR7YBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
