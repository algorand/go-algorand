// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"gAEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
