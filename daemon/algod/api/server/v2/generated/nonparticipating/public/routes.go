// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"NH0wev//AgAA///Wr1XrAdIBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
