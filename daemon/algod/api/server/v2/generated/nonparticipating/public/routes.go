// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/B+89F9ItjIazcf3H///AAAA///s8G0fPoABAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
