// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"dw+bRwEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
