// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9/XfbtrIo+q9g6d618nFFOUnTnt281XWfm6Stb/O1Yrf7nNPktRAJSdimAG4AlKXm",
	"5X+/CzMACZKgRNmyk7T+KbFIAoPBYGYwnx9GqVwWUjBh9OjJh1FBFV0ywxT8RdNUlsIkPLN/ZUyniheG",
	"SzF64p8RbRQX89F4xO2vBTWL0Xgk6JLV79jvxyPF/l1yxbLRE6NKNh7pdMGW1A5sNoV9uxppncxl4oY4",
	"xiFOno0+bnlAs0wxrbtQvhb5hnCR5mXGiFFUaJraR5pccLMgZsE1cR8TLogUjMgZMYvGy2TGWZ7piV/k",
	"v0umNsEq3eT9S/pYg5gombMunE/lcsoF81CxCqhqQ4iRJGMzeGlBDbEzWFj9i0YSzahKF2Qm1Q5QEYgQ",
	"XibK5ejJbyPNRMYU7FbK+Ar+O1OM/ckSQ9WcmdH7cWxxM8NUYvgysrQTh33FdJkbTeBdWOOcr5gg9qsJ",
	"eVlqQ6aMUEHe/vCUfPXVV9/ahSypMSxzRNa7qnr2cE34+ejJKKOG+cddWqP5XCoqsqR6/+0PT2H+U7fA",
	"oW9RrVn8sBzbJ+TkWd8C/IcREuLCsDnsQ4P67ReRQ1H/PGUzqdjAPcGXD7op4fyfdFdSatJFIbkwkX0h",
	"8JTg4ygPCz7fxsMqABrvFxZTyg7624Pk2/cfHo4fPvj4P347Tv7b/fn1Vx8HLv9pNe4ODERfTEulmEg3",
	"yVwxCqdlQUUXH28dPeiFLPOMLOgKNp8ugdW7b4n9FlnniualpROeKnmcz6Um1JFRxma0zA3xE5NS5JZN",
	"2dEctROuSaHkimcsG1vue7Hg6YKkVOMQ8B654HluabDULOujtfjqthymjyFKLFyXwgcs6PNFRr2uHZhg",
	"a+AGSZpLzRIjd4gnL3GoyEgoUGpZpfcTVuRswQhMbh+gsAXcCUvTeb4hBvY1I1QTSrxoGhM+IxtZkgvY",
	"nJyfw/duNRZrS2KRBpvTkKP28Pahr4OMCPKmUuaMCkCeP3ddlIkZn5eKaXKxYGbhZJ5iupBCMyKn/2Kp",
	"sdv+f05fvyJSkZdMazpnb2h6TphIZcayCTmZESFNQBqOlgCH9su+dTi4YkL+X1pamljqeUHT87hEz/mS",
	"R1b1kq75slwSUS6nTNkt9SLESKKYKZXoAwhH3EGKS7ruTnqmSpHC/tfTNnQ5S21cFzndAMKWdP3dg7ED",
	"RxOa56RgIuNiTsxa9Opxdu7d4CVKliIboOYYu6eBYNUFS/mMs4xUo2yBxE2zCx4u9oOnVr4CcPwgveBU",
	"s+wAR7B1hGbs6bZPSEHnLCCZCfnFMTd4auQ5ExWhk+kGHhWKrbgsdfVRD4ww9XYNXEjDkkKxGY/Q2KlD",
	"h2Uw+I7jwEunA6VSGMoFyyxzBqClYcisemEKJtx+3+lK8SnV7JvHfTK+fjpw92eyvetbd3zQbsNLCR7J",
	"iOi0T92BjWtWje8H3A/DuTWfJ/hzZyP5/MxKmxnPQRL9y+6fR0OpgQk0EOFlk+ZzQU2p2JN34r79iyTk",
	"1FCRUZXZX5b408syN/yUz+1POf70Qs55esrnPcisYI1euOCzJf5jx4uzY7OO3iteSHleFuGC0sbFdboh",
	"J8/6NhnH3Jcwj6vbbnjxOFv7y8i+X5h1tZE9QPbirqD2xXO2UcxCS9MZ/LOeAT3RmfrT/lMUuf3aFLMY",
	"ai0dO5EM5gNnVjguipyn1CLxrXtsn1omwPAiQes3jkCgPvkQgFgoWTBlOA5KiyLJZUrzRBtqYKT/qdhs",
	"9GT0P45q+8sRfq6Pgslf2K9O4SOrsqIalNCi2GOMN1b10VuYhWXQ8AjYBLI9UJq4wE20pMQtC87Zigoz",
	"qa8sDX5QHeDf3Ew1vlHbQXy3rmC9CCf44pRp1IDxxTuaBKgngFYCaAWFdJ7LafXD3eOiqDEIz4+LAvEB",
	"2iPjoJixNddG34Pl0/okhfOcPJuQH8OxQRWXIt9Y4YCqhpUNMye1nBSrbEtuDfWIdzSB7ZRqYrfGo8Gq",
	"+YegOLhWLGRutZ6dtGJf/sm9G5KZ/X3Qx18GiYW47ScuuGg5zOEdB34JLjd3W5TTJRxn7pmQ4/a3lyMb",
	"O8oWgtEnNRYPTTzwCzdsqXdSQgBRQE1ue6hSdDNySmICyl6XTH7RDCmkoHMuANqxvT4JsqTnuB8S8G4J",
	"genqXoS0hBpkZUJ1OqdD/aRjZ/kCqDW2sV4TtZpqzrWBezW8TBYsB8WZCk/QIalcijIGbPiWRVQwXyha",
	"IC27J6h2cQH3eXwJYb2i4B0oE6MwB+w+2GiA6tJseSfrjEICXKMFw/e5TM9/onpxgBM+9WN1aR+mIQtG",
	"M6bIgupF5OC0aLsebQh92xeBZsk0mGpSLfGFnOsDLDGX+7CuonhK89xO3WVZrdXCwIMOcp4T+zJhSw4G",
	"c3dxRAs73r/Ic5ourFpAUprn49pUJIskZyuW20s7F4KpMTELaurDDyP7ew2cI80sszOMBKtxZiYwsanK",
	"FqEYWVKQQEt7myny5jcVB9V0yVpaEEhEWYIVIbhonDzzq2MrJoAnVUMD+NUawVoTDj6xc7tHMLOQuDi0",
	"ABrvvqvwV/GLBtD27VqeinoKqTK0WRv7G1cklQqHQAnvJrf/YVTVHyN13i0US9wQiq6Y0jS3q2st6l5F",
	"voc6nTtOZkYNDU6mo8L4BQw5B3wH6h1TESvNa/gPzYl9bLUYS0k19XBQRmTgTs1QMFtU4Uz2BbC3SrJE",
	"UyYpaHq+F5RP68njbGbQyXuO1lO3hW4R1Q6drXmmD7VNMFjfXjVPCNquPDvq6CJbmU4w1xAEnMmCIPto",
	"gYCcAkZDhMj1wcXa93Idg+l7ue6INLlmB9kJO85gZv+9XD9zkEm1G/Mw9hCk2wUKumQapJsIGaedpfbL",
	"HU+lupw20RIwgtTeRkLtqIEyNW4hCV4ti8SdzYjHAl9oDVQHeGxXAtrDxzDWwMKpodeABW1HPQQWmgMd",
	"GgtyWfCcHYD0F1Elbko1++oROf3p+OuHj35/9PU3liQLJeeKLsl0Y5gmd51Zjmizydm96O0ItIv46N88",
	"9j6q5rixcbQsVcqWtOgOhb4vvP3ia8S+18VaE82w6grAQRyRWdGGaCfo1rWgPWPTcv58bRR9o+Ts4Kyw",
	"OXwMLnjjTaGsSqGbHkKnJx1l9pUjZkc5KuBNJjKMMLAr4Nre/pbTg5BT35Zn9SwZcbjM2M7jsO8G1dNs",
	"wk1SG1UewrDBlJIqKnwLJY1MZZ5YDY/LiGnijXuDuDf8dhXt3xFackE1sXOD37IUWY8FwqzFcMmFQ5+t",
	"RY2brbIL1xtZnZt3yL40kV/fPwqmErMWBKizYRiZKbkklGTwIWgZPzKDmhdfslNDl8Xr2ewwdk4JA0Us",
	"OHzJtJ2J4BtW79EslQLD+HYYa9yoQ9DTRoz3L5l+ABxGTjciBSfZIY5tvx1ryQV47PVGpIFRy8KYs2ze",
	"IMurG6/60IFT3dERcCw6XsBjsNI/Y7mhP0h1ViuuPypZFgfnze05hy6HusU4P0Bmv/UGYC7meTN0dG5h",
	"n8TW+EkW9LQyH+AaAHqgyBd8vjDBTfGNktcgEKOzxACFB2gmyu03XWPRK5lZZmJKfQAlsh6s5nCWbkO+",
	"RqeyNIQSITMGm1/quHrZE2wIUU4QnGVCjRUsE1yTKbPUldLSrrYsCIQedeRF/WFCUzyhCaBG9wReVBEz",
	"+BZOh4FsuWI025ApY4LIqYtucHEXsEgKcVPGK2hOuY3wiwZchZIp05pliTNC7wTNv4eiw2zBEwAOAFez",
	"EC3JjKorA3u+2gnnOdskEOWnyd2ff9X3PgG8Rhqa70AsvBNDb9uS1oV62PTbCK49eUh2aKNDqrXqrWUQ",
	"OTOsD4V74aR3/9oQdXbx6mhZMQXBJNdK8X6SqxFQBeo10/tVoS2Lnth1d0G3Gp7dMEGF9IpVbLCcapPs",
	"Ysv2pYYVwa4g4IQxTgwD9yheL6g2GADFRQbWTBQnMA8qYXaKfoB7ryF25F/9DaQ7dmrloNClrq4juiwK",
	"qQzLYmsAX2zvXK/YuppLzoKxqzuPkaTUbNfIfVgKxnfIcjdg+IOayvPqfLndxYE33cr5TRSVDSBqRGwD",
	"5NS/FWA3jN/tAYTrGtFIOFy3KKcKGh6PtJFFYbmFSUpRfdeHplN8+9j8Ur/bJS50b6DcziTT4Dpx7zvI",
	"LxCzGLm9oJo4OLxzHQw5GKnVhdkexkRzkbJkG+XDFc++FR6BnYe0LOaKZizJWE43kbAAfEzw8bYBYMfr",
	"6640LMEQ3Pim15TsIx63DC1hPB1THgk8Iak9gvYqUBOI+3rHyBmDsWPMydHRnWoomCu6RX48WDZudWRE",
	"kIYraeyOO3oAkB1HHwJwDx6qoS+PCvg4qe+e7Sn+i2k3QaVH7D/Jhum+JdTj77WAHiuwy24KzkuLvbc4",
	"cJRt9rKxHXyk78j2mKTfUGV4ygu46/zMNge/+rUniLrMScYM5TnLSPAAr4FF+D3B4NH2mJe7Cg6yvXXB",
	"7xjfIsvxATpN4M/ZBu7cbzArITB1HOIuGxnVyicqCADqY52tCh6+wtY0NfnGKmpmwTbkgilGdDnF4IWu",
	"J8XIIgkHiHpmtszo/LJRr+hWR/EpDBUsLxZlhneC7fCdtS4GDXS4u0AhZT7AQtZBRhSCQVEjpJB217lL",
	"fPKpL56SGkA6pg1O+Ur839ENNMMKyH/JkqRUwJWrNKzSaaQCRQEUSDuDVcGqOV1YYo0hlrMlw5skPLl/",
	"v73w+/fdnnNNZuzCZwvaF9vouH8f7DhvpDaNw3UAe6g9bicR8QEuKyv43C2kzVN2xzq5kYfs5JvW4JWf",
	"y54prR3h2uVfmQG0TuZ6yNpDGhkW5wXjDvLlNCODOuuGfT/lyzKn5hBeK7aieSJXTCmesZ2c3E3MpXi+",
	"ovnr6jPIhGSppdGUJSnk7w0ci53ZbzDlz47DBbcHGMP9hwLETvCrU/xoxxWzjlHlyyXLODUs35BCsZRh",
	"ppvVHHW11AnBGPh0QcUcLgxKlnMX1orjAMMvNZpmVCk6Q0SVKrMWCRi5YwLABaj5ZEerTjFqr3RtCzle",
	"YC5oNZ/Lbx0imYM9aHsMok6y8aj3xmuRuqpvvIicZsbmAGHQ0PcC/NQTD3SlAOqs7tPFV7gt9jDZzb0e",
	"k309dAzK7sRBrG/9sC/c1163880BlB4ciChWKKZBRIVmKo1P5SzMzvZBghtt2LJrycdPf+85fm9774tS",
	"5FywZCkF20QLknDBXsLD6HECMdnzMSgsfd+27yAN+FtgNecZQo1XxS/sdvuEtj1W+gepDuUSxQEHq/cD",
	"PJA73e1uysv6SWmeR1yLLnezzQD0uArT5YpQrWXKQWc7yfTYxQOjN9IlejbR/6bKSDnA2WuP2/KhhWUB",
	"wEbM8oJQkuYcLMhSaKPK1LwTFGxUwVIj4Vv+Mt5vtXzqX4mbSSNWTDfUO0EhdK+yXEUDNmYsYqb5gTFv",
	"vNTlfM60ad11Zoy9E+4tLkgpuIG5lva4JHheCqYghmqCby7phswsTRhJ/mRKkmlpmto/pCZrw/PcOfTs",
	"NETO3glqSM6oNuQlF2drGM47/f2RFcxcSHVeYSEu3edMMM11Eg8z+xGfQkS/W/7CRfdDoDs+9uGmda2E",
	"kV1mozzK/3f3fz/57Tj5b5r8+SD59n8dvf/w+OO9+50fH3387rv/v/nTVx+/u/e//2dspzzsscRZB/nJ",
	"M3czPnkG158gSL8N+43Z/5dcJFEiC6M5WrRF7kKRCEdA95rGMbNg74RZC0tIK5rzzPKWy5BDW8J0ziKe",
	"jhbVNDaiZQzza93zUnEFLkMiTKbFGi+tRXUjM+Mp6uCUdFnncF5mpcCt9No3ZmD6+DI5G1dlCLBC2RMC",
	"OeoL6sM73Z+Pvv5mNK5zy6vno/HIPX0foWSerWMVBDK2jt0Vw/SIO5oUdKOZiXMPgD0aSoexHeGwS7ac",
	"MqUXvLh5TqENn8Y5nE9WcjantTgRGNpvzw+4ODfOcyJnNw+3UYxlrDCLWOWihqIGb9W7yVgr7KRQcsXE",
	"mPAJm7RtPpm9L7qgvpzRmQ9MVVIOuQ1V5wAJzVNFgPVwIYMMKzH6aSU2OOGvD34dcgPH4GrPGYvovfPj",
	"8zNy5BimvoPFLHDooPxA5Crt0iYbAUmWm4XZZO/EO/GMzcD6IMWTdyKjhh5NqeapPio1U9/TnIqUTeaS",
	"PPGZmM+ooe9ER9PqLakYpEuTopzmPCXn4YWkJk8sk9Ud4d2732g+l+/eve/EZnSvD26qKH/BCRKrCMvS",
	"JK7IT6LYBVUx35euirzAyFjFa9usqGTLEg2kvoiQGz/O82hR6Haxh+7yiyK3yw/IULtSBnbLiDayykSz",
	"CopL5rX7+0o6waDohberlJpp8seSFr9xYd6T5F354MFXkNNXVz/4w4l8S5Obgg22rvQWo2gbVWDheK2E",
	"WPWkoPOYi+3du98MowXsPujLS7Bx5DmBzxr5hj61AIaqF1AlN/duAMKxd1owLO4Uv/IFHeNLgEewhc3U",
	"6yvtV5A5f+nt2pF9T0uzSOzZjq5KWxL3O1PVeZtbJctHY2g+h9uqK4k3ZSRdsPTc1Spjy8Jsxo3PfcCP",
	"UzQ96+Aaq9hhbiHUUQIHxZSRssioU8Wp2LQL2mhmjA8rfsvO2eZM1mWY9qlg0yyoovsOKlBqoF1aYg2P",
	"rRujvfkuqsynmLq6JJC26cniSUUX/pv+g4wq7wEOcYwoGgU/+hBBVQQRSPw9KLjEQu14VyL92PK4SJkw",
	"fMUSlvM5n8YK8P6z6w/zsFqqdDUHXRRyNaAmfEbsVX6KgtVd7xUVc2bFsxWpUtMc66lGgzbgPrRgVJkp",
	"o2arnV+EpSg8dHClvICca7Dwje0S2NruNzdgsRPswt4qwFCE77jo5Ul//BkCzrJLwuM/r28Kk967rkNd",
	"pNagl8oVdqtrrQvNC+kM4MLnSwbFSuWF3RcLhXR1NrGcSyBfSk3nrOfuEnrvBlbCaHj8YJBdGklUB5Gz",
	"tqrR0QSiIOPLiV1z9Awz+8QeYrhmtgIy/UzoIHY+Iyif7RA2zUGBrSJXce+panhRsR5wH2hx1sKUqFVB",
	"D0YTI+FxXFDtjyNUSvVcdpB2do0FX7YVpTsJYgmDcqhVyTkvDdsctHPvd6XpfD06X4QuvPQPKChn716Q",
	"vhDbDilANc1Yzua4cHzZE0pdKqneIAvH69kMeEsSC0sMDNSBAuDmYPbmcp8Q9I2QwSPEyDgAGwIfYGDy",
	"SoZnU8z3AVK4Uk/Ujw0iIvibxRP7MFDfKqOysMKV9/gbU88BXBGKWrNoRVTDMISLMbFsbkVzy+bcXbwe",
	"pFMbDS4UrUpoLvTmXt9FY4trCkX+XmtCJeEyqwm1WQ90XNXeAvFUrhPMTY7eRabrqaX3aO4CZErHDiZW",
	"obujyVSuIZwLRAvGyu+ApR8OD0Zge1lzDfQK3/XpWQjMtmm367kxKtRAMs7QWpFLn6I3ZOoe3bKPXO4G",
	"heUuBUDLDFV3aXBmiZ3mg6Z60hXmtVQb1wVTfVpY7Pj3HaHoLvXgr2sfa5aC+6ku+ddfVsyfqBupgde1",
	"LF2lNiF+XGC9wX1KE7bJoQHEFqy+aeuBUbQ2Y72aeA2wFmMllvl2nZJdtGmWM7gEJw3VNDmPRQrYuzwD",
	"OX7qPwuMdbB7VGzuBQGEis25Nqx2Gvm4oE9hjqdQOFnKWf/qTKFmdn1vpayEP7rN4cPGMm98BRCBP+NK",
	"mwQ8btEl2Jd+0GBE+sG+GtdAmyGK2GaAZ3GOC9Oes02S8byM06ub9+dndtpXlaDR5RSkGBcYoDWFthjR",
	"wOUtU2Ns+9YFv8AFv6AHW++w02BftRMrSy7NOb6Qc9FiYNvYQYQAY8TR3bVelG5hkEHCeZc7BtpoENMy",
	"2eZt6BymzI+9M0rNp733SX4cKbqWoABgPENQzucs84XNvD9MBOXjcinmQf+mothWLW9CsGgd1JzbUq7O",
	"heGzviD8QN1PuMjYOg59eCsAyOvMOii1B5PMmcByJXGzUBQ1YYg/vBHY6m7YF9pOAIgGQZ+1nNl1dDLu",
	"UrWdsAE5o5m7k2jm17f9WHY3xKFu3Bc+3ah5uv0IwYBAU9wELU26ZQh6GDAtCp6tW44nHLXXCEb3si73",
	"aFvAWtxgOzDQDIKOElyjiLYLtXYG9iO48x7ZWxnGXrvAYkvfNHUJ+FmpwIPRiGzuVmyv7moD1/7zr6dG",
	"KjpnzguVIEhXGgKWsw8agnromhiO4SQZn81Y6H3Rl/EcNIDr2NizAaQbIbK4i6bkwnzzOEZGO6inhnE3",
	"yuIUE6GFPp/8WdfL5XX6wJRUiYRgay7hqoqm6//MNsmvNC/tJYMrXYfnOrdTU/juseur5c9sAyPvjHq1",
	"gO3YFbA8vWVAgzFLf/VIB6Wr7+hGcX+4Xja2cI+dOo7v0oG2xrVj6Cf+Wso02hU0l3KVg1EHSVhYhuzG",
	"aTw2wZ4e1kR8m5R3bQLPdusggb4fTsW1b17ZFUVVLYpdtHvGaO6JF5Yz+jgeXS0SICbN3Ig7cP2mEqBR",
	"PEOkKXqGG4E9e6KcFoWSK5onLl6iT/gruXLCH1734RU3fJOJU/bZ8+MXbxz4H8ejNGdUJZUloHdV8F7x",
	"xawKGzhsFyVY59sZOtFSFGx+VYs5jLG4gJreLWNTpx1KHT8THEUXczGLB7zv5H0u1AeXuCXkhxVVxE/t",
	"88SAn2aQD11Rnntno4e2JzgdFjesp06UK4QDXDlYKIj5Sg7KbjqnO346aurawZNgrtdQmjJ+4xCucCWw",
	"Ihf8Qw+uPf0gVYP5u8zEaPDQ9alVVslGPPbEavvOlW1lakJQ8fpj/oc9jffvh0ft/v0x+SN3DwIA4fep",
	"+x3uF/fvR72HUTOWZRJgpRJ0ye5VWRa9G3GzF3DBLoYJ6OPVstIsZT8ZVhSKUUAe3RcOexeKO3xm7peM",
	"5cz+NBlySQ83HdEdAjPkBJ32ZSJWQaZLbJapiRTtmGpIgrWkBczeNWNAZ2z3CIlyCQ7MROc8jYd2iKm2",
	"7FVgMKV9mcDLPdZaO2LJe2JzRcmDsexrQ2qmtoAM5ogiU0fLtta4m0p3vEvB/10ywjN7q5lxpkCutUSd",
	"vxzAqB2FNG4XcwOjn6oe/ip2kC3+Jm8L2mYE2eq/e1b5lPxCY+1+9owAD2fsMO4t0duOPhw1YzbbohmC",
	"OeweM6Rpumd0zlnXM0e0CTrXyUzJP1ncEQL+o0ghDO/45GDm/ZOJWORem6VUTuW6l3s9+67tHn437tv4",
	"K9+F/aKrfmOXEabxU73fRl7m0qvj5ZodkvsuYWGEQTM1oIe1wPEKgmGhAYqPPqICzxNWgWhkmMVPZZjL",
	"eYTj16fSwdzJf83pxZTGusPYu5CFKdjeRpyUkcR/7DdAVzUOcHYSRHBX73KsJFcwVfsgulVpL3mvwWkH",
	"32jqCwxQVHh1GWOYQq5lZJhSXFCB/cPtd8iv3NeaoQvefnUhFdSB1PGQroylfBk1x75791uWdsN3Mj7n",
	"2Bq71CzovewGIlhsEqjI9a+uKnc41JzMyINx0ADe7UbGV1zzac7gjYf4xpRqEJeVO7z6xC6PCbPQ8Pqj",
	"Aa8vSpEplpmFRsRqSaq7Jyh5VWDilJkLxgR5AO89/JbchZBMzVfsnsWiU4JGTx5+CwE1+MeDmJR1rc23",
	"sewMeLYP1o7TMcSk4hiWSbpR49HXM8XYn6xfOmw5TfjpkLMEbzqBsvssLamgcxbPz1jugAm/hd0Ed34L",
	"LwK9AUwbJTeEm/j8zFDLn3pyvi37QzBIKpdLbpYucE/LpaWnurEyTuqHwy7/rlOUh8s/hPjXwof/tWxd",
	"N3yNocuenC2IUn4FPtoQrWNCsfhnzuvIdN+pk5z42sLQOqvqmIW4sXPZpYMuCYHqM1IoLgzYP0ozS/5h",
	"r8WKppb9TfrATabfPI60oGp2aRH7AX7jeFdMM7WKo171kL3XWdy35K6QIllajpLdq2ssBKeyN1A3HpLZ",
	"Fxe6feihmq8dJeklt7JBbjTg1FciPLFlwCuSYrWevehx75XdOGWWKk4etLQ79MvbF07LWEoVaxhQH3en",
	"cShmFGcryJiLb5Id84p7ofJBu3AV6D9t/JNXOQO1zJ/l6EUg8GhuS5a3WvyvL+vK5+BYxUzElg1Qqoi1",
	"09ntbjjacD+rW9t/iwFj8KwHc4PRBqN0sdITfY/h9dU3nyJeqA0S7nnD4PjwD6LsHRz0+Pv3Aej798dO",
	"Df7jUfMxsvf79+MFiKMmN/trjYWr3Ijh29gefi8jBjDfr7AKKHL1ESIGyD4hZR9YJjh1Q41JszfczWsR",
	"h8nvikebxk/Bu3e/wROPB/ijjYhPzCxhA+sshf7D3uyNGSWZrHoexLlT8r1cDyWclgzyxPMZoKgHJQPN",
	"c7CSTu/PqLt+Z7xIQKN21CnLpb1khk2BQnv+l4Nnu/jxFmyXPM9+rWu7tQSJoiJdRKOEp/bD31FHb4hg",
	"ZJXRPiMLKgTLo8Ph3fZ3fweO3NL/JYfOs+Ri4Lvt3rO43NbiasCbYHqg/IQWvdzkdoIQq82yWVVZhnwu",
	"MwLz1E0taubYbeLcaZ4ZSW6GMZelcUGrkAjuqg3NeA4xmHGnMbyZKGp6qmdBm3PfXMiOA13HNdoYcHSm",
	"COVLkMqaLoucwbFcMUXn8KkUrPU51E+DkYN2FUQX9hG8CdUqJDGlEkTOZsEymDBcsXwzJgXVGgd5YJfF",
	"1jD36MnDBw+iNi/AzoCVIhb9Ml/XS3l4BK/gE9dhCfsA7AXsblg/1uS0z8Z2qcY1lPx3ybSJMVR4gGmr",
	"4CK1IhubSVaNTyfkRyh7ZCm4UecebJW+gnCzmmZZ5JJmY6hsfPb8+AXBWfEb7ByPzSznYKpr0n7UtzK8",
	"uqgv69RTNmf4ONvreNhVa5NUvSdjhQntG3V3TN4KuAEjXoidCXmG9tOqbz9OQqA+tlqyLGh1iTd4IA77",
	"H2NougDDZEP96WeUw7uwel5Wu22C1MOq9RFwawu3a8SKfVjHRJoFUxdcM0jHZyvWrIVYFQZ1hnFfG7G5",
	"PFUKgZQy2UMTrRod7Yt2DxyqsT6iIApZC/F7mqWwDfO+TWlP4at4Ikarw23L5e8r6/n62uSl8yykVEjB",
	"U+iDEFOjoW7bMB/lgJYRceeiHrkTGjlc0b66VSKww2Jvp13PCB3iuv7+4KndVKQO/NOwteu3NmdGO87G",
	"srFvcO28YVxo5lpZWSIK+aRUkYimaBZEFT2xJxlBSaYe8+YP9tkrZ/yGihjnXICZy6HNXc7QX5VrDm5p",
	"Qbghc8m0W08zlUf/Zr+ZQInGjK3fT17IOU9P+RzGwBg6u2wMGO0OdezDR124pn33qX3XFc6vfm7EguGk",
	"x0XhJu1vfx7VIs1a9CI4FrTko0gC5Fbjh6NtIbetcd8gTy2hsRWErLEC5HCHMKpG2s1RntuLJVIUvEEw",
	"nTJaPZeLCBgvuPD+07iASKMiATYGzmvPdzpV1ODFYRBPO2M078l+gPRkdMBfdah22wCLElijn6N/G+se",
	"4D2Mo3qhVvep2BB/KCx1B8rEU5pXcdORjt6gVTklKoPMolaP7xjjsIw78fmSDXTtzN2rPodWHPtKor4C",
	"hdMymzOT0CyL1bX6Hp4SeOozxNiapWXVgapKDWwWKO9Sm5solUKXyy1z+ReuOF3QND9CDWHjfr/DUGZn",
	"uoF/Y+2X+nfGRUzvnZLrw6Oz/aryd1OMY1qvpelE83kyHBMgU66OjnrqyxF6/f1BKd3n6n4WqbgtLhfu",
	"UYy/PbeCI6za2wlOR9FSFdWFQHAJz321o6ocZJMrgSjrNBmDkAfYvMiWtYD3L0YBX9G8Jw0+dJSgfEXn",
	"QV8yfNpbu4EaV5vLULKVBfXWO8JA4Zbrpes/7AsOxtjgw7ks3Fq3IrTfcfdzw02HAWI1s+h1z13Og1Zv",
	"8L4utJ9XffURfJMOeB42A3EhPGNXA56tuCx96JUPgPZXQvzV1d9pNP3oWX80reBTuyx6HSxnrnktLtPd",
	"yX/+FV2whAmjNp+Bu6Wz6e2OMhFtF81T9Suk6ns4qA9iQyoOaWAT65XidENvK0PW0qClTu+ZDlk9G6IO",
	"dPDxcTw6yfYSmLF+OyMcJXbsXvD5wkC5/p8YzZh6s6MdQd2CAI5YITWv24/mdjBX/3UBw02GZhpYAuZh",
	"O4XuWD4CdcVSAz1n68g6xdg+zRXsZN7jc9uWoP86XSVkuG4E21oQdBvN7pDxnapJQeUvbNI5GV5w/7iK",
	"n8b0rwuq61otrYTpwWmbsxlLoSTy1ipV/1wwEVRAGnu7DMAyC4pW8SqJCYp67291rAHaVkRqKzxBc50r",
	"g9OXxH7ONnc0aVBDtGtolcF3marBgAF0gfkC0n2GZBcyxnVFGYAFHw/s6jDXnTF6Cz4HNdcuOZcnSSs4",
	"6jpsW6aMdzwfNJf9dK+aj5CP01fIqtswuf/+8Qz6U2sXHUerqsPhLZ2cdLvmXLiqxVBTrPKd+PrFTPvf",
	"fAFBnCXn5655AGAFPVUXVGX+jYNUhELZxONAz6qZeZ290Y1wiPRhgESoNJdWjUj6ssmaCRNVtOEdjWGh",
	"dfUegGvGlGJZ5RLJpWaJkT7bYxsc21CBsa+XQoLu7X2EwPXWvX5bF/aGHnAU6lxTF/IaLpAotqQWOhWU",
	"3+6fcxuyn+Jzn4Hve4DttDBV9Lq7Ga3P2+G6g8SQ6mfEScvdmf2XMTZxIZhKvOepXYtbNMuxQdHNrExR",
	"QIcHozLIDS6cs4WVRO00aXeVrTtCkCF/zjZHeAnyXXz9DoZAo+aEoAfVRlubfFDzm47BPT8IeJ+2iFwh",
	"ZZ70ODtOugXE2xR/ztNzBgUAq/j2ngbt5C7Y2Ctv9sVi4wtmFwUTLLs3IeRYYEaRd2w3ewu2Jhd3zLb5",
	"1zBrVmJNf2dUm7wT8dQMqLavrsjN/DDbeZhmltVdcSocZEd56rXoC7m5gMr8zRaek6G38q6rud1CviYq",
	"hCKmk5yix+opHPSY4QjqHwSFOsCRSYnzdBGdy1gg72VqNNih4pgKJwOADBNDSgVUULjBowiINkWPnEKs",
	"e+cq3skZUax2Il+29F+3f3vsRt+euZqlye9mUrFGJ3b7NZb5rLJeoIYm/GfKjaJqc5kCfZ3+8R3rSS+W",
	"d4ZjVZFY9ULqaKwuDvNcXiTArJKqyUXsamvf001h7Duu1d/ZUz1lQVwX1U5R25AFzUgqlWJp+EU82ROh",
	"WkrFklxCmFfMAz0zVu9eQoaXILmcE1mkMmPYLCZOQX1zlUJQUJtYEFUTRQHSDqQK4zcBHQ+c0spU9CMl",
	"oGrN92icnzJMW69LOuGiE/Rl9oQrM+1KODkM4ctdeLc0/t+rTcsJhDGuOMS6NDP2UfssrIypyhiEZ+40",
	"rDFEzELJcr4IqjmTC57n3mBgt0GV7gIajvKLLiEcCdK17BSPyVJq4252OJKuhqpDvO6mUhgl87xpBEKV",
	"eO4s2y/p+jhNzQspz6c0Pb8H90ghTbXSbOyTmdvBePVMqlXHqynwEuwdvrsuLr4HoWmOSAYzpBZL2buL",
	"egDm+90ca7eN+7i7sPa6mswrfm04FoQaueRpnIa/rOi23pi0GEuIFgjDRoZY0gFeA0YdCocqmAFYUhfN",
	"TNBoJ7Zj4niac+oC87D/BY23PS6ZMSckegRTl086rSVJe3WrFgAAKeYZm1Jh98NQ86m4ipxjXQJwSbcB",
	"HcjFIfLnarDZEQ4OlGFXAqoTbVgBeBcv+2Ms5IaRi1O59s/v1ZXeLgX8x+1U3mAefSFVpzVpKQyq8lVh",
	"ejhCvJ701vijM8gxnw6NQqo61Q6UqAEA/XFJDRgGRSftC8aM8pxlSazR4UllExoHN1uXB9XuP8614+Qp",
	"LX2fQTt2qZirUoIqtWr6mwpqSUlWr3cttyJja4Z5FH8yJbGB4Djwd7Ac+wu2Lt+ySHK2Yo1wLVc6pQTV",
	"jq+Y/1ZXH5OMsQK8f22bVCwOKZTlLUOFW3sSRLIMwW7UcoGIxZ0iO8wSUSPKWiR4TPTQo2QhWvGspA38",
	"6X1VjqbZzR7lCKo6Onni721Dp/kFR3jrBzj238dUGY+J98P40N4sKI66bQxoZ1xiqftOvYiHJYZ1gSqH",
	"BsyWVY5PJPGab+iCXoh+A2CX5OvrzcB94lIEiH2+ZiloNc24u6vjhMBgRLdqfvWq4Kra4csbkj8JDW8l",
	"4d7xYlcNzVyi2hZLjacLp7DDC9BxWli112rN0EvQ8X/H/8ZkWvqB7L0aWxuGN7hnzHvsoAx55axwCi2v",
	"BJqPLxy7KpTtSzkPIquXdEOkgn/sfe3fJc35bAMnFMH3nxG9oJaEnIsQfdcuXtFOvF0xGXvAvF1A+qlw",
	"3XzomMFwGztKALQVgb4HjSRLes7CbQC3PHKe1FiWo8vpkmsNwq61nV0suMX7SiJLmoV3ZKhn2Oz27Svc",
	"2q//nzprK5zKlyErcpr6Rpauk07DII7Naj1xmQVbbk/r616PPQlUDXBrolU+CTy7hHFvz8iNWKx8X5eQ",
	"BtidxqCdBilXWsZAG2WrFcSWhMhBSzn0LgyND+kAHbYT3AV+2F3xZvAfLTXat4wh4H8ueO/ppxrCi61T",
	"bwDLjUIREVjRrjqV60Sxmd4VCoGGVXsRVnWJCW+c5CJVjGqMDTl57a5sdSVNLuwVEqMXK+9bNUrGZlzU",
	"zJKLojSRGwAU1BSbAGGheRrQ2uPs6dMSrBq2ovnrFVOKZ30bZ08Hdh4MOxl4k7z7NnL5r2RqdwCu69sP",
	"ZBKyOlMteM0KcOyVhIGF2lCRUZWFr3NBUqas3CcXdKMv7/uw0KrS6hc7vB800Gaa+e2BHwRIGwHJN859",
	"eUXPRAUgPaCLYoBrASJYI24FNIoY2eNJ6MIQL8ZB10ku55Bf1kOArmQp+H7wsiIFGGxRH9pvHs3/ZNun",
	"gWrt7uAbCbMOmWL7OXsNqIMLzy+Cm60nDa1p7YQ/jMjEg+DpX8zrsHDcnC79x3I0XVmOME/TK3c+icHv",
	"NYaH4Hysx5PRtOD27CI4yF2Cb2iuHd4Fq+mDj2WC4h02gbut3hL4zXQd5ExTF7jTNfp0LsWIlLHLo93T",
	"JoSWZC8HesDDluXubDWnrYIp7Dj7tA7bnjmbFLJI0iHRgNjQIXMGbQdpE8Ye+gjM1T3rrgIndNXipFEO",
	"p9HrZN/uab29Vnb5ZYp02yW7z6DRw0GbxnI5A16GDb3BDgM5HpXxYtzOPmoabComQShRLC0VGDQv6GZ3",
	"N6qeQsKnPx1//fDR74++/obYF0jG50zXxahb3ZzqiDEu2naWm40R6yzPxDfB56Uj4rynzKfbVJvizhpy",
	"W11Xmuz0strHEhoRAJHjGOkidKm9gnHqoO/Pa7tiizz4jsVQcP17pmSex5sBVKpbxNQf263A2G81/oIp",
	"zbWxjLDpq+OmjpXVCzDHQUnYFdYZkSJ1NfsrKuCmJxgntpC+UEvgZ5D16/wbhK2L3PEq9ElsW5e7F6FF",
	"DIIzIH5jykghC6dK8xmJQQS5JSrIuXSGRgjvDKInK2aLcZQxQnQxyXHSC/sob+f2zR6fJs7p7SZG1At/",
	"KC9Bmn2W9P6M9stwktqU/tnwj0iK/sG4RrXc6+AV0fvB5Xq1DwKtm64dIQ8AoCcPs5FBF6QQBfVpFVrl",
	"wX7vXZ1t9eNl7QLdmTAAkPgPdoAXJlbW71Ux7g6cT1zo9WWFlGAp7/soobH8XbmanvVWgiTYImekMIZp",
	"ZEuyqxYGibj6aZXf2nMr6aTBKikNsTfTPI+kz6LdBM5USDj2SqBWNL95rvEDV9ocAz5Y9rY/aSbMoQyR",
	"jKjUl6vg9oIOmjvIlzzc1OINpOz+k9k9iso5N5RzF3ekGVi9oJH53EsFzAImFzAmhgM9/IZMXQ+GQrGU",
	"67Yb+sIrJ1XKIFN85kIv2drsyFHctc5fpbkCGc98zAh5FbiTJJjtagjrI/qJmUrPyY1SeYz6OmQRwV+M",
	"R4U9W3eIiyvW679cQZCgtNeeBUG63WiHLg+LXlihU2rWXedgad3AbURQ12sbWs1mcNn/d+9+M9MhRWji",
	"Jfrt51AF5yC1+veq1H8N9W8QR24MN2+MYn7tq4iKVT97Sja39qPk+c4AkUYB7o/j0ZwJprmGEtO/u5Yi",
	"NytLPQSYk989qgjrVQqJIGIia21MHkwVlNYeUFXbfRaphgz5bmmpuNlAO1lvQOO/Ryv1/FhVfXBVQyrf",
	"lZN9Rp6zqqV3XSOi1F66/ihpDvIIXWrCSiGZT8hzrP3sDsp3d6b/wb76x+PswVcP/2P6jwdfP0jZ46+/",
	"ffCAfvuYPvz2q4fs0T++fvyAPZx98+30Ufbo8aPp40ePv/n62/Srxw+nj7/59j/uWD5kQUZAfcX3J6P/",
	"TI7zuUyO35wkZxbYGie04D8zuzdwV55JaHdokZrCSWRLyvPRE//T/+tP2CSVy3p4/+vIte0ZLYwp9JOj",
	"o4uLi0n4ydEcksITI8t0ceTngSZ0DX3lzUkVTY5xL7CjtfUYNtWRwjE8e/v89IwcvzmZ1AQzejJ6MHkw",
	"eeg6Hgta8NGT0VfwE5yeBez7EVRePALf11FRYE31j+PRkSNC99eC0Rxqq9g/lswonvpHitFs4/6vL+h8",
	"ztQEEgnwp9WjI69uHH1wSfMf7cxRPxyW2A7qKvu2W0U5zXnqy1NxjQZijPXWYVNRtJyXekym2HbWh5OK",
	"DEJ+MA9dh62XTzKLSPz8pGZmvnMu+GlHT36LFDLyOQi+oWsYxBWEd/2f09eviFTEXXve0PS8yr/wCTd1",
	"klGYb2O/nHi6/nfJ1KamO8cRx6O68zsT5dIyF5fIsdTzolnTs9a2YtagDq79zJZcAoKvSlzUDA1MfwEk",
	"NXu2LPdB8u37D1//4+NoACBQb0Uz6O/3B83zP9B8xtYQ49mKZBn3xRiN65IJ8EG9k2OwVFVPg8/rd5ql",
	"sP8QUrA/+rbBARbdB5rn9kUpWGwP3kMHOiAWOIuPHjzwDMip9wF0R+5MjQb2+ffV39F7UI3iSeISA3UZ",
	"FT56W1VFVLTAs+ieYAan89/gSxPLjx4fcKHN2o1XXm57uM6iv6cZUS5zFZby8ItdyonA2EorcFAwfhyP",
	"vv6C9+ZEWJ5DcwJvBu1du4LmF3Eu5IXwb1qlqFwuqdqAymMqXtjuR0LnGpymwCLxbAeFt8R89P5jr9Q7",
	"CoMIjz40quZkV5KJ6EVpdPPZISbv6D7OCWNhfpT74e5xUUAM5Wn1/LgosFs0xAkwDtKPrbk2+t6E/Bh+",
	"3XB+ICTo+/BmFiv1qubJviVzwxcetGGMCu1GPvqt/P608vu4aQThGROGzzgo5DFgGqdgK0ydaKSrCtBu",
	"ukpQHWffAOOqMrJTLRLXcmvgGK75+uH6yQ0oioEzvY9dEXcy6lvc9eCuT00K4K00prqZ3c2wZl9ktZIk",
	"DZFxjYz7C1f6XtLc0kmw3FYzk5Nnt8rg30oZrIoxzlE7K4oDqIc+E2LXK0cfXIHBQ2iNcD0epC+GN+/g",
	"2yCY/W6L49ybkOP2O5djK65A405N0L53qwN+DjogVrjcpf05Ov6kel+YR7VPWlNDYbG/D/r4C1f0/sbI",
	"6tXsLKS7dbpLsM+OvuaY9bWx1b+knuaQdquh/a01tKps8pV0tDC29cil9Qca25UMfG0DHjeVJtYsnR1w",
	"Nqh8AQnueITHdRy/ZTEYoOxCk/XYXx7BE4v3Styscedq2VWxfmThHfb7zcmzXdrVF2QKGtwBNyIF4ntz",
	"3bw06pl4ezOeiWG86fGDxzcHQbgLr6QhP4AUv2YOea0sLU5W+7KwbRzpaCrXu7iSaLGlqlaaPbQNHlWV",
	"xBwHz+3bGOBxF1Jomz2T7k3I9+7VuqyGSxGfS8uofCoYVXP8yPI6iwxyx//5BMa/MyE/QIKj0WOIU4PM",
	"CXiRC/Pk4aOvHrtXFL3AMLD2e9NvHj85/u4791qhuDAQMoD3nM7r2qgnC5bn0n3gZER3XPvgyX/+139P",
	"JpM7O9mqXH+/eYVNVj8X3jqOFd+rCKBvt77wTYrd1l3z252ouxEP//dyHZUCcn0rhT6ZFLLY/0tIn2mT",
	"jNxFtDJ2NtqwHFAa4THZRx6NnfyBLI1KmEzIK+k6YpU5VVhwBaq5ajIvqaLCMJZNPKVCip3GDkBpzqE2",
	"gCKaqRVTieZV1eRSsaoqSKHYCsLr63qjDQh2M3oIwv1smfxLug7y4qeVmDbSLRnMnku6JtDiwRDNzBhL",
	"kq3Jd9+RB+P69pLndoCkQkyMuS7penSDVr+K2IbW2XnmsCPV7theGHuIBanWfqpSh/VV4+/Oub9YzR3J",
	"3W3sgTjn3o6f2rET2hFc36mtFgRU7AwU5tVlUeSbuiSr1fK8ChVncXaGocaBz9hHsNM0Hb2EttF7e4hv",
	"jQBXYiVtgtqTbUDCqj76APfykGd0zi0k3P293KWB70jJpXceSTJjJl24XN8W6iPsSbl8w37etOSCLy2U",
	"D8bXrtXALnYLCodtfzOKGfZDOksFaZjgwGMqQsSvfSN8+5jPsMq47z3hywOCa8oVaq56beLlG7vvupB/",
	"nxJc0Ebv0N1QPq0n7ypkgJZD+D9vEbwfgjvM8bkrZ4DHyy3ir5AU4K+SCXkl64xzvEH9JV2P1ynZr3tB",
	"r6Rg6GO3mi/S4q07tVI7LONApPhSI3h/qTs9XVYFOfIlerbqIT/Zl3boIkOkN5T7+RJF+E/RQkYNKWPX",
	"NtlZR6EebQhzti9ig4Gw0snkU95iPgk//QyvNp+CY90Mi4FD6vmMUwvEYZkOVO9BYj6q+s33caAX9uVA",
	"L8OCRoO5kZFVGBqLlA0iU5ZLMdefJyvaRh1xvESoBItUYZ+Szvonf8Oz+9Q1EfF93F2pKM1FyoiWSwZX",
	"BqujQ2MLDJZ8/OAfNweh4UvftFmE6a2fmLt8/eCrm5v+lKkVTxk5Y8tCKqp4viG/iKpZyFW4nSbU7Xlo",
	"DY4wBy7A29QsKZaG9Y+uwARd0/S41djZreuiiBr1KlkaprAcXqubEu8w6Zg9GBjGCzv1AfS5XM6/NHXO",
	"Y31oFeenNM8BXbucTDDwoCjlPMf9ZEtuTN2DIZSu5DlNF9XejmvrXtVjzhcPH7fKTcLIruEYpvprZvfZ",
	"MBKsJrBWMIXdqQ00QlpSCFhelrnhRd78pmrCCK11ImFISJthVf6TZ3516JyVs3roNv36UuNu8Imd2z2C",
	"mYXExVHFgHdXtpVWt6ZJA2hsMuXDr4PWQK7BkatkyFWrtGQdO1MUjKr6Y6T8u4ViiRtC0RVTmsJhbS3q",
	"3q2q/nmo6mtXy/gzUdSjPsqr8vrLi6JGFPUHs+bZx916eVAOeE+VnItAJQ/ZBZ61y+viu6Mo2k2uT56F",
	"iSqyKpjlFYQeUCyK9szV+l+jgS4QKNIiZ+4eVgoE1NewdBqryyKRs3EVp2kvpHL2hLwT94leUF9i2f35",
	"6Otvepw4dh5Xeq7rxqkHso9xmCG+nC/aM3VYjaPC75Ob3u39NnE84tk6UkdeZGwdtC5pNuF18vCOJgXd",
	"+IyOTinFIl5OubqYhsMumRVTesGLmy/Zqw2fxmuWe0tc1cz9RHxfGWSxrqzVGopPUap1PDKKsYwVZrGz",
	"gjO8Ve8mc7WcuXZdd7DO7pjwCZtgGdq6G1k2Z04wUZIzOqvaikk5JI8v4DOW0DxVBFgPFzJEk47SD+i8",
	"QJQ3byet891Q0HnktZXiT6qEmU+lhCUtLayJlk+nk0G/hnEQeVUoaWQqcwyjLItCKlOdbj0ZZHlgfYpe",
	"w/DQR7hXUubWPNM7XTpn8NYBbABNytZfjEvnzKMp5tOJLeqSdWXruYawtDNZkE4TeQvCJ+Vrt5fKGD9r",
	"uX++dO+P6SW9AzuDUmrSRVkcfYD/QF3dj3XOLnQc0UdmLY6gp+PRh63RtcBSc6ubKGxW0jDpdjpERmNk",
	"X8DndWOUH6Rqd9/eGT3bQtq4LfSxPyWE4UbY4/XcJv/Wl7CtrrPWhl89GiQyYue8ViUpgi57Fe0G7XZ8",
	"lQnssRkh4dvopc9rQbU/ccZFRmiwjS1bU9UH398B/vHFLvpTuChvPmTr6y/4nL2Shpwsi5wtmTAsu1rg",
	"O2lzOC89torb/RQDJ/q70fFdmR9KfJ/TU+kiOwX8HveeoIoR89NRBWWFrKy+nuvOrST/vCX508rbGpLh",
	"rVz+cuSy8plItyL48xfBX32xq7nGGKaBIvkSzuGmGK5v4nsK5I4y4GxYLcPBNr8yXL3bq9Q/SOWbyt1K",
	"8S/UKYo7OTgQa4iFZpcl1k15iKyzzwr6YXaGPI9YGvoO6riK9eJQr1GmHLrznGR67ILK0DjhTvGt4vNZ",
	"Kz7BXt/qPbemhy/M9NCj5bhbf54PUTT2VYBWS5kx71iVs5mrj9yn/TQ7Plry1IYuC4JfTnrjsM/4kp3a",
	"N1/jFAcVsTXYLbWoBZ5FlmapFJkeEMXhRr2sHAJHUz8AN+7ZrHbAw+IqJ00uTbJvg/KLHUogbeRr6NTp",
	"60Q7ZGRsRSwBTg5Atkcf8F8wpxVSR1Zz6gm4szF33bZg4WsctwEgeQNKKFbQ9l/JGXmA9a9LAUnudUtu",
	"KjJi1MYqqr7cn2I0J2kjubWCo3tyTntPzs6rQGd1PWuK3wVkfUIPGcHQKizw840fgKdUOJLvIshIQolg",
	"c2r4inmX/+S2GNWlpZkrBbWFAY4JzTI8jfUmsBVTG6LLqba6jmjmKN3RzfOyB8Ng64IpbkU0zWsHPF4T",
	"jrDS1LY4olN844pCq8WLsL6VakYtesnqql/JGXnJUyWP87msYuH1Rhu27DS8dp/+3tOvwBsSujGrUuRc",
	"sGQpRawN82t4+hIexr6Gal19H5/Zh33ftuRtE/4WWM15hsjkq+L3Mzn9Vwp0aa1WsUIqe7udbjD/Auh/",
	"z6PkD81GpN2TtBFp4NRyD4OBwubMjZ+PfDpCo1Vz9M0PjT9dRTr3pl6UJpMXwSxgA8BwxiHFqED53jPJ",
	"o7a5NbMnub5eq9t1epsCPMTOVvU00oK3ftjfhfdvmoTtnDMhkbicxhVTunWRu83E/ktlYg/e9724Mbac",
	"38XRSn1Y3eWVzBiOW6fj2qMfa4IiZMZcZ/yuylKFRcZThrz8qt9rJXGktJwvDCkLYmQsXaT+MKEpMtkE",
	"L0LxCYOyw3hdgukWdMUIzRWjmb28MkHk1C66lqSwSKqh8LPPOXHBn1GlKYCrUDJlWrMs8U1fdoHm38NQ",
	"dbMFTwA4AFzNQrQkM6quDOz5aiec52yTwGVYk7s//2qv1jcOLyqN2xGL5WYj6G2nXXehHjb9NoJrTx6S",
	"HSZ0I9VCipxcFjlzSXIRFO6Fk979a0PU2cWrowWyyPg1U7yf5GoEVIF6zfR+VWjLIrHyuwviU3x6xpeg",
	"iQkqpLdAxgbLqTbJLrZsXwrXou0KAk4Y48QwcM/V9AXV5q3Ll86gzCOKE5gHdWw7RT/AVori3SIy8q/4",
	"MDZ2auWh0KUmbgSfA8Wy2BoEW2+Z6xVbV3NB7RQ/dpVkhbbAXSP3YSkY3yEr6HxDqAn8/na4yOLAUkmd",
	"KaOLygYQNSK2AXLq3wqwGzr8ewDhukY0Eg5U8g8pZyplzqjAXFVZFJZbmKQU1Xd9aDrFt4/NL/W7XeLC",
	"WhgotzPJdJgA5yC/QMxqMOUuqCYODrKk5y5Hbu46mXZhtocxgTJLyTbKB+OufSs8AjsPaVnMFc1YkrGc",
	"Rowuv+Bjgo+3DQA77skzWUnDkinUSIlvek3JqteYVA0tYTwdUx4JPCGpPYL28lwTiPt6x8gZg7FjzMnR",
	"0Z1qKJgrukV+PFg2bnWPAcuOYXfc0QOA7Dj6EIB78FANfXlUwMdJbT5oT/FfTLsJKj1i/0k2TPctoR5/",
	"rwW0DX+hAGtIihZ7b3HgKNvsZWM7+EjfkY2ZGr9It0A7yukak+yaptbgAji5zOX26IJyk8ykQkU6oTPD",
	"1M7Q+X9S7h3nPn1XuqorBEZwctONA0w+7CfnuAiCQJy4sCTiKklZGUbJQ7LkojT4RJZmjOWvFaPpwirt",
	"oQ0WR4KOwK5Ik2JzqrIcusXOKrkpFRZ9Mi0BD0BH8hGbN3677h+kGlRUv1k6knJDSmF4HjQWqu7tn5/1",
	"8tYicWuRuLVI3Fokbi0StxaJW4vErUXi1iJxa5G4tUjcWiT+vhaJT1UmKfEah6/YKKRI2sGUt7GUf6mq",
	"8pWo8gYSsE5cUG5cm3xfpaDfbrGHIcgwmgMOeM76o7sx6PTs+fELomWpUkZSCyEXpMipvRqwtamaNk+p",
	"Zt889qmGKDrpEju/g3y1L3z1iJz+dOwrji5cZczmu3ePMV6NaLPJ2T3XFo2JDDVR3x+NCYt01x6NepHg",
	"mzu7Vtc8h8h4TZ7D28/YiuWyYAqLGRKjSta1+Jwxmj91uNlh8PmnndyF2v5hR/tj3DB6ObQtaeHVfL9W",
	"qgnFjEvyLMjB/GNGc83+6EvDxPGWtIj1V64EH5qCgJl8L7NN64TYXTuCDWyejbruKBdUbSJVoropEG3S",
	"MNKyK0dYXVvWx4NXx+0SbZfMdlFYTFvHMvjx0fuoPFoWttqwzlCYqDtr0ckolmParoU6qgAcVBgQ0iRw",
	"T8hb/O7TlgEEiNwRq5n5ZxPF2HyzYhrwrr1EONbzpeYSeMRHTy+c/bEl7KxMGeFGE19gd7d4GY/WiR1p",
	"zkTiGFAyldkmabCvUUMKZVxTrdlyulsShfwTTlwlfOyT7XLq04iRZ8HitvHkkGjWiWPAPdx5Y9hg3lxh",
	"C0Z07DnA+HWz6D42GoJAHH+KGZVavG9fpldPs7llfLeMLziNLY2AC1eQvM1EJtfI+NRGlaKf5z1fs7S0",
	"wIUn+S5Y58Elx9am4WTN2LScz+1toeujgzY6MB6X4hOxQlzuUC64HwXh4FW3/KsmqbeH63KXIG/8rq/M",
	"eA+2g4oNODOWBRUb7/JliebLMkccYlPpwzJarBkeKzFd2/76rNpvvMkvsN06Udv8HdFCLqgmuL8sI6XI",
	"XMZTp7b1Wgyvc4JDn61Fzaa31jTB9UZW5+YdIiL8LjdTzTUpmErMWuCBahwm18EAT+4nraV9KzZuTmxg",
	"ojrrYbDdavw1QziQ9FABXwPxEfRcqhPzGp2YaDOdsPEMLBr9KS5hcyZ886CBJZ3hm/EltbnF+U9ZXhBK",
	"0pyDd1UKbVSZmneCgv8mWNikG3viDdX9vO+pfyXuQox4+NxQ7wSFIKPKqxPlgTMWcWH8wJhnsbqcz5m2",
	"fDQkoBlj74R7iwtSCnsLkzOy5KmSCabW2vNldZcJvrmkGzKDiiaS/MmUJFMr9YNdR1uyNjzPXbCLnYbI",
	"2TtBDckZ1Ya85JYD2+F8OYUq5IyZC6nOKyzEe/XMmWCa6yRumPkRn0I7HLd8bwAEYyY+rttY3GwfHA87",
	"z3ohP3kGMWpQjTnnOuy/2Ib9xnzjSy6SKJGdLRhx4WJt2iJ3oQacI6B7TceRWbB3wko/IwlwfGouRw5t",
	"D1DnLOLpaFFNYyNajiK/1kHXv4NwGRJhMrdul79QCmlAB96zCRuP9fVbe7+ni6Uhchm0Bu0TyPjUtU/s",
	"ecldIBpGslaBG/fGWQPkrf6LL7+s5OHvkh6NB7tNdgfssqtmgzzAm9/wMaG5FHOsq2hvlxL2iYuiNBAA",
	"fp0GPLaieSJXTCmeMT1wpVyK5yuav64++zgesTVLE6NoyhK0KAzF2pn9BukUGg0KbjjNE7hVDwWIneBX",
	"p/jRDnkcdBtdLlnGqWH5hhSKpSzDQmRck/o+P8ECDSRdUDEH0a1kOV/gazjOBVOsasxor9DtIeKFYNYi",
	"waJ0XRiPXaPmsG4vo+ki0jgGBJy9s3uCyho9qQbuQaPkaN8lfTzqVbQtUld16Bwip8lmBmgRDX0gwE89",
	"8SFqtN4S/S3Rf+lEHyupCKibtawViK9wW67ZrHXdBURv0Er2SaoL35bo/6uX6PccSBNKFG3cQeK94agm",
	"3JALKIs0ZcTKrxKs867hnruvQ6ZdcNRdpU3t2vOlC8qFq6lT5TUAHPZKvFxyY3x72msxbCIzA4umRQdL",
	"S8XNBm4ttOC/nzP7//dW7ddMrfyFplT56MloYUzx5OgolynNF1Kbo9HHcfhMtx6+r+D/4O8iheIre7/6",
	"CGBLxedcWJl7QedzpmoT4ujR5MHo4/8NAAD//025z9X7vAEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
