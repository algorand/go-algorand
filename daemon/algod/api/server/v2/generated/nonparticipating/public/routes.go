// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
