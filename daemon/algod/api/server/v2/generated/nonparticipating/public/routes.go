// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
