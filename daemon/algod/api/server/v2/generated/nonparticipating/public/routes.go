// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9fXPbtrI4/FUw+v1m8nJFOW/tPc1M5z5u0vb4tkkzsdtzz23ytBC5knBMATwAKEvN",
	"k+/+DBYACZKgRNmynbT+K7FIAovFYrHv+2GUimUhOHCtRs8/jAoq6RI0SPyLpqkouU5YZv7KQKWSFZoJ",
	"PnrunxGlJePz0XjEzK8F1YvReMTpEup3zPfjkYR/l0xCNnquZQnjkUoXsKRmYL0pzNvVSOtkLhI3xLEd",
	"4uTl6OOWBzTLJCjVhfInnm8I42leZkC0pFzR1DxS5ILpBdELpoj7mDBOBAciZkQvGi+TGYM8UxO/yH+X",
	"IDfBKt3k/Uv6WIOYSJFDF84XYjllHDxUUAFVbQjRgmQww5cWVBMzg4HVv6gFUUBluiAzIXeAaoEI4QVe",
	"LkfPfx0p4BlI3K0U2Ar/O5MAf0CiqZyDHr0fxxY30yATzZaRpZ047EtQZa4VwXdxjXO2Ak7MVxPyqlSa",
	"TIFQTt5+94I8ffr0K7OQJdUaMkdkvauqZw/XZD8fPR9lVIN/3KU1ms+FpDxLqvfffvcC5z91Cxz6FlUK",
	"4ofl2DwhJy/7FuA/jJAQ4xrmuA8N6jdfRA5F/fMUZkLCwD2xLx90U8L5b3VXUqrTRSEY15F9IfiU2MdR",
	"HhZ8vo2HVQA03i8MpqQZ9NdHyVfvPzweP3708f/8epz8r/vzi6cfBy7/RTXuDgxEX0xLKYGnm2QugeJp",
	"WVDexcdbRw9qIco8Iwu6ws2nS2T17ltivrWsc0Xz0tAJS6U4zudCEerIKIMZLXNN/MSk5LlhU2Y0R+2E",
	"KVJIsWIZZGPDfS8WLF2QlCo7BL5HLlieGxosFWR9tBZf3ZbD9DFEiYHrUvjABX26yKjXtQMTsEZukKS5",
	"UJBoseN68jcO5RkJL5T6rlL7XVbkbAEEJzcP7GWLuOOGpvN8QzTua0aoIpT4q2lM2IxsREkucHNydo7f",
	"u9UYrC2JQRpuTuMeNYe3D30dZESQNxUiB8oRef7cdVHGZ2xeSlDkYgF64e48CaoQXAER039Bqs22//fp",
	"T6+JkOQVKEXn8Iam5wR4KjLIJuRkRrjQAWk4WkIcmi/71uHgil3y/1LC0MRSzQuansdv9JwtWWRVr+ia",
	"Lcsl4eVyCtJsqb9CtCASdCl5H0B2xB2kuKTr7qRnsuQp7n89bUOWM9TGVJHTDSJsSddfPxo7cBSheU4K",
	"4Bnjc6LXvFeOM3PvBi+RouTZADFHmz0NLlZVQMpmDDJSjbIFEjfNLngY3w+eWvgKwPGD9IJTzbIDHA7r",
	"CM2Y022ekILOISCZCfnZMTd8qsU58IrQyXSDjwoJKyZKVX3UAyNOvV0C50JDUkiYsQiNnTp0GAZj33Ec",
	"eOlkoFRwTRmHzDBnBFposMyqF6Zgwu36TvcWn1IFXz7ru+PrpwN3fybau751xwftNr6U2CMZuTrNU3dg",
	"45JV4/sB+mE4t2LzxP7c2Ug2PzO3zYzleBP9y+yfR0OpkAk0EOHvJsXmnOpSwvN3/KH5iyTkVFOeUZmZ",
	"X5b2p1dlrtkpm5ufcvvTj2LO0lM270FmBWtU4cLPlvYfM16cHet1VK/4UYjzsggXlDYU1+mGnLzs22Q7",
	"5r6EeVxpu6Hicbb2ysi+X+h1tZE9QPbirqDmxXPYSDDQ0nSG/6xnSE90Jv8w/xRFbr7WxSyGWkPH7kpG",
	"84EzKxwXRc5SapD41j02Tw0TAKtI0PqNI7xQn38IQCykKEBqZgelRZHkIqV5ojTVONL/lTAbPR/9n6Pa",
	"/nJkP1dHweQ/mq9O8SMjsloxKKFFsccYb4zoo7YwC8Og8RGyCcv2UGhi3G6iISVmWHAOK8r1pFZZGvyg",
	"OsC/uplqfFtpx+K7pYL1IpzYF6egrARsX7ynSIB6gmgliFYUSOe5mFY/3D8uihqD+Py4KCw+UHoEhoIZ",
	"rJnS6gEun9YnKZzn5OWEfB+OjaK44PnGXA5W1DB3w8zdWu4Wq2xLbg31iPcUwe0UcmK2xqPBiPmHoDhU",
	"KxYiN1LPTloxL//dvRuSmfl90MefB4mFuO0nLlS0HOasjoO/BMrN/RbldAnHmXsm5Lj97eXIxowSJ5hL",
	"0crW/bTjbsFjhcILSQsLoHti71LGUUmzL1lYr8hNBzK6KMzBGQ5oDaG69FnbeR6ikCAptGD4Jhfp+d+p",
	"WhzgzE/9WN3jh9OQBdAMJFlQtZiMYlJGeLzq0YYcMfMiKvhkGkw1qZZ4qOXtWFpGNQ2W5uCNiyUW9fgd",
	"Mj2QEd3lJ/wPzYl5bM62Yf122Ak5Qwam7HF2TobMaPtWQbAzmRfQCiHI0ir4xGjde0H5op48vk+D9uhb",
	"a1NwO+QWgTsk1gc/Bt+IdQyGb8S6cwTEGtQh6MOMg2KkhqUaAN9LB5nA/Xfoo1LSTRfJOPYQJJsFGtFV",
	"4Wng4Y1vZqmNs8dTIS/HfVpshZPa5EyoGTVgvuMWkvDVskgcKUbMVvaF1kC1l28702gPH8NYAwunml4D",
	"FpQZ9RBYaA50aCyIZcFyOADpL6JMf0oVPH1CTv9+/MXjJ789+eJLQ5KFFHNJl2S60aDIfaebEaU3OTzo",
	"rgy1ozLX8dG/fOYNlc1xY+MoUcoUlrToDmUNoFYEsq8R814Xa00046orAIcczjMwnNyinVjbvgHtJVNG",
	"wlpOD7IZfQjL6lky4iDJYCcx7bu8eppNuES5keUhVFmQUsiIfQ2PmBapyJMVSMVExJvyxr1B3BtevC3a",
	"v1toyQVVxMyNpt+So0ARoSy95sP5vh36bM1r3Gzl/Ha9kdW5eYfsSxP53pKoSAEy0WtOMpiW84YmNJNi",
	"SSjJ8EO8o78HjaLAGVvCqabL4qfZ7DCqosCBIiobW4IyMxH7hpHrFaSC20iIHdqZG3UIetqI8SY63Q+A",
	"w8jphqdoZzzEse1XXJeMo9NDbXgaaLEGxhyyeYMsr66t9qHDTnVPRcAx6PgRH6Oh4yXkmn4n5FltCfxe",
	"irI4uJDXnnPocqhbjDOlZOZbr0MzPs+b0TdzA/sktsZbWdALf3zdGhB6pMgf2XyhA7XijRRidngYY7PE",
	"AMUHVinLzTdd1ey1yAwz0aU6gAhWD1ZzOEO3IV+jU1FqQgkXGeDmlyounPXEa6CjGP3bOpT39MLqWVMw",
	"1JXS0qy2LAh6bzv3Rf1hQlN7QhNEjerxXVVOR/uWnc7GAuQSaLYhUwBOxNQ5iJzrChdJ0fWsvXjjRMMI",
	"v2jAVUiRglKQJc4wtRM0/569OvQWPCHgCHA1C1GCzKi8MrDnq51wnsMmwUAJRe7/8It6cAvwaqFpvgOx",
	"+E4MvZWa77yAXaiHTb+N4NqTh2RHJRB/rxAtUJrNQUMfCvfCSe/+tSHq7OLV0bICif64a6V4P8nVCKgC",
	"9Zrp/arQlkVP+J9Tb42EZzaMUy68YBUbLKdKJ7vYsnmpoYObFQScMMaJceAewetHqrT1ITOeoenLXic4",
	"jxXCzBT9APeqIWbkX7wG0h07NfcgV6Wq1BFVFoWQGrLYGjist8z1GtbVXGIWjF3pPFqQUsGukfuwFIzv",
	"kGVXYhFEdeVqcUEW3cWhQ8Lc85soKhtA1IjYBsipfyvAbhgC1QMIUzWiLeEw1aKcKu5qPFJaFIXhFjop",
	"efVdH5pO7dvH+uf63S5xUV3f25kAhZFX7n0H+YXFrA1+W1BFHBxkSc+N7IFmEOvs7sJsDmOiGE8h2Ub5",
	"qOKZt8IjsPOQlsVc0gySDHK66Q76s31M7ONtA+CO1+qu0JDYKKb4pteU7INGtgwtcDwVEx4JPiGpOYJG",
	"FagJxH29Y+QMcOwYc3J0dK8aCueKbpEfD5dttzoyIt6GK6HNjjt6QJAdRx8CcA8eqqEvjwr8OKl1z/YU",
	"/wTlJqjkiP0n2YDqW0I9/l4L6LGhugDx4Ly02HuLA0fZZi8b28FH+o5sj0H3DZWapaxAXecH2Bxc9WtP",
	"EHUzkgw0ZTlkJHhg1cAi/J7Y+Jv2mJdTBQfZ3rrgd4xvkeXkTKHI0wT+HDaoc7+xgZ2BqeMQumxkVHM/",
	"UU4QUB8uZkTw8BVY01TnGyOo6QVsyAVIIKqcLpnWNmC7qepqUSThAFG/xpYZnRPPBkX6HRjiVTzFoYLl",
	"dbdiPLI6wXb4zlqKQQMdThcohMgHWMg6yIhCMCjegxTC7DpzseM+ethTUgNIx7TRg1td//dUA824AvJP",
	"UZKUclS5Sg2VTCMkCgooQJoZjAhWzekiO2oMQQ5LsJokPnn4sL3whw/dnjNFZnDhEy7Mi210PHyIdpw3",
	"QunG4TqAPdQct5PI9YEOH3PxOS2kzVN2Rxa4kYfs5JvW4JWXyJwppRzhmuVfmQG0TuZ6yNpDGhkWVYHj",
	"DvLlBEPH1o37fsqWZU71IbxWsKJ5IlYgJctgJyd3EzPBv13R/KfqM0wmgdTQaApJiikQA8eCM/ONzZrY",
	"pRvW0WRsuYSMUQ35hhQSUrBR/kbkUxWME2Lj/9IF5XOU9KUo5y4AzY6DnLpU1qYiS94ZIioN6TVP0Dod",
	"49wu6Ngnehg5CKjRxdqmbat5XNBqPpfbM+RKDZDXNvVHvVvjUa+qapC6qlVVi5xmtsoALt4Q1AL81BMP",
	"9IEg6ozQ0sVXuC3mFJjNvR5bez10DMruxEFIXP2wLyrO6Mn55gDSih2ISCgkKLxbQvuSsk/FLMxMc5eP",
	"2igNy64J3n76W8/xe9ur6AmeMw7JUnDYRJOxGYdX+DB6nPB+6/kYJY2+b9vKQwP+FljNeYZQ41Xxi7vd",
	"PqFtV5P6TshD+TLtgIPl8gGuw51+cjflZR2cNM8jPkGXt9JmAGpc5ckzSahSImUobJ1kamwPmnMjuiSX",
	"JvrfVNG4Bzh77XFbzq8wJRKNu5AXhJI0Z2j6FVxpWab6HadoXAqWGola8lp0v7nxhX8lbt+MmB/dUO84",
	"xYi1yuQUjbSYQcS+8h2Atzqqcj4HpVtKygzgHXdvMU5KzjTOtTTHJbHnpQCJoUMT++aSbsjM0IQW5A+Q",
	"gkxL3RTbMS1LaZbnzhNnpiFi9o5TTXKgSpNXjJ+tcTjvrfdHloO+EPK8wkL8dp8DB8VUEo+u+t4+xcBX",
	"t/yFC4LFNHr72PpuzPh17tYGbU91avj/e/+/nv96nPwvTf54lHz1H0fvPzz7+OBh58cnH7/++v9r/vT0",
	"49cP/uv/xnbKwx5LGnKQn7x0Ku3JS9RbaudNB/YbM9wvGU+iRBaGYbRoi9zHBFlHQA+aVi29gHdcr7kh",
	"pBXNWWZ4y2XIoX3DdM6iPR0tqmlsRMuK5de6pzZwBS5DIkymxRovLUV1AxLj6XnoTXQZd3heZiW3W+ml",
	"b5t94gPDxGxcpWDa6izPCebnLaiPanR/Pvniy9G4zqurno/GI/f0fYSSWbaOZU9msI4pee6A4MG4p0hB",
	"Nwp0nHsg7NEYOBuUEQ67hOUUpFqw4uY5hdJsGudwPqbfGYvW/ITbYHtzftA3uXEuDzG7ebi1BMig0ItY",
	"1YaGoIZv1bsJ0IoXKaRYAR8TNoFJ21iTGX3RRePlQGdYPQC1TzFEG6rOgSU0TxUB1sOFDLKIxOgHRR7H",
	"rT+OR+7yVwdXh9zAMbjac1aOSP+3FuTe99+ekSPHMNU9m8hrhw5SLyOqtMsuakQSGW5ma9VYIe8df8df",
	"woxxZp4/f8czqunRlCqWqqNSgfyG5pSnMJkL8twnLL2kmr7jHUmrt5xUkCpGinKas5SchwpJTZ62REh3",
	"hHfvfqX5XLx7974TVNFVH9xUUf5iJ0iMICxKnbgCB4mECypjTitVJbjjyLaCybZZrZAtSmvZ9AUU3Phx",
	"nkeLQrUTXbvLL4rcLD8gQ+XSOM2WEaWF9LKIEVAsNLi/r4W7GCS98HaVUoEivy9p8Svj+j1J3pWPHj0F",
	"0sj8/N1d+YYmNwUMtq70JuK2jSq4cKtWwlpLmhR0HvONvXv3qwZa4O6jvLxEG0eeE/yskXHqI+pxqHoB",
	"Hh/9G2Dh2Dt7Dhd3ar/yxaziS8BHuIX4jhE3ao/9ZfcryEG99Ha18lg7u1TqRWLOdnRVypC435mqxs3c",
	"CFk+jEKxOWqrrhzQFEi6gPTc1WmBZaE348bnPlLHCZqedTBlK/jYDDKsIYGehSmQssioE8Up37ST+RVo",
	"7eOB38I5bM5EXYJin+z9ZjK56juoSKmBdGmINTy2boz25rtwMFTsi8LnZGNynieL5xVd+G/6D7IVeQ9w",
	"iGNE0Uh27kMElRFEWOLvQcElFmrGuxLpx5ZntIypvfki1Xw87yfulVp5cpFb4WrQ6m6fLwHLgYkLRabU",
	"yO3CVbKyCdMBFysVnUOPhBw6dwamJTccQjjIrnsvetOJWftC69w3UZDty4lZc5RSwDwxpILKTCtez89k",
	"/YfOM4EFKh3CpjmKSVVgo2U6VDacbLbiXh9ocQIGyWuBw4PRxEgo2Syo8kW2sBaZP8uDZIBrLACwrezL",
	"SRBqFhQcq4q6eJ7bPqcd7dIVf/EVX3yZl1C1HFCyxUj4GN0e2w7BUQDKIIe5Xbh92RNKXYyg3iADx0+z",
	"Wc44kCQWtRaYQYNrxs0BRj5+SIi1wJPBI8TIOAAb/eI4MHktwrPJ5/sAyV0xBerHRo968DfE875sHLcR",
	"eURhWDjr8WqlngNQF+pY3V+tgFschjA+JobNrWhu2JzT+OpBOtVHUGxt1RpxkRkP+sTZLQ4Qe7HstSZ7",
	"FV1mNaHM5IGOC3RbIJ6KdWITP6MS73Q9NfQeDW3HNNTYwbR1Xu4pMhVrjPbBq8WGUu+ApR8OD0ag4a+Z",
	"QnrF7/pucwvMtmm3S1MxKlRIMs6cV5FLnzgxZOoeCaaPXO4HpVsuBUDL2FHXQXbK704ltSmedC/z+lYb",
	"1yXJfNZQ7Pj3HaHoLvXgr2uFqYqtvGlLLFE7RTNopVlnJhAhY0Rv2ETXSdN1BSnIAZWCpCFEJecxz6nR",
	"bQBvnFP/WWC8wGo2lG8eBJFQEuZMaaiN6D5O4jbMkxSL6Akx61+dLuTMrO+tENU1Zd2I+GFjmTe+Agwl",
	"njGpdIIeiOgSzEvfKVSqvzOvxmWlZqyVLTnLsjhvwGnPYZNkLC/j9Orm/eGlmfZ1xRJVOUV+y7gNWJli",
	"ieRoBOaWqW2Q7tYF/2gX/CM92HqHnQbzqplYGnJpzvGZnIsW593GDiIEGCOO7q71onQLgwwyZ7vcMZCb",
	"Ah//ZJv1tXOYMj/2zqgdn7/bd0fZkaJrCQwGW1fB0E1kxBKmgwrD3ZTWnjNAi4Jl65Yt1I7aqzHTvQwe",
	"vi5bCwu4u26wHRhAkfYtzEBC1IRQPbLR0ZW4FNblw8zuRimcyKb3Gv+bpjR/UVaNEoKJLmEEc5UU+/e4",
	"jr1sVBpsLiVSqr87a8m4/vJZlyIrG7+BZchunMZN66dG0WgiPlC3bOXuHZvAehT3kDwD9hxOxZTvO9El",
	"2yoHchflngHNf4DNL+ZdXM7o43h0NUN2jPLdiDtw/aY6bFE8Y6CENWw2/FJ7opwWhRQrmifO3N/HKKRY",
	"OUaBr3vvwA1fPHHKPvv2+Mc3DvyP41GaA5VJJbj1rgrfKz6bVdnaiz0HxNe1Nxq416CsYB9sflUwLnQR",
	"XCzAFQgPdINOJdPa/RMcRecymMXjtXbyPuepskvc4rGConJY1cZU669q+qjoirLcWzE9tD2xVbi4YeVw",
	"o1whHODKvq7AZZkclN10Tnf8dNTUtYMnhXNtKWG+tFX6FRG8HdCAEeibwsVALCnWIbU2qi5z4uUS7TqJ",
	"ylkat3jzqTLEwa0n07xM8OUe1cCMWLIexzgvWTCWeW1IpaEWkMEcUWSqaLGjGndT4QSLkrN/l0BYBlyb",
	"RxJPZeugetEGR+1cp0aS687lBrb+knr4q0h8YQ3e9o2HQGwX90K/aQfcl5UBwy+0sg/WEt++4RfhjJ0r",
	"cUvohKMPR802lHTR9H8Ok8KGdGvykp8rBtwzR7T7ElPJTIo/IK51o7Eikj7mqw4zjDn6A0LhMuw50mAx",
	"la2tbiJVz75ru4dL9n0bf2VJ3i+6KnR8GTE+fqr328jLiOwqXuTMIblPhAwNr824nB7Wgscr8ERjjVnv",
	"lKHcniebO9UI74yfyjCQ+siOX59KB3Mn+DynF1MaK8BrJDkDU7C9DfeRFsR/7DdAVQlGdnYShE9U7zJb",
	"f6EAWafPdms5XVIqs9MOlsdq8QspKhS8xtblnSsRGabkF5TbxkXmO8uv3NcKrL3XfHUhJFZPUXFPVwYp",
	"W9I8Lp5laderkbE5sz15SgVB0xc3kO13ZqnINc6p0uYcak5m5NE46DzldiNjK6bYNAd847F9Y0oVXpeV",
	"7bX6xCwPuF4ofP3JgNcXJc8kZHqhLGKVIJXkjDpk5a+dgr4A4OQRvvf4K3IfPdWKreCBwaITgkbPH3+F",
	"fgb7x6PYLet6Km1j2Rny7H84nh2nY3TV2zEMk3SjTqKFJmxTxf7bYctpsp8OOUv4prtQdp+lJeV0DvHg",
	"qOUOmOy3uJtoO27hhWe2I5jSUmwI0/H5QVPDn3oSLgz7s2CQVCyXTC+dP1OJpaGnuqOLndQPZ9uLuWLc",
	"Hi7/EMMCCu8VbWnqN+snsEJEbNUYvPGaLqGJ1jGhtmROzuqAHd8igJz4ilxYnbwqSm5xY+YyS0dZEuN3",
	"ZqSQjGvU3ko9S/5G0gWVNDXsb9IHbjL98lmkInuzMjDfD/Abx7sEBXIVR73sIXsvs7hvyX0ueLI0HCV7",
	"UCc4BaeyN34h7qnuc5dvH3qo5GtGSXrJrWyQGw049ZUIj28Z8IqkWK1nL3rce2U3TpmljJMHLc0O/fz2",
	"RydlLIWMldmsj7uTOCRoyWCF4arxTTJjXnEvZD5oF64C/e0627zIGYhl/ixHFYHV8hdv++5NUzEi/C+v",
	"XAfRjuzdE1pjY2eqb244/SYahWclNIxcJbhq8vvj34k0miRKow8fItAPH46dMPf7k+Zjy6QePowXn4oa",
	"jsyvNRauotfht7E9/EZEzDi+00PlAHQpNhEzWh+rNQ/MUZ66ocakWVX/5u/CwwRvxh308VPw7t2v+MTj",
	"Af9oI+KWjzxuYB2CZFfSQyhBV5EoyWTV8yA0iJJvxHoo4bQ4qSeeTwBFPSgZaGTClXS6pkRdZlGfLTl5",
	"GdKmGW0KuTAqUlgIOrRGfz74NYseb8FyyfLsl7osQOsCkZSni2hAxdR8+FvdxLNaomWR0dqyC8o55NHh",
	"rGb2m9fgIjrmv8TQeZaMD3y33a3HLre1uBrwJpgeKD+hQS/TuZkgxGoz47rK6MnnIiM4T13ItGaK3S5P",
	"QS+Of5egdOxI4AMbVYyuGsN0bSsIAjxD282EfG/79C+ANKrUoc3ElxFqltQoi1zQbIzljc6+Pf6R2Fnt",
	"N7YVnW1FMUeTQXMVURvv8BIjVVe5eO7c8HG2J/OYVSudVJ0jYtUJzBt1bwvWcluiMSHEzoS8DDpu20IG",
	"ZgiC1a3kErKgUYXVJJAmzH+0pukCDSSNC6yf5If3UPFUqYK+xVX/wapwMZ47A7dro2K7qIyJ0AuQF0zZ",
	"9uywgmZBhKo6iDPQ+QIJzeXJknNLKZM9ZImqTPG+aPfAWUHEezajkLUQv6d6bFsQ7dtS5hS/itZRbPen",
	"6TQstun1VV+5V77lNOWCsxSrGMYEIdfHfYivZEDBx7iTQ43cCY0crmhXnCpO22Gxt0+OZ4QOcV2/Y/DU",
	"bKqlDvunxobhC6rJHLRynA2ysW/u5KzyjCtwhaix63/AJ4VshFJU8WPdxr2VF3dPMsK8zB4zy3fm2Wtn",
	"hMOEpXPGUd12aHPitbWbY5tpbXR0pslcgHLraRanUL+abyZYpyGD9fuJb0uNY9hIBLNsG3bTHerYB+G4",
	"oBfz7gvzrqueV/3cSIGxkx4XhZu0v/VXVB7Qa96L4IgIlHhvdoDcavxwtC3ktjV6Du9TQ2iwwtgbKPAe",
	"7hBG1Qar1WLRqAaWovANYmOIoyV0GI+A8SPjUDdNj1wQafRKwI3B89rznUol1VYEHMTTzoDm1mwRYWhK",
	"O0fgVYdq1w40KME1+jn6t7Hu4NXDOKoXasGN8k3Vq91QdyBMvKB5FX0W6ceFUpUTojJMaWt16IoxDsO4",
	"fQ/A5gXQY01pyET2cyykue9N1FelYFpmc9AJzbJYXfBv8CnBpyQrUXKANaRlVT+6KEiKRbmaVcq61OYm",
	"SgVX5XLLXP6FK04XtLyLUEPYds/vMGZBTjf4b6x4cv/OuLizvePQfZBZtl9pvm5cfUzqNTSdKDZPhmMC",
	"75Sro6Oe+nKEXn9/UErPxbwJyG0YR3u4XLhHMf72rbk4wtI9nYrg9mqpKutgnLHwjYpRbaxqQjS5El5l",
	"nRLh6HqtGqFuN0P0tzQd4+XXk/sRmrrt/WrNv30ZIGlvwhLVLnVaU7KVBfWmo9qAxZbxvOvH6AtStDGK",
	"hzM6u7VuRaiPfu0C9IMPrScFZS5QpWYWXcy6lKhuktqQ8Px6g9uLcIlGvXbRH1Z9SUG+Uic+b7c8PAdX",
	"T6WQsGKi9CEgPhDTq4T210YDwSotK7r+rnkbp7pdo3OvifzMtZ6xy3Q6+Q+/2LBdAlzLzSdgMO9seqeZ",
	"Ylfateap+hVSdS0Y1MWgcSsOqWIbK5jqZMNGO8cdzSg7ZPVyiDjQbS45Hp1ke12YsaK7IztK7NjFW0X2",
	"1ySs6xDiESuEYnXzkFgPyYERz2fYBjKoqdgdy0fCrSDV2DGmjvCRAPtUWDSTBV2p72oT9qjTVWC4K0m4",
	"rQ5ht03Mjju+kyocpLvbFhuT4VX3jqs4TuTTWCp/Dtw1hm6mnQ1OfpnNINVstSM1+x8L4EHa79jbZRCW",
	"WZCpzapkCqzstb/VsQZoW+b0VniCCrtXBqcvFfAcNvcUaVBDtOfH2F+1lynqhBhA7pAYEhEqFidlDcku",
	"dIWpijIQCz4u0X4OdXnM3naBQaGBS87lSdJcHHXxgS1TxvuVDZrLfLpXSQ7MC+jL3u62O+rXP15idylV",
	"tfL1RaFCLZ2cdEvnXriiUphIX/lOfHkpUP43XzXDzpKzcwgbGqKn6oLKzL8RNb14q06y5T7qpFz7Vj1t",
	"oGfVzKyOIu/6qCPFGDEhI82FESOSvqyWZuB2FfV0T9nwNNsbBEPSDVwzkK7xK8q/uVCQaOGjzrfBsQ0V",
	"NgbvUkhQvQWQLXC9Zcne1nXXsBA8xTJk1IXehQskEpbUQCeD6mj9c25D9gv73Ocx+kLgOy1MFb3u7kjj",
	"8weY6iAxpPoZcbfl7vzIyxibGOcgE+95apdK4yCb3pBCiqxM7QUdHozKIDe4EOEWVhK106TdVbZ0hCDJ",
	"/Bw2R1YJ8q18/A6GQFvJyYIelNhpbfJBzW8qBvf8IODdpuVqPCqEyJMeZ8dJt75bm+LPWXoOGTE3hY+z",
	"7WmvRu6jjb3yZl8sNr6eWVEAh+zBhJBjbjMbvGO72WCgNTm/p7fNv8ZZs9KWXHRGtck7Hg8Rx2KI8orc",
	"zA+znYcpMKzuilPZQXZUD1v31JaT9CLSbHAyVCvvuprbDeBqorJQxGSSU+uxeoEHPWY4upBMgwtssJe4",
	"2UjiPF1E5SIWigkXw0pRVGG7Zkdy0XNxh5MhQBr4kJTlCgo3eBQBVXO3HYFCVYxQ3RerjhPqikd5Li4S",
	"PEZJVR0zpnSZ91TzmvAFwevvDL1NIYg4osqJEBuyoBlJhZSQhl/E06EsVEshIckFBiDFfKMzbSTCJeZA",
	"cJKLORGFUfRtlVnvRYp2bevMVXJO8UKHIN4jigKapqh9CuK+IdU3Q6c8VFM8W7LBLjqxXrae8jWgXIkG",
	"hyH7chfeLX3p9u95d7aIGMsQc55A9m5s54h8735UAZgDDtduQ+FxrG9fc13tDpJ9/Vy1WLI0ju7PK0So",
	"N7AnRr0xVLiS8DY/F19DnhLyscojjKeni2bgdJpH7wd3/JxnDOnc/BfFhva4ZAaOn/Xw0EgDesv6k7T3",
	"gmoBgJDapDFdSltHPrw+qu6UYm6TTNGv1wZ0IMPB8ImrwWZGOCRQH7cTSqx9ZeQgVLvjumv6LPmeQxUN",
	"zNgeB2FbGk+HRkNUbTMG8s8AgP74iAYMg6Ik9gVjhi3CExpB8kmlm44DCdtF1rebITHlmGFKrW1qAcSM",
	"XUpwWdu2l3GreWJB9cLLqub1rgWJZ7AGhSnVtgMcVdbe6e2urpFyWwkQRZLDChphIy6VvMSLnK0gbMJs",
	"PyYZQIFeiLZuHIuHCK/DlsLk1p4EHvUh2I1qUBaxdqfIDvUoqsyteWKPiRp6lAxEK5aVtIE/dYV2tP2d",
	"aDsSWGIlLXsghkzzsx3hrR/g2H8fkwY8Jt4P40N7s6A46rYxoJ3xUXiioqeex8OjwjoJlWEVZ8sqB4wl",
	"8ZpvqIJe8H5DRJfka2F2eJvoALHfriFFwaAZ/3N1nBAcjKhWDZReKVZWO3x5g9at0PBWEu4dL8aJ2gqN",
	"13UwmD4XF6GHiRIF2iaht7Wg2kjtVz8hL8F7BrBoZGUUdTIfqy4sH8c0JkwT1wmgkWszZL6Kei3PNMwy",
	"dT16OMyYtn5S+7BarFpQJKP7bBas0rbjYZxsF04ejIkz7g2Fr6Nl2Ss1pZwLHQN0f/gcaNsTdro6m19B",
	"1XmkXoD0CXqZraMhZOY9FdXdjv+ZMi2p3GwJH9zpk41FwaKFeBfYRRHWIj0Y+Pu0BqtzHLekOG1dQqsr",
	"xcGwP9Tj2wEa3Ua+yswO8G11MF+R5ibwHy1i1reMIeB/KnjvaWARwmt7VdwAlhvJuxFYrT1qKtaJhJna",
	"5dy0BqmpWNcAq8qjzXgqgSrr7T35ySk/dY0uxo0yZuORKnt6NUoGM8brDsaMF82G0cG9QPkmQFho1kO0",
	"9phv++5bI9CsaP7TCqRkWd/GuZuzVeHVmzLdtxE12jrSmYoMwFStR2BuENS5J8FrS7ohGZvNQNqbRWnK",
	"Myqz8HXGSQrSXLjkgm7U5W3GBlpZwnin1dhodU7AaGWsBvZjJG0LSL5xDokrWnQrAOkBTbsDTLIYkxYx",
	"x1rzghY9FtguDPFEabpOcjHHjJEeAnTF0NBmbsV+wdF6SJb0HPacR7E/YPs0WAfWHXwtcNYhU2w/Zz8h",
	"6lB1+JkzvfWkWbtUO4XHxljZg+Dpn8/rQE+7OV36j2Vdndn+1GHmVbvdo99r6/C180FP+4qmObFnF9Hl",
	"5VL2QtuhGm5Wb3jVYrldVhtMUEtUW0I5QQUNslPniu+aTzrqpUXK2GXG7WldsWZNfw/0gGd7RLmz1Zy2",
	"co+acYbLGoEvMA5RIYokHRLfk0EOhs1Z66qDtAnjAP9hkW5TAfvU7R6u1DTlihnyBzwW1siAkdCVaj1u",
	"x+g3zQnVwSOUSEhLiea2C7rZXfm+NinE0xvtyN5X4KO2K6jdBtsjbsUFHi0sv48hK8J1Yi1EuyW9D78Y",
	"m7dbRxZe33Jc7FB8AcfcyZPYGH4bvdUmX08qEVozwliEafjomEsssM/SNCDz7GBbVZ2W69ig6CV5ub47",
	"g0DrZiFFsIkA9KQXNALDw7ZcdeEsaY1AaC7ylvM2v3hVW9R3xsEhJP6DHeCF+QL1e1XolgPnlitQvaqQ",
	"EizlfR8lNJa/KwXBLbB2QQRb5CR1rcE2SbT1NJr7EuSXqBdV2kbP1dzJ7sAeXEY8y/NIVohVHvBMhYRj",
	"7kW5ovnNZ3Zgc7ZjxAdkb/tjQcPUgBDJFpXqcoVJfqSD5g7SAA43NX+DmSj/ALNH0WvBDeW8Dx3mj6of",
	"zW3Uzsxl9ZkhyQWOaT3Lj78kU1fitJCQMtX2alz4zutVJDxINnNpJbDWO0Lvd63zF6GvQMYz74IkrwNb",
	"qkDdtYawPqK3zFR6Tm6UymPU1yGLCP5iPCps6LLjujhv5LfWUl1wowkJB85zDSpW7Jnn2m1VM3R5NpfT",
	"XDqlgu46B9/WDdxGLup6bUOTtAfXI8UWu0Nyq+O1Q83nmNx9kCKie5UQvYa0bosjN4abN0Yxv/QV+rLF",
	"rHpqyrX2o2T5Tn9jo0Lgx/FoDhwUU1gD7zdXsfdm71IPgU016x5VC+tV8mMtYiJrbUweTBXU/htQ9s99",
	"Finyh2HcaSmZ3mC3Jq/xst+iCejfV8mMLhm2MuC6u0+Lc6j6fdWpj6Xyt+v3guZ4H1m7Mje3kMgn5Ns1",
	"XRa5s4mQr+9N/xOe/u1Z9ujp4/+c/u3RF49SePbFV48e0a+e0cdfPX0MT/72xbNH8Hj25VfTJ9mTZ0+m",
	"z548+/KLr9Knzx5Pn3351X/eM3zIgGwB9SUpn4/+JznO5yI5fnOSnBlga5zQgv0AZm9QtZwJ7CZikJri",
	"SYQlZfnouf/p//EnbJKKZT28/3XkqmKPFloX6vnR0cXFxST85GiOuU6JFmW6OPLzYI+Hhrzy5qSK77MB",
	"HLijVTS5dQM4UjjGZ2+/PT0jx29OJjXBjJ6PHk0eTR6b8UUBnBZs9Hz0FH/C07PAfT9yxDZ6/uHjeHS0",
	"AJpjarD5YwlastQ/kkCzjfu/uqDzOcgJhnDan1ZPjrxYcfTB5Xx9NDNEjc62QmRQFtBXr6+b3DrvPlpu",
	"bOifCnvzKGK7bY+J69Hto5B4hoX7bBqVYXMV4k6yuhH2Sc20fAMq2x/1+a+RPHwf/en7IoWxAUHUwH+f",
	"/vSaCEmcevOGpudV5Cs5mdk+F1KsGNaDy4IigubLiafff5cgNzV9Oc4XdpsEXi4NE3EhtEs1L5olqWqp",
	"KmYk6eDaz2zIIiDsKkOzZlzoogggqdmwYa2Pkq/ef/jibx9HAwDBdGEF2Cbjd5rnv5MLlucE1hga1HLb",
	"jhuCVeBQH9cZf/hBvZNjNOBUT4PP63ealRx/54LD733b4ACL7gPNc/Oi4BDbg/fYyAGJBc/ck0ePPKNx",
	"YnwA3ZE7U0N7i/ripdaVX43iSeISA3UZkn30tirqI2lhz6J7YtM8nGHVvjQxfOfZARfaLD105eW2h+ss",
	"+huaEenSW3Apjz/bpZxwzNg3FwSxF+DH8eiLz3hvTrjhOTQn+GbQJal70fzMz7m44P5NI/yUyyWVGxRt",
	"dMUL24WR6VyhNwNZpD3bQd0IPh+9/9h76x2FETNHHxpJ39mV7kQbJNBoAb3jmryn+jhnt5Hr/eOiqLs4",
	"4/PjorBN19Ap5iLgYM2UVg8m5Pvwa+Te2LLDNsQoJQY91OYUc+tVPch8Z7Matnsq7GYSvbQDc/Hd/X3b",
	"9/dx09jRaBYaA6ZxCrbC1PEwXvUC7UY5B8nd+0bTVYX9nGiRuJr/e7a9P1hDiwE+WTvT+5gquJNR3+Gu",
	"B3d9YlIAbyUx1d00boY1+xph1U3SuDKukXF/5kLfK5obOgmW26rFbTvo3gmDfxlhsKolNLfSmWsafzXx",
	"EEN6jz74rsgHEAldM+EBwmCoVgffBmGZ91vs5MHEdt8N37kcz3DFg3aKedir+k7A+wQEvG4f+BgYdXfv",
	"2xPqwoyAfQL0G9KIb9U9uKH9ZyrF/YWR1Su2GUh3C2yXYJ8dYcwx62tjq39KIcwh7U78+kuLX1VJvysJ",
	"YGE855FLBQ3cWFey3rWtc0xXklizrGPA2TAb2jAUd4THdXAwZotidK2Lq1VjrxmiO9UqjXazxh29sSti",
	"fQ+hgvrN5uTlLunqM7LzDO7OFrkF4ntz3bw06nZ4ezNuh2G86dmjZzcHQbgLr4Um3+Etfs0c8lpZWpys",
	"9mVh2zjS0dR2AN7GlXiLLSGjqDv7Bjyqqmc7Dp6bt22Uxn1MBmvW838wIb7fsCJLV/zJJTvOhWFUPgGD",
	"yrn9yPA6gwxyz//5HMe/NyHfYaqOVmMMNsOSKvgi4/r54ydPn7lXJL2wsVzt96ZfPnt+/PXX7rW6Q7jV",
	"czqvKy2fLyDPhfvA3RHdcc2D5//zz/+dTCb3drJVsf5m89o2APtUeOs4VmipIoC+3frMNymmrfuGybtQ",
	"dyPu+2/EOnoLiPXdLXRrt5DB/p/i9pk2ycgpopUls1Ei/IC3kT0m+9xHY9/j1/Cd6jKZkNfCdWsocypt",
	"6QAskqfIvKSScg2QTTylYjUqZavTpznDLFdJFMgVyESxDOo6flV+eyFhhTHyVW25JgS7GT1G0n6yTP4V",
	"XQcZntPqmtbCLRnNnku6Jlh+WBMFGovHmJ++/po8GtfaS56bAZIKMTHmuqTr0Q1a/SpiG1oxIuiAvzNA",
	"F8ceYkGqpZ9Oh/g7zv3ZSu6W3N3GHohz7u34qR07oR3B9UTYakGwgp3GYo2qLIp8U5fpM1KeF6HiLM7M",
	"MNQ48An7CHaapqNKaBu9d4f4zghwJVbSJqg92QZmnaqjD6iXhzyjc24xa+6v5S4NfEdSLL3zSJAZ6HTh",
	"EnZbqI+wJ98Zvp83LRlnSwPlo/G1SzW4i90ik2FLuozaNPkhXQ+CXEp04IGMEPFPvkmrecxmtvKsL+nt",
	"C12ha8oV76z6QFnl23aGc/H8Pq+3oI2+VruhfFFP3hXIEC2H8H/eIXg/BHeY47euJoE9Xm4Rf4aIf69K",
	"JuS1qNPGXdP7P6Pr8Tpv9ute0GvBwfrYjeRrafHOnVqJHYZxWKT4eiFWf6naD19aBDlaULXYKYf83by0",
	"QxYZcnubyT7LK/zvDktbbhmztsnOYgj1aEOYs3nRFp1uNsS9RS3mVvjpJ6ja3AbHuhkWg4fU8xknFvDD",
	"Mh0swWOJ+ajqhdrHgeLtpQdzIy2qMLRoR+gp5ILP1afJirY2+o7iJUIlVePteHftv97ZfYHVfYzKayMg",
	"Xb0nxXgKRIkloMpgZPQlU8oFSz579Lebg1CzpW8oyMPc1VvmLl88enpz05+CXLEUyBksCyGpZPmG/Mzp",
	"irIcmzFdgdth7/Cq/pq3BkfbxaO3qVkXLA2LGF2eCTZC1z7oNcs+7maGQd3BPfkg4wEfDGsA06IAKi/P",
	"AHe7rtoN205ehtHBjZbWVUWtCCgGRXsGyP/HaKDdCdPexcxdfiW3gPrqX45NuNBdMRtXwTFGChCz5+Qd",
	"f0jUgn7x+MlvT7740v/55IsveyxnZh5XtKdrO6sHMo/tMEMMaJ+1OfCwUnuF3+c3vdv7beJ4xLJ1tOkt",
	"rIPKx81uWE4su6dIQTe9nbF7msxX0kA47BKMGK8WrLj5YodKs+kiql959adqTHjCv6m0YFuRzwjfxW0U",
	"uRuPtATIoNCLnbUv8a16N8FVwWTKFe22FQrHhE1gYgv41c0MMuw/bTRqSnKgs6orgRBDkicCPmMIzVNF",
	"gPVwIUN00ij9YMEQJMqbV07rJAN70Xnkydadc6uCrr4tJTVBHRW4F2yaaLk9mRIbM48Dd3chhRapyG3s",
	"SlkUQurqdKvJIHEP+tx2DWmvj3D3EuZSqtNFWRx9wP9gha+PdeIB1j5WR3rNj7DFwtGHrSECCGJuzrq0",
	"ZZMbcmm012JXTcbP6xLN3wnZ6Te7KwSgdWLG7UNk20VgLEFEPrse6ewvLdRs1f9bG351k3ZkxM4BrvLq",
	"ggL9Fe0Ghb99qpxteREh4TsXzKe1oNooMmM8IzTYxpbuJmTNCK7ZMHLdi74NO8vN+52++IzP2Wuhycmy",
	"sJ10Ibta9A5pczh/e2y9bvcTDNzV3w3x6d754Y3vAxMr6/rOC34Ph1yQig1+OioxN9rc1ddj+767yT/t",
	"m/yFLzncIMO7e/nzuZelD6e8u4I//Sv46We7mmt0xAy8kv1NdOlruNbE97yQO8KA673UcoVv89Og6t1e",
	"pfpOSN/e4u4W/0ydDHYnByctDbHQ7EplclMeInT2k4J+mJ0hzyOWhr6DOra9fvQCGBadESnD+uEnmRrb",
	"Q+yME+4U3wk+n7TgE+z1ndxzZ3r4zEwPPVKO0/ptR9Ndgsa+AtBqKTLwUSdiNnNF3vqkn2bvGUOeStNl",
	"QeyXUSkHvbFnbAmn5s2f7BQHvWJrsFtiUQs8gywFqeCZGuAVdaNe9h5CN24/ADfuAa12wMPi0r8nlybZ",
	"t0ENmQ4lkDbyFfYM8sXuHDIyWJGlbzR8RbI9+mD/RXNaIVRkNaeegDsbc99ti63eZ8dtAEjeoBDqmhG7",
	"r8SMPLJF/EqOmTp1c0DKM6LlBvu5u5olEmhO0kaEfgVH9+Sc9p6cnapAZ3U9a4rrAqI+oYcMZ21lR/1w",
	"4wfgBeWO5LsI0oJQwmFONVuBj1uf3GXUX/o2c/nsWxjgmNAss6ex3gRYgdwQVU6VkXV4M9Dynmqelz0Y",
	"BqwLkMxc0TSvHfBWTTiy6fLbAipP7RtXvLRavMgm6ctmFJC/WV0Kv5iRVyyV4jifC+XjutRGaVh2Wu+5",
	"T3/rKbrqDQndGDDBc8YhWQoeawj3Ez59hQ9jX2PJgb6Pz8zDvm9b920T/hZYzXmG3MlXxe8ncvqvlKvR",
	"Wq2EQkij3U5tk1pL/3seJX9oNjztnqQNTwOnlnsYDBS2j2v8fPSh8acrluHeVItSZ+Ii+BY1exv0MyRP",
	"PmhUfQlLWqvhs7peW9p1+pACPMROTPU00voraEfe2/3rL5of4lwuIZG4Fv0rkKqlnt0lifypkkQG7/te",
	"PNa2utzF0Up1WInktcjAjtvsNBurz8xFBq4jZ1cQqYId44H1/laq32uFOqe0nC80KQuiRSyouv4woall",
	"solVb+ITBhXRrBKE0y3oCgjNsc8pmQJwIqZm0fX9iIukCmvS+chsF9IZFYUCuAopUlAKssTXo94FWtXn",
	"FOO49RY8IeAIcDULUYLMqLwysOernXBWfcIVuf/DL0ZhvnF4rSi4HbG2ElYEvVW1DSftdaEeNv02gmtP",
	"HpIdlUC8aICJJGJZ5OBSSSIo3AsnvfvXhqizi1dHC+ZasGumeD/J1QioAvWa6f2q0JZFYu7vLogv7NMz",
	"tkRJjFMuvF0xNlhOlU52sWXzUrgWZVYQcMIYJ8aBexTOH6nSb11WYYYVaOx1gvNYGdtM0Q/wqq8fvRn5",
	"l6obfWfs1NyHXJWqalnvMgUgi62Bw3rLXK9hXc2FaZ1+7CoVwVr4do3ch6VgfIesoCg3oTrw5pvhIotD",
	"+yN1BoouKhtA1IjYBsipfyvAbujG7wGEqRrRlnCwyGhIOVMhcqDcZnSJojDcQiclr77rQ9OpfftY/1y/",
	"2yUuqut7OxOgwjQRB/mFxaxCA+2CKuLgIEt67jJJ5q7JUhdmcxgTzABPtlE+mmzNW+ER2HlIy2IuaQZJ",
	"BjmNmFJ+to+JfbxtANxxT57JSmhIpjATEuKbXlOy7DURVUMLHE/FhEeCT0hqjqBRnmsCcV/vGDkDHDvG",
	"nBwd3auGwrmiW+THw2Xbre4xS5kxzI47ekCQHUcfAnAPHqqhL48K/DipzQftKf4Jyk1QyRH7T7IB1beE",
	"evy9FtA254UXWOOmaLH3FgeOss1eNraDj/Qd2ZgB8bM09rdjl66x+kvTgBoogJPLKLdHF5TpZCakFaQT",
	"OtMgdwbE/4My7w53rgEtXG0CgiO4e9ONg0w+bHXhuIgFgbjrwpBI1/9mpvpOyEElNpuFZCjTpOSa5UGZ",
	"8UpV/vQMhndGgDsjwJ0R4M4IcGcEuDMC3BkB7owAd0aAOyPAnRHgzgjw1zUC3FbR3MRLHL6UGBc8aUcl",
	"kruoxD9VkcnqrvJGCTRjXFCmXddMn+/vnlytxq4GmiMOWA79cdI2fPPs2+MfiRKlTIGkBkLGSZFToxvA",
	"Wlc93JrdQX3fYtsI0jYepQqePiGnfz/2tfAWrmZb8937x67/t9KbHB64LgnAMyuK+nYJwA3SXbcE6u8E",
	"3+vNdb5jOcaYK/Itvv0SVpCLAqQts0W0LCMmnzOg+QuHmx0Wn3+YyV3Q6u9mtN/HDUOTQ9uSFl7O92ul",
	"ilCbu0heBtmMv89oruD3voRGO96SFrF2a9XNZ21ByE2+EdmmdULMrh3hBjbPRl0Rj3EqN5F6S91kgjZp",
	"aGH4lSOsrjHr48HrNnaJtktmuygsJq5LUNFzvI3KowULqw3rDGVTXmctOhnFsjXbVfpGFYBDQmDPMOHA",
	"7gl5a7+73arwCJE7YjUz/2QiB5tvVkwD3zVahGM9n2tUvkd89PTi2R8bws7KFAjTivjSj7uvl/FonZiR",
	"5sATx4CSqcg2SYN9jRq3UMYUVQqW0903Ucg/XYNhd/mYJ9vvqdu5Rl4Gi9vGk0OiWSeOAfdw542Gwby5",
	"whaO6NhzgPHrZtF9bDQEgTj+FLMqtXjfvkyvnmZzx/juGF9wGlsSAeOuVG6biUyukfHJjSx5P8/7dg1p",
	"aYALT/J9NM+jTw7WuuHYzGBazufYKLnjpDNLAxyPCX5LrNAudygX3I+C7OBV88yrpnu3h+tylyAD+76v",
	"cfgAt4PyDXozlgXlG+/zhUSxZZlbHNoec4dltLaabTcSAP2xzvjXZ9Z+421+gfHWXbXN3y1ayAVVxO4v",
	"ZKTkmcsd6tS8XvPhFUPs0GdrXrPprdVB7Hojq3PzDrki/C43k7YVKUAmes3tgWp2Ure1te3Jndw1iP1r",
	"XBs25Rt6GGy3TnTNEA50e8iAr+H1EXQDqZPhGj1C0GrRnzoStgaxbx40eqQzfDOIpDapOCcp5AWhvnt/",
	"KrjSskz1O07RSRMsbNINMPHW6H7+9sK/EvcTRtx4bqh3nGJz98p1E+VzM4j4Kb4D8GxUlfM5KMMrQyKZ",
	"Abzj7i3GScmNpiVmZMlSKRKbiGrOkJFPJvbNJd2QGdb/EOQPkIJMzc0e7Lo1GCvN8txFtJhpiJi941ST",
	"HKjS5BUzXNYM54sPVKFcoC+EPK+wEO8UMQcOiqkkbnz53j7FZgxu+d7IhwZL+7guon6zXRg87Czrhfzk",
	"pYGbYu3inCldB0F0YL8xB/iS8SRKZGcLIC4mrE1b5D5WTHME9KDpHdILeMfNDacFQa5O9eXIoe3m6ZxF",
	"ezpaVNPYiJY3yK91kIp3EC5DIkzmzrXyJ0rNDOjAuy9x4201+tbe7+lGaVy5wDPztOdCtk9d866el5yS",
	"0DCEtcrBuDfOGiD/eRu/v78efdGj8WAaY3fALrtqtmdCvPkNHxOaCz63VQiNBilwnxgvSo2B1ddppIMV",
	"zROxAilZBmrgSpng365o/lP12cfxCNaQJlrSFBJrNRiKtTPzjaXTXRdp0KRuuYSMUQ35hhQSUshsvS2m",
	"SK1sT2zFApIuKJ/jnStFOV/Y1+w4FyCh6udl9Nv2EPF6J2ue2NprXRiPiTVUhuVpgaaLSH8UvJmMQu0p",
	"wZaTGKIyR1gBVtbs06DHo14J2SB1VQe2WeQ0+cOA679xkQf4qSc+RCnSO2q9o9Zbo9ZYyT9E3axlA7D4",
	"Crflmo1F113g8gZtT7dS/fauhPyfvYS850CKUCJpQ+qP9y6jijBNLrDAzxSIuXhKtHm7FudOQ54Qw5AC",
	"+76tBKlc5810QRl31WGqdAGEQ7vuwNq3I7wWc6FlZmgnNOiAtJRMb1BPoAX77RzM/98bQVuBXHkVopT5",
	"6PlooXXx/OgoFynNF0Lpo9HHcfhMtR6+r+D/4KX/QrKV0Wg+vv/4/wcAAP//8K9d2dqPAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
