// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
