// Package private provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package private

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Aborts a catchpoint catchup.
	// (DELETE /v2/catchup/{catchpoint})
	AbortCatchup(ctx echo.Context, catchpoint string) error
	// Starts a catchpoint catchup.
	// (POST /v2/catchup/{catchpoint})
	StartCatchup(ctx echo.Context, catchpoint string) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AbortCatchup converts echo context to params.
func (w *ServerInterfaceWrapper) AbortCatchup(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "catchpoint" -------------
	var catchpoint string

	err = runtime.BindStyledParameter("simple", false, "catchpoint", ctx.Param("catchpoint"), &catchpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catchpoint: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AbortCatchup(ctx, catchpoint)
	return err
}

// StartCatchup converts echo context to params.
func (w *ServerInterfaceWrapper) StartCatchup(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "catchpoint" -------------
	var catchpoint string

	err = runtime.BindStyledParameter("simple", false, "catchpoint", ctx.Param("catchpoint"), &catchpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catchpoint: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StartCatchup(ctx, catchpoint)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"fee":              true,
		"key-dilution":     true,
		"round-last-valid": true,
		"no-wait":          true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"timeout": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.DELETE("/v2/catchup/:catchpoint", wrapper.AbortCatchup, m...)
	router.POST("/v2/catchup/:catchpoint", wrapper.StartCatchup, m...)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys, m...)
	router.POST("/v2/shutdown", wrapper.ShutdownNode, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
