// Package private provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package private

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Aborts a catchpoint catchup.
	// (DELETE /v2/catchup/{catchpoint})
	AbortCatchup(ctx echo.Context, catchpoint string) error
	// Starts a catchpoint catchup.
	// (POST /v2/catchup/{catchpoint})
	StartCatchup(ctx echo.Context, catchpoint string) error
	// Return a list of participation keys
	// (GET /v2/participation)
	GetParticipationKeys(ctx echo.Context) error
	// Add a participation key to the node
	// (POST /v2/participation)
	AddParticipationKey(ctx echo.Context) error
	// Delete a given participation key by id
	// (DELETE /v2/participation/{participation-id})
	DeleteParticipationKeyByID(ctx echo.Context, participationId string) error
	// Get participation key info by id
	// (GET /v2/participation/{participation-id})
	GetParticipationKeyByID(ctx echo.Context, participationId string) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AbortCatchup converts echo context to params.
func (w *ServerInterfaceWrapper) AbortCatchup(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "catchpoint" -------------
	var catchpoint string

	err = runtime.BindStyledParameter("simple", false, "catchpoint", ctx.Param("catchpoint"), &catchpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catchpoint: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AbortCatchup(ctx, catchpoint)
	return err
}

// StartCatchup converts echo context to params.
func (w *ServerInterfaceWrapper) StartCatchup(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "catchpoint" -------------
	var catchpoint string

	err = runtime.BindStyledParameter("simple", false, "catchpoint", ctx.Param("catchpoint"), &catchpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catchpoint: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StartCatchup(ctx, catchpoint)
	return err
}

// GetParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetParticipationKeys(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetParticipationKeys(ctx)
	return err
}

// AddParticipationKey converts echo context to params.
func (w *ServerInterfaceWrapper) AddParticipationKey(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddParticipationKey(ctx)
	return err
}

// DeleteParticipationKeyByID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteParticipationKeyByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "participation-id" -------------
	var participationId string

	err = runtime.BindStyledParameter("simple", false, "participation-id", ctx.Param("participation-id"), &participationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteParticipationKeyByID(ctx, participationId)
	return err
}

// GetParticipationKeyByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetParticipationKeyByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "participation-id" -------------
	var participationId string

	err = runtime.BindStyledParameter("simple", false, "participation-id", ctx.Param("participation-id"), &participationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetParticipationKeyByID(ctx, participationId)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":           true,
		"fee":              true,
		"key-dilution":     true,
		"round-last-valid": true,
		"no-wait":          true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"timeout": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.DELETE("/v2/catchup/:catchpoint", wrapper.AbortCatchup, m...)
	router.POST("/v2/catchup/:catchpoint", wrapper.StartCatchup, m...)
	router.GET("/v2/participation", wrapper.GetParticipationKeys, m...)
	router.POST("/v2/participation", wrapper.AddParticipationKey, m...)
	router.DELETE("/v2/participation/:participation-id", wrapper.DeleteParticipationKeyByID, m...)
	router.GET("/v2/participation/:participation-id", wrapper.GetParticipationKeyByID, m...)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys, m...)
	router.POST("/v2/shutdown", wrapper.ShutdownNode, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
