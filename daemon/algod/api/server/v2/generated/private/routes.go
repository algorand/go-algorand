// Package private provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package private

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Aborts a catchpoint catchup.
	// (DELETE /v2/catchup/{catchpoint})
	AbortCatchup(ctx echo.Context, catchpoint string) error
	// Starts a catchpoint catchup.
	// (POST /v2/catchup/{catchpoint})
	StartCatchup(ctx echo.Context, catchpoint string) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AbortCatchup converts echo context to params.
func (w *ServerInterfaceWrapper) AbortCatchup(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "catchpoint" -------------
	var catchpoint string

	err = runtime.BindStyledParameter("simple", false, "catchpoint", ctx.Param("catchpoint"), &catchpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catchpoint: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AbortCatchup(ctx, catchpoint)
	return err
}

// StartCatchup converts echo context to params.
func (w *ServerInterfaceWrapper) StartCatchup(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "catchpoint" -------------
	var catchpoint string

	err = runtime.BindStyledParameter("simple", false, "catchpoint", ctx.Param("catchpoint"), &catchpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catchpoint: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StartCatchup(ctx, catchpoint)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":           true,
		"fee":              true,
		"key-dilution":     true,
		"round-last-valid": true,
		"no-wait":          true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"timeout": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.DELETE("/v2/catchup/:catchpoint", wrapper.AbortCatchup, m...)
	router.POST("/v2/catchup/:catchpoint", wrapper.StartCatchup, m...)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys, m...)
	router.POST("/v2/shutdown", wrapper.ShutdownNode, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
