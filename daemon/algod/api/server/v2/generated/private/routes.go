// Package private provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package private

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Aborts a catchpoint catchup.
	// (DELETE /v2/catchup/{catchpoint})
	AbortCatchup(ctx echo.Context, catchpoint string) error
	// Starts a catchpoint catchup.
	// (PUT /v2/catchup/{catchpoint})
	StartCatchup(ctx echo.Context, catchpoint string) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AbortCatchup converts echo context to params.
func (w *ServerInterfaceWrapper) AbortCatchup(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "catchpoint" -------------
	var catchpoint string

	err = runtime.BindStyledParameter("simple", false, "catchpoint", ctx.Param("catchpoint"), &catchpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catchpoint: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AbortCatchup(ctx, catchpoint)
	return err
}

// StartCatchup converts echo context to params.
func (w *ServerInterfaceWrapper) StartCatchup(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "catchpoint" -------------
	var catchpoint string

	err = runtime.BindStyledParameter("simple", false, "catchpoint", ctx.Param("catchpoint"), &catchpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catchpoint: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StartCatchup(ctx, catchpoint)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"fee":              true,
		"key-dilution":     true,
		"round-last-valid": true,
		"no-wait":          true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"timeout": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.DELETE("/v2/catchup/:catchpoint", wrapper.AbortCatchup, m...)
	router.PUT("/v2/catchup/:catchpoint", wrapper.StartCatchup, m...)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys, m...)
	router.POST("/v2/shutdown", wrapper.ShutdownNode, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Bo7dXt7+bwAAAP//a0ZV0gxhAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
