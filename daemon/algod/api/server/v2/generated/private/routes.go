// Package private provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package private

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Aborts a catchpoint catchup.
	// (DELETE /v2/catchup/{catchpoint})
	AbortCatchup(ctx echo.Context, catchpoint string) error
	// Starts a catchpoint catchup.
	// (POST /v2/catchup/{catchpoint})
	StartCatchup(ctx echo.Context, catchpoint string) error
	// Return a list of participation keys
	// (GET /v2/participation)
	GetParticipationKeys(ctx echo.Context) error
	// Add a participation key to the node
	// (POST /v2/participation)
	AddParticipationKey(ctx echo.Context) error
	// Delete a given participation key by id
	// (DELETE /v2/participation/{participation-id})
	DeleteParticipationKeyByID(ctx echo.Context, participationId string) error
	// Get participation key info by id
	// (GET /v2/participation/{participation-id})
	GetParticipationKeyByID(ctx echo.Context, participationId string) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AbortCatchup converts echo context to params.
func (w *ServerInterfaceWrapper) AbortCatchup(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "catchpoint" -------------
	var catchpoint string

	err = runtime.BindStyledParameter("simple", false, "catchpoint", ctx.Param("catchpoint"), &catchpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catchpoint: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AbortCatchup(ctx, catchpoint)
	return err
}

// StartCatchup converts echo context to params.
func (w *ServerInterfaceWrapper) StartCatchup(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "catchpoint" -------------
	var catchpoint string

	err = runtime.BindStyledParameter("simple", false, "catchpoint", ctx.Param("catchpoint"), &catchpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catchpoint: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StartCatchup(ctx, catchpoint)
	return err
}

// GetParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetParticipationKeys(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetParticipationKeys(ctx)
	return err
}

// AddParticipationKey converts echo context to params.
func (w *ServerInterfaceWrapper) AddParticipationKey(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddParticipationKey(ctx)
	return err
}

// DeleteParticipationKeyByID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteParticipationKeyByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "participation-id" -------------
	var participationId string

	err = runtime.BindStyledParameter("simple", false, "participation-id", ctx.Param("participation-id"), &participationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteParticipationKeyByID(ctx, participationId)
	return err
}

// GetParticipationKeyByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetParticipationKeyByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "participation-id" -------------
	var participationId string

	err = runtime.BindStyledParameter("simple", false, "participation-id", ctx.Param("participation-id"), &participationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetParticipationKeyByID(ctx, participationId)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":           true,
		"fee":              true,
		"key-dilution":     true,
		"round-last-valid": true,
		"no-wait":          true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"timeout": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.DELETE("/v2/catchup/:catchpoint", wrapper.AbortCatchup, m...)
	router.POST("/v2/catchup/:catchpoint", wrapper.StartCatchup, m...)
	router.GET("/v2/participation", wrapper.GetParticipationKeys, m...)
	router.POST("/v2/participation", wrapper.AddParticipationKey, m...)
	router.DELETE("/v2/participation/:participation-id", wrapper.DeleteParticipationKeyByID, m...)
	router.GET("/v2/participation/:participation-id", wrapper.GetParticipationKeyByID, m...)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys, m...)
	router.POST("/v2/shutdown", wrapper.ShutdownNode, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"6ii7faYAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
