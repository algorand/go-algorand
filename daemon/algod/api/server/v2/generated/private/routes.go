// Package private provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package private

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Aborts a catchpoint catchup.
	// (DELETE /v2/catchup/{catchpoint})
	AbortCatchup(ctx echo.Context, catchpoint string) error
	// Starts a catchpoint catchup.
	// (POST /v2/catchup/{catchpoint})
	StartCatchup(ctx echo.Context, catchpoint string) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AbortCatchup converts echo context to params.
func (w *ServerInterfaceWrapper) AbortCatchup(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "catchpoint" -------------
	var catchpoint string

	err = runtime.BindStyledParameter("simple", false, "catchpoint", ctx.Param("catchpoint"), &catchpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catchpoint: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AbortCatchup(ctx, catchpoint)
	return err
}

// StartCatchup converts echo context to params.
func (w *ServerInterfaceWrapper) StartCatchup(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "catchpoint" -------------
	var catchpoint string

	err = runtime.BindStyledParameter("simple", false, "catchpoint", ctx.Param("catchpoint"), &catchpoint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter catchpoint: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StartCatchup(ctx, catchpoint)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":           true,
		"fee":              true,
		"key-dilution":     true,
		"round-last-valid": true,
		"no-wait":          true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"timeout": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.DELETE("/v2/catchup/:catchpoint", wrapper.AbortCatchup, m...)
	router.POST("/v2/catchup/:catchpoint", wrapper.StartCatchup, m...)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys, m...)
	router.POST("/v2/shutdown", wrapper.ShutdownNode, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"vHt3978BAAD//9RHW+GqYwAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
