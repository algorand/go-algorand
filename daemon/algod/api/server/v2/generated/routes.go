// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/boxes/{box-name})
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, boxName string) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Path parameter "box-name" -------------
	var boxName string

	err = runtime.BindStyledParameter("simple", false, "box-name", ctx.Param("box-name"), &boxName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box-name: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, boxName)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/boxes/:box-name", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
