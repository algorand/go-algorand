// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
