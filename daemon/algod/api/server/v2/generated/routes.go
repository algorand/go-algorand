// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof of a light block header for a given round
	// (GET /v2/blocks/{round}/lightblockheader/proof)
	GetProofForLightBlockHeader(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// get a state proof for a given round
	// (GET /v2/stateproofs/{round})
	StateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProofForLightBlockHeader converts echo context to params.
func (w *ServerInterfaceWrapper) GetProofForLightBlockHeader(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProofForLightBlockHeader(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightblockheader/proof", wrapper.GetProofForLightBlockHeader, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.StateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"A3wlAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
