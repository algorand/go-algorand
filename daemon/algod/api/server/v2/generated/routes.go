// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get the proof over a block for a given round
	// (GET /v2/LightBlockHeader/proof/{round})
	LightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// get a state proof for a given round
	// (GET /v2/stateproofs/{round})
	StateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// LightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) LightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LightBlockHeaderProof(ctx, round)
	return err
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/LightBlockHeader/proof/:round", wrapper.LightBlockHeaderProof, m...)
	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.StateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9a3fbOJLoX8HV7jlJvKLkvHomPqfPXnfSD99J0jmxe3Z227ndEFmSMCYBDgDaUufm",
	"v9+DAkCCJCjJz6S7/SmxiEehUKgq1AsfR6koSsGBazU6+DgqqaQFaJD4F01TUXGdsMz8lYFKJSs1E3x0",
	"4L8RpSXji9F4xMyvJdXL0XjEaQFNG9N/PJLwr4pJyEYHWlYwHql0CQU1A+t1aVrXI62ShUjcEId2iKNX",
	"o08bPtAsk6BUH8ofeb4mjKd5lQHRknJFU/NJkQuml0QvmSKuM2GcCA5EzIlethqTOYM8UxO/yH9VINfB",
	"Kt3kw0v61ICYSJFDH86XopgxDh4qqIGqN4RoQTKYY6Ml1cTMYGD1DbUgCqhMl2Qu5BZQLRAhvMCrYnTw",
	"80gBz0DibqXAzvG/cwnwGySaygXo0YdxbHFzDTLRrIgs7chhX4Kqcq0ItsU1Ltg5cGJ6TcibSmkyA0I5",
	"ef/dS/L06dMXZiEF1RoyR2SDq2pmD9dku48ORhnV4D/3aY3mCyEpz5K6/fvvXuL8x26Bu7aiSkH8sBya",
	"L+To1dACfMcICTGuYYH70KJ+0yNyKJqfZzAXEnbcE9v4RjclnP+z7kpKdbosBeM6si8EvxL7OcrDgu6b",
	"eFgNQKt9aTAlzaA/7ycvPnx8PH68/+nffj5M/sf9+fzppx2X/7IedwsGog3TSkrg6TpZSKB4WpaU9/Hx",
	"3tGDWooqz8iSnuPm0wJZvetLTF/LOs9pXhk6YakUh/lCKEIdGWUwp1WuiZ+YVDw3bMqM5qidMEVKKc5Z",
	"BtnYcN+LJUuXJKXKDoHtyAXLc0ODlYJsiNbiq9twmD6FKDFwXQkfuKAvFxnNurZgAlbIDZI0FwoSLbaI",
	"Jy9xKM9IKFAaWaUuJ6zIyRIITm4+WGGLuOOGpvN8TTTua0aoIpR40TQmbE7WoiIXuDk5O8P+bjUGawUx",
	"SMPNaclRc3iH0NdDRgR5MyFyoByR589dH2V8zhaVBEUulqCXTuZJUKXgCoiY/RNSbbb9/xz/+JYISd6A",
	"UnQB72h6RoCnIhveYzdpTIL/Uwmz4YValDQ9i4vrnBUsAvIbumJFVRBeFTOQZr+8fNCCSNCV5EMA2RG3",
	"0FlBV/1JT2TFU9zcZtqWomZIiakyp+sJOZqTgq6+3h87cBSheU5K4BnjC6JXfFBJM3NvBy+RouLZDjqM",
	"NhsWSE1VQsrmDDJSj7IBEjfNNngYvxw8jWYVgOMHGQSnnmULOBxWEZoxR9d8ISVdQEAyE/KT41z4VYsz",
	"4DWDI7M1fiolnDNRqbrTAIw49Wb1mgsNSSlhziI0duzQYbiHbePYa+EUnFRwTRmHzHBeBFposJxoEKZg",
	"ws2Xmb6InlEFXz0bEuDN1x13fy66u75xx3fabWyU2CMZkYvmqzuwcbWp1X+Hy184t2KLxP7c20i2ODGi",
	"ZM5yFDP/NPvn0VApZAItRHjBo9iCU11JODjle+YvkpBjTXlGZWZ+KexPb6pcs2O2MD/l9qfXYsHSY7YY",
	"QGYNa/Q2hd0K+48ZL86O9Sp6aXgtxFlVhgtKW7fS2ZocvRraZDvmZQnzsL7KhreKk5W/aVy2h17VGzkA",
	"5CDuSmoansFagoGWpnP8ZzVHeqJz+Zv5pyzzGE4NATtBi0YBZyw4LMucpdRg7737bL6a0w/2ekCbFlOU",
	"pAcfA9hKKUqQmtlBaVkmuUhpnihNNY707xLmo4PRv00bq8rUdlfTYPLXptcxdjKKqFVuElqWlxjjnVFo",
	"1AYuYTgzfkL+YPkdqkKM290zNMQM783hnHI9aS4iLUZQn9yf3UwNvq0OY/HduVgNIpzYhjNQVq+1DR8o",
	"EqCeIFoJohXVzEUuZvUPDw/LssEgfj8sS4sP1AmBoboFK6a0eoTLp80RCuc5ejUh34djo4IteL42UsHq",
	"GEYozJ24cuKrthi5NTQjPlAEt1PIidkajwajvN8ExeFlYSlyo+5spRXT+AfXNiQz8/tOnX8fJBbidpi4",
	"8PrkMGdvLvhLcGV52KGcPuE4I86EHHb7Xo1szChxgrkSrWzcTzvuBjzWKLyQtLQAui9WiDKOVy/byMJ6",
	"TW66I6OLwhyc4YDWEKorn7Wt5yEKCZJCB4ZvcpGevZNCzG8ckGboGDTIEfFrqClMaphugAfNzDh9VoDD",
	"kyXQDCTJqKbBWXdnOK5AYMcfsB9yKZCRW8aP+B+aE/PZHEbDq+2wE3KCHEfZ8+ds/Zm5dFtV3s5kGqAx",
	"QJDC3rOJuR9fCsqXzeQ9vmXRsgvf+tZe7Qn28IswS28Md4czIa9Gwx3i5KQxRxJqRg2O8Lizs9i0KhOH",
	"n4hJwzboDNR4gPqabYih7vAxXLWwcKzpLWBBmVFvAgvtgW4aC6IoWQ43cF6XVC37izB3zKdPyPEPh88f",
	"P/nlyfOvzCWplGIhaUFmaw2KPHSqPVF6ncOj/spQx65yHR/9q2feiNUeNzaOEpVMoaBlfyhrHLOC1DYj",
	"pl0fa20046prAHc5lidg2ItFO7F2XwPaK6aMnC5mN7IZQwjLmlky4iDJYCsxXXZ5zTTrcIlyLaubuBCB",
	"lEJGzDN4xLRIRZ6cg1RMRCzt71wL4lp4Jans/m6hJRdUETM3Wg4rnoGcxChLrziCxjQUaptstUOfrHiD",
	"GzcglZKue+i3642szs27y760ke8NUYqUIBO94iSDWbVo6dNzKQpCSYYdUXC8FRkYyV+pG+CWzWANMGYj",
	"QhDoTFSaUMJFBnhxqlScjw643dDej24KHbJmvbRyegZGSU9ptVhqUpUEjfC9rW06JjS1m5KgTFUDVsra",
	"vGxb2emsSyeXQDOjvAMnYuZMgc5IiYuk6EHQnhM5Lh65zrTgKqVIQSlz6bKq9FbQfDu7y3oDnhBwBLie",
	"hShB5lReEVgtNM23AIptYuDWapezn/ah3m36TRvYnTzcRirNvctSgdHxzOnOQcMQCnfEyTlItCPe6v75",
	"Sa66fVU54OV3msoJK/D6xikXClLBMxUdLKdKJ9uOrWnUUqfMCoKTEjupOPCACeE1VdpakxnPULW27Abn",
	"sbYFM8UwwIMSxYz8dy9M+mOnhk9yValasqiqLIXUkMXWwGG1Ya63sKrnEvNg7Fp8aUEqBdtGHsJSML5D",
	"ll2JRRDVte3FuVv6i0MLhZED6ygqW0A0iNgEyLFvFWA39HQOAGLuYXVPJBymOpRTu1fHI6VFWZrzp5OK",
	"1/2G0HRsWx/qn5q2feKiuuHrmQAzu/YwOcgvLGatj3tJjQ6MI5OCnhnZhBqtNXv3YTaHMVGMp5Bsonxz",
	"LI9Nq/AIbDmkA5cJF0UTzNY5HB36jRLdIBFs2YWhBQ/cbN5RqVnKStQk/gbrG7eQdCeIWm1IBpoyo20H",
	"H5CBI++t+xPrx+iOeTVFaycltA9+TwuNLCdnCgVGG/gzWKP59p11kJ8EbvUb0BQjo5rTTTlBQL3bzQjk",
	"sAmsaKrztRFzeglrcgESiKpmBdPaRjy0FUktyiQcIHrB3zCjM7FY57LfgV1sPsc4VLC8/laMR1Zt2Qzf",
	"SUdxaaHDKUylEPkO5vEeMqIQ7GQ+J6Uwu85cgI2PwvCU1ALSKTFoX6uZ5wPVQjOugPy3qEhKOSpglYZa",
	"IgiJbBbFr5nBCLB6TmcobzAEORRg9Ur8srfXXfjenttzpsgcLnxUmmnYRcfeHt6S3gmlW4frBm685rgd",
	"RXg7Wj6MoHA6XJenTLZe7d3Iu+zku87gtbnEnCmlHOGa5V+bAXRO5mqXtYc0sqRquX3tOO5ORo1g6Ni6",
	"7b5f2Q7fN6TFoxLwcuICDUwrMq+4BapS7jqCvjdv0BDzcR15YiPODwiGJSypt8a5P588/2o0bsIJ6u9G",
	"JtuvHyIaJctWsaCRDFaxPXFHDG9TD8zVY60g6qlDxizmkbgxkGe5W1mHdZACzJlWS1aaIZsYl7WGVnzs",
	"/334nwc/Hyb/Q5Pf9pMX/zH98PHZp0d7vR+ffPr66//X/unpp68f/ee/R82Kms3i5s8fzC6JOXEsfsWP",
	"uHVgzIW097G1U/PE/O7h1hIgg1IvYwGppQSFrNEGlpZ62WwqQMeGUkpxDnxM2AQmXRabLUB5Y1IOdI6B",
	"kXinELs4auvjYOnNE0eA9XAhO/GxGP2g2xFpEw9z4+C6cb2xGXqzZy3iKA3dbnFfqbks5esbULrsQES2",
	"6cAbGZT9KuZhFLI74GqtNBR9O53t+svALeW91/F7zEDwnHFICsFhHU28YRze4MdYbyumBzqjwjTUt3sH",
	"asHfAas9zy5EeF384m4HculdHSRwA5vfHbdjog3jr9HEBHlJKElzhgYowZWWVapPOcUrbstD3CMLf3Ef",
	"Nnq89E3iVpaIEcQNdcqpMjisL75R0/0cIqL2OwBv+1DVYgFKd5T9OcApd60YJxVnGucqzH4ldsNKkOiL",
	"mtiWBV2TOc3RRvMbSEFmlW6rvyislWZ57uzFZhoi5qecasM7lSZvGD9Z4XA+GtPTDAd9IeRZjYW4aF0A",
	"B8VUEpdX39uvKLbc8pdOhGHOjv3s+eRdyysPeyyI0UF+9MpdDY9eof7fWIp7sN+Z+bBgPIkSmdHnCsYx",
	"Fr5DW+ShucV4AnrU2Jzdrp9yveKGkM5pzjKj812FHLosrncW7enoUE1rIzrWIL/WD7Fwh4VISpqeobd7",
	"tGB6Wc0mqSim/ko8XYj6ejzNKBSC47dsSks2VSWk0/PHW/Tza/ArEmFXn8Yjx3XUjSsCbuDYgrpz1nZY",
	"/7cW5MH3356Qqdsp9cBGNNuhg1DUiBXDRVu1HG1m8TYjz4Z0n/JT/grmjDPz/eCUZ1TT6YwqlqpppUB+",
	"Q3PKU5gsBDnwAVyvqKanvMfiB5Nmg9A5UlaznKXkLBTFzdG0iVD9EU5PfzYEcnr6oee16QtON1X0jNoJ",
	"kguml6LSicv0SCRcUJlFQFd1pD+ObPO0Ns06Jm5sS5Euk8SNH2fVtCxVN/C3v/yyzM3yAzJULqzVbBlR",
	"WkjPBA1ntNDg/r4V7qoo6YVPE6oUKPJrQcufGdcfSHJa7e8/BdKKhP3V8RpDk+sSWvauKwUmd21duHCr",
	"UMFKS5qUdAEqunwNtMTdR0FdoGU1zwl2a0Xg+tgQHKpZgMfH8AZYOC4dTYiLO7a9fMpufAn4CbcQ2xju",
	"1DgsrrpfQUzulberE9fb26VKLxNztqOrUobE/c7UmXwLw5O9F0mxBTeHwCU9zoCkS0jPIMP8KyhKvR63",
	"untHpZNwnnUwZfMUbYAeJtOgaXAGpCoz6nQAytfdrAYFWvtUjvdwBusT0eTiXCaNoR1cr4YOKlJqIIwM",
	"sYbH1o3R3Xzn9MaA4rL0MeoY++jJ4qCmC99n+CBbCXkDhzhGFK3g7yFEUBlBhCX+ARRcYaFmvGuRfmx5",
	"Rr2ZWckXMU953k9ck0Zrc47rcDUY026/F4BJz+JCkRlVkBHh8nVtAHnAxSpFFzBgMwutszuGabcsujjI",
	"NrkXlXRi3hVoPXkTBdk2Tsyao5QC5oshFTRvdsIV/EzWAYArmBAsw+EQNstRTaojJSzTobJlJbd1BYZA",
	"ixMwSN4oHB6MNkZCzWZJlU8lxoxrf5Z30gFuMSFiU/7bUeBpD9Kq6+w2z3O757Rnb3ZZcD71zee7hcbm",
	"HXLXxiMX/BXbDsFRAcogh4VduG3sCaVJzmg2yMDx43yeMw4kiTntqVIiZTYXvBEzbg4w+vEeIdb2RHYe",
	"IUbGAdjo2MKByVsRnk2+uAyQ3CWXUD82usSCvyEewWjDsozKI0rDwhkfCKjzHIC6SI9afnXijXAYwviY",
	"GDZ3TnPD5pzxtxmkl42Famsn98q5Vh8NqbMbTH9WsFxqTVYUXWU1oc7kgY4rdBsg3qxKxLZAIb7c1bfG",
	"1ZAs3WXqAfE9hKuHQR7XlQDoWCKaUkfu5rf1htaWzX1J1rD0cZOY7CNKY7Q/RD/RXRrAX98QXGdeveuK",
	"6+glve1ybSedBfpTjBWbM9I3jfYNsApyQI04aWkQyVnMYG4Ue0B2e+y7BTd3TG2jfP0o8ONLWDCloTFd",
	"GankbbF37aajmEovxHx4dbqUc7O+90LUPNqmbFq3Y7jMO1/BudCQzJlUOkG7X3QJptF3Cm+U35mmcUWh",
	"HSlgq8qwLM4bcNozWCcZy6s4vbp5//bKTPu2NsKoanYGa1QHgaZLMsMqSNH4oQ1T2xCzjQt+bRf8mt7Y",
	"enc7DaapmVgacmnP8Ts5Fx3Ou4kdRAgwRhz9XRtE6QYGiYL/FeQ6lmkVKA32cGam4WST6bF3mDI/9lZn",
	"rYViWEbZkaJrCW7LG1fBMGrCXPeYDooI9dMdBs4ALUuWrTqGQDvq4HWRXuq275O0O1jA3XWDbcFAYPSL",
	"RdRKUO18/Ea7teWgeLi2yU6YOWlnzYcMIZyKKV/MsI8oQ9pYcWsbrk6A5n+D9d9NW1zO6NN4dD27YQzX",
	"bsQtuH5Xb28Uz+gQs3aklhvgkiinZSnFOc0TZ10dIk0pzh1pYnNvjL1jVhe34Z18e/j6nQP/03iU5kBl",
	"UqsKg6vCduXvZlU29X/ggPhiaebC43V2q0oGm1+nP4cW2YsluMJUgTbaK6TRWNuDo+gstPO4X36rvdU5",
	"BuwSNzgIoKz9A43tyroH2i4Bek5Z7o1GHtoBHzoubrdqLFGuEA5wbddC4CFKbpTd9E53/HQ01LWFJ4Vz",
	"bSidVdjqcIoI3g0lMyok2qKQVAuKZTCsSaDPnHhVJOb4JSpnadzAyGfKEAe3jiPTmGDjAWXUjFixAT8k",
	"r1gwlmmmdrjodoAM5ogi05dUGcLdTLiyvhVn/6qAsAy4Np8knsrOQcW6I87U3BenRnfoz+UGtubpZvjr",
	"6BhhCZiuxEMgNisYoZuqB+6r+srsF1qbY8wPgT3+Et7ucMaeSNzgqXb04ajZhgwt2+6msApvn/8ZwrAV",
	"27aXAPaXV1eLZmCOaElfppK5FL9B/J6H1+NIuL0vesMw2vM34JNI1lKXxdTWnaYycTP74HYPaTehFart",
	"oR+getz5wCeFxTy8eZZyu9W2wmYrLiROMGEs19SO3xCMg7kX/5bTixmNVToxSoaB6bDxfrYMyVoQ39nj",
	"3tm8matDNCGBI7Vuy2wiWgmyyYTpJz1fUWGw0+6sKjSaAVJtqBOMrfMrVyIyTMUvKLeFWk0/e5RcbwXW",
	"+GV6XQiJaaQqbvPOIGUFzeOaQ4bYb6fdZmzBbJnSSkFQB9MNZOs7WypytUStf7lBzdGc7I+DSrtuNzJ2",
	"zhSb5YAtHtsWM6qQk9eGqLqLWR5wvVTY/MkOzZcVzyRkeqksYpUgtVKH15vaczMDfQHAyT62e/yCPESf",
	"lWLn8Mhg0cnn0cHjF2h0tX/sxwSAq0e8iZtkyE7+y7GTOB2j086OYRi3G3USTYq0ReSHGdeG02S77nKW",
	"sKXjddvPUkE5XUA8TKLYApPti7uJhrQOXnhmKyArLcWaMB2fHzQ1/Gkg5tOwPwsGSUVRMF04z4YShaGn",
	"psilndQPZ8spu6pHHi7/ER2EpfePdC6Rd2s0tfIttmp0476lBbTROibU5g7nrHHd++Jp5MhXIMAyUHX1",
	"J4sbM5dZOqo56Mmfk1IyrvFiUel58leSLqmkqWF/kyFwk9lXzyKlr9rVbvjlAL9zvEtQIM/jqJcDZO91",
	"CNeXPOSCJ4XhKNmjJsY6OJWDnsx4tJjn6N1gwc1D76qUmVGSQXKrWuRGA059LcLjGwa8JinW67kUPV56",
	"ZXdOmZWMkwetzA799P610zIKIWP1aJrj7jQOCVoyOMfAtfgmmTGvuRcy32kXrgP95/U8eJUzUMv8WY5d",
	"BIIChQNFAuusup0utidYeyjIXbR183ydmUYynkOqhQyT4S6VxGjmCQqW3X3e39AVG8GNYrpiefb3Jjun",
	"U6dRUp4uox6Wmen4S1Pbu16l5ZjRQjNLyjnk0eHsHvzitZiInvVPses8BeM7tu3WX7TL7SyuAbwNpgfK",
	"T2jQy3RuJgix2k5XqONb84XICM7TVDVpznO/pGRQY+1fFSgdS+vEDzbGBi1p5gZmS3wR4BneXybke/s2",
	"zxJIq+gC3htYUeU2gR+yBUhn4q3KXNBsTMw4J98eviZ2VtvHFqq1JcYWqDa3V9GxoAQlkHaL1vQ1Z+OR",
	"5LuPszm01axaaayBojQtyliSkGlx4htgJlJoVUaFOsTOhLyydxnlNWU7iaGHOZOFuQPUo1lpijRh/qM1",
	"TZd4SWgxkGGS3702nqdKFTxnUFcnrqsY4bkzcLvyeLY63pgIc5O7YMo+yQLn0M5LqpP0HAP1eUrt5cmK",
	"c0spUWm4KYn0Kmj3wNnQAW94jkLWQfwlVURbWvKypQKPsVe0LEi37mDvHQObd14XsfVPbaWUC85SLMoR",
	"PAJTg+yed9nFK7ND/ZKu2c8fcXdCI4crWu2wDtxyWBysf+gZoUNc3ywcfDWbaqnD/qnxHZEl1WQBWjnO",
	"BtnYF+10linGFbiqVPjST8AnhWx5upBDRp2nSa2LXJKMMEth4Krxnfn21l1EMXz3jHFUOR3aXKSwtR3h",
	"6xPa6KlMk4UA5dbTLt6gfjZ9JljAIIPVh4l/rQLHsI4is2zrFe0Pdeh9pM4nadq+NG1tSnvzcysg1E56",
	"WJZu0uGSrlF9QK/4IIIjvq7Ea0IBcuvxw9E2kNvG4AaUp4bQ4Bxdo1CiHO4RRl3etFPP+ZzmlaUobEFs",
	"UFE0k5XxCBivGYfmLZWIgEijIgE3Bs/rQD+VSqqtCrgTTzsBmqM/NMbQlHbG8OsO1dlgRAmu0c8xvI1N",
	"ZdYBxlE3aBQ3ytf1Ey6GugNl4iW+HeUQ2a+zilqVU6IyDPDuVF6NMQ7DuH1t57YA6B+Dvk5ku2tJ7cm5",
	"jCQaytlLRUzf/HYFaWXd/UL5eG+SYhJ8IC+ituOmhnBkG8I6xh61GIw/W+O/sSJcwyhx/vhLR4R55zt2",
	"vLTC2h6pp24aYkoUWyS7YwKZ+fXR0Ux9NQpr+t8oieVi0QbkjqvlbGIv4R7FGMu3hmOHGeS9ynKWp9cJ",
	"3hh/JfxzBHhfq1MT2+wAZUiv1Bza/evK8ptNAMM14scodQaiMIMaQdQKNutIGorFTAdDh6l2GTyakqZQ",
	"SJ8n2MLusRFsIIctKG/fx4wa0YaCN2zshvnc672bStZTcHHsjQj1UUF9gP7mQw5JSZnzkjbMoo9ZF5zc",
	"DxffJWyx2eDuIlzILw4SW0mvguRmCumFfAdpC7bQ32T30gGHtQsaHWNYpn0B3NVpbwdz7hxSNp9Dqtn5",
	"lhD7/zLKchO+PfbqtH0EJIi4Z3WIkn9G9ZJafgPQpgj4jfAE9UmuDc5QgO0ZrB8o0qKGaOXBsSfUq2Sm",
	"IgbQJJsYEhEq5uKx939ndWeqpgzEgnep2u7QlPsaLPkcJIxccS5PkoSGSSQbpjwXsQvETnOZrpdKrcJo",
	"m6Eo/H7R1WHp9Qpr3Kq6XH/9TmoQMWPuid2KgBcuMxYTImqTl8+RBeV/89lPdhb7/m5TlBoNjBdUZr5F",
	"VGP2yniywfzfC533BUO7QM/rmVkTANMPlo5UlMAwpzQXivFFMhQr1o45CZ/wQs8a2iawmi3CNQfpitFr",
	"/7xxooUPmNkExyZUuOemroIENVjX0QI3mFv9vkkexzJa1D5u7byG4QKJhIIa6GSQ4j085yZkv7TffXSw",
	"L6PUKVoWGdfTa7I1R9uHPjHVQ2JI9XPipOX2qOOrXFUY5/atDxXL9+YGlaERq5Qiq1IroMODAf5Kt3M1",
	"hQ2sJKrlp/1V9hS2HGuLvA5yOM5gPbVKU7qkvCny0j7WtlylXUOQM9nZ7Ru9xcUV1nxhF7C4ETg/501o",
	"PCqFyJMBq9VRP229ewbOWHoGGTGywwcNDJR9Jg/RWFK7JS6Wa5+mXZbAIXs0IcTcpYpSr72Hol2wrTM5",
	"f6A3zb/CWbPKVpJwl7TJKY/Hu9jn4q/J3/wwm7maAsP8rjmVHWRLXvhqIGVe0otIEfRd37mL+Ay6hakb",
	"orJQxLSUKyYJ7nS++xe1COkHxVw3337CHGKf5pcKae/7qC35W3hXeXkz9EBcGEngOt99LM0mBIQABqVr",
	"Pb/7TDB36OxNjfZgKTFaCzN5tmz2WesCb6tPdVxCQsINX+QDW/glL/L9HKVdl4frwA2tFPTXufNZa+E2",
	"csyate1qheojd9h4pGe7GI/ilXJMd7ReWYRgmSmCoJJfH/9KJMyx7KQge3s4wd7e2DX99Un7s7lo7+1F",
	"mfCd2a1aLye6eWMU8/ehEALrJh+IVunsR8XybOsztGHsUVMCFqNrfnHxcJ+lCO0v1hrSP6quHudlLObd",
	"TUDERNbamjyYKogq2iGgyHWbRN+2VJBWkuk1pun5yzP7JVr+4Pva3uae460TO1xegRZnUCd6Nta5Svmi",
	"e98L+xZmYSQi+is0Pu7x7YoWZQ7uoHz9YPYXePrXZ9n+08d/mf11//l+Cs+ev9jfpy+e0ccvnj6GJ399",
	"/mwfHs+/ejF7kj159mT27Mmzr56/SJ8+ezx79tWLvzwwfMiAbAEd+aDw0T+wUnNy+O4oOTHANjihJavf",
	"9DFk7Ku+0hRPorl+5qMD/9P/9idskoqiGd7/OnIxp6Ol1qU6mE4vLi4mYZfpAq/jiRZVupz6efpvqbw7",
	"qqO0bB4T7qgNwDGkgJvqSOEQv73/9viEHL47mjQEMzoY7U/2J4+xuHoJnJZsdDB6ij/h6Vnivk8dsY0O",
	"Pn4aj6ZLoDm+FGD+KEBLlvpP6oIuFiAnrvyt+en8yfQ1Wyx18OryFJWf6Ue8E38yMyxsMmMN/lGGXup2",
	"t3eu3H9QE+Hg5492Ow2sDbZ9dEhzlrSsIMzB35St8ukDhqzjvRTX/2R/f4g71e2mkRe4P41Hz/Yf31iV",
	"4LbnKFIr+IijYdhsMrFEjBA8uzsIjgPdNrxfcaGtlchA9Nyi865wYiQAzQm2tNM/vUOEgDxnKZATKEoh",
	"qWT5mvzE66C0IDWqz1V/4mdcXHAPueHJVVFQuUaOq5u3XYjAW6KLU0ZuEJZwxq7mHPpgq+lHZxIMz16H",
	"o2P3INivX53ZuRfQhW/jOlvVDpUrvjeua2C6GzvPMBzPWtmMitE+9c6YchS8b9878r1XAeZsUcnOa4C1",
	"A9UVyGWK2KedJXGa/juanoUhb8hJ/lWBXDesxKkUIe/w9QpdYFyhFmU7iqS5X8TeDYuVuY7wsMY6P8zF",
	"Gv3G6Cz7yYsPH5//9dNoB0DQVeRep/+V5vmv9rlGWKG93edHu/y3caQ2H95ix421Fzs02zTGMJj6a1h+",
	"uW7TDr78lQsOvw5tgwMsug80z01DwSG2BwPM/EaOfx1vbINp6lE8SVxhoL6kt58ib8D48u0DD8A8u0U2",
	"e83lbmWb39AMS+KC0rctRW97KVGh/Px3vDd9iXplCUb7DxBMNkiraVhjdPqx5cvLriXLeuWVj15tEW8P",
	"1BBT7Fe96ZQwNd/rIp3o7XF1WmHFlFaPJuT7sDcyZkwisylaleTNA4alFOcsMyzWhUH4XPsGtgcqzK+L",
	"CtvAQHovd29V7h62rX+tsikxYFokvhGmXW8xV3yLkJZl9wWKK73wEBRLvULJuVstg90xvgy+KbwDg73H",
	"3dB7zAPqTQBvrem0i9zePt91N6dGTLTkwS1y5d+5svaG5oZOguV20l5sLaF7Je5Po8TV8V/WCoHl8zap",
	"dVgje/rRl366AVXOlb7aQYkLb7pB36A00cMOp3g0sXWcwjZXYwculmureoYFue4Vs9tWzPqV7GJgNPXJ",
	"Pp8yhjAsm1J3l3m9qVWZ/lIl+X6n2tefGFmD6paBdLuidQXe2FOiHCe+NZ75h1SeHNLu1aY/tdpkw6c3",
	"KE6tMpMu1n5Yd3Iuo5zZ/MtIbL7CEF87+pgoIV3EaSmZkEyvx4RxkoE5e+i5FxLrPGhZ8dQa+u0UwPG/",
	"bw7/gdH+bw7/Qb4m++NaBcM02Mj0Np6yrQN9D7ofNqy+WR/W6sBGXeiLUTBOaiQFAf0h6rXwlSIRaQVd",
	"fT2EspX178fUs4KuRhs1kfHvR1u8rtLUSWDvU5F7IRqDb/yrZu0oVkVgRVOdrwlF+bO26RaqmjVlHtvq",
	"hhZlEg4QTfHcMKN/NCmWqHvZQNpIlRB8nGgzfCedkngtdLgqWPhC2XbFpIeMKARX0/Lud/d3u7t9tZSU",
	"wpxphlVoGnniZVULyObpHAfuQI7AhPy3qDDozL4MCbFa1TgD5lP4OZ0CGhSbz/Fdzho7e3vdhe/tuT1n",
	"iszhAjko5diwi469vT+AyrqqSwRTwgVPOD5ceA4kiFS911u/aL31NqOgbns1txlURWueU/Gg9tpG/tNL",
	"Tmq06EB9v5bvuuubZrrRDFu5qoEJoX5f1t2Vx80DNeYujxWafI0QNfauEwzAtV4Vux/jnmNlElPSAw/O",
	"N+ujV7vo5b8TR+jOlQIjci2+N7ctAaLxNO/vJp7mC4xKDXfhrdDkuy8kEvXqTCpOVgGzubRHpfGYhKzF",
	"5X5vZCrmhI5dHW0s7LwmdW6m4SeWEdqXdPpcw8ywK7/4gu3zO7whH6HLLnrv+cI9X7gWX+gSVMMRMDZc",
	"bc25+B5sxsUfyMUY+FukKLzDRZA56HRZ1/ZupafdWUrJFf1/CPRQsXOXgoUPc+yYgx0k2aDTC2SE+H70",
	"JcjMZzbHTPq6mKx/5wfdOcyXvq+r3ru3QZjyMecu45eYXbwUlC+byfvpcoiWm/AZ3iP4cgjuMbVvXbK3",
	"PV5uEX+EqHRfNz0hb1EdwgPua6n+Ec0etymRb3tBbwUH65c2GqulxXsXZCuBrMkZw5eAm6yxIdWh7XT8",
	"qFcs+zStK6MNKRUDuZtDkpo1DzS3zSu0LIFKdWUhvd0ddtKZ8ehVGKfRKuRWl3CLgGLwcklP4n+MdtRm",
	"MOFHzMmSqiWZV9wCWj8FiCErTXbguDbWmtMg5gfklO8RtaTPHz/55cnzr/yfT55/NaCPmXlcHYC+RtYM",
	"ZD7bYXZRy/64bse2KlEj7+Cut/JyOzQesWwVrdrUPIQTngtn+0Tm8ECRkq4Hi70N1E18A/Isr1NY2wnD",
	"BRiBqpasvPtCNkqzWfyBvB/MLok5qR9TOOLf1PzzHCSb4yuPn+Uxn/FIS4AMSr3cWBrFPlJZ6mX4bpGt",
	"ncWUqzZWSnEOfEzYBCZdZ1i2aOqS50DndbUqIXYJVQt4iaE3TxwB1sOF7KJqvovRD6ZDuqqed21UaUK6",
	"rDDzyJMdufJZLS76s1hc3gqeoD4GXPu7QQstn8/6ggXGxoGBs36ehguNhk0hUY0M2Zaa7KSAwaCzqcUD",
	"bejkIBk7dSylOl1W5fQj/gcrgHxqam3Yt5im1hC7SSM7ti1uNMTGjklkm9v4ojPOOCzm5A1LpTjEQnRO",
	"jKi10lD030S2XX/Z9MpPVOQInjMOSSF4rF7Nj/j1DX6MlrpDt/1AZwygGOrbfcmuBX8HrPY8u7C66+J3",
	"8mUYea91YemsVkJZhyliPAfSf3NaWrXGm2PS+nn6sfWn85e4lmpZ6UxcBH3RB2qP/1Z7alBJ7kstXNOA",
	"+CcuXPNSVHlmy9Sw+hWWslWksFVR5b6KzU0EXCxQBnaRHS9eY6vJbJRotsWNSrS3IgM7bruQWixqm4sM",
	"XNGbviCrZXX8Hui5WtOuo5KntFostX1JO/pMf90xoallHrZIvtpWVdy28tVzz4HQXALN1mQGwImYmUW3",
	"X2cgVOEbDv4G4TSSeHHsBq5SihSUgiwJH3bcBFpdSgjvG3oDnhBwBLiehShB5lReEVgrmjcD2n07uga3",
	"ts/7N2N7UO82/aYN7E4ebiOVQLwIQTuCKMocnCUhgsIdcYI3XHbL++cnuer2VSW+HRgp726/nrACq+Vw",
	"yoWCVPBMDT/CsO3Y4rMLwVqUWUFwUqJPspmBBxTa11Rp93Rlq1Z18HiHmWLDqxFD5TjNyH+vi3H2xk4N",
	"v+SqUs2rnvbGA1n0aXpYbZjrLazqucQ8GLu+UmlBKgXbRh7CUjB+/c5n8AyEDmzHZrjI4jD1jLoLUB+V",
	"LSAaRGwC5Ni3CrAb2jUHAGGqQXRd271NOTMhcqDcWqZEWZrzp5OK1/2G0HRsWx/qn5q2feJyKTvI1zMB",
	"KrzuOsgvLGbtE75LqoiDgxT0zN2UFy5zpg+zOYyJYjx1b9cMZUWyAo5Nq/AIbDmk3ctWePxb56xzODr0",
	"GyW6QSLYsgtDC45d774INfuyemzXWn6LDqr29TZQryYdrXB6QZlO5kK6d4HoXIOM3M06NfAo08ppnNYW",
	"pYVzMBEcwTEUN07wgLUK0w4sCD71zex+P9LNTPWdkDuF1jReMC2IWRipuGa+foE5b7WO+eXFqdxrz/fa",
	"8732fK8932vP99rzvfZ8rz3ftvb8eWLlSZJ4Pu0DMmJpkGT0u9Tw7y3VG24jgZrqLglGRTfneGMMnQaa",
	"44JYjsK1jD6SbpNx8OkaJSqZAknNdIyTMqdGG4KV9iUhyIwq+OpZ/aySf+zbPl5jeI1p8PQJOf7h0IcH",
	"LV38SrvtQ/+ErtLrHB65WOP6dQkfdAyc4tPiGHNM/e0ndWFcVpmfsxyIMrj6Flu/gnPIjSZvQw6IuYv0",
	"b0cnQPOXDjdbLketuuVmtF/HrTuZQ1tBS6/y+LVSRSiGknXKjs9probrjtvxClrGimrUfNpem5A1fCOy",
	"dYfcza5NcQPbhN5EBzFO5ToS/dcj7x5paGGYjyOs/r3v042HsvWJtk9m2ygs/maeih7KTVQeDd6qN6w3",
	"lI0jnHfoJPr4TTdiaVQDuIub3tCz3xPy3vb7rNKKIETuiDWc+Yvx8XYfEXZMA9sahcqxnt9rapZHfPT0",
	"4tkf+0dW8TVAR3GrxDRaAE8cb0lmIlsnLc7UFjAZU1QpKGbbhUzIGvEw1XLFfNksgj6PhHgVLG4Tuw3p",
	"YZU43jrAeG1Y5m5st8YWjug4b4Dx2+a+QxwyBIE41hO7O3drBl6SnzXTrO952j1PC05jR9gz7iKCu0xk",
	"cjWeJtey4sPs7Fv7MrIi4SF9qB4ZloUYXemW5T6DWbVY2OeAu1ZorF1Xv2r9ebicXe6uDO5yxGEHrxO+",
	"r5ur1B2uzziCUNaHQpKFFFX5yFYS5Ws0cBYl5Wvv1DA3/6LK3Sv/mF95szy0fpq6pzd649qwXe6dN78F",
	"1icnRdu/W7Tgg9Z2fyEjFc9Axh8TXXWeiNyO8ZMVbzjwxgck/avJvdW5eXfh/n6XXV5O7cgp7Rvy9kC1",
	"DpPLDrAnd3Jf1ODPIRHe2Yq9Awy2H9veMITtgkEGLAslQ6fEnRcNbX76nl6EBfNuSmnc/ba+BJSJ9e01",
	"Ug/QqJFS0CylCo0aHPSFkGe3rEvq1VHEioxgYl3XfrqXuZNMtiqVOO5OKmU7w9LfyqtZwZR9k/bzKpdN",
	"Ds+hS5NvYePesPtHMex+4w+fIpRIetE9nNaHg2dyBzZFL/SKR7nUtLR14Yfil4MD4SrI32gkRm/4dkBG",
	"UJXdOpQhLwklac7Q3Sy40rJK9Smn6NAKFtYvkVq76YZVqZe+SdynGnF5uqFOuVGq5qR2c0VVqjlEHNjf",
	"AXiNTVWLBSjd4cRzgFPuWjFOKs40zlWwVIrEZtMYcW04+sS2LOiazGmOHtnfQAoyM5eIsFYguoeUZnnu",
	"okPMNETMTznVJAfD9N8wo9CZ4bwHoY54snRXYyGeXeseZ07i1tnv7VfMXHXL914AdFbYzz7HbPx5nlBP",
	"WDYI+dErV8f36BWWZmziQnqw31mwQMF4EiUyI/FdfFWXtshDo+N5AnrURJi4XT/lRpnWgiCjp/pq5NB1",
	"6vbOoj0dHappbUTH9+vX+iFWQ2YhEnNlpAvz+4LpZTXDR8x9bZnpQtR1ZqYZhUJw/JZNacmmqoR0ev54",
	"i35wDX5FIuzqXnL/gZ7ADujAnJZ64/G9ku7eD8jlG3g24ct+K2FrwOn9ywT3LxPc166/f5ngfnfvXya4",
	"r9t/X7f/z1q3f7JRQ3S17rZW0tY90yYlElI7c83Aw2atmtt9ryTTE0JOlob/UyMD4BwkzUlKlVWMuI17",
	"LthiqYmq0hQgOzjlSQuSVBRu4ofNf+0197Ta338KZP9Rt4+1WwSct98XVVX8hK4m8jU5HZ2OeiNJKMQ5",
	"uAq82DyrMPzF9to67P+qx/1R9rauoGtrXFnSsgQj1lQ1n7OUWZTnwlwGFqITrc0FfgFpgLPVxgjT9rED",
	"xCdGubuYGOpq+MSU7r58v8RTrYfdmlB3Wkzwj6tgb+JT/Q27OR64ceweQ7xnGXfBMj470/gD1T2+L3H8",
	"hS0odKS23jC4hiZVP94bsTt5Hcmakw1vxhEgrSTTa5RwtGS/nIH5/wfDxxXIcy/8KpmPDkZLrcuD6RRf",
	"GVoKpacjI5qab6rz0cgHurAjOOFSSnaOFco/fPr/AQAA//82AGCKUSQBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
