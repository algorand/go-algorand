// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
