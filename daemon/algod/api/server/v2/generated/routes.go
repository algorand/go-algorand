// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
