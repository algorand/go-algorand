// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"WmxWsuQAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
