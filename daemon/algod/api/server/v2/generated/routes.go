// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"lJKdY/rg95f/LwAA///1Bvg7gBcBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
