// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryRun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryRun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryRun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
