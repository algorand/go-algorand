// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
