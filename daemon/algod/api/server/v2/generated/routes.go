// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/boxes/{box-name})
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, boxName string) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Path parameter "box-name" -------------
	var boxName string

	err = runtime.BindStyledParameter("simple", false, "box-name", ctx.Param("box-name"), &boxName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box-name: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, boxName)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/boxes/:box-name", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
