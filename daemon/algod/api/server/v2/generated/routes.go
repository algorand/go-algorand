// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/xQqt5dS8gAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
