// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys)
	router.POST("/v2/shutdown", wrapper.ShutdownNode)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9f3cUN7LoV9Gbt+cE2GmPAScbfA5nnwlJ1m8D4YCzu+9h7kbTXTOjuFvqSGqPJ1y+",
	"+z1VkvqnesaAIZCdv8DdalWpVL+rpHk9SVVRKgnSmsnx60nJNS/Agqa/eJqqStpEZPhXBibVorRCyclx",
	"eMeM1UIuJ9OJwKclt6vJdCJ5Ac0Y/H460fBrJTRkk2OrK5hOTLqCguPEdlPi6Hqmq2SpEj/FiZvi9PHk",
	"zZYXPMs0GDPE8keZb5iQaV5lwKzm0vAUXxm2FnbF7EoY5j9mQjIlgakFs6vOYLYQkGfmICzy1wr0prVK",
	"D3x8SW8aFBOtchji+Y0q5kJCwApqpOoNYVaxDBY0aMUtQwiIaxhoFTPAdbpiC6V3oOqQaOMLsiomxy8n",
	"BmQGmnYrBXEJevJqGlvMwoJOrCgiSzn11NZgqtwaRmNpTUtxCZLhVwfsSWUsmwPjkj3/7ht2//79B4h4",
	"wa2FzDPV6Coa6O01uM8nx5OMWwivI7gbA3GWPsE37PTxGNjwYWSjhbSwJMJ1eBS/iLBu83gOC6XhmpR0",
	"g2+UlG3470DLtNIaZLpJlho4bcqKy+FCnvsFmJWq8oyt+CVhywvSIP5bht86ibzkeYULE6lWJ/lSGcb9",
	"ujNY8Cq3LABmlcyR+3E2vz1MGFZqdSkyyKYo1OuVSFcs5cZNQePYWuQ5Eq0ykI0RJ766LbvfIQni9U70",
	"oAV9usRo1rWDEnBF7JukuTKQWLVD6wVFxmXG2nqqUYHm7XQgO1sBI+D4wulwop1E5s7zDbO0rxnjhnEW",
	"NN6UiQXbqIqtaXNycUHf+9Ug1QqGRKPN6ahntGtj5BsQI0K8uVI5cEnECwI4JJlciGWlwbD1CuzKq1YN",
	"plTSAFPzXyC1uO3/98WPT5nS7AkYw5fwjKcXDGSqsvE99kBjhuEXo3DDC7MseXoRtwq5KEQE5Sf8ShRV",
	"wWRVzEHjfgWFZhXTYCstxxByM+7gs4JfDYGe6UqmtLkN2I79R1YSpsz55oCdLljBrx4eTj06hvE8ZyXI",
	"TMgls1dy1PYj7N3oJVpVMruGqbS4YS01b0pIxUJAxupZtmDiwezCR8i3w6cx4C10wiSj6NRQdqAj4SrC",
	"Myi6+IaVfAktljlgP3nNRW+tugBZKzg239CrUsOlUJWpPxrBkUBv99qkspCUGhYiwmMvPDlQe7gxXr0W",
	"3iKnSlouJGSoeQlpZcFpolGcWgCjBnm+sXFbfM09Xaj+Xm7dx2vtIQ1KnKBFrB2+9WIYjxM6318jUmjD",
	"NmKZuMeD7RHLMzQQC5GT8fgFdyWQoTIk2h1CBHNixFJyW2k4Ppd38C+WsBeWy4zrDJ8U7tGTKrfihVji",
	"o9w9+kEtRfpCLEeIWeMadb3ps8L9g/PFlay9ivquPyh1UZXtBaWdEGa+YaePxzbZzXl9duu6s2dXQxc3",
	"PLNX9eaMAB6lR8lx4AVsNCBEni7on6sF8Qhf6N9iBEJu9LaQwkEfJj73z/ARSiVIUjq8LHORcqTQjCzc",
	"8esWJn/SsJgcT/73rImRZ+6tmfl5HcTuVtyCorSb27j8R7lKL94JdqlVCdoKt4o5zhPRUNNJCjqiPn+k",
	"//Cc4WvkBW6Da4BukTDoIKhWbJyhN+F0lNt6HEBejmKFcyAYGv6DuOqpBfalR7XZGQc1RqdvnTPC6IuA",
	"Ha7pW62Vfg9qQfh+O6Zu2HUwbe3oU5XBC8ttZd5pW7vzNpMFU2FoC4R0m4CCy+eqsowzqTJghgZPpr0F",
	"p9ymq6ocCSO/cW/PRIEzM8mlMpAqmZlmM2uNOp3k3NgxB+EHbqxT50JmxFUOYfzG2RFmAOT4vJegjVAy",
	"PvM/3MvY3ClSWprKMD8DM1VZKm0hG3KkcyrGYT2FqxqWWrTmLrWyKlU5cn1lYNfMY1Rqze+J5VbiCMSt",
	"9xJqL2a4OArIkJM2UVJ2kGgIsQ2RF2FUi7rtAGIEEdQC9ZfkXglDrNjgVUct04mxqiwhS7hNKll/N0am",
	"F270if2pGTtkLgzzyHPKgGUKELoNOHnM146yLnRcccM8HqzgF2jlS62WPkM3xBllJjFCppBs43yUnhc4",
	"qi0CO2Spp286UtqRs55w9Pg3ynSjTLBjF8YW/JZq8JmLjc4aD+MG1OFjsFzkplZ5dQDWQKFYrZ+eXXND",
	"0bu0+QZ5eCF04dIdZNtMeOYUauahuMC+EUuZMQ1rrrMw4mCgZ31WRWZwFQ9ZXDqFBjARR3RRQxOWpSEB",
	"4TM2B1FxdzkDh5yJZZPoBfJjIVKtuEsSIeHRqVWEhsuDaCg4YkfpCp+dH4cp5DJxOamIUXHvQ84qRBXt",
	"rYrPG7ZnVNDqHVmvgMJg1J49IrY3eYGxl4GxhZRK5UntEfRjo4Ge6UO6EOkFZAwZkgoDXv190cUJgbBb",
	"uKmmjgnXq42bdsXLEiRktw8YO5GMhMinZXumrgdcfmG3wb8iqFlF6SkuGS3y4FzGzFZIbr0nF4VptvOO",
	"KyK8Jyg3yXZA9kqOMBBfd4jp814u0UeJMU9/pdkjbuCro3pI29utndJdTm+LyRxW11Gn31MOn3cQFRnl",
	"Mxt1Zqp5ISiR3xo2Rd0RUlVDZ1HYA8bOSHq4RkpegsZYgBtn9H1iuRDLFZrSNAXIjs9l0sEkVYUHfKv5",
	"rxPM8+rw8D6ww9v9b4xFv8XnOpxM9L99yA6n7hWRiz1k55PzyWAmDYW6hIwttCpYm8/dVzun/V/1vOfy",
	"x4FqYgXfuKx7kE1mqsVCpMIRPVeo2Zaq535IRW9AI3pQzEEbJuyUlDlRlNw2ty+NQMbN5U2ED5FZ0WFD",
	"Y6I134RURpd3DIMrnuIqOSmdDVsjo9R8NrR6VpVJe4JI4awFsQuqkTsQ5GsOxI9fUwCFhcJEQ2D/gDCg",
	"v5Xl+Q6Mz3DMWGq4xcAHu926AXmiGFxHIZywUiEfCF+cCBnsXBg7QNLVYyyF8DWLRszSAft/qmIpJ4ku",
	"Kwu12680+dIUYyEEsrMBpvdeGgpBDgVIW1Pnzp3+wu/c8VwgDFvAOlT0cGCfHHfuOLFQxr63TPSY9eo0",
	"4lQQbxHDDZ2yFTer3Rqe5r3OJrbWw04fB4AkXsaQW/RmOsFoLN/cgApwEzEN3gdyfoTnDQqTcpLKVvXQ",
	"75/ZGAvFMJXgPv33iHf2PAQRA1usZC4kJIWSsIn2YQgJT+hl1JITi4x8TMI69m0/yOrg30OrC+c6u/m+",
	"9KXdbrHEs7qWeQOb35+3l0Vq103JD4W8ZJylOVo5ivWtrlJ7LjnF0D3XvccWITMwnlX5JgyJp3EiWRY/",
	"1bnkBmlYR9YHMQ92AZHU1ncAIbliquUSTM9RYguAc+lHCckqKSzBIr8zcRtWgmbzjYUDNxJ9gwXPKQn0",
	"G2jF5pXtql4q7zhfx5XuEQxTi3PJLcuBG8ueCHl2RdOFyCjwjAS7VvqipkLcs12CBCNMgsppuOzv3du/",
	"cbMKy8eBQdn4j11iFefvZ/NLbi1onOm/bv31+OVJ8v958tth8uDPs1evj97cvjN4eO/Nw4f/3X10/83D",
	"23/9U2ynAu6xMoXH/PSxd1ROH5PtaSpkA9wH03+o/GQhZBJlMgwoCiGpht3jLXYLLWhgoNssaKKw6+fS",
	"XklkpEuei4zbd2OHvoobyKKTjh7XdDail24Kax2oQF/FQd+LL/H5UthVNT9IVTHDME1zmc2WKqn/n3Eo",
	"lKR32YyXYoYB8Ozy7g7T+B76ikXUFRUCXWWmVfSJOKq+abETM+GMrp/KVUIxZngMCyEFvj8+lxm3fDbn",
	"RqRmVhnQj3jOZQoHS8WOmZ/yMbecQu9exmisMZGabzw2ZTXPRcou2vat4fexDMz5+Uuk+vn5K2Z73uzQ",
	"GnlQUcZ3AJK1sCtV2cRn3cbD9ybFQTO7BNA2qFPm53bb7LN6fv64/qNsmIkvGl/hqt0YZJMmNR3SBbiH",
	"T5X1CT6+Dn0xFYbAPxe8fCmkfcUSH8pSR97fVI6I/exlFBXrpoRO7LG1ItiaIxaW+Fxfsm1pJde4spYk",
	"qEVYZ8gVji31uF5r4Ktti32vVcaWV3JtRSpKbr13cI3q6bPONzjJLt6Lcpta9JnKMWCLSFEmc4OTOTcQ",
	"3Q7AN7gflXExLK4xGNkAyUVV3CWnqd3Yu3DzHFpZVuOLPlyTogvLdp2ZY6jFuQS0bIQ+oNGlSFu7rHx2",
	"XFw2OXGqilxHDncmaZGLQjlLdJNRAuHmcMlH84Sumhlbo5I5rjGDHJbc55aoTuqp7xf3hWmt+lzeYT8u",
	"FujvsyRWQ+LGqFS4hHswBCbAAFT8dxhzkQq79gwx3mihTSE4TcyeqjbDy+XbICnr9Imfm4L31t8Q9ZXi",
	"jTGnrQpgq4uybntBgLSsnqqZ1o1Nrk8+tMeEnpjQCDOZvm1TS9u9adrpveXbaaGGeqMRoGnTweS4bRj1",
	"TSdRdTTmPHRGMTdkDgMXJkZAVEvDOGgYbRnIgTybpKNVk4tYdHx+/tIAScuL8FnLo2C3xIJxubndShhp",
	"WKLP3fipKKkh8Pq4scKlspAshDY2IRc5ujwc9J0hm/8dDo2rng6pmGucFllc8xDYC9gkmcir+G57uH9/",
	"jGCf1q6VqeYXsCEDAzxdsTm3KQVeXfA4ZgtoV+7duuAf3IJ/4De23uvxEg5FwFphZNOB8Zlw1ZuYhJPb",
	"sqWDc678wZtKil8rYCIDafGV9un9jnDjAkPNdiC9I/VhP7EvEdfTx4uWFB5dyxdzkdRAizok6plejdEk",
	"OKyRYnxQbGGhtaeND1rO51vESm2Ig1BpS5yDDNmENy6Ls/JdtCPBw9YTPsFQrxwukWlGT+yQGx4rJp+E",
	"QwhoU4Oz7rQ/lfbrvrv28a5Q4x5wV/Mh5e7n4BoHXLGJ50ZFpqnkmkt3ngG/c2TyXxtw5ge/WitUoik3",
	"cadBmGSh1W8QV4oL3ItICcGTkpL/9PVBpN2mb+prA98crQr0beMxyr3PajmJ7LPPMXTD1REhJkZuRWBU",
	"JQ0uHZeOc93Zi07mIc7/7WzhzM3f8L/HeZBhzfl6zl2X54DoKeIUGAwxajufVrHwcdgFUzcLeN5jpwvX",
	"eDBtxgrXS1WCbip/w/7SMXY/a7HfZ8/yGaSi4Hk8FsmI+medalgmlsIdYKkMtE5I+IlYqYS0jov8KRPX",
	"bt6Q5nTBDqetM1h+NzJxKYyY50Aj7roRGIfS2urwJ3yCywNpV4aG37vG8FUlMw2ZXRlHWKMYRq5n9VGz",
	"2smfg10DSHZI4+4+YLcoeDTiEm4jFQt3rmdyfPcBZRTdH4cxjexPqm3TKxkpln96xRLnY4qe3Rxoh/ys",
	"B9G+voUG+A3GVdgWaXKfXkeWaKTXertlqeCSL2MnJM7PXxY7cHLf0m6S/9mji8zc2ThjtdowYePwwXLU",
	"TyNVBVR/Dg3f/FGgAFnFjCqQn5qDEg5omM4dtPNt4wGv8JJiyTI09bSqWx8/1nC2PLZqyqc85QV0yTrF",
	"uJ5qfKI5XOQV4kG8y8qAvowD0SMbHOym/5bdkkomBcpOdrupV7X4LxrnK8vzKFgbdFc/R7x96pbs4sBk",
	"lHZVh3a8pXbemYqVji+FVwjqp+c/eN1fKB1rlW8UnrcDGqwWcBkVyn5ppXY+aosQiBvzQf4x2mHuUs/c",
	"sjUwLqWy3EKgCeOsUBnkzPgGoxyWPN34Qoc5l4h3JjRQl44oqNOZM7PmyyVoqpBpsrSh0EqzDbMI80rk",
	"2a4Yws/xiMZGCo+/Z+lwmC1wyLoo65r9QP3jKbTQ7aWyGsyHKo+henUJ7w75o0WiUCikKRih33TnN8wf",
	"2X7NZbqKUohmaZ3Xi7TprriUkMePHJFx+J04pOC/qBGcCyHjr/os4AjTI0Oz5u4KA8gwf0wPUKNfQmI4",
	"7EhCKxilY2GWuw8p4aBIo8p0YiCttLCbFyjIPoIuxb+jaZ3va5WxAp6Bbjxv7/i5c7ReXzYKpjkk+b3i",
	"OXkF6GlQgtxSb9m3V7woc/Ce48Mv5n+B+18fZYf37/5l/vXhl4cpHH354PCQPzjidx/cvwv3vv7y6BDu",
	"Lr56ML+X3Tu6Nz+6d/TVlw/S+0d350dfPfjLF+GEokO0OSn4L2rWSE6enSZniGzDG7wUf4eNqzejQISG",
	"Gp5SMgEKLvLJcXj0f4Joosy27vbwTyfe/ExW1pbmeDZbr9cH7U9mSzoBkFhVpatZgDNs5Xt2ykBmLgyg",
	"QJPEF/mCxNUlB4XNKbtA755/++KMnTw7PWg00OR4cnhweHCX+qtKkLwUk+PJfXpEgraifZ9d3puFMtPs",
	"tQ+Q3uCbZSzpFfqO63Oiwzr01NmqlNf9rJ2akvHVmCmbu/QO863vMqOyl4vr0XbWCz7NWnf2NGorZKj8",
	"lUMvY52lsSp57LKhum4wfn640U2obw6TB69ef/n1m4hb8Kp3jPTe4eFHPjp6dIMQ2/opAvUJz3FDoL53",
	"w8G/+7Hgn0pKXSPzMyfcb6aTLz/e+k8lMgXPmTt42sSrXQQG3/0kL6Ray/AZKuWqKLjekMq1rapPy0zj",
	"sLjAdtNGvqQ1LsXQat1tVcA7nWrzTdjSKTP1Ib5SC4Wmgy6EyQCdXuO6sTPQ01YTsC9Jgju1+OTkX5Rl",
	"eHLyL9dvH70sowXenUXpqoDvwUba1h9tTmrp/ST1wfSTvV/k87kg5n116v7ww/7wwx/o8MNHNfBXdVaX",
	"M6lkIqk/5RJYK37aW/z3t/g1u1ayPqO6g3UH50gbo914C9QObWavqaDedu0H1pWuHNllRj/hW8S2tJpp",
	"VYQGCMUWYNOVvzuklwcZu2FoqyuwrYDx3qbrj3eby7Sz4rCh+yts/BU2H065X4Pw76EYH/GMPYdfKzCW",
	"Jewp5RhJCML9XR/UTnzYtUWNztHh0We5mKdKAoMrYaiT1PHfhzWiH3pzPoxFpno4USecvGkf9ajtaw7Z",
	"EvTMHejbZl7dgcDJjYYy+0Ocn8Ehzt/bO745cegtXEP7eidgThQa0Qh9ncP+0V6yuVTGjtce2C2lmQYJ",
	"69v+rh03baRxlqkmqHPJcy+0IfVTu8f97NJzP2mnR/vvsNmZV0Iv8+fmuvqfqbOnzLiFKXq/P/M8bz2j",
	"9E1I4B28e/rpWs7vAiD0GZGD45MVqPYvILTdOhp0s2/ssWMZU1+pUh+RXcDoRcXuJGFbVXm+u3t4GHON",
	"Bzi7UpDHmJTuWiU5XEI+3OoxJDqt2W+X/zrrHvdsN023S1sRrgu3YNd91KP3obb7t98Ou8dKfmHZmgt/",
	"ZVIr9rPKt92EC4BdrtD3hpCtGb80NsEpt98pfbMxzOdwzwKaJL40dEGPFpfcwuRV0GpmVdlMreW44qLe",
	"cJ77zivqhaorelaxMEGtqQ5YCFnyTbiSmHG6o19VtntTeDj307tgxt8HP4elkASApJyguBZD3spJ+Xvn",
	"hkrwhcfsqbumr6f3otewOhzjcv8h4uHrXzW3dQ/r82Oj3lq4L/MGvbX9pZ37Szv3l3buL+38/C7t/NwS",
	"/JG7vT9K0qAbH7Z0eBMUub9n6HUlC6UTSjEkZKRDkn42Wrr/Jxf+In7ucxNWoeIAHn5swSkdP5EPl5ou",
	"HF/s8ieiw8WVooChL4CgvlP6WkWBJtNulXNRK2lF3vJDa0v26WXY9zZ6b6P3Nnpvoz9/G/3RiuCdWk8S",
	"IsvQJxDrEmD7NoGb8y9adsdbfbS5KFZbKxX91p6QvOglQvm6lSDxZhmMfaSyzRbqXSVzIQnP19Efg3Ev",
	"p7s9M/Ql5hsLdWPTsBcLbcFcK56laIesClehDXyIN/9xiavfTw2wphf4xHe9d2ixVwDvrQAeBZ6nHx3s",
	"XVTuM/VeFA7owBEK0BJk4kU4matsEy4m0Hxtr2RUOcyaSySi6bHBbXw3mybbX066v5x0fznp/nLS/eWk",
	"f5jmgd59HfWi6Xdg+usesUk3cKrl0z7KsjPLtj84sj84sj848s4HR67Rhrjf7/1BoT/UQaE/UL/1vj/5",
	"5k8MHWz1tWav7ZXIdl8H8Pn+DBm7qV8hYx/qR8h+558gizivQ6v4Nrcy9JglXhFGtnvL09d/vs7R6/8U",
	"R3X/c6j7n0Pd/xzq/udQ9z+Huv851D/Wz6H+PtXNTyER++GOm26tMz9Vln1HBuYGA5f6/rCYY+IwCpfU",
	"kQ9ZX0/38hV6SnTdqXcvmzvXjmezXKU8XyljZxN0/rr3sbVfvqrPBrwO7ls4I/Dm1Zv/CQAA///JL2vw",
	"25QAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
