// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryRun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryRun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryRun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
