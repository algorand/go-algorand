// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetProofForLightBlockHeader(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	StateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProofForLightBlockHeader converts echo context to params.
func (w *ServerInterfaceWrapper) GetProofForLightBlockHeader(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProofForLightBlockHeader(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetProofForLightBlockHeader, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.StateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
