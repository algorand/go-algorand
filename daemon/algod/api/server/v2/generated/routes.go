// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAAA///QLTg0r9cAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
