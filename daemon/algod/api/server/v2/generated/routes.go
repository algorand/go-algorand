// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get the proof over a block for a given round
	// (GET /v2/LightBlockHeader/proof/{round})
	LightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// get a state proof for a given round
	// (GET /v2/stateproofs/{round})
	StateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// LightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) LightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LightBlockHeaderProof(ctx, round)
	return err
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/LightBlockHeader/proof/:round", wrapper.LightBlockHeaderProof, m...)
	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.StateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"sgnwJAEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
