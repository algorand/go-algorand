// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"SsnOMVPi+8v/FwAA///mV+UM0eoAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
