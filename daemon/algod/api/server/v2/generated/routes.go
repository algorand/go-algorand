// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9e3fbOJIo/lXw0+45Sbyi5Lx6Jj6nz/7cST+8k6RzYvfs7LZzuyGyJGFMAhwAtKXO",
	"9Xe/BwWABElQkh9xOt3+K7GIR6FQKBTq+XGUiqIUHLhWo4OPo5JKWoAGiX/RNBUV1wnLzF8ZqFSyUjPB",
	"Rwf+G1FaMr4YjUfM/FpSvRyNR5wW0LQx/ccjCf+qmIRsdKBlBeORSpdQUDOwXpemdT3SKlmIxA1xaIc4",
	"ejW63PCBZpkEpfpQ/sjzNWE8zasMiJaUK5qaT4pcML0keskUcZ0J40RwIGJO9LLVmMwZ5Jma+EX+qwK5",
	"DlbpJh9e0mUDYiJFDn04X4pixjh4qKAGqt4QogXJYI6NllQTM4OB1TfUgiigMl2SuZBbQLVAhPACr4rR",
	"wc8jBTwDibuVAjvH/84lwG+QaCoXoEcfxrHFzTXIRLMisrQjh30Jqsq1ItgW17hg58CJ6TUhbyqlyQwI",
	"5eT9dy/J06dPX5iFFFRryByRDa6qmT1ck+0+OhhlVIP/3Kc1mi+EpDxL6vbvv3uJ8x+7Be7aiioF8cNy",
	"aL6Qo1dDC/AdIyTEuIYF7kOL+k2PyKFofp7BXEjYcU9s41vdlHD+z7orKdXpshSM68i+EPxK7OcoDwu6",
	"b+JhNQCt9qXBlDSD/ryfvPjw8fH48f7lv/18mPyv+/P508sdl/+yHncLBqIN00pK4Ok6WUigeFqWlPfx",
	"8d7Rg1qKKs/Ikp7j5tMCWb3rS0xfyzrPaV4ZOmGpFIf5QihCHRllMKdVromfmFQ8N2zKjOaonTBFSinO",
	"WQbZ2HDfiyVLlySlyg6B7cgFy3NDg5WCbIjW4qvbcJguQ5QYuK6FD1zQ7xcZzbq2YAJWyA2SNBcKEi22",
	"XE/+xqE8I+GF0txV6mqXFTlZAsHJzQd72SLuuKHpPF8TjfuaEaoIJf5qGhM2J2tRkQvcnJydYX+3GoO1",
	"ghik4ea07lFzeIfQ10NGBHkzIXKgHJHnz10fZXzOFpUERS6WoJfuzpOgSsEVEDH7J6TabPt/Hf/4lghJ",
	"3oBSdAHvaHpGgKciG95jN2nsBv+nEmbDC7UoaXoWv65zVrAIyG/oihVVQXhVzECa/fL3gxZEgq4kHwLI",
	"jriFzgq66k96Iiue4uY207YENUNKTJU5XU/I0ZwUdPX1/tiBowjNc1ICzxhfEL3ig0KamXs7eIkUFc92",
	"kGG02bDg1lQlpGzOICP1KBsgcdNsg4fxq8HTSFYBOH6QQXDqWbaAw2EVoRlzdM0XUtIFBCQzIT85zoVf",
	"tTgDXjM4Mlvjp1LCOROVqjsNwIhTbxavudCQlBLmLEJjxw4dhnvYNo69Fk7ASQXXlHHIDOdFoIUGy4kG",
	"YQom3PyY6V/RM6rgq2dDF3jzdcfdn4vurm/c8Z12Gxsl9khG7kXz1R3YuNjU6r/D4y+cW7FFYn/ubSRb",
	"nJirZM5yvGb+afbPo6FSyARaiPAXj2ILTnUl4eCU75m/SEKONeUZlZn5pbA/valyzY7ZwvyU259eiwVL",
	"j9liAJk1rNHXFHYr7D9mvDg71qvoo+G1EGdVGS4obb1KZ2ty9Gpok+2YVyXMw/opG74qTlb+pXHVHnpV",
	"b+QAkIO4K6lpeAZrCQZams7xn9Uc6YnO5W/mn7LMYzg1BOwuWlQKOGXBYVnmLKUGe+/dZ/PVnH6wzwPa",
	"tJjiTXrwMYCtlKIEqZkdlJZlkouU5onSVONI/y5hPjoY/du00apMbXc1DSZ/bXodYycjiFrhJqFleYUx",
	"3hmBRm3gEoYz4yfkD5bfoSjEuN09Q0PM8N4czinXk+Yh0mIE9cn92c3U4NvKMBbfnYfVIMKJbTgDZeXa",
	"pgXJqKYILG0I3quZUNgM2hrKvxzX8xjp+Da2FKXxpciNPLF1M0zjH1zbcB/N7zt1/jL2MMRtd/fwVbJ1",
	"35z2I9yxa23WRoTacTcspF7DhaSlhd99sdcE4/i4sI0srDfkFzse5SjMAa0Hm41QXZvYtxJkFBLcvQ4M",
	"3+QiPbuFAzcz4/TpHocnS6AZSCSvgLAdwcavI+z4A/bDIwkyIrP+iP+hOTGfDbVS7d9j5i1qjpciItAc",
	"Z+YJZwVDO5NpgE9LQQr7aiPmtXUlKF82k/cOqUXLLof0W/tQJNjDL8IsvVEDHc6EvB69dAiBk0a5RagZ",
	"NTgu487OYtOqTBx+Ig9k26AzUGNP6MtJIYa6w8dw1cLCsaafAAvKjHobWGgPdNtYEEXJcriF87qkatlf",
	"hHmxPH1Cjn84fP74yS9Pnn9lRO5SioWkBZmtNSjy0AmKROl1Do/6K0OJrcp1fPSvnnmVSHvcrRhCgOux",
	"dzlRJ2A4g8UYsQpAA90ruZbVbYiNIKWQkUcsko4WqciTc5CKiYg+8p1rQVwLw4fsQ7rzu4WWXFBFzNyo",
	"X6l4BnISw7xecQSNaSjUtovCDn2y4g1u3IBUSrru7YBdb2R1bt5d9qSNfP9cV6QEmegVJxnMqkVLKJpL",
	"URBKMuyIDPGtyMDI3JW6BS7QDNYAYzYiBIHORKUJJVxk5kCbxnH+MGCcQK0oKnN1yHL00t4/MzDP3ZRW",
	"i6Um5p0oYlvbdExoajclwbtCDehyaiWcbWWns4rvXALN1mQGwImYOYWJU+XgIinqWbU3oTruFJFJW3CV",
	"UqSglJGcrTi2FTTfzu6y3oAnBBwBrmchSpA5ldcEVgtN8y2AYpsYuLU44bRMfah3m37TBnYnD7eRSiD+",
	"aBrZxZzuHDQMoXBHnJyDRG3LJ90/P8l1t68qB2yh7gY+YQU+ATjlQkEqeKaig+VU6WTbsTWNWmKCWUFw",
	"UmInFQceeAe+pkpbnRvjGYqMlt3gPPaBaKYYBnjwRjEj/91fJv2xU8MnuapUfbOoqiyF1JDF1sBhtWGu",
	"t7Cq5xLzYOz6+tKCVAq2jTyEpWB8hyy7EosgqusHtFNK9xeH9jVzD6yjqGwB0SBiEyDHvlWA3dAeNACI",
	"eV/UPZFwmOpQTm2EGo+UFmVpzp9OKl73G0LTsW19qH9q2vaJi+qGr2cCzOzaw+Qgv7CYtZbAJTWyHY5M",
	"Cnpm7iaU1KxysA+zOYyJYjyFZBPlm2N5bFqFR2DLIR0Qkp2vQTBb53B06DdKdINEsGUXhhY8ILG/o1Kz",
	"lJUoSfwN1rf+3O9OEH35kww0ZTlkJPiADBx5b92fWG1vd8zrCVo7CaF98HtSaGQ5OVN4YbSBP4M16uDe",
	"WTPiSWB8vAVJMTKqOd2UEwTUGyfMhRw2gRVNdb4215xewppcgASiqlnBtLZ24bYgqUWZhANEH64bZnSq",
	"A2uC8zuwiy7jGIcKltffivHIii2b4TvpCC4tdDiBqRQi30HH2UNGFIKddKCkFGbXmXND8LZqT0ktIJ0Q",
	"g3qjmnk+UC004wrI/4iKpJSjAFZpqG8EIZHN4vVrZjAXWD0ns5JOgyHIoQArV+KXvb3uwvf23J4zReZw",
	"4X13TMMuOvb28JX0TijdOly38OI1x+0owtvxRW8uCifDdXnKZOvr3o28y06+6wzuJ8UzpZQjXLP8GzOA",
	"zslc7bL2kEaWVC23rx3H3UmhEQwdW7fddynE/JYURHHbLT5OnDnWtCLzilugKuWeI2hA8QoNMR/X9nnr",
	"l2ttt1WBvfH/S+oUTqNxY3S1DcyF3Hz+EBEpWbaK2dYzWMU2xZ0xfE49MG+PtYKovQU5s5hH3GtAnuVu",
	"aR3eQQowh1otWWmGbFwB1hpaboT/5+F/Hvx8mPwvTX7bT178x/TDx2eXj/Z6Pz65/Prr/9v+6enl14/+",
	"899jorXSbBbX6/1gEC3mxPH4FT/iVjM/F9I+yNZOzhPzu4dbS4AMSr2M+e2VEhTyRut/V+pls6kAHSVK",
	"KcU58DFhE5h0eWy2AOW1STnQOfqP4aNC7GJuq8+DpTdPHAHWw4XsxMhi9IO2K6RNPM3m1ZGvb0F6sQMR",
	"2canf60r+1XMQ6dHd1DUWmko+gov2/WXAXH/vReWe4dK8JxxSArBYR3182cc3uDHWG973w10RsljqG/3",
	"MdGCvwNWe55dNvOm+MXdDhj8u9oF8xY2vztuR9cZunuirgbyklCS5gw1OYIrLatUn3KKb8WAXCN2Ev8C",
	"HtYevPRN4uqKiDbBDXXKqTI4rF+QUR34HCJ31ncAXomgqsUClO5IzXOAU+5aMU4qzjTOVZj9SuyGlSDR",
	"WDGxLQu6JnOao7LjN5CCzCrdliPx1lOa5blTvJppiJifcqoND1KavGH8ZIXDeecvTzMc9IWQZzUW4lfU",
	"AjgoppI43//efkX275a/dFcBhgjYz57f3DXf97DHfKYc5Eev3Bvr6BUK0o3KtQf7nenhCsaTKJEZwahg",
	"HF1vO7RFHprngCegR43y1u36KdcrbgjpnOYsM8LTdcihy+J6Z9Gejg7VtDaio1bxa/0Qs4cvRFLS9AzN",
	"oaMF08tqNklFMfVvy+lC1O/MaUahEBy/ZVNasqkqIZ2eP94i6N6AX5EIu7ocjxzXUbeuiXEDxxbUnbNW",
	"aPq/tSAPvv/2hEzdTqkH1oHSDh14vkXUAc71pWWxMou3AUDWg/SUn/JXMGecme8Hpzyjmk5nVLFUTSsF",
	"8huaU57CZCHIgfemeUU1PeU9Fj8Yo4eORA6asprlLCVn4VXcHE0bd9Ef4fT0Z0Mgp6cfeuaP/sXppoqe",
	"UTtBcsH0UlQ6cY7liYQLKrMI6Kp2LMaRbVjIplnHxI1tKdI5rrvx46yalqXq+hn2l1+WuVl+QIaKYCfr",
	"naW0kJ4JGs5oocH9fSvcm0vSCx+VUClQ5NeClj8zrj+Q5LTa338K5LAsG9fFXx2vMTS5LqGlOLqWH2RX",
	"aYQLtwIVrLSkSUkXoKLL10BL3H28qAtUUeY5wW4tt0HvPIBDNQvw+BjeAAvHlV27cHHHtpePEIwvAT/h",
	"FmIbw50azf919yvwULz2dnW8HHu7VOllYs52dFXKkLjfmTpwaGF4sjfHKLbg5hC4GKsZkHQJ6RlkGO4B",
	"RanX41Z3b/FzN5xnHUzZsCjrwYW++6hjmwGpyow6GYDyddeJWoHW3nP8PZzB+kQ0rv9X8Zpu+/KqoYOK",
	"lBpcRoZYw2PrxuhuvrMeG0hpWZJFLmbudNdkcVDThe8zfJDtDXkLhzhGFC1X2CFEUBlBhCX+ARRcY6GN",
	"m+2NDkBskUbImdn7L6Ls8TcAcU0a2c3ZgcM1oZ+v/V4ARlqKC0VmVEFGhAsS7LlAV4ouYEADFSo7d/Sc",
	"bSlIcZBtt1/0vhPz7rXWu3WiINvGiVlzlF7AfDEEg9rCjvXfz2T16biCCcHYf4ewWY7CUu14YFkPlS2l",
	"sw1mHgItTsYgeSN2eDDaGAnlmyVVPn4Rwzz9id5JEviETuKbgm6OAsN1EMtZh9R4zts9rXH1rQ2uKVQT",
	"ZBPqbncImBmPnC9VbDsERzEogxwWduG2sScUB9oDFWyQgePH+TxnHEgSs4FTpUTKbABqc9m4OcBIyXuE",
	"WA0U2XmEGBkHYKOdCAcmb0V4NvniKkByYGhYon5stDAFf0PcIdB6ORnBR5SGkTM+4J/mOQB1jhP1LdZx",
	"38FhCONjYtjcOc0Nm3Oq1GaQgLsFwuvDltzpLZWPhoTaDQpAe71caU32QrrOakLJyQMdF+s2QLxZoIht",
	"gUJ8uQdwjauhG3WXqQcu8SFcPQwu3WsB0NFHNPlV3Ptv6zutfTf3b7KGpY+baEjvoBmj/SH6ie7SAP76",
	"6uA6GOZd97qOPtXbFsx2IE4gRcVYsTkjfQVpXw2rIAeUi5OWBJGcxdTmRrwHZLfHvlvwficP2dxI248C",
	"s7iEBVMaGgWWuZW8RvaujV4U43eFmA+vTpdybtb3XoiaR2NHZ8QLl3nnKzgXGpI5k0onqP2LLsE0+k7h",
	"u/I70zQuKLQN7zaVBcvivAGnPYN1krG8itOrm/dvr8y0b2tVjKpmZ7BGcRBouiQzTL0SdcfZMLX12Nq4",
	"4Nd2wa/pra13t9NgmpqJpSGX9hxfyLnocN5N7CBCgDHi6O/aIEo3MEi8+F9BrmMBOYHQYA9nZhpONikg",
	"e4cp82NveigFUAzfUXakDWtR30opZKhG7vlpYchEo+X1On2f8iwQ64Fn6GFs9YpGLrGRbf04BMzQ4QQZ",
	"dCaDVQqQxXzJjNAVxRKmrrDR9rHQ/fEoCHPaVaa8gqi2q4y0u0CzRfIYDqtqxYZupkmGHiXm8W7wHyTY",
	"66J9gKPRsmTZqqPctaMOPv7plTQ4Pgy5s3o8q26wLRgIFLkxd2MJXhltD2jwVrEZhXi4tslOmDnpBI8H",
	"7D2ciimfD6+PKMOoMGnTNlydAM3/Buu/m7a4nNHleHQzXXAM127ELbh+V29vFM9o5LS6wRYTuCLKaVlK",
	"cU7zxGnMh0hTinNHmtjcK9jv+OKK62VPvj18/c6BfzkepTlQmdSC3+CqsF35xazKMDUhBw6Iz7dluL5/",
	"gdmHQbD5dcxzqGW/WILLbRS8LQwXc8Rlj1djQQmOotO6z+O+Flt16M7YY5e4wegDZW3zaTSR1uTTNvPQ",
	"c8pyrwL00A74ReDidkvoEeUK4QA3NhcFVr/kVtlN73THT0dDXVt4UjjXhuxLhU0wpojgXTc78yBAzSKS",
	"akHXhoKsgqfPnHhVJOb4JSpnaVxdzGfKEAe3xkDTmGDjgaeFGbFiA7ZlXrFgLNNM7aC26AAZzBFFpk8a",
	"MoS7mXCZYSvO/lUBYRlwbT5JPJWdg4rZOJzhoH+dGtmhP5cb2BobmuFvImOESU66Nx4CsVnACE2PPXBf",
	"1QoQv9BauWZ+CKwrV/BgCGfsXYkbvA8cfThqtm5gy7YJMUzk2ud/hjBs0q/tWWS9KsLlqRmYI5oVlqlk",
	"LsVvEH+1o7IjEovgJkJhCntPIiFdXRZT6+qa5LbN7IPbPSTdhDrFttfFANXjzgd2Rszg4ZXtlNuttkka",
	"W74+cYIJ/fOmdvyGYBzMPZ/GnF7MaCy9iREyDEyHjUW7ZRbQgvjOHvfOgmHuLpydBMbxui2zUXolyCZM",
	"qB8Rfk2BwU67s6jQSAZItaFMMLamzFyJyDAVv6Dc5vo0/exRcr0VWFWm6XUhJMbYqrgFI4OUFTSPSw4Z",
	"Yr8dk5yxBbOZLisFQSpFN5BNEWypyKWjtD4DDWqO5mR/HKRFcruRsXOm2CwHbPHYtphRhZy8VivWXczy",
	"gOulwuZPdmi+rHgmIdNLZRGrBKmFOnze1Ha4GegLAE72sd3jF+QhWiAVO4dHBovufh4dPH6BKnT7x37s",
	"AnApbTdxkwzZyX87dhKnYzTB2jEM43ajTqIRozYP+TDj2nCabNddzhK2dLxu+1kqKKcLiLu+FFtgsn1x",
	"N1Et2sELz2wSXaWlWBOm4/ODpoY/DfjxGvZnwSCpKAqmC2enUqIw9NTkSbST+uFsRl6X6sjD5T+iubf0",
	"1q7OI/JuVeD2foutGo3yb2kBbbSOCbWB1TlrHDEcQ5yQI5+eAXM/1SmfLG7MXGbpKOagX8aclJJxjQ+L",
	"Ss+Tv5J0SSVNDfubDIGbzL56Fsl31U5xw68G+J3jXYICeR5HvRwgey9DuL7kIRc8KQxHyR41fvPBqRy0",
	"S8c9AD1H7zqAbh56V6HMjJIMklvVIjcacOobER7fMOANSbFez5Xo8coru3PKrGScPGhlduin96+dlFEI",
	"GUvW0xx3J3FI0JLBOTojxjfJjHnDvZD5TrtwE+g/rx3Ji5yBWObPcuwh8E3F8uzvTRxQJ2WgpDxdRk0M",
	"M9PxlyZpcb1ke46juWGWlHPIo8PZO/MXf7dGbv9/il3nKRjfsW03FaBdbmdxDeBtMD1QfkKDXqZzM0GI",
	"1XZgRO1Jmy9ERnCeJhFJQ2X97IZBWrR/VaB0LBATP1g/HtTvmHeBzcpVG68m5HtbdGQJpJUnAaVZVlS5",
	"jbmHbAHSKR6rMhc0GxMzzsm3h6+JndX2scnhbVawBQpz7VV03vVB1qLdPEJ9qtG4z/ru42x2ojWrVhrT",
	"lihNizIWjmRanPgGGPMU6jpRzAuxMyGvrIStvPxmJzH0MGeyMJJpPZrl8UgT5j9a03SJomuLmwyT/O7p",
	"7DxVqiBPe51Jtk48hOfOwO0y2tmEdmMizPvigilbawLOoR0BVYcDuqeTj4hqL09WnFtKifLoTeGq10G7",
	"B866J3h1aBSyDuKvKLgoUckUrprd7xh7RTN5dFMF9hK020jxOp+qryGUUi44SzGPRlDdogbZ1a3YxVaw",
	"Q8qRrjLKH3F3QiOHK5qgsHYOc1gcTFnoGaFDXF9ZGXw1m2qpw/6psUDCkmqyAK0cZ4Ns7JNQOn0J4wpc",
	"IiksYRLwSSFb9hfkkFGTXlKrfq9IRhgPMSAAf2e+vXXPI3QRPmMcBSGHNueNbDUamFZfG+mJabIQoNx6",
	"2ukW1M+mzwRTDmSw+jDxafhxDGu+MMu2trr+UIfecucsZabtS9OWWB/S+ueW06md9LAs3aRRx7F6h2Np",
	"NAcRHLHAJF4FHiC3Hj8cbQO5bTS5431qCA3O0WAHJd7DPcKoM5J2Uguf07xybibokGIdl6Ixs4xHwHjN",
	"ODRFIiIXRBq9EnBj8LwO9FOppNqKgDvxtBOgOVrpYgxNaaeivelQnQ1GlOAa/RzD29gkUx1gHHWDRnCj",
	"fF3XpjDUHQgTL7EojkNkPzUqSlVOiMrQibyTLDXGOAzj9mmG2xdA/xj0ZSLbXUtqT85VbqKh6MBUxOTN",
	"b1eQVtYILZT3KScphtsH90VUo8mUeTwVszzi3feq/hhkIEaH/9ka/43lzRpGibMSX9nrzJuEseOVBdb2",
	"SD1x0xBTotgi2R0TyMxvjo5m6utRWNP/VkksF4s2IHec32YTewn3KMZYruxk2PYftCUdfBDkru6Bg95/",
	"V/CrM7fOgKdnkNWH2ovNmjeG/D3TQfdkql2UkKakSUnS5wk2x3hsBOteYHOb28J/UdXOkEuB9Sgwn3u9",
	"dxPJegIujr0Rod5XpQ/Q37wjHCkpc7a7hln0MescoPsu6bs40zUb3F2EcyvGQWIr6SV93EwhPbfyIDTC",
	"5uab7J6k4LA2jKK5BjOrL4C71OptF8OdHZ3mc0g1O9/ixv/fRlhuXMTHXpy29SgCr35WO874+pBXlPIb",
	"gDZ52W+EJ8iEcmNwhtw+z2D9QJEWNUSTBY49oV4n+hUxgFliEkMiQsUMD/b973TBTNWUgVjwhj7bHZoE",
	"XYNZmoOglGvO5UmS0DBQZcOU5yL2gNhpLtP1SuFb6AMy5Onfz5M6fHu9wrS0qs6wXxeADPw4zDuxm8Pv",
	"wkXfYtBFrfLycbig/G8+wsrOYguLNnmkUcF4QWXmW0QlZi+MJwPeVl3/ZesmzuJAz+uZWeOW0XfhjeSu",
	"QOebNBeK8UUy5MHU9oSozQgPlLX3NDEDCNccpMsfr33d1kQL78axCY5NqHBVhq6DBDWYidECNxi//b4J",
	"UMeEXdRW7XW2rHCBREJBDXQyCCMfnnMTsl/a795n1Qd3dNKjRcb19JpsjQP3DjlM9ZAYUv2cuNtyuy/s",
	"dZ4qjHNbnkPFYsq5QWWoxCqlyKrUXtDhwQD/pNs5Y8MGVhKV8tP+KnsCW45ZTF4HkQVnsJ5aoSldUt6k",
	"k2kfa5tg0q4hiMvs7PatvuLiAmu+sAtY3Aqcn/MlNB6VQuTJgNbqqB8a3z0DZyw9g4yYu8ObsgcyNZOH",
	"qCypzRIXy7UPBS9L4JA9mhBi3lJFqdfeQtFODdeZnD/Qm+Zf4axZZbNVuEfa5JTHvTBsHewb8jc/zGau",
	"psAwvxtOZQfZEnu+GgjLl/Qikrd815JrEZtBN5d0Q1QWipiUcs1AxJ3Od/+hFiH9MOhgy/vnrPWqs8mP",
	"OnYCIeGWX3eBgvSKr7t+OMWuy8N1IFerFPTXufMGtHA7gPtdEN+oJvrIHdYo6NkuGoV4ihbTHVUaFiGY",
	"34ggqOTXx78SCXNXlH9vDyfY2xu7pr8+aX82r6+9vejJvDNlRquym5s3RjF/H7IrW9vpgAtDZz8qlmfb",
	"CKPlkNJkIEWXi1+c685nyYH6i30i94+qSwd5FTVqdxMQMZG1tiYPpgpcTXbwMnHdIj4leNmklWR6jRFF",
	"/kXFfonG3X9fK2FcudDaB925QNvS884jqlHZNNXCvxe24F9h7npUYmss0vDtihZlDu6gfP1g9hd4+tdn",
	"2f7Tx3+Z/XX/+X4Kz56/2N+nL57Rxy+ePoYnf33+bB8ez796MXuSPXn2ZPbsybOvnr9Inz57PHv21Yu/",
	"PPClui2gTRnsf2Ci4OTw3VFyYoBtcEJLVtdmMWTsk47SFE+ieZPkowP/0//vT9gkFUUzvP915NzjRkut",
	"S3UwnV5cXEzCLtMFvtESLap0OfXz9GtivDuqXXdsyAXuqPXKMKSAm+pI4RC/vf/2+IQcvjuaNAQzOhjt",
	"T/YnjzG3dwmclmx0MHqKP+HpWeK+Tx2xjQ4+Xo5H0yXQHBO+mz8K0JKl/pO6oIsFyInLvmp+On8y9Zb/",
	"6Uf3Pr00oy5isVbWCSlSw7hJ3uB0XWhPsk5GrfReymWbGtdJ35z4yDP0DbFPPsPaamQdZU2ClyCw3wdG",
	"2Ujxg58jybDnbFHJTjWpWpvv8kIyRf7r+Me3REjyxurc39H0LPS/iJVld6wsVpXdeWkUalG2TZqNpj9W",
	"dyaW3RVnNvscUGqtKmo4kZYVhJA0fNXwyv3kxYePz/96OdoBENRbuqq9v9I8/9WW+4IVKn98CJkLERhH",
	"klGhUDduVA/YodmmMdpk669h1tG6TdsT6FcuOPw6tA0OsOg+0Dw3DQWH2B586JS/f7K//wnqbI9bo3iS",
	"+KwFu5/d/kI76Tpua9m9YXtI+IZmmBMSlLZLe3xrS7vlJW1dyhFHU4K5AYi94S7Ho+e3uFd3vyDDg2hO",
	"sGUQD9W/VX7iZ1xccN/SSDdVUVC5RtklSF8bSqmXg7fXNEyyN/3YUjRnn/Jue6CGOGIvMakN6cVER1i7",
	"DFZM6Ue1tt4mGA87HL0auhKDN/X97fhJb8fD9pa04r9jwLQIbyNMPfvQTa+nvndSJz36tdKPB1mErpE7",
	"55NmZ+08zQYrR+7A9u5xN1R1c0AICeCt5ZF27sXw2Fi/GUyw2mO1XTZ59OrWZZa7vgff0NxshBF3fcSf",
	"7HL2e9nlzyS79G/5zdIMpmKbfvRJIj61BBO+8eyBbB5xWyUWl35jUFbBNBv3UsqnllL6+WliYDRZRz6f",
	"ZIIwLJsENleps9FKVnilRDtfqCjyJ0bWoOxhIB2SOvAYbJU3HM/6g0oaniPfyxh/ZhnD+n9tkDJa2Zuc",
	"s+CwoAFBAe6gmknLWWm29nQ4Jgrr/JufSsmEZHo9JoyTDAxXQiuTkBio2pTydo4pwPG/bw7/ge6Kbw7/",
	"Qb4m++NaeME4nsj01iGkLYR8DzpSav6b9WF9H28URn43N/xJjaSBUvBa+ARMiLSCrr4eQtnK2qJi8lFB",
	"V6ONosD4yxHXbiq1dCLw+lTkimnaUvKu9EvbDUcRWNFU52tClRWh0V8Ui4z77EmdsujdGv2xGJUNM/rK",
	"ErFIo6t6AkXCnHv18QfKBg9RqctShmVctksGPWREIbiemHW/u1/s7vblQlIKc6YZhtE394m/q1pANvUF",
	"HLgDTo4T8j+iQgcJWz4LYikgcQZ0CPVzOi/tIIdrjsXLauzs7XUXvrfn9pwpMocL5KCUY8MuOvb2/gAi",
	"66rOvEcJFzzhWN3pHEjgVXUvt/6u5dbn+0+/2NUcgzxnKZATKEohqWT5mvzE61QlNxPLa55T8SB5zEb+",
	"0/OubqToQHy/kX2zrXseE6YbybAVbBO84esifC5N1bjJ+26e0Jhiwgc5q7HPf47OYtYIavdj3MuOPokJ",
	"6YE94Zs1KhO3yuVfiFlu51RHkXstvjef+gaI+ly8vxufi92Y6bP9Z3cHQbgLb4Um36G+6hOz9E+qO4iT",
	"VcBsrmx+8CqnNmtxwWsbmYo5oWOXnhLzJa5JHVxi+IllhDZBfZ9rmBl25Re/YwX5DoV2I3TZRe89X7jn",
	"CzfiC12CajgChmir6UfU1YfsoHckvzEt/0A2vsDgIUXhLR6CzEGnSxu63g2liLAVnzFtmKdsyit+ywY4",
	"BDqSVxXX4sIFMN/1jkFk2PEH671/OR6lICPE96PPoWI+szmGAtbZ8Hz6fMwhy3xG2TqZrEu5zZT3U3aZ",
	"UojZxStB+bKZvB/agWi5DaPdPYKvhuAeU/vW5fa1x8st4ktXfAS3JUnIWxSH8ID7ZHB/RLXHp7yRP/WC",
	"3goO1ufFSKyWFu9NkLW4gBU4ECk+ct4aHl2J1rjo0DY6ftQrll1O69QuQ0LFO2ywRahobmrW1D1sq1do",
	"WQKV6tqX9HZz2ElnxqNXoaNEKxNNnYMmAorByxUtif+xixnxj2uta9/AS6qW8Zhg3KB1iYn7TSsyr7jd",
	"qrrGEHrNWEuG2aJxra42/EDMD075HlFVgb3x/0v6/PGTX548/2o0rlfsGhhsNJ8/RGJWWbaKpmuAlc86",
	"E9KT0xnioXqgSEnXg1leBhImvQF5lvtS3W3jCCnAXERqycrPUXqczeL1Wn4wiBZzUmdRPuLf1HznHCSb",
	"Y9Gh+jzdcRYOCZBBqZcbw99tzaRSL5tNBVfVjymXZqSU4hz4mLAJTLpGpGzRJCTNgc7rNBVC7OJjVZ8H",
	"S2+eOAKshwvZRUR7F6MfDD1z6bzuWhnRuELZS8AjT3b48WfVVOjPoql4K3iCcgxw7WXqFlo+n9YCM4uM",
	"A8VgnZeeC40KQSFR/ArZlprsJLjAoJGmxQOtn+AgGTsxJqU6XVbl9CP+B6O8L5t4aluEYWoVmJskmWPb",
	"4lZdU+yYRLa5jU8s4JSqYk7esFSKQ8xA464RtVYain6JPtv1l03p/aNXjuA545AUgsdyEvyIX9/gx/Fg",
	"OfKBzuh4MNS3W1ilBX8HrPY8u7C6m+J38vtQjt5I0O+sVkJZu/ehHwTSf3NaWklGm2PS+nn6sfWnszO4",
	"lmpZ6UxcBH1tDoGNZ8u2uNWz9VZkYMdtp+2I+V1ykYFLddA/UjXXiIukHr9Nu45wkNJqsdS2xFy0fmXd",
	"MaGpPQo2T6faltjQtvIJvM6B0FwCzdZkBsCJmJlFtxPEEqrqmqFIHJY3xvPzNXCVUqSgFGRJWFtmE2h1",
	"AgmUfPQGPCHgCHA9C1GCzKm8JrCWSWwGtFtUrQa31rA5PtCHerfpN21gd/JwG6kE4hkiPmlEUebgHjUR",
	"FO6IE5S12SfePz/JdbevKrF8SSTDpP16wgrMkcApFwpSwTM1nAd227HFzK/BWhTYip3+pESrQpiBB67W",
	"11RpVz2nlS4vyB9sptiQuHYo+ZMZ+e916qfe2Knhl1xVqiksZGUvyKI1G2G1Ya63sKrnEvNg7Fq4s/Vk",
	"t408hKVg/LrUUJCJVgfaHzNcZHGY4oQ6USxS9zwEokHEJkCOfasAu6GKZQAQphpE1+kl25QT1HpVWpSl",
	"OX86qXjdbwhNx7b1of6padsnLud0j3w9E6BCwdtBfmExa6uILakiDg5S0DMnsy+c73sfZnMYE8V46tJn",
	"DwUWsQKOTavwCGw5pF2xLzz+rXPWORwd+o0S3SARbNmFoQXHBM3fhVh41XdfV3H3CVXMbUE7EK8aQdP+",
	"Pb2gTCdzIV1qcqxTHbFWdzIfUaZddXT3KtbCqYhdpWvLUNw4QQ09FToOWxB88IrZ/b6vipnqOyF3Mo43",
	"emwtiFkYqbhmPnbXnLdaxvz9WZrvped76fleer6Xnu+l53vp+V56vpeeP7X0/Hm8XUmSeD7tbcOxQCYy",
	"+iIl/C8oVugug3saob8W+fGRYER0c443esFooPnUVa5Fd4VonUbrTh9WwU3NdIyTMqdGGoKV9kHdZNau",
	"g+/rDdpU6YbXmAZPn5DjHw6d/4F1eMBS/GHbh76Kl9LrHB45b8E6l7F3GwROsboheg1S//pJvUeJlebn",
	"LAeiDLK+xeav4BxyI8pb6ycxj5H+8+gEaP7SIcdyJVD6G5GtO4Rj1j9FVLRJprH4M05lpBZrn1B6SNYC",
	"6zG74sK9F9Tlrfun9Le/v2Hb9ipeACNeM3UTvcR8h3oOBKN67F2sZmZPPTqJq+P6WVk2QYgcmTXs6XcT",
	"tdAt5uUODrY1UoU7f19qhIFHfPTg4bEd+2JHhGlFHMWtEtNoATxxbCGZiWztam77stAtLmvr9Q4zWVsM",
	"F1y1cXcMHqpHhs0iRle6perBUsELW8Kmq7bAdCV1JabPwzhtudaNfPP61GEHr4N8buqf2h2uzzUCN4yH",
	"QpKFFFX5yCZt4mt8Ehcl5WuvBjOyYlHlTZrJyeh2OXVdT6nHZ3uF8WNVu+2DLXivOLfC9u8WLViFye4v",
	"ZKTiGch4sZMVV1cs5tuU0t5W4MKX+omU/R8o8t/fRL/Lzqm0Vv2VtvBZpPh2p9T2fSDbn+JKeCfFOTMP",
	"5yiH7ftlNQxhsvVmkAHLwquhk9bE3w1tfvqeXpy0CqLvxlNXiRM8byyVLgEFslpKi+SAMfelFDRLqcJY",
	"HQ76QsizTyyx6tVRRO+AYGIur76rsrnAJ1sFSxx3J3my7VXvJsRkO8rWzPm80mXjf3roQqNa2LhXBfxR",
	"VAHf+MOnCMXye53DabV+eCZ3YFP0Qq94lEtNbfrdQY+34EC4tJ23arvrDd824TUmTGeCgLwklKQ5QwOF",
	"4ErLKtWnnKIKtFObsGPe84rdYVHqpW8S18JHlORuqFNuhKo5qRWjUZFqDhGTx3cAXmJT1WIBSnc48Rzg",
	"lLtWjGNVYJwLSz0m1hPUXNeGo09sy4KuyZzmqMP/DaQgM/OKCPPDoEJRaZbnzp5opiFifsqpJjkYpv+G",
	"GYHODOd1TrWN3NJdjYWBEra2eFQS10J8b79i1IVbvtcboXrLfm6qdn+WEm9JrAq6g/zolcvddvQK0/E0",
	"lsQe7HdmXioYT6JEZm58Z5Hv0hZ5aGQ8T0CPGpuk2/VTboRpLQgyeqqvRw5dM0DvLNrT0aGa1kZ0rAV+",
	"rR9iccMLkZgnI12Y3xdML6sZFlnz8cTThahji6cZhUJw/JZNacmmqoR0ev54i3xwA35FIuzq/ub+4yjx",
	"Qzowp6XeeMx83937gXv5FlLl/r7z4251UbrPRnufjfY+X+l9Ntr73b3PRnufq/U+V+ufNVfrZKOE6PKb",
	"bM2eqHuqTUokpHbmmoGHzVp5FvtmSaYnhJwsDf+n5g6Ac5A0JylVVjDi1lOuYIulJqpKU4Ds4JQnLUhS",
	"UbiJHzb/tc/c02p//ymQ/UfdPlZvEXDefl8UVfETmprI1+R0dDrqjSShEOfgsq5h86xCW7HttXXY/68e",
	"90fZ27qCrq1yZUnLEsy1pqr5nKXMojwX5jGwEB3/Pi7wC0gDnM2UQZi2CW4Rn+gX6bxzqIs/jwnd/fv9",
	"CvWxDrv5DO4TyHzy6s79Dbs9Hrhx7B5DvGcZd8EyPjvT+APlurtPa/c7W1BoSG3lrb2BJFVXWYvonbyM",
	"ZNXJhjfjCJBWkuk13nC0ZL+cgfn/B8PHFchzf/lVMh8djJZalwfTKWaWXwqlpyNzNTXfVOejuR/owo7g",
	"LpdSsnPMSvnh8v8FAAD//6WlkWzfDwEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
