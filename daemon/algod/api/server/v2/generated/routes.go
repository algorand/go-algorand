// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
