// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
