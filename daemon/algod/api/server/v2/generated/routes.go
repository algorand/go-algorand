// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
