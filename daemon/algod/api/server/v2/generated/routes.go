// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"EZxO7qcAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
