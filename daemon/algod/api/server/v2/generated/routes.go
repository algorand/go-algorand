// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/transactions/dryrun)
	TransactionDryRun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionDryRun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.POST("/v2/transactions/dryrun", wrapper.TransactionDryRun, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
