// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"gWEPF/IAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
