// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Gets a proof of a light block header for a given round
	// (GET /v2/blocks/lightblockheader/{round}/proof)
	GetProofForLightBlockHeader(ctx echo.Context, round uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// get a state proof for a given round
	// (GET /v2/stateproofs/{round})
	StateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetProofForLightBlockHeader converts echo context to params.
func (w *ServerInterfaceWrapper) GetProofForLightBlockHeader(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProofForLightBlockHeader(ctx, round)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/lightblockheader/:round/proof", wrapper.GetProofForLightBlockHeader, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.StateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"5OWwfCUBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
