// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Get the state proof transaction for a given round
	// (GET /v2/transactions/state-proof/{round})
	StateProof(ctx echo.Context, round uint64) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.GET("/v2/transactions/state-proof/:round", wrapper.StateProof, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"///8WcQX4BwBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
