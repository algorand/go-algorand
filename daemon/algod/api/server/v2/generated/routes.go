// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
