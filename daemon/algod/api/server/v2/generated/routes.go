// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"4/sSAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
