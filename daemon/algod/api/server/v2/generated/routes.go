// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys)
	router.POST("/v2/shutdown", wrapper.ShutdownNode)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"lAAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
