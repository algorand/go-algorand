// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9e3fbOJIo/lXw0+45eawoOa+eic/psz93nO72nSSdE7tn526c2w2RJQljEuAAoC11",
	"rr/7PSgAJEiCkvzIq9d/JRbxKBQKhUI9P45SUZSCA9dqtP9xVFJJC9Ag8S+apqLiOmGZ+SsDlUpWaib4",
	"aN9/I0pLxhej8YiZX0uql6PxiNMCmjam/3gk4V8Vk5CN9rWsYDxS6RIKagbW69K0rkdaJQuRuCEO7BBH",
	"h6PLDR9olklQqg/lLzxfE8bTvMqAaEm5oqn5pMgF00uil0wR15kwTgQHIuZEL1uNyZxBnqmJX+S/KpDr",
	"YJVu8uElXTYgJlLk0IfzhShmjIOHCmqg6g0hWpAM5thoSTUxMxhYfUMtiAIq0yWZC7kFVAtECC/wqhjt",
	"vx8p4BlI3K0U2Dn+dy4B/oBEU7kAPfowji1urkEmmhWRpR057EtQVa4Vwba4xgU7B05Mrwl5XSlNZkAo",
	"J+9+fEGePHny3CykoFpD5ohscFXN7OGabPfR/iijGvznPq3RfCEk5VlSt3/34wuc/9gtcNdWVCmIH5YD",
	"84UcHQ4twHeMkBDjGha4Dy3qNz0ih6L5eQZzIWHHPbGNb3VTwvm/6K6kVKfLUjCuI/tC8Cuxn6M8LOi+",
	"iYfVALTalwZT0gz6fi95/uHjo/Gjvct/e3+Q/Lf789mTyx2X/6IedwsGog3TSkrg6TpZSKB4WpaU9/Hx",
	"ztGDWooqz8iSnuPm0wJZvetLTF/LOs9pXhk6YakUB/lCKEIdGWUwp1WuiZ+YVDw3bMqM5qidMEVKKc5Z",
	"BtnYcN+LJUuXJKXKDoHtyAXLc0ODlYJsiNbiq9twmC5DlBi4roUPXNDXi4xmXVswASvkBkmaCwWJFluu",
	"J3/jUJ6R8EJp7ip1tcuKnCyB4OTmg71sEXfc0HSer4nGfc0IVYQSfzWNCZuTtajIBW5Ozs6wv1uNwVpB",
	"DNJwc1r3qDm8Q+jrISOCvJkQOVCOyPPnro8yPmeLSoIiF0vQS3fnSVCl4AqImP0TUm22/X8d//KGCEle",
	"g1J0AW9pekaApyIb3mM3aewG/6cSZsMLtShpeha/rnNWsAjIr+mKFVVBeFXMQJr98veDFkSCriQfAsiO",
	"uIXOCrrqT3oiK57i5jbTtgQ1Q0pMlTldT8jRnBR09f3e2IGjCM1zUgLPGF8QveKDQpqZezt4iRQVz3aQ",
	"YbTZsODWVCWkbM4gI/UoGyBx02yDh/GrwdNIVgE4fpBBcOpZtoDDYRWhGXN0zRdS0gUEJDMhvzrOhV+1",
	"OANeMzgyW+OnUsI5E5WqOw3AiFNvFq+50JCUEuYsQmPHDh2Ge9g2jr0WTsBJBdeUccgM50WghQbLiQZh",
	"Cibc/JjpX9EzquC7p0MXePN1x92fi+6ub9zxnXYbGyX2SEbuRfPVHdi42NTqv8PjL5xbsUVif+5tJFuc",
	"mKtkznK8Zv5p9s+joVLIBFqI8BePYgtOdSVh/5Q/NH+RhBxryjMqM/NLYX96XeWaHbOF+Sm3P70SC5Ye",
	"s8UAMmtYo68p7FbYf8x4cXasV9FHwyshzqoyXFDaepXO1uTocGiT7ZhXJcyD+ikbvipOVv6lcdUeelVv",
	"5ACQg7grqWl4BmsJBlqazvGf1Rzpic7lH+afssxjODUE7C5aVAo4ZcE795v5yRx5sG8CMwpLqUHqFK/P",
	"/Y8BQP8uYT7aH/3btNGUTO1XNXXjmhkvx6ODZpzbn6npadfXecg0nwnjdnew6di+CW8fHjNqFBIUVDsw",
	"/JCL9OxaMJRSlCA1s/s4M+P0TwoOT5ZAM5Ako5pOmkeVlbMG6B07/oz98JUEMnLF/YL/oTkxn80ppNqL",
	"b0Z0ZcoIcSJQNGVG4rP3iJ3JNEBJVJDCCnnECGdXgvJFM7ll0DVHfe/Q8qE7WmR3Xlq5kmAPvwiz9ObV",
	"eDAT8nr00iEETpq3MKFm1Fr6NStv7yw2rcrE4SciT9sGnYEa9WOfrYYY6g4fw1ULC8eafgIsKDPqbWCh",
	"PdBtY0EUJcvhFs7rkqplfxFGwHnymBz/fPDs0ePfHj/7ztzQpRQLSQsyW2tQ5L67V4jS6xwe9FeGDL7K",
	"dXz07576F1R73K0YQoDrsXc5USdgOIPFGLH6AgPdIeSg4S2VmqWsRGwdZSFG26O0GpIzWJOF0CTDQTJ7",
	"0+Ooci0rfgsbA1IKGZGkkSC1SEWenINUTESUIm9dC+JaGO5mpfnO7xZackEVMXPjI6/iGchJbD/N6w0F",
	"BQ2F2nb92KFPVrzBuBuQSknXvX21642szs27y063ke/fDIqUIBO94iSDWbUIbz4yl6IglGTYEdnsG5HB",
	"saa6UrfAW5rBGmDMRoQg0JmoNKGEi8ywCdM4znUGNKSomkGNkg4ZmV7aW20GRuZOabVYamKEVRHb2qZj",
	"QlO7KQneQGrgQVlrAmwrO53VvuUSaLYmMwBOxMy92tx7EhdJUdmjvR3H8bwGrPql0YKrlCIFpSBLnNFq",
	"K2i+nd1lvQFPCDgCXM9ClCBzKq8JrBaa5lsAxTYxcGshxT11+1DvNv2mDexOHm4jleblaqnASETmdBs2",
	"N4TCHXFyDhKffJ90//wk192+qhwwyLh7/YQV5vgSTrlQkAqeqehgOVU62XZsTaOW8GFWEJyU2EnFgQfU",
	"Dq+o0vbhz3iGgqhlNzgP9sEphgEevFHMyH/3l0l/7NTwSa4qVd8sqipLITVksTVwWG2Y6w2s6rnEPBi7",
	"vr60IJWCbSMPYSkY3yHLrsQiiGqneao1Y/3FoZLf3APrKCpbQDSI2ATIsW8VYDdUSg8AYl4tdU8kHKY6",
	"lFNrwscjpUVZmvOnk4rX/YbQdGxbH+hfm7Z94qK64euZADO79jA5yC8sZq05YkmNxIgjk4KembsJ5T+r",
	"oejDbA5johhPIdlE+eZYHptW4RHYckgHRG9n8Axm6xyODv1GiW6QCLbswtCCB94BLaH0b7C+dSVCd4Ko",
	"PoFkoCnLISPBB2TgyHsbqZllowjQ1xO0dhJC++D3pNDIcnKm8MIouyK/QvCtLeMksIDcgqQYGdWcbsoJ",
	"Auo1pOZCDpvAiqY6X5trTi9hTS5AAlHVrGBaW+NUW5DUokzCAaLP4Q0zOoWEtQP4HdhFQ3KMQwXL62/F",
	"eGTFls3wnXQElxY6nMBUCpFPtp/4HjKiEOzy8DggpTC7zpwt1BvMPCW1gHRCDGqjauZ5T7XQjCsg/1tU",
	"JKUcBbBKQ30jCIlsFq9fM4O5wOo5mZV0GgxBDgVYuRK/PHzYXfjDh27PmSJzuPAOBKZhFx0PH+Ir6a1Q",
	"unW4buHFa47bUYS3o57AXBROhuvylMlWnYEbeZedbD/zjw79pHimlHKEa5Z/YwbQOZmrXdYe0siSquX2",
	"teO4O6lJgqFj67b7LoWY38JqWbaKWc0yWMVW6ggX3yj3jEC/VqAnUdmrNABGDOcgz3JUgIh550CSAsxJ",
	"UUtWmiEbI99aQ8tB6P/c/8/99wfJf9Pkj73k+X9MP3x8evngYe/Hx5fff/9/2z89ufz+wX/+e0xeVZrN",
	"4iq4n6laGkgd41zxI26V6HMh7Stn7YQnMf/ccHdIzGymx3ywpJ2OW2xDGCfUbjbSnJGN8/Ut3LF2ICKh",
	"lKCQI4ZvSmW/innoH+QoT62VhqKvlrFdfxsQSt95ka5HpYLnjENSCA7rqEss4/AaP8Z6W6480Bnvx6G+",
	"XZG3BX8HrPY8u2zmTfGLux2wobe1t9ItbH533I5GLvSMQo0C5CWhJM0Z6hsEV1pWqT7lFF80AblGbAT+",
	"nTb8xn3hm8Qf1ZE3rxvqlFNlcFi/c6Ka2jlENBg/AvinrqoWC1C6I9vNAU65a8U4qTjTOFdh9iuxG1aC",
	"REX9xLYs6JrMaY5P8j9ACjKrdFvaQQcOpc2L2aoHzTREzE851SQHqjR5zfjJCofzfhKeZjjoCyHPaizE",
	"ef4COCimkjgj/cl+RX7qlr90vBW9ae1nz28+9wXgYY+5FzjIjw7dS+DoEMW9RjHYg/2zaYsKxpMokZ0s",
	"gRSMo5dah7bIfSO0egJ60KgY3a6fcr3ihpDOac4yqq9HDl0W1zuL9nR0qKa1EZ3Hv1/rh5gteCGSkqZn",
	"aAocLZheVrNJKoqpfwFNF6J+DU0zCoXg+C2b0pJNVQnp9PzRFnHsBvyKRNjV5XjkuI66dX2BGzi2oO6c",
	"tdrN/60FuffTyxMydTul7llfIzt04CQSebS6UJeWXcUs3vrKW2erU37KD2HOODPf9095RjWdzqhiqZpW",
	"CuQPNKc8hclCkH3ihjykmp7yHosfDGdBT2AHTVnNcpaSs/Aqbo6mdVHuj3B6+t4QyOnph56Svn9xuqmi",
	"Z9ROkFwwvRSVTpwPZiLhgsosArqqffBwZOtBvWnWMXFjW4p0Pp5u/DirpmWpklykNE+Uphriyy/L3Cw/",
	"IENFsBO6jhClhfRM0HBGCw3u7xvhzBSSXngH3kqBIr8XtHzPuP5AktNqb+8JkIOyfGXGPDZw/O54jaHJ",
	"dQkt9caOTj/NYDHVBi7cClSw0pImJV2Aii5fAy1x9/GiLlCRlucEu4U4qQ3nOFSzAI+P4Q2wcFzZrQkX",
	"d2x7+WCa+BLwE24htjHcqdFPX3e/zFA/i9wQ2bW3KxgjukuVXibmbEdXpQyJ+52pfewXhid7o4FiC24O",
	"gQtHmAFJl5CeQYae0VCUej1udfd2KXfDedbBlI0gsN5L6OaKmqAZkKrMqJMBKF93/Q0VaO2dLN/BGaxP",
	"ROMlexUHw8vxKLU+/YmhmaGDipQaXEaGWMNj68bobr6zcRpIaVmSRS5m7nTXZLFf04XvM3yQ7Q15C4c4",
	"RhQ1GjbQe0llBBGW+AdQcI2FmvFuRPqx5RnxZmZvvojexPN+4po0UpuzU4arOVnW3wvwzlTo+/5ob2+8",
	"t7eHJqCFFBeKzKiCjAgXX2NDVQLeVim6gAEVT6ii29H/s6XWw0G23YbR+0/Mu9dc7xaKgmwbJ2bNUfoB",
	"88UQkDn0XZu1n8lqgXEFE4Jhsw5hsxyFp9pcblkRlS1VqY0DHAItTtYgeSOGeDDaGAnlnSVVPvQHI6T8",
	"Cd9JMhgy7NWGWUP23jKLD9RG1GNm3hzO6RD+h/3VjwJzaxAGVXuje07cPb3jOjLBRiR7r3Xvqu7900fj",
	"K/maj0fOAyi2HYKjWJRBDgu7cNvYE4oD7Z4KNsjA8ct8njMOJIlZbqlSImU2dqu5fNwcYKTmh4RYjRTZ",
	"eYQYGQdgo3UDByZvRHg2+eIqQHJgaA6hfmy0iwR/w3b1eBMa7uTxrXJzm2P2OUlzpMZNIIfd1L4SbTyK",
	"MqihB07bOmGbzKD3IowRrGFUfbVSX3mlIAeUJpIWn03OYspGIxQBEuWx7xa8esh9NjcyyoPA5CVhwZSG",
	"5tlvzq7XY31e1cu50JDMmVQ6QY1DdHmm0Y8KZdkfTdM4M+qYpJRVYcR5EU57BuskY3kV3203798OzbRv",
	"6uefqmZnsMYrB2i6JDOMjI4aqjdMbX0ZNi74lV3wK3pr692NlkxTM7EUQnfm+EaoqsNdNh2mCAHGiKO/",
	"a4Mo3cBe8Ol2CLmOOcAHYhc+yg37tBEag0qP3mHK/NibhLEAimE+bEeKriWQ0zeugqEh0YiUTAeBxX2/",
	"2oEzQMuSZauOCsKOOiiS0iu9M+yDJWJJG9WDbcFAoG6IuW5J8CoTu6XBDWpDxHm4tslOmDGyWIiQgCGE",
	"UzHlE5z0EWVIG6Pwt+HqBGj+N1j/3bTF5Ywux6ObaSxiuHYjbsH123p7o3hGVbx9wbYUkFdEOS1LKc5p",
	"nji9zhBpSnHuSBObezXQZ2Z1ce3BycuDV28d+ObpnAOVVtO3cVXYrvxmVmUe9EIOHBCfQMHIrv7pbwWx",
	"YPPrqLRQF3SxBBesHshy+GK2xGWPV6PnC46i0w3N4xbBrZoep5K0S9ygmoSy1kw272OrmGwrI+k5Zbl/",
	"mHpoB6x3uLhGHXxlrhAOcGOlZqCbTm6V3fROd/x0NNS1hSeFc20Ipy9sxghFBO+6hRkREt+7SKoFXRsK",
	"srr1PnPiVZGY45eonKVxJQafKUMc3KqsTWOCjQeEUTNixQYsILxiwVimmdrB2NcBMpgjikzUiG3A3Uy4",
	"VF8VZ/+qgLAMuDafJJ7KzkE159Kni+lfp0Z26M/lBrYqsGb4m8gYZqgh6QKB2CxghAryHriH9YPTL7TW",
	"7JsfAk3gFexs4Yy9K3GDjczRh6Nm66ywbCu6w8xcff5nCMNmcdieFswrMZYW0IE5omm+Bm+Lg+GbwvS+",
	"wh3RXAkIbngZjK1mNVciMkzFLyi3WXtMP4tD11uB1RmYXhdCYqCKgqiTAVPJXIo/IP6SnZuNiniuOlSi",
	"uIi9J5EAgC4TrXU0TT42j98QjkHSHpLkgo+kbQcdOOFI5YHmH+PJvbqLckvWNsNQy/oePxyhx8zUjt8c",
	"Dgdzz8sopxczGgu2NwKVgemgsTG1FHNaEN/Z74LTITa0F5ir6rbMRneUIBv38n4k4TWFo2+L5DNIWUHz",
	"uJSUIfbbsWwZWzCbpqlSEOQBcgPZ/HaWilwuJWvFa1BzNCd74yDTmNuNjJ0zxWY5YItHtsWMKry1auVr",
	"3cUsD7heKmz+eIfmy4pnEjK9VBaxSpBagMWnXK0Jn4G+AODEmnkePSf30Qag2Dk8MFh0ssho/9FzVKLa",
	"P/Zil53Lx7aJr2TIWP7LMZY4HaMRxI5hLik36iQaaWSTaA6zsA2nyXbd5SxhS8f1tp+lgnK6gLgxutgC",
	"k+2Lu4lKww5eeGYzwCktxZowHZ8fNDX8acCzzrA/CwZJRVEwjUY/LYgShaGnJsmPndQPZ9PJucQbHi7/",
	"EQ0upX02QPfB/HkVxPYuj60azWJvaAFttI4JtQF5OWsMpI4hTsiRD+vFTCR1AhKLGzOXWTqKdGgZnZNS",
	"Mq7xEVXpefJXki6ppKlhf5MhcJPZd08j2VfaCRf41QD/7HiXoECex1EvB8jeSxOuL7nPBU8Kw1GyB40n",
	"a3AqowkOhKZ53CfHc/SuS9bmoXcVQM0oySC5VS1yowGnvhHh8Q0D3pAU6/VciR6vvLLPTpmVjJMHrcwO",
	"/frulZMyCiFjSR6a4+4kDglaMjhH96D4Jpkxb7gXMt9pF24C/Ze1sjQvgFos82c59hD4oWJ59vfGM7+T",
	"wEpSni6jNo6Z6fhbk3GvXrI9x9GcAkvKOeTR4eyd+Zu/WyO3/z/FrvMUjO/YtpuYyi63s7gG8DaYHig/",
	"oUEv07mZIMRq21W59m3LFyIjOE8TwN5QWT/XVpBO518VKB3L/osfrFso6rLMu8BmcyHAM5SqJ+QnmzF7",
	"CaQVX4vSLCuq3MZqQrYA6ZSsVZkLmo2JGefk5cErYme1fWxmU5tNZoHCXHsVHR1GkO1iN08tn7Iu7kW6",
	"+zib3drMqpXGcHelaVHGAgRMixPfAKMQQr0uinkhdibk0ErYystvdhJDD3MmCyOZ1qNZHo80Yf6jNU2X",
	"KLq2uMkwye+eBslTpQqSjNb5GuuEFXjuDNwuE5JNhDQmwrwvLpiyiZLhHNoxCXWAjns6+RiF9vJkxbml",
	"lCiP3hRAdh20e+Cs8d6rfqOQdRB/RcFFiUqmcNWsUMfYKxoB3k0x1csuaoMh6+x+PgF+SrngLMX46yA1",
	"cw2yS7q8i11kh1D1rlrKH3F3QiOHK5rYqnYPclgcTHXlGaFDXF8xG3w1m2qpw/6pMbvvkmqyAK0cZ4Ns",
	"7FOiOX0J4wpcAhLMvx3wSSFbtibkkFHzZVKrua9IRuihPCAA/2i+vXHPI3TSO2McBSGHNucPaDUamBNW",
	"G+mJabIQoNx62hHF6r3pM8Go2gxWHyY+hyyOYU01ZtnWLtkf6sBbKZ1V0LR9YdoSNMs0P7e8oe2kB2Xp",
	"Jo0GBNc7HEu/NojgiLUp8er+ALn1+OFoG8hto3sB3qeG0OAcjZNQ4j3cI4w6k10n0eU5zStLUdiCWLee",
	"aBQb4xEwXjEOTYbjyAWRRq8E3Bg8rwP9VCqptiLgTjztBGiOFskYQ1PaqWhvOlRngxEluEY/x/A2Nkn4",
	"BhhH3aAR3Chf14mVDXUHwsQLzOjuENlPqYdSlROiMnTj7CTZizEOw7h90sv2BdA/Bn2ZyHbXktqTc5Wb",
	"aCheJxUxefPlCtLKGtyFzexBy5KkGAAb3BdRjSZT5vFUzPKI79th/THIh4kut7M1/hvLtzKMEmcRv7JP",
	"ljd/Y8crC6ztkXripiGmRLHFNbe56X+r+5yLRRuQz6tQ2HjGQ5KJne6Xhm0OZyw98Iy1jrBENyThkyXj",
	"o6mODWqfSWTk0Udpk/d286N8OIPtGFn/gDPiuyZ5ALW3i7UxDLkkpoMetFQ7Z3lNSROp3z+YNu1sbATr",
	"z2DT3drSMVH9ypAPg3VhMJ97vXeTi3pSJo69EaHeOaYP0N+85x0pKXMGtObE9jHrfHT7XtO7eO81G9xd",
	"hPN8xUFiK+ll7NpMIT3P58D33SZWmuweu9sY5NFmgmlxF8BdXty2T+POnlXzOaSanW/xNP8vI7E2Xsxj",
	"L9PaFOWB4zmrPXV8haEritoNQJscwTfCEyQIuDE4Q36mZ7C+p0g7O/Nh9Pw5Qr1OEBhiAJMnJIZEhIpp",
	"/+0j3ClkmaopA7HgrW22OzR5awZTbNbuXrE0RTvN5UmSUCdn1TmAhrJ6ipgUv9NcpusOjleN9za6ZAw5",
	"o/eT3A3fXoeYU1DV6ZHrEkKBM4V5rHVzRV24IDSMC6j1Tj4cDZT/zYfQ2FlsaaomCShq+S6ozHyLqNjq",
	"JeJkwL2r6zBt/dJZHOh5PTNrfCP6PsORkG70hUlzoRhfJEMuU213hFqXf09ZowsqCDB7IMI1B+mS/2pf",
	"+SvRwvtSbIJjEypc4YnrIEENZvyywA2GMb5r4jQxjw21dd+cQSlcIJFQUAOdDKIph+fchOwX9rt3kvV5",
	"TDpZgyLjenpNtoZDeq8YpnpIDKl+Ttxtud359jrvBca5za2uYqGV3KAy1CSVUmRVai/o8GCAf1ftHM68",
	"gZVEpfy0v8qewJZjcP+rIJThDNZTKzSlS8qbLAvtY21TrNs1BIF3nd2+1adUXGDNF3YBi1uB80u+hMaj",
	"Uog8GVAdHfUjRLtn4IylZ5ARc3d4e/JAmk1yHzUWtW3gYrn2ScXLEjhkDyaEmLdUUeq1NxO0MyZ1Juf3",
	"9Kb5VzhrVtmgbfdIm5zyuCuEraR4Q/7mh9nM1Wxp4RtOZQfZPJFe8QHWRi8iSWd3rcITUdx3E4E2RGWh",
	"iEkp14yV2+l89x9qEdIPoxy2vH/OWq86mxOko6wXEm75dRdoKa/4uuvHb+y6PFwHcrVKQX+dO29AC7cD",
	"uN8F8Y1qoo/cYY2Cnu2iUYhnKjDdUaVhEYLJPwiCSn5/9DuRMHdlXR8+xAkePhy7pr8/bn82r6+HD6Mn",
	"87MpM1rFfty8MYr5+5Bx1xowB/wIOvtRsTzbRhgtr5AmMR/6Pfzm/Ge+SGrA3+wTuX9UXZa0q6hRu5uA",
	"iImstTV5MFXg77GDq4frFnHswMsmrSTTawxh8i8q9ls0NPynWgnjKsjVjuDOD9kWL3VuSY3Kpqk3+ZOw",
	"NaAKc9ejYl1jhu2XK1qUObiD8v292V/gyV+fZntPHv1l9te9Z3spPH32fG+PPn9KHz1/8gge//XZ0z14",
	"NP/u+exx9vjp49nTx0+/e/Y8ffL00ezpd8//cs8Xe7SANoUU/4H5M5ODt0fJiQG2wQktWZ1Y35Cxz8VH",
	"UzyJ5k2Sj/b9T/+/P2GTVBRBfXr368j5qI2WWpdqfzq9uLiYhF2mC3yjJVpU6XLq5+knNH97VPvP2LgH",
	"3FHrGmFIATfVkcIBfnv38viEHLw9mjQEM9of7U32Jo8w5W0JnJZstD96gj/h6Vnivk8dsY32P16OR9Ml",
	"0Fwv3R8FaMlS/0ld0MUC5MQlJTQ/nT+eevP79KN7n16aURex4C7rCRS4f/Rz9TldFxp1fA3jILuKcklX",
	"xnVGJCc+8gwdNOyTz7C2GllHWZPB4ygou+gisWxo+v77b6g+daxoQCzpYaTsbKMqGq44GxTl94X4n/31",
	"MuIH+KFTRfTx3t4nqBw6bo3i8XLNEqRPbxHEtgHoxoB2h+txhdc0N3QDdVX5ES7o0Te7oCOO+m/Dtohl",
	"y5fj0bNveIeOuDk4NCfYMoik6bPCX/kZFxfctzRXclUUVK7xwg1SEYai1eUgy23HsDlt7TAfhqB8RZBV",
	"raUtmq09nY2JqmsclZIJIziMzSsgg1QCxWteSHTXawphOM0A2KJOrw/+gfri1wf/IN+Tofr0wfT2Rd5m",
	"4j+BjhRq+WHd1FjeyNG/FJscf7Ul/b+dO++mV81duZ9vttzPDkz7bnfvijl9s8Wcvm2RdFXHH1PCBU84",
	"Zpk8BxKote5k1K9aRn229+SbXc0xyHOWAjmBohSSSpavya+8Dti4mQhe85yKByE0G/lPz7zVSNGB+B6k",
	"6J5+bHkyZNuVJy2XhmxMmG4kw5a3Q5Cht04G7IL1xk2mL8oz62jvPV/V2Ge8Qm2dtcfa/Rj38mFNYkJ6",
	"YKb5YX10uItc3lpTkIgnJpu38LVRRO9dWp9UYxEGfEXutfjefOoboAfHDzQjPqLvE/Pm3Zjp072nnw+C",
	"cBfeCE1+REePT8zSP6meIE5WAbPBNPjTjz5nzw4MxuXDarMW5z20kamYEzp2Qfqu4Fht3Tf8xDJCm5Ks",
	"zzXMDLvyi37KrhinaNIUfS08wpYBiNBlF713fOGOL9yIL3QJquEI6COrph/Rky1kB70jiSUv/0SGkqCc",
	"gRSFz6AryBx0urS+w11bdoSt+LjRYZ6yKbvSjflLx7qOW9TPLoFrcfZazPqzoxcPdvzZmk8vx6MUZIT4",
	"fvFBLOYzm6MvVh0T7JOIYSYN5vNq1Ck1XOIhpoghUC2IC1UhZhevBOWLZvK+bR3Rcj1t0h2Cb4LgHlN7",
	"6TKc2OPlFvGtKz6C25Ik5A2KQ3jAfUjsn1Ht8Slv5E+9oDeCA4EVU1jmxNLinbmxFhfqAt+163JYu3FA",
	"dGgbHT/qFcsup3VszZBQ8dZVqt4oVDQ3NWsy3bfVK7QsgUp17Ut6uznspDPj0WFYiaMVClQHAUVAMXi5",
	"oiXxP3YxI/55rXV31ervqtVfr1r9Z30yNw45llV5O5HscI0v+p7WX+Q9/UbwBG9b4NpLfi20fLm3NQYg",
	"tArk+RxSXNg6+UKikBDyATXZ6XqFQVNCi6mgS+cwGbvLNqU6XVbl9CP+B51BLxu3S5swbWrVbJvu22Pb",
	"4lYdKOyYRDY++aH/sVP9RYsXq7XSUPTTaduuv21KxRXl4QJr4yWF4DHXZVs57zV+jIbCoFF2oDOax4f6",
	"dpMgtuDvgNWeZxdWd1P8Tr4OFd6NxNHOaiWUtRMaWuuR/pvT0q1LGvt5+rFdtstqw11Ltax0Ji6Cvk0x",
	"yMGzZVvc6tl6IzKw47a9+/spQSm6OziP6P6RqrlGPNrL47dpZwPvmHKhiimtFktt00FHc83XHROa2qNg",
	"w/nVtvhn28rH+Z0DobkEmq3JDIATMTOLbueR6JazdLwxHsbbwFVKkYJSkCVhHshNoNV+5qgh1BvwhIAj",
	"wPUsRAkyp/KawFomsRnQbgLkGtxaD+T4QB/q3abftIHdycNtpDIoTqwF+tnk4MqLR1C4I05QeGWfeP/8",
	"JNfdvqrEVIORQHT79YQVGDTHKRcKUsEzNZwuYtuxxQQRwVoU2Oz6/qREM7iZgQeu1ldUaZfpshVVG6QZ",
	"MVNsyG8xFCNmRv57HSHWG7sph1onAbWyF2TR/Oqw2jDXG1jVc4l5pNSqq/2wbeQhLAXj12lBg4QVOtBR",
	"mOEii7tgeY7W2rgk0gKiQcQmQI59qwC7oSJgABCmGkTXUehtygnqMigtytKcP51UvO43hKZj2/pA/9q0",
	"7ROXcw1Hvp4JUKHg7SC/sJi1GX+XVBEHBynomZPZF85Duw+zOYyJYjx1WXaGsjmwAo5Nq/AIbDmkXbEv",
	"PP6tc9Y5HB36jRLdIBFs2YWhBccEza9CLLzqu6+rUfiEitC2oB2IV42gaf+eXlCmk7mQLoMR1pSJ2FQ7",
	"iZ0o066SkXsVa+EUma4qjWUobpwg37UK3Vtd4XGffIEVET8sM9WPQu5kwm20rVoQszBScc18AJ45b7WM",
	"+fXZQ++k5zvp+U56vpOe76TnO+n5Tnq+k54/tfT8ZXwySZJ4Pu0DbmLhNmT0TUr431BEy+cMQWmE/lrk",
	"x0eCEdHNOd7oq6GB5lNXZQKN6tGc6tbpO6xYkZrpGCdlTrFc5Ur70GOsVBnUrPKp0m1GJcNrTIMnj8nx",
	"zwfPHj3+7fGz7wz3WdqyWWHb+z7Zr9LrHB44n7Y65Yl3bgNOMSc7+rZR//pJvd+DlebnLAeiDLJeYvND",
	"OIfciPLW+knMY6T/PDoBmr9wyLFcCZT+QWTrDuGY9U8RFW2SaUzojFMZqZvQJ5QekrXA2imuEEjvBXV5",
	"q14Ucc+B/oZt26uBkoFR8t5EL1s9BVzJKzf2LlYzs6cencTVXPiiLJsgRI7MGvb01fjWd3P+uoODbY1U",
	"4c7ft+oH7xEfPXh4bMc+JyrB+uWW4laJabQAnji2kMxEtva1xV0JlxaXtbU1hpmsLVwBrjKQOwb31QPD",
	"ZhGjK91S9URrmwV1AJuErV+GcdqqDhv55vWpo1107sZelN3h+lwjcMO4LyRZSFGVD2wVa77GJ3FRUr72",
	"ajAjK2LVOsxgjZ7ft8up67SrPT67e9G18L2CYfzd3y1aMFmrq7iW2ZJr8ZyI3cJg2zHelL3ZlgfPZwSN",
	"lOgaKMjV30S/y871sVb9lTY/cqRQTqcszl241f+IK+GtFOfMPJyjHLbvl9UwhMnWm0EGLAuvhk7yDX83",
	"tPnpO3px0ipetBtPXSVO8LyxVLoEFMhqKS2SqcTcl1LQLKUKI0pcLcNPLLHq1VFE74BgYsapvu+vucAn",
	"WwVLHHcnebLt++0mxJQwyqbW/LLSZeN/euACeFrYuFMF/FlUAT/4w6cIxSzdncMZ1BfdgU3RC73iUS41",
	"RSvhsMdbcCDe2pa3arvrDd824TUmTGeCgLwklKQ5QwOF4ErLKtWnnKIKtJPCvGPe84rdYVHqhW8S18JH",
	"lORuqFNOsSZ9rRiNilRziFXbBPASm6oWC1C6w4nnAKfctWK8qX+PGeET6wlqrmvD0Se2ZUHXZI418gT5",
	"A6QgM/OKCLOYoEJRaZbnzp5opiFifsqpJjkYpv+aGYHODOd1TrWN3NW19VgYqHRhc8wmcS3ET/YrhjG4",
	"5Xu9Eaq37OemuM8XyQSdxIolOciPDl2GsaNDTBrTWBJ7sH8281LBeBIlMnPjO4t8l7bIfSPjeQJ60Ngk",
	"3a6fciNMa0GQ0VN9PXLomgF6Z9Gejg7VtDaiYy3wa/0Qi25diMQ8GbFu3mjB9LKaYS5mH/U6XYg6Anaa",
	"USgEx2/ZlJZsqkpIp+ePtsgHN+BXJMKu7m7uP48SP6QDc1rqjccSRd29H7iXbyGh69edxXWri9JdztS7",
	"nKl3WTXvcqbe7e5dztS7jKJ3GUX/p2YUnWyUEF0Wjq05/lqxxxm6fjZ1W2sGHjZrZQPsmyWZnhByglUx",
	"qbkD4BwkzUlKlRWMXJnbgi2WmqgqTQGy/VOetCBJReEmvt/81z5zT6u9vSdA9h50+1i9RcB5+31RVMVP",
	"tiL79+R0dDrqjSShEOfgcoOFVQJtr63D/n/1uL/0Co6iFgaVK76uIVHVfM5SZlGeC/MYWIiOfx8X+AWk",
	"Ac6mniBM2zSsiE/0i3TeOe1ihm2hu3+/X6EUzkGHXO7SnHz6+jebKqzelAduHLvHEO9YxudgGV+cafyJ",
	"MrLdJV/7yhYUGlJb2VVvIEnVNeRipemdjNTUaAxrHuINV1c7fP/B8HEF8txffk0Jv/3pFPOfL4XS05G5",
	"mtrl/cKP5n6gCzuCu1xKyc4xd+KHy/8XAAD//9eCZixI8gAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
