// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
