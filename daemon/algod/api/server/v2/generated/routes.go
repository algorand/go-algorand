// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryRun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryRun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryRun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
