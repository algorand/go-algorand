// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
