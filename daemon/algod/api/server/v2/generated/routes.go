// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys)
	router.POST("/v2/shutdown", wrapper.ShutdownNode)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
