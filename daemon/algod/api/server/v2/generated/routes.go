// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{addr}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, addr string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{account-id})
	PostV2RegisterParticipationKeysAccountId(ctx echo.Context, accountId string, params PostV2RegisterParticipationKeysAccountIdParams) error

	// (POST /v2/shutdown)
	PostV2Shutdown(ctx echo.Context, params PostV2ShutdownParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "addr" -------------
	var addr string

	err = runtime.BindStyledParameter("simple", false, "addr", ctx.Param("addr"), &addr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter addr: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, addr, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// PostV2RegisterParticipationKeysAccountId converts echo context to params.
func (w *ServerInterfaceWrapper) PostV2RegisterParticipationKeysAccountId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV2RegisterParticipationKeysAccountIdParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostV2RegisterParticipationKeysAccountId(ctx, accountId, params)
	return err
}

// PostV2Shutdown converts echo context to params.
func (w *ServerInterfaceWrapper) PostV2Shutdown(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV2ShutdownParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostV2Shutdown(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:addr/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:account-id", wrapper.PostV2RegisterParticipationKeysAccountId)
	router.POST("/v2/shutdown", wrapper.PostV2Shutdown)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
