// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"gYaYKD73AAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
