// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9e3fbtrIo/lXw0zlrNckRJefV3XitrvNz47T13UmaFbs9+544t4XIkYRtEuAGQFtq",
	"rr/7XRgAJEiCkvzIq8d/JRbxGAwGM4OZwcyHUSqKUnDgWo32P4xKKmkBGiT+RdNUVFwnLDN/ZaBSyUrN",
	"BB/t+29Eacn4YjQeMfNrSfVyNB5xWkDTxvQfjyT8q2ISstG+lhWMRypdQkHNwHpdmtb1SKtkIRI3xIEd",
	"4uhwdLnhA80yCUr1ofyF52vCeJpXGRAtKVc0NZ8UuWB6SfSSKeI6E8aJ4EDEnOhlqzGZM8gzNfGL/FcF",
	"ch2s0k0+vKTLBsREihz6cD4XxYxx8FBBDVS9IUQLksEcGy2pJmYGA6tvqAVRQGW6JHMht4BqgQjhBV4V",
	"o/13IwU8A4m7lQI7x//OJcCfkGgqF6BH78exxc01yESzIrK0I4d9CarKtSLYFte4YOfAiek1Ia8qpckM",
	"COXk7Y/PyePHj5+ZhRRUa8gckQ2uqpk9XJPtPtofZVSD/9ynNZovhKQ8S+r2b398jvMfuwXu2ooqBfHD",
	"cmC+kKPDoQX4jhESYlzDAvehRf2mR+RQND/PYC4k7LgntvGtbko4/2fdlZTqdFkKxnVkXwh+JfZzlIcF",
	"3TfxsBqAVvvSYEqaQd/tJc/ef3g4frh3+W/vDpL/dn8+fXy54/Kf1+NuwUC0YVpJCTxdJwsJFE/LkvI+",
	"Pt46elBLUeUZWdJz3HxaIKt3fYnpa1nnOc0rQycsleIgXwhFqCOjDOa0yjXxE5OK54ZNmdEctROmSCnF",
	"OcsgGxvue7Fk6ZKkVNkhsB25YHluaLBSkA3RWnx1Gw7TZYgSA9e18IEL+nKR0axrCyZghdwgSXOhINFi",
	"i3jyEofyjIQCpZFV6mrCipwsgeDk5oMVtog7bmg6z9dE475mhCpCiRdNY8LmZC0qcoGbk7Mz7O9WY7BW",
	"EIM03JyWHDWHdwh9PWREkDcTIgfKEXn+3PVRxudsUUlQ5GIJeulkngRVCq6AiNk/IdVm2//X8S+viZDk",
	"FShFF/CGpmcEeCqy4T12k8Yk+D+VMBteqEVJ07O4uM5ZwSIgv6IrVlQF4VUxA2n2y8sHLYgEXUk+BJAd",
	"cQudFXTVn/REVjzFzW2mbSlqhpSYKnO6npCjOSno6vu9sQNHEZrnpASeMb4gesUHlTQz93bwEikqnu2g",
	"w2izYYHUVCWkbM4gI/UoGyBx02yDh/GrwdNoVgE4fpBBcOpZtoDDYRWhGXN0zRdS0gUEJDMhvzrOhV+1",
	"OANeMzgyW+OnUsI5E5WqOw3AiFNvVq+50JCUEuYsQmPHDh2Ge9g2jr0WTsFJBdeUccgM50WghQbLiQZh",
	"CibcfJnpi+gZVfDtkyEB3nzdcffnorvrG3d8p93GRok9khG5aL66AxtXm1r9d7j8hXMrtkjsz72NZIsT",
	"I0rmLEcx80+zfx4NlUIm0EKEFzyKLTjVlYT9U/7A/EUScqwpz6jMzC+F/elVlWt2zBbmp9z+9FIsWHrM",
	"FgPIrGGN3qawW2H/MePF2bFeRS8NL4U4q8pwQWnrVjpbk6PDoU22Y16VMA/qq2x4qzhZ+ZvGVXvoVb2R",
	"A0AO4q6kpuEZrCUYaGk6x39Wc6QnOpd/mn/KMo/h1BCwE7RoFHDGgrfuN/OTOfJg7wRmFJZSg9Qpis/9",
	"DwFA/y5hPtof/du0sZRM7Vc1deOaGS/Ho4NmnNufqelp19e5yDSfCeN2d7Dp2N4Jbx8eM2oUElRUOzD8",
	"kIv07FowlFKUIDWz+zgz4/RPCg5PlkAzkCSjmk6aS5XVswboHTv+jP3wlgQyIuJ+wf/QnJjP5hRS7dU3",
	"o7oyZZQ4ERiaMqPxWTliZzINUBMVpLBKHjHK2ZWgfN5Mbhl0zVHfObS8744W2Z0XVq8k2MMvwiy9uTUe",
	"zIS8Hr10CIGT5i5MqBm11n7Nyts7i02rMnH4iejTtkFnoMb82GerIYa6w8dw1cLCsaYfAQvKjHobWGgP",
	"dNtYEEXJcriF87qkatlfhFFwHj8ixz8fPH346PdHT781ErqUYiFpQWZrDYrcc3KFKL3O4X5/Zcjgq1zH",
	"R//2ib9BtcfdiiEEuB57lxN1AoYzWIwRay8w0B3Ktaz4LaAQpBQyovMi6WiRijw5B6mYiJgv3rgWxLUw",
	"fMjq3Z3fLbTkgipi5sbrWMUzkJMY5s09C0W6hkJtExR26JMVb3DjBqRS0nVvB+x6I6tz8+6yJ23ke+1e",
	"kRJkolecZDCrFqGMInMpCkJJhh2RIb4WGRxrqit1C1ygGawBxmxECAKdiUoTSrjIzIE2jeP8YcCWiUYU",
	"tP3okOXopZU/MzDacUqrxVITo1aK2NY2HROa2k1JUFaogatffWe3rex01k6WS6DZmswAOBEzd79yNz9c",
	"JEWzjPYeF8edGrDqO0ELrlKKFJSCLHHupa2g+XZ2l/UGPCHgCHA9C1GCzKm8JrBaaJpvARTbxMCt1Ql3",
	"Ke1Dvdv0mzawO3m4jVSaO6alAqO7mNOdg4YhFO6Ik3OQeDn7qPvnJ7nu9lXlgOvESeATVpjjSzjlQkEq",
	"eKaig+VU6WTbsTWNWmqCWUFwUmInFQceMBC8pErbKzrjGaqMlt3gPNgHpxgGeFCimJF/88KkP3Zq+CRX",
	"laoli6rKUkgNWWwNHFYb5noNq3ouMQ/GrsWXFqRSsG3kISwF4ztk2ZVYBFHtbES1Dau/ODTHGzmwjqKy",
	"BUSDiE2AHPtWAXZD8/EAIOZ+UfdEwmGqQzm1zXo8UlqUpTl/Oql43W8ITce29YH+tWnbJy6qG76eCTCz",
	"aw+Tg/zCYtY6DpbU6HY4MinomZFNqKlZW0IfZnMYE8V4CskmyjfH8ti0Co/AlkM6oCQ712QwW+dwdOg3",
	"SnSDRLBlF4YWPKCxv7EW8JPAbn4LWktkVENplBNU3bxdzQiHsAmsaKrztWG5eglrcgESiKpmBdPaujTa",
	"So0WZRIOEL1EbZjRXWOt9dirpLvcq49xqGB5feV0PLIidDN8Jx0h2kKHE96lEPlkO/X1kBGFYBcl+ICU",
	"wuw6cx4072bJmdI9IJ1ARRtGfZC/US004wrI/xYVSSlHZaDSUHMnIfHIoygwMxhmWs/JrNRtMAQ5FGB1",
	"HPzy4EF34Q8euD1niszhwrudTcMuOh48QI39jVD6xiegQ5qrowiTwaul4ViRUCFzgZxsvWbiuDvdLoOh",
	"jw79hHiYlOEoduFSiPktrJZlq5izIYNVbKVu51Bh/MZoV2sFehIVhKUBMOJvBHmW421UzDsUSQowpKKW",
	"rDRDNr6RtYZWXMX/ufef++8Okv+myZ97ybP/mL7/8OTy/oPej48uv//+/7Z/enz5/f3//PeY8qA0m8Ut",
	"Fz9TtTSQOs6x4kfc2h7nQlqVc+0kmZh/arg7JGY202M+WNIuRPcmtiGME2o3G2nOKCr5+haEjB2ISCgl",
	"KGQJoYKv7FcxD8MqHOWptdJQ9O/ItuvvAxrCWy9fe1QqeM44JIXgsI5GEjIOr/BjrLdlSwOdUUAM9e3q",
	"Hy34O2C159llM2+KX9ztgA29qYM8bmHzu+N2zCNhQAle7yAvCSVpzvDyJ7jSskr1KaeoXgbkGjGteqV5",
	"+MLx3DeJ33AiFxA31CmnyuCwVjqjZrM5RK6TPwL4e4eqFgtQuqPczAFOuWvFOKk40zhXYfYrsRtWgkT7",
	"5sS2LOiazGmO96M/QQoyq3Rb3KPfW2lzfbG2GjMNEfNTTjXJwVzlXjF+ssLhvHvZ0wwHfSHkWY2FOM9f",
	"AAfFVBJnpD/Zr8hP3fKXjrdiEKL97PnNpxYAHvaYV9ZBfnToVOGjQ9R3GitND/ZPdnUvGE+iRHayBFIw",
	"jsE9Hdoi94zW5gnofmPvcbt+yvWKG0I6pznLqL4eOXRZXO8s2tPRoZrWRnRuYn6t72MutIVISpqeoQdl",
	"tGB6Wc0mqSim/gowXYj6OjDNKBSC47dsSks2VSWk0/OHW9SxG/ArEmFXl+OR4zrq1n21buDYgrpz1jYQ",
	"/7cW5JufXpyQqdsp9Y0N0bBDB771yK3NvRBoGbnN4m2IsY1ROeWn/BDmjDPzff+UZ1TT6YwqlqpppUD+",
	"QHPKU5gsBNknbshDqukp77H4wVcAGEDpoCmrWc5SchaK4uZo2sjO/ginp+8MgZyevu9ZTPuC000VPaN2",
	"guSC6aWodOJC1xIJF1RmEdBVHbqEI9vA002zjokb21KkC41z48dZNS1LleQipXmiNNUQX35Z5mb5ARkq",
	"gp3Q406UFtIzQcMZLTS4v6+FsxlLeuHjHisFivxR0PId4/o9SU6rvb3HQA7K8qUZ89jA8YfjNYYm1yW0",
	"7vc7xko0g8Xu9rhwq1DBSkualHQBKrp8DbTE3UdBXaBZOs8JdgtxUvsbcahmAR4fwxtg4bhyNAgu7tj2",
	"8m8Q4kvAT7iF2MZwp8ZYeN39MkP9LHJDZNfermCM6C5VepmYsx1dlTIk7nemDk1eGJ7sLbiKLbg5BC6K",
	"ewYkXUJ6BhkGlEJR6vW41d07CZyE86yDKRt4bYM+MDoQTSEzIFWZUacDUL7uhmkp0NrHpr2FM1ifiCa4",
	"8CpxWZfjUWpDoRNDM0MHFSk1EEaGWMNj68bobr5zOBlIaVmSRS5m7nTXZLFf04XvM3yQrYS8hUMcI4oa",
	"DRvovaQygghL/AMouMZCzXg3Iv3Y8koqNUtZade/WxTam1YfM8g24RIVJ2LelRo9ph5lYrZxMqMqLkDA",
	"fDH7Yc5Q1x/nZ7JWRVzBhODjPUe4sxx1kdoVaE82lah0+WXb10hDoMWpBCRvpLoHo42RUH1YUuUfIOA7",
	"DX9gdhK0Q06L2ulkqMh7nfC+12hOzMybwzkdwv9w1OxR4EoKHmPUMbGesXUPw7iOj7bvIn3srA+Y9VGy",
	"o/GVIl7HIxfdENsOwVHLyCCHhV24bewJxYH2jQo2yMDxy3yeMw4kiXmlqFIiZfYFScPL3RxglNAHhFgD",
	"D9l5hBgZB2CjtRwHJq9FeDb54ipAcmBoXqd+bLSzB3/Ddmtz80DVqbdb1dA+72gO0bgJILfb2LdCjUdR",
	"ljR0Q2i1IrbJDHpXqhiJGtbUt8v0rT8KckBxnLQ4a3IWs9YZrQKQDI99t+DaQO6xuRHy9wOniYQFUxqa",
	"e7M5rd4Q9GltF+dCQzJnUukEr+zR5ZlGPypUBn80TePsp4UqYl+4sSzOfXDaM1gnGcur+G67ef9+aKZ9",
	"Xd+fVDU7gzUKGaDpkszwRaaRQq3pTZsNU1vP7MYFv7QLfklvbb270ZJpaiaWQujOHF8JVXX4yabDFCHA",
	"GHH0d20QpRvYC959DiHXscDb4E6Gt1rDMG1k+KDVoHeYMj/2JvUrgGKY89qRomsJFN2Nq2DoiaM8I0wH",
	"Dxr7UYIDZ4CWJctWnTu8HXXAbYcK/BUUdavxR1xRo3qwLRgI7uuxQBQJ3uZgtzSQmfZpKg/XNtkJM0b7",
	"ChESMIRwKqZ8YoU+ogxp4+vfbbg6AZr/Hda/mba4nNHleHSzK38M127ELbh+U29vFM9oy7ZXwJYF74oo",
	"p2UpxTnNE2cYGSJNKc4daWJzb0f5xKwufv0+eXHw8o0D39w9c6DSmso2rgrblV/NqsyNWMiBA+Ifbhtt",
	"1d+drSIWbH79GiY0plwswT2SDXQ5w8Uccdnj1RjKgqPojCvzuEttq6nE2fTsEjfY9qCsTXvNjdha9trW",
	"PHpOWe6voh7aAfcXLq6xp16ZK4QD3NgqGBh3k1tlN73THT8dDXVt4UnhXBue8Rb2pboigncDi4wKiTdc",
	"JNWCrg0FWeN0nznxqkjM8UtUztK42YLPlCEObm2+pjHBxgPKqBmxYgMuBF6xYCzTTO3gLesAGcwRRSaa",
	"lDbgbiZciqGKs39VQFgGXJtPEk9l56Cac+nTVPTFqdEd+nO5gW3Kimb4m+gYZqgh7QKB2KxghBbmHriH",
	"9YXTL7Q2jZsfAsPgFRxV4Yw9kbjByeTow1Gz9fYv25biMCNQn/8ZwrCvx7enI/Jmi6UFdGCOaHqhQWlx",
	"MCwpTO8ryIhGJCC4oTAY2+QjuRKRYSp+QbnNFmL6WRy63gqszcD0uhASw+4VRL30TCVzKf6E+E12bjYq",
	"EvvoUInqIvaeRMKZu0y0tso0eaA8fkM4Bkl7SJMLPpK2I3HghCOVB6ZzfMfqDVyUW7K2mU1a7uv44QhD",
	"TqZ2/OZwOJh7YTo5vZjR2CNfo1AZmA4aJ03LFKcF8Z39LjirYUN7gb+nbstsrHoJsglQ7r+LuqZy9HWR",
	"fAYpK2ge15IyxH77ZU7GFsymh6kUBPlH3EA2r5alIpfDxbrBGtQczcneOMhw5HYjY+dMsVkO2OKhbTGj",
	"CqVWbW6tu5jlAddLhc0f7dB8WfFMQqaXyiJWCVIrsHiVq23fM9AXAJzsYbuHz8g9tPordg73DRadLjLa",
	"f/gMw1LsH3sxYefyQG3iKxkylv9yjCVOx+j2sGMYIeVGnUTfTdjkfcMsbMNpsl13OUvY0nG97WepoJwu",
	"IO7NLbbAZPvibqLRsIMXntnMU0pLsSZMx+cHTQ1/GghNM+zPgkFSURRMF+YAaUGUKAw9NclF7KR+OJvG",
	"yj3493D5j+hiKe21AboX5k9rILayPLZqdIS9pgW00Tom1D4vylnzgNMxxAk58o8UMQNCnfjA4sbMZZaO",
	"Kp3ZQnzozbjGS1Sl58l3JF1SSVPD/iZD4Cazb59Esj60H3rzqwH+yfEuQYE8j6NeDpC91yZcX3KPC54U",
	"hqNk95tQ0OBURp9rC03zeFCL5+jdmKbNQ++qgJpRkkFyq1rkRgNOfSPC4xsGvCEp1uu5Ej1eeWWfnDIr",
	"GScPWpkd+vXtS6dlFELGnqw3x91pHBK0ZHCO8TXxTTJj3nAvZL7TLtwE+s/rZWluALVa5s9y7CLwQ8Xy",
	"7LcmtL2TOEdSni6jPo6Z6fh7k+mrXrI9x9EX0kvKOeTR4azM/N3L1oj0/6fYdZ6C8R3bdhPi2OV2FtcA",
	"3gbTA+UnNOhlOjcThFhtx/rWwWH5QmQE52me4zZU1s/xEyQH+VcFSseyjuIHG1eJtixzL7C5KQjwDLXq",
	"CfnJZupdAmm90ERtlhVVbl/7QbYA6YysVZkLmo2JGefkxcFLYme1fWxGRZsbY4HKXHsVHRtG8HZ/t1An",
	"nyorHoa5+zib48LMqpXGx7tK06KMRdibFie+AYbxh3ZdVPNC7EzIodWwldff7CSGHuZMFkYzrUezPB5p",
	"wvxHa5ouUXVtcZNhkt89qYunShUkN6zzxNXP7/HcGbhdXheb1mVMhLlfXDBlE7TCObSD+usXLu7q5IP8",
	"28uTFeeWUqI8etMLrOug3QNnnffe9BuFrIP4KyouSlQyhavmuDnGXtE3xN2EOb2shvY1YZ1VzCfeTikX",
	"nKX4gjdICVuD7JK97uIX2eGxc9cs5Y+4O6GRwxVN01OHBzksDibu8YzQIa5vmA2+mk211GH/1JhVdEk1",
	"WYBWjrNBNvapmJy9hHEFLp0C5v0N+KSQLV8Tcsio+zKpzdxXJCMM8R1QgH8031676xGG5Z0xjoqQQ5uL",
	"ALQWDcxFqY32xDRZCFBuPe0nueqd6TPBZ6kZrN5PfO5KHMO6asyyrV+yP9SB91I6r6Bp+9y0JeiWaX5u",
	"hRPbSQ/K0k0afVFb73AsmdQggiPepsSb+wPk1uOHo20gt43hBShPDaHBOTonoUQ53COMOi9XJ8HeOc0r",
	"S1HYgtiwnugzMMYjYLxkHJrMqhEBkUZFAm4MnteBfiqVVFsVcCeedgI0R49kjKEp7Uy0Nx2qs8GIElyj",
	"n2N4G5uUYgOMo27QKG6Ur+uEroa6A2XiOWaSdojsJwhDrcopURkGbnZShsUYh2HcPtleWwD0j0FfJ7Ld",
	"taT25FxFEg09eElFTN98sYK0sg53YXND0LIkKb4gDeRF1KLJlLk8FbM8Evt2WH8M8vBhkO1sjf/GMnYM",
	"o8R5xK8ck+Xd39jxygpre6SeummIKVFscc1tbvrf6j7nYtEG5NMaFDae8ZBkYqf7hWGb4RvIXi4Yy1jr",
	"J4oYhiR8kla8NNWPa9pnEhl59FLa5NvcfCkfzpw5RtY/EIz4tnl9T610sT6GoZDEdDCClmoXHq8paZ66",
	"9w+mTXcZG8HGM9g0m7ZkRdS+MhTDYEMYzOde7930op6WiWNvRKgPjukD9HcfeUdKypwDrTmxfcy6GN1+",
	"1PQu0XvNBncX4SJfcZDYSvqZlIYJ/BA0Zbmq80HW1Q0Cf6vR57r5WC7cyxQMHa6vpv6NCij/m4+yt7PY",
	"qhlN1jM0BFxQmfkWUcnmhWYyEAHSjam0oassDvS8npk17tN+WGHk2SS6y9NcKMYXyVBURdtjWZv7vlHW",
	"Lot3CExRhXDNQbpsh9oXJUm08O7WTXBsQoXLiX0dJKjBrDoWuMG3TW+bx1uYK4LakjTO5hwukEgoqIFO",
	"Bk+shufchOzn9ruPo/O5AjqZOSLjenpNtr6R8o5zpnpIDKl+ThzL3R6fdx2VgnFuk8mq2HsrblAZXjZL",
	"KbIqtbb+8GCAV712fjK4gZVEFYG0v8oeT8/xAe3LINr5DNZTy1fTJeXNS+b2sbY5Ze0agrc5nd2+VW0r",
	"LtPyhV3A4lbg/JzK0nhUCpEnA7fLo/6zse4ZOGPpGWTEyA7vchrI5Ubu4aWmNh9eLNc+i2pZAofs/oQQ",
	"o24VpV57S2I7K0lncv6N3jT/CmfNKvuS0+lxk1Me95baIk835G9+mM1czVY9vOFUdpDNE+kVH2Bt9CKS",
	"2XDXAgER215HQQmIykIR01Ku+Zxmp/Pd1+UipB8GQm9Ros9aip99d9+x5wkJt6wABoaMKyqA/RDvXZeH",
	"60CuVinor3PnDWjhdgD3uyC+ub30kTt86dCzXS4d8efLpjveeixC8IE9QVDJHw//IBLmruLcgwc4wYMH",
	"Y9f0j0ftz+YK8uBB9GR+svtOqw6BmzdGMb8N+X+sj2PA1djZj4rl2TbCaDmOm+RX6Br93bnYP0v6rd9t",
	"6HL/qLpMRFextHQ3ARETWWtr8mCqwCW8gzfYdYv4flHYpJVkeo2vHPyNiv0efT36E3BXjcEVt6ljRV2o",
	"oq2r5iIXFnXrphTWT8KWpyiMrEfbm8Y0ri9WtChzcAfl+29mf4PH3z3J9h4//Nvsu72neyk8efpsb48+",
	"e0IfPnv8EB599/TJHjycf/ts9ih79OTR7MmjJ98+fZY+fvJw9uTbZ3/7xtehsoA2NZ7+gTnqkoM3R8mJ",
	"AbbBCS3Z32Fts1IZMvb5rmiKJ9HcSfLRvv/p//cnbJKKIiid634duTCW0VLrUu1PpxcXF5Owy3SBd7RE",
	"iypdTv08/ay5b45qF7sNjcYdtd5TQwq4qY4UDvDb2xfHJ+TgzdGkIZjR/mhvsjd5iGklS+C0ZKP90WP8",
	"CU/PEvd96ohttP/hcjyaLoHmeun+KEBLlvpP6oIuFiAnLvGX+en80dR76KYf3P300oy6iL3/sMECgYe4",
	"nw9rbLU1tPv68opBygXlMjGMycy+dCBOfeQZ+nDtlc+wthpZR1lQqDuoCDVu1Rl/9xWVzoxlpo4lFosV",
	"Q6/fAg8XwwvqBfsawU+/u4yECr3vFDh7tLf3EYqajVujeLxcszrak1sEsW0jvjGg3eF6XOEVzQ3dQF3w",
	"doQLevjVLuiI46t7w7aIZcuX49HTr3iHjrg5ODQn2DIItu+zwl/5GRcX3Lc0IrkqCirXKHCDdF+hanU5",
	"yHLbz1yctXaYD0OQIz1ItdSyFs3Wns7GRNVFHUrJhFEcsDx0BqkEimJeSIzoabKtO8sA2CoWrw7+gfbi",
	"Vwf/IN+TodK5wfT2Rt5m4j+BjlQD+GHdlH/cyNE/F5scf7HVhr8emXdTUXNXU+KrrSmxA9O+2927iiFf",
	"bcWQr1slXdVPFCnhgiccU8+dAwnMWnc66hetoz7de/zVruYY5DlLgZxAUQpJJcvX5Fdex3TfTAWveU7F",
	"gyj7jfyn595qtOhAfQ/S4E4/tCIZsu3Gk1ZIQzYmTDeaYbwAd5Ah1L3nGTfJgCjPbCyuD45TY58UB611",
	"1h9r92PcS5kziSnpgZvmh/XR4S56eWtNQa6OmG7ewtfVyvp/VIvFtYujf0wJ0IPjB5oR/+jnI/Pm3Zjp",
	"k70nnw6CcBdeC01+xECPj8zSP6qdIE5WAbPBVNPTDz6txw4MxqXMabOWbkX9GFMxJ3Ts3vG6oj61d9/w",
	"E8sIbdaiPtcwM+zKL/pZfWKcoslk8qXwCJtqO0KXXfTe8YU7vnAjvtAlqIYj2OrK0w8YyRayg96RxLJy",
	"fyFHSZDjXIrCJ9kUZA46XdpaSV1fdoSt+KdlwzxlUwKWG/OXjncdt6j/AB3X4vy1mBhkxyge7PizdZ9e",
	"jkcpyAjx/eLj3M1nNsdYrPrZoM8zhI/t6+rh9at7l5uEKWIIVAviotmJ2cUrQfm8mbzvW0e0XM+adIfg",
	"myC4x9ReuCQI9ni5RXztho9AWpKEvEZ1CA+4fzX3VzR7fEyJ/LEX9FpwILBiCmsfWFq8czfW6kJdRLcO",
	"XQ7row2oDm2n4we9YtnltC6zO6RUvHHVYDcqFY2kZjwogR+aV2hZApXq2kJ6uzvspDPj0WGYrF/UoU6E",
	"NsV2I6AYvFzRk/gfu7gR/7reuruK0HcVoa9XEfqTXpmbgBzLqryfSHa4xme9T+vPcp9+LXiC0ha49ppf",
	"Cy2f726NDxBaVbN8mhkubC1qIVFJCPmAmuwkXmHQldBiKhjSOUzGTtimVKfLqpx+wP9gMOhlE3ZpcypN",
	"rZltk7y1tbdHtxpAcVcv/Suol/75TXg3Ukc7q5VQ1kFo6K1H+m9Oi1pWOhMXQWByU+Bt8GjYFrd6NF6L",
	"DOy47eD8ftI/itEKLqC5fyLqQx9/rOXR07Sz7+aYci8NU1otltomfI1mk647JjS1lJxY/X7b82Xbyj/T",
	"OwdCcwk0W5MZACdiZhbdbBQuslOizrG2+CvcBq5SihSUgiwJM71tAq0OE0cDn96AJwQcAa5nIUqQOZXX",
	"BNae8c2AdlOc1uDWZhx3jPtQ7zb9pg3sTh5uI5XQVF3XAsNkcnAVeCMo3BEnqHuyj7x/fpLrbl9VYjKx",
	"yDty+/WEFfjmjVMuFKSCZyo6GNYR23ZssYR+sBYFNn+2PymfslS/LXw29MTLjPxb/cCrN3ZT8LBO82dV",
	"J8iiGZRhtWGu17Cq5xLzSDFFl91928hDWArGrxP/BfkmdGBiMMNFFnfB8hydrXFFogVEg4hNgBz7VgF2",
	"w3v8ACBMNYiuH5G3KSfIvK60KEtz/nRS8brfEJqObesD/WvTtk9cLrIb+XomQIV6s4P8wmLW5vRcUkUc",
	"HKSgZ07lXrgA6z7M5jAmivHUleYbSsbACjg2rcIjsOWQdrW28Pi3zlnncHToN0p0g0SwZReGFhzTE78I",
	"re6q17auQeAj2jHbenKgXgV6Iv49vaBMJ3MhrcRMsGpExCXanv2/KNOuVom71Grh7JCu7oRlKG6cIKOt",
	"CqNTXTFhnzuBFZEwKjPVj0Lu5IFtjKVaELMwUnHN/Ps5LDrvdcwvz515pz3fac932vOd9nynPd9pz3fa",
	"8532/LG1588TUkmSxPNp/14m9lqGjL5KDf8repDyKV+QNEp/rfLjJcGo6OYcbwy10EDzqcsjjz7xaNZk",
	"G7Md5qRPzXSMkzKnWJBupf3LYaxFF1Sl8cmQbUIkw2tMg8ePyPHPB08fPvr90dNvDfdZ2sI4Ydt7vkqU",
	"0usc7ruQtDpjiY9NA04x6zKGplF/+0l92ILV5ucsB6IMsl5g80M4h9yo8tZ5ScxlpH89OgGaP3fIsVwJ",
	"lP5BZOsO4Zj1TxEVbZJpPOCMUxnJjN4nlB6StcDqCC7Vf+8GdXmrQRBxx39/w7bt1UBRsCh5b6KXrY5+",
	"V9TGjb2L08vsqUcncVnVPyvLJgiRI7OGPX0xofHdlL3u4GBbo1W48/e1hrF7xEcPHh7bsU9pSrBCsaW4",
	"VWIaLYAnji0kM5GtffVgV6ShxWVt9vxhJmtT04Or/eGOwT1137BZxOhKt0w90epFQaWvJt/q52GcNm/7",
	"Rr55fepol5W6cRBkd7g+1wiiKO4JSRZSVOV9W6eWr/FKXJSUr70ZzOiKWJcKE1Bj4Pbtcuo6a2qPz+5e",
	"Vim8r+Ar/O7vFi2Ya9XVVMpsUaV4SsNu6Z/tGG8KW2xLY+cTekaK8AyU3Olvot9lF7lYm/5Km944Ugqj",
	"U/ji7rXU/wiR8EaKc2YuzlEO2w+rahjCZKtkkAHLQtHQyZ3hZUObn76lFyet8iS78dRV4hTPG2ulS0CF",
	"rNbSIolGjLyUgmYpVfggxFUr+8gaq14dRewOCCYmjOqH7hoBPtmqWOK4O+mT7dBtNyFmdFE2M+bn1S6b",
	"8NED9/6mhY07U8BfxRTwgz98ilBMst05nEEFwR3YFL3QKx7lUlP0Eg5HvAUH4o1teau+u97wbRde48J0",
	"LgjIS0JJmjN0UAiutKxSfcopmkA7Gcg77j1v2B1WpZ77JnErfMRI7oY65RSrTteG0ahKNYdYPT0Ar7Gp",
	"arEApTuceA5wyl0rxpsK15jQPbGBnEZcG44+sS0LuiZzrIIlyJ8gBZmZW0SYhAQNikqzPHf+RDMNEfNT",
	"TjXJwTD9V8wodGY4b3OqfeSucqXHwkChCpsidqBY/U/2K75CcMv3diM0b9nPPrx5/HkSOScsG4T86NAl",
	"CDs6xJwvjSexB/sncy8VjCdRIjMS33nku7RF7hkdzxPQ/cYn6Xb9lBtlWguCjJ7q65FD1w3QO4v2dHSo",
	"prURHW+BX+v72OPUhUjMlRErY40WTC+rGaZS9o9WpwtRP2CdZhQKwfFbNqUlm6oS0un5wy36wQ34FYmw",
	"qzvJ/dcx4od0YE5LvfFYYai79wNy+RbysX7ZSVi3hijdpTy9S3l6lxTzLuXp3e7epTy9Swh6lxD0f2pC",
	"0MlGDdEl0diaoq/1dBgL9tOm7GrNwMNmrWR+fbck0xNCTrCoJTUyAM5B0pykVFnFiNtIuYItlpqoKk0B",
	"sv1TnrQgSUXhJr7X/Ndec0+rvb3HQPbud/tYu0XAeft9UVXFT7bm8vfkdHQ66o0koRDn4FJ7hUX+bK+t",
	"w/5/9bi/9OqFohUGjSu+LCFR1XzOUmZRngtzGViITnwfF/gFpAHOZo4gTNssqohPjIt00TntWoRtpbsv",
	"369QyeagQy53WUo+fvmaTQVSb8oDN47dY4h3LONTsIzPzjT+QgnV7nKnfWELCh2preSoN9Ck6hJwscry",
	"TkdqSiyGJQtRwtXFCt+9N3xcgTz3wq+pwLc/nWL68qVQejoyoqldnS/8aOQDXdgRnHApJTvH1IfvL/9f",
	"AAAA///cmmPlouoAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
