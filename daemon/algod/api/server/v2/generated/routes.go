// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"QwEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
