// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetProofForLightBlockHeader(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	StateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProofForLightBlockHeader converts echo context to params.
func (w *ServerInterfaceWrapper) GetProofForLightBlockHeader(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProofForLightBlockHeader(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetProofForLightBlockHeader, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.StateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
