// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
