// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/transactions/dryrun)
	TransactionDryRun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionDryRun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.POST("/v2/transactions/dryrun", wrapper.TransactionDryRun, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"q7qRYVijAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
