// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
