// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/transactions/dryrun)
	TransactionDryRun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionDryRun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.POST("/v2/transactions/dryrun", wrapper.TransactionDryRun, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{
	"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",
	"0A3Xd1f/LwAA//+XDSh1aaMAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
