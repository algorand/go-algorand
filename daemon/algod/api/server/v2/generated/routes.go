// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"include": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "include" -------------
	if paramValue := ctx.QueryParam("include"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//0rqJr0QMAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
