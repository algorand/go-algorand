// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/boxes/{box-name})
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, boxName string) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Path parameter "box-name" -------------
	var boxName string

	err = runtime.BindStyledParameter("simple", false, "box-name", ctx.Param("box-name"), &boxName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box-name: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, boxName)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/boxes/:box-name", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9aXPbuLLoX8HTvVVZrig529wTV03d58SZGb+TZFKx59xlnDeByJaEYxLgAUBbmrz8",
	"91doACRIgpK8xJnM8afEIpZGo9Fo9PpplIqiFBy4VqP9T6OSSlqABol/0TQVFdcJy8xfGahUslIzwUf7",
	"/htRWjK+GI1HzPxaUr0cjUecFtC0Mf3HIwn/qJiEbLSvZQXjkUqXUFAzsF6XpnU90ipZiMQNcWCHODoc",
	"fd7wgWaZBKX6UP7M8zVhPM2rDIiWlCuamk+KXDC9JHrJFHGdCeNEcCBiTvSy1ZjMGeSZmvhF/qMCuQ5W",
	"6SYfXtLnBsREihz6cL4UxYxx8FBBDVS9IUQLksEcGy2pJmYGA6tvqAVRQGW6JHMht4BqgQjhBV4Vo/1f",
	"Rwp4BhJ3KwV2jv+dS4DfIdFULkCPPoxji5trkIlmRWRpRw77ElSVa0WwLa5xwc6BE9NrQt5USpMZEMrJ",
	"+x9ekidPnjw3Cymo1pA5IhtcVTN7uCbbfbQ/yqgG/7lPazRfCEl5ltTt3//wEuc/dgvctRVVCuKH5cB8",
	"IUeHQwvwHSMkxLiGBe5Di/pNj8ihaH6ewVxI2HFPbOMb3ZRw/q+6KynV6bIUjOvIvhD8SuznKA8Lum/i",
	"YTUArfalwZQ0g/66lzz/8OnR+NHe53/59SD5H/fnsyefd1z+y3rcLRiINkwrKYGn62QhgeJpWVLex8d7",
	"Rw9qKao8I0t6jptPC2T1ri8xfS3rPKd5ZeiEpVIc5AuhCHVklMGcVrkmfmJS8dywKTOao3bCFCmlOGcZ",
	"ZGPDfS+WLF2SlCo7BLYjFyzPDQ1WCrIhWouvbsNh+hyixMB1JXzggv64yGjWtQUTsEJukKS5UJBoseV6",
	"8jcO5RkJL5TmrlKXu6zIyRIITm4+2MsWcccNTef5mmjc14xQRSjxV9OYsDlZi4pc4Obk7Az7u9UYrBXE",
	"IA03p3WPmsM7hL4eMiLImwmRA+WIPH/u+ijjc7aoJChysQS9dHeeBFUKroCI2d8h1Wbb/8/xz2+JkOQN",
	"KEUX8I6mZwR4KrLhPXaTxm7wvythNrxQi5KmZ/HrOmcFi4D8hq5YURWEV8UMpNkvfz9oQSToSvIhgOyI",
	"W+isoKv+pCey4ilubjNtS1AzpMRUmdP1hBzNSUFX3++NHTiK0DwnJfCM8QXRKz4opJm5t4OXSFHxbAcZ",
	"RpsNC25NVULK5gwyUo+yARI3zTZ4GL8cPI1kFYDjBxkEp55lCzgcVhGaMUfXfCElXUBAMhPyi+Nc+FWL",
	"M+A1gyOzNX4qJZwzUam60wCMOPVm8ZoLDUkpYc4iNHbs0GG4h23j2GvhBJxUcE0Zh8xwXgRaaLCcaBCm",
	"YMLNj5n+FT2jCr57OnSBN1933P256O76xh3fabexUWKPZOReNF/dgY2LTa3+Ozz+wrkVWyT2595GssWJ",
	"uUrmLMdr5u9m/zwaKoVMoIUIf/EotuBUVxL2T/lD8xdJyLGmPKMyM78U9qc3Va7ZMVuYn3L702uxYOkx",
	"Wwwgs4Y1+prCboX9x4wXZ8d6FX00vBbirCrDBaWtV+lsTY4OhzbZjnlZwjyon7Lhq+Jk5V8al+2hV/VG",
	"DgA5iLuSmoZnsJZgoKXpHP9ZzZGe6Fz+bv4pyzyGU0PA7qJFpYBTFhyUZc5SarD33n02X83pB/s8oE2L",
	"Kd6k+58C2EopSpCa2UFpWSa5SGmeKE01jvSvEuaj/dG/TButytR2V9Ng8tem1zF2MoKoFW4SWpaXGOOd",
	"EWjUBi5hODN+Qv5g+R2KQozb3TM0xAzvzeGccj1pHiItRlCf3F/dTA2+rQxj8d15WA0inNiGM1BWrrUN",
	"7ykSoJ4gWgmiFcXMRS5m9Q/3D8qywSB+PyhLiw+UCYGhuAUrprR6gMunzREK5zk6nJAfw7FRwBY8X5tb",
	"wcoY5lKYu+vKXV+1xsitoRnxniK4nUJOzNZ4NBjh/SYoDh8LS5EbcWcrrZjGP7m2IZmZ33fq/G2QWIjb",
	"YeLC55PDnH254C/Bk+V+h3L6hOOUOBNy0O17NbIxo8QJ5kq0snE/7bgb8Fij8ELS0gLovthLlHF8etlG",
	"FtZrctMdGV0U5uAMB7SGUF35rG09D1FIkBQ6MLzIRXp2A+d9ZsbpHzscniyBZiBJRjUNzpU7L/HLGjv+",
	"hP2QI4CMSPQ/439oTsxnQ/iGL9phzUudIf2KQK+emQeuFZvtTKYBPrwFKeyblpi36KWgfNlM3uMRFi27",
	"8IhX9hlNsIdfBO6QWN04jbwQqxgML8SqSx+Niu5gJuTVqLVDhpw0ikdCzajBYR136AqbVmXidieivLAN",
	"OgM1tp6+DBvuT3f42E61sHCs6RfAgjKj3gQW2gPdNBZEUbIcboBbLKla9hdhXpNPHpPjnw6ePXr82+Nn",
	"35nnUCnFQtKCzNYaFLnvhHii9DqHB/2VoTRd5To++ndPvbqqPW5sHCUqmUJBy/5QVg1mr0zbjJh2fay1",
	"0YyrrgHchSmcgGFuFu3EangNaIdMmRu5mN3IZgwhLGtmyYiDJIOtxHTZ5TXTrMMlyrWsbuLpA1IKGVHE",
	"4BHTIhV5cg5SMRHRqb9zLYhr4cWhsvu7hZZcUEXM3KgjrHgGchKjLL3iCBrTUKhtrNoOfbLiDW7cgFRK",
	"uu6h3643sjo37y770ka+VzkpUoJM9IqTDGbVoiU5z6UoCCUZdsRr663IwLx6KnUD3LIZrAHGbEQIAp2J",
	"ShNKuMgAn0iVivPRAQMbavbRIKFD1qyXVkqYgRHHU1otlppUJUF1e29rm44JTe2mJHijqwF9ZK1Itq3s",
	"dNZ4k0ugmRHTgRMxc0o/p47ERVK0FWjPiRwXjzxcWnCVUqSglHleWaF5K2i+nd1lvQFPCDgCXM9ClCBz",
	"Kq8IrBaa5lsAxTYxcGuhz2lK+1DvNv2mDexOHm4jleaFZanASJjmdOegYQiFO+LkHCRqDL/o/vlJrrp9",
	"VTlgz3eSygkr8KHGKRcKUsEzFR0sp0on246tadQSp8wKgpMSO6k48ICy4DVV2uqNGc9QsLfsBuexWgQz",
	"xTDAgzeKGflv/jLpj50aPslVpeqbRVVlKaSGLLYGDqsNc72FVT2XmAdj19eXFqRSsG3kISwF4ztk2ZVY",
	"BFFda1mcYaW/ONRFmHtgHUVlC4gGEZsAOfatAuyGNs0BQMwrsO6JhMNUh3JqQ+p4pLQoS3P+dFLxut8Q",
	"mo5t6wP9S9O2T1xUN3w9E2Bm1x4mB/mFxay1Zi+pkYFxZFLQM3M3oURrFdx9mM1hTBTjKSSbKN8cy2PT",
	"KjwCWw7pwGPC+csEs3UOR4d+o0Q3SARbdmFowQMvm3dUapayEiWJv8L6xh/c3Qmi+hmSgabMSNvBB2Tg",
	"yHvr/sRaLLpjXk3Q2kkI7YPfk0Ijy8mZwgujDfwZrFFR+86awk8CA/oNSIqRUc3pppwgoN7AZi7ksAms",
	"aKrztbnm9BLW5AIkEFXNCqa19W1oC5JalEk4QPSBv2FGp+CxZmS/A7tonI5xqGB5/a0Yj6zYshm+k47g",
	"0kKHE5hKIfIdFOE9ZEQh2ElRTkphdp05Vxrvb+EpqQWkE2JQu1czz3uqhWZcAflvUZGUchTAKg31jSAk",
	"slm8fs0M5gKr53Qq8QZDkEMBVq7ELw8fdhf+8KHbc6bIHC68/5lp2EXHw4f4SnonlG4drht48ZrjdhTh",
	"7aj5MBeFk+G6PGWy9WnvRt5lJ991Bq/VJeZMKeUI1yz/2gygczJXu6w9pJElVcvta8dxd1JqBEPH1m33",
	"XQoxvyFFWtz/AB8nzqXAtCLzilugKuWeI2hl8woNMR/XPibWt3yfoAPCknptnPvz8bPvRuPGcaD+bu5k",
	"+/VDRKJk2SrmHpLBKrYn7ojha+qeeXqsFURtcsiYxTziIQbyLHcr67AOUoA502rJSjNk482y1tDyhP2/",
	"9/9j/9eD5H9o8vte8vzfph8+Pf384GHvx8efv//+/7V/evL5+wf/8a9RtaJms7j68yezS2JOHItf8SNu",
	"zSdzIe17bO3EPDG/fbi1BMig1MuY62kpQSFrtC6kpV42mwrQ0aGUUpwDHxM2gUmXxWYLUF6ZlAOdowsk",
	"vinELibZ+jhYevPEEWA9XMhOfCxGP2hgRNrEw2weHfn6BoQXOxCRbXz6x7qyX8U89Nt1B0WtlYair++y",
	"XX8bkPbfe1m5d6gEzxmHpBAc1tFQFcbhDX6M9bbX3UBnFDyG+nbfEi34O2C159llM6+LX9ztgL+/q83q",
	"N7D53XE7qs7QYxlVNZCXhJI0Z6jIEVxpWaX6lFN8KgbkGjEn+QfwsPLgpW8S11ZElAluqFNOlcFh/YCM",
	"qsDnELmyfgDwOgRVLRagdEdongOccteKcVJxpnGuwuxXYjesBIk2nYltWdA1mdMcdR2/gxRkVum2GImX",
	"ntIsz53e1UxDxPyUU214kNLkDeMnKxzO+y96muGgL4Q8q7EQv6IWwEExlcT5/o/2K7J/t/yluwowysV+",
	"9vzmtvm+hz3m9ucgPzp0T6yjQ5SjG41rD/ZbU8MVjCdRIjNyUcE4eo93aIvcN68BT0APGt2t2/VTrlfc",
	"ENI5zVlmZKerkEOXxfXOoj0dHappbURHq+LX+iHmtLAQSUnTM7QajxZML6vZJBXF1D8tpwtRPzOnGYVC",
	"cPyWTWnJpqqEdHr+aIucew1+RSLs6vN45LiOunFFjBs4tqDunLU+0/+tBbn346sTMnU7pe5ZH2A7dOC8",
	"GdEGOP+klsHKLN7GsFkn6FN+yg9hzjgz3/dPeUY1nc6oYqmaVgrkC5pTnsJkIci+d3k6pJqe8h6LHwwz",
	"DZzNSFnNcpaSs/Aqbo6mDR3qj3B6+qshkNPTDz3rR//idFNFz6idILlgeikqnbjYiETCBZVZBHRV+8bj",
	"yDayadOsY+LGthTpYi/c+HFWTctSdV1l+8svy9wsPyBD5RxBzZYRpYX0TNBwRgsN7u9b4Z5ckl74wJpK",
	"gSIfC1r+yrj+QJLTam/vCZCW7+hHx2sMTa5LaOmNruTK29UZ4cKtQAUrLWlS0gWo6PI10BJ3Hy/qAjWU",
	"eU6wW8tn1ftY4FDNAjw+hjfAwnFp/ztc3LHt5YNc40vAT7iF2MZwp0bxf9X9CrxYr7xdHU/Y3i5VepmY",
	"sx1dlTIk7nemjn1bGJ7srTGKLbg5BC5McAYkXUJ6BhlGLEFR6vW41d0b/NwN51kHUzayz7rZYfgJqthm",
	"QKoyo04GoHzdjQNQoLUPfngPZ7A+EU30ymUc/9vu6GrooCKlBpeRIdbw2LoxupvvjMfogluW3qsbPRg9",
	"WezXdOH7DB9ke0PewCGOEUXLXXoIEVRGEGGJfwAFV1ioGe9apB9bnhFvZvbmi6h5PO8nrkkjtTkDcLga",
	"9AK33wvAMGFxociMKsiIcBGu1uU64GKVogsY0D2FWs4dHZtbmlEcZNu9F73pxLx7ofXumyjItnFi1hyl",
	"FDBfDKmgmrBj9vczWUU6rmBCMHGFQ9gsRzGp9jiwTIfKlrbZRuIPgRYnYJC8ETg8GG2MhJLNkioffIsx",
	"yv4s7yQDfMEQgk0RY0eBxToIRK7jwTzP7Z7Tnt7WxY35YDEfIRYqbXeI9hqPnBNVbDsERwEogxwWduG2",
	"sSeUJpyh2SADx8/zec44kCRm/KZKiZTZ6OnmmnFzgJGPHxJidU9k5xFiZByAjQYiHJi8FeHZ5IvLAMld",
	"OAb1Y6NpKfgb4p6A1r3JiDyiNCyc8QHHNM8BqPOYqO+vjt8ODkMYHxPD5s5pbticU6I2g/Til1Bs7UQr",
	"ORPlgyFxdoPqz14sl1qTvYqusppQZvJAxwW6DRBvFiViW6AQX+7pW+Nq6C7dZeqB63sIV/eDyKcrAdDR",
	"RDTJgdzLb+sLrX0392+yhqWPm1Be75kZo/0h+onu0gD++orgOlbpXfe6jj7S26bLdphWID/FWLE5I33V",
	"aF8BqyAHlIiTlgSRnMUU5kawB2S3x75b8HLHYDDK1w8Ce7iEBVMaGtWVuZW8Lva2zV0Ug8+FmA+vTpdy",
	"btb3XoiaR9sgR2u+C5d56ys4FxqSOZNKJ6j3iy7BNPpB4YvyB9M0Lii0Le42DwvL4rwBpz2DdZKxvIrT",
	"q5v3r4dm2re1EkZVszNYozgINF2SGeYNivrhbJjaumptXPBru+DX9MbWu9tpME3NxNKQS3uOb+RcdDjv",
	"JnYQIcAYcfR3bRClGxgkXvyHkOtYxFIgNNjDmZmGk02qx95hyvzYmx5KARTDd5QdKbqW4LW8cRUMvQ/M",
	"c4/pIO1OP2xg4AzQsmTZqqMItKMOPhfppV77Pqy5gwXcXTfYFgwESr+YZ6oE1Y5gb6Rbm0CJh2ub7ISZ",
	"k3acecgQwqmY8un/+ogypI05qrbh6gRo/ldY/820xeWMPo9H19MbxnDtRtyC63f19kbxjAYxq0dqmQEu",
	"iXJallKc0zxx2tUh0pTi3JEmNvfK2FtmdXEd3smrg9fvHPifx6M0ByqTWlQYXBW2K7+ZVdlg+YED4tOL",
	"mQePl9mtKBlsfh3EHGpkL5bgUjkF0mgv9USjbQ+OotPQzuN2+a36VmcYsEvcYCCAsrYPNLorax5omwTo",
	"OWW5Vxp5aAds6Li43fKXRLlCOMC1TQuBhSi5UXbTO93x09FQ1xaeFM61IdlUYfOpKSJ41yXLiJCoi0JS",
	"LSgmjrAqgT5z4lWRmOOXqJylcQUjnylDHNwajkxjgo0HhFEzYsUG7JC8YsFYppna4aHbATKYI4pMn4Rk",
	"CHcz4RLhVpz9owLCMuDafJJ4KjsHFTN1OFVz/zo1skN/LjewVU83w19HxgiTpnRvPARis4ARmql64B7W",
	"T2a/0FodY34I9PGXsHaHM/auxA2Wakcfjpqty9CybW4K89b2+Z8hDJvjbHvSXP94ddlbBuaIJsFlKplL",
	"8TvE33n4PI64rfs0MQy9Jn8HPolE/3RZTK3daXL5NrMPbveQdBNqodoW+gGqx50PbFKYksOrZym3W21z",
	"Urb8QuIEE/pyTe34DcE4mHv+bzm9mNFYvhIjZBiYDhrrZ0uRrAXxnT3unc6bucw9ExIYUuu2zAZ0lSCb",
	"iJJ+8PAVBQY77c6iQiMZINWGMsHYGr9yJSLDVPyCcpva1PSzR8n1VmCVX6bXhZAYjqniOu8MUlbQPC45",
	"ZIj9dvhqxhbMJvasFASZI91ANiOypSKXfdPalxvUHM3J3jjITet2I2PnTLFZDtjikW0xowo5ea2IqruY",
	"5QHXS4XNH+/QfFnxTEKml8oiVglSC3X4vKktNzPQFwCc7GG7R8/JfbRZKXYODwwW3f082n/0HJWu9o+9",
	"2AXgMvhu4iYZspP/dOwkTsdotLNjGMbtRp1Egwtt2vVhxrXhNNmuu5wlbOl43fazVFBOFxB3kyi2wGT7",
	"4m6iIq2DF57ZnMFKS7EmTMfnB00Nfxrw+TTsz4JBUlEUTBfOsqFEYeipSQtpJ/XD2QTELneRh8t/RANh",
	"6e0jnUfk7SpN7f0WWzWacd/SAtpoHRNqY3Bz1pjufboxcuQj+TGZU53DyeLGzGWWjmIOWvLnpJSMa3xY",
	"VHqe/IWkSyppatjfZAjcZPbd00gCq3bWGH45wG8d7xIUyPM46uUA2XsZwvUl97ngSWE4Svag8bEOTuWg",
	"JTPuLeY5etdZcPPQuwplZpRkkNyqFrnRgFNfi/D4hgGvSYr1ei5Fj5de2a1TZiXj5EErs0O/vH/tpIxC",
	"yFhel+a4O4lDgpYMztFxLb5JZsxr7oXMd9qF60D/dS0PXuQMxDJ/lmMPgRci8jp9IVaWDr0m3TlqR7QD",
	"Q8fUfDBkMHNDjUk7W9ftG/288rlvfDJfPKz4RxfYr7yliGS/gugmVizP/tYE/nQSOUrK02XUeDMzHX9r",
	"Em3Xi7TMOJoLZkk5hzw6nBV8fvMCUkSE+7vYdZ6C8R3bdhM02uV2FtcA3gbTA+UnNOhlOjcThFhtR0LU",
	"rrP5QmQE52kSjzSsop9zMkiD9o8KlI5FXuIH676DSjrzuLNZuAjwDJ9GE/KjLZSzBNLKi4BPElZUuY2x",
	"h2wB0mmPqzIXNBsTM87Jq4PXxM5q+9issTYL2AIl8vYqOsqZIEvRbo6gPgFs3El993E2e82aVSuNaUqU",
	"pkUZiz8yLU58AwxyChXWKKuH2JmQQ/tMUl4It5MYepgzWZjnRT2avaiRJsx/tKbpEt8fLf4xTPK7p6/z",
	"VKmC2gJ1quA60RCeOwO3y2BnE9iNiTCPxAumbH0UOId2yFMd/+fevz4Eqr08WXFuKSV60W6KT70K2j1w",
	"1ivB67SjkHUQf0np02Z/vGw2v2PsFc3c0U0N2CsqYEPD6yy3vu5VSrngLMW8GbF7yNVa2cXgs0OKka5G",
	"0R9xd0IjhyuakLD2CXNYHExR6BmhQ1xf4xx8NZtqqcP+qbGox5JqsgCtHGeDbOzzajqlF+MKXOIoLLsT",
	"8EkhW0Y05JBRu2xS6+8vSUYYADHwivnBfHvr3rjoGXzGOEqzDm3OCdmqpbAUhDYiMNNkIUC59bTzK6hf",
	"TZ8J5hjIYPVh4ktH4BjWBmWWbQ2u/aEOvPnVmTtN25emLbGuo/XPLV9TO+lBWbpJh7OuRuUBveKDCI6Y",
	"0RJvxwiQW48fjraB3Db6TeB9aggNztHqCiXewz3CqDOQdhI+GwnNUhS2INZfKRoky3gEjNeMQ1PYJHJB",
	"pNErATcGz+tAP5VKqq0IuBNPOwGao6k1xtCUdnr26w7V2WBECa7RzzG8jU3y1AHGUTdoBDfK13U9FUPd",
	"gTDxEgs5OUT2U6GiVOWEqAx9xzvJUWOMwzBun365fQH0j0FfJrLdtaT25FzmJhoKB5xV2QJ0QrMslnHv",
	"BX4l+JVkFUoOsIK0qjOWlSVJMey+nYegT21uolRwVRUb5vINrjldKmJy9FucQHnn+GbwCUH2a1jv4at3",
	"71+9PDh5dWjvC0VUZeMBjcwtoTAMcUKOuNJgROdKAfkYovEj9vvYWXAczCApcoRow8TMnhAxKmK2xn9j",
	"WcWGCcg5RlzaNc97QWDHS4v37ZF6wrk5eolii2R3TODVd310NFNf7Tw2/W/0QOZi0QbkltP/bGLG4R7F",
	"2PArc7+Fofy9VHn2Bqwj7dERTvjqDvi6rWNE28wTb9xe7jw0wNSp8jfrS4aT3o/xjh5whw2SHlErBliL",
	"3pBTbDrow021C6XSlGzklJipPjaC9aixGfJtac+oNnPIi8Y60ZjPvd67CbC95wCOvRGh3j2rD9Bfve8n",
	"KSlz5uqGWfQx67zEh1V4mw5ds8HdRTjf60EtWi8l5mYK6fneB/EjNnPhZPccDge1LwBaKDHv/AK4Szzf",
	"9qrd2bdvPodUs/MtsQ7/aZ4WjR/92D8+bE2VIPSB1b5ivgLsJd9EDUCbQhE2whMkirk2OEOezmewvqdI",
	"ixqiqRTHnlCvEiKMGMAkOokhEaFitjarLXHmD6ZqykAseNu27Q5N/rLBHNZB5M4V5/IkSWgYzbNhynMR",
	"e27tNJfpeqkYN3R7GgqH6GeRHb69DjFpr6rrD9QlXgNR1LyquykOL1yIMkam1ApCH6wMyv/mw9DsLLZ0",
	"cJNlG9WxF1RmvkX0feGfLsmAg2HXZd9GRrA40PN6ZtZ4IvW91iOpPdDfLM2FYnyRDDnttZ1/wupjaOJE",
	"TQ6m50W45iBddn3tKzMnWnjPpU1wbEKFq5R1FSSowUSVFrjBIPf3TRQ/5jOjti63M9+GCzSPDWqgk0Gs",
	"/fCcm5D90n73bto+n9UOzyhHr8nWYHnvg8ZUD4kh1c+Juy23u39f5anCOLfFS1Qs8J4bVIYqv1KKrErt",
	"BR0ejOZhuGtaiw2sJCrlp/1V9gS2HJO8vA6Cac5gPbVCU7qkvMm20z7WNv+mXUMQvNrZ7Rt9xcUF1nxh",
	"F7C4ETi/5ktoPCqFyJMBHd9RP39A9wycsfQMMmLuDu+9MZDHmtxH1VJtxLlYrn28fFkCh+zBhBDzlipK",
	"vfb2nHbmvM7k/J7eNP8KZ80qm9LDPdImpzzueGQr3V+Tv/lhNnM1BYb5XXMqO8iWAP3VQO4CSS8iWd13",
	"LRsYsbB0M203RGWhiEkpV4zW3Ol89x9qEdIP42y2vH/OWq86mxuqY1UREm74dReoky/5uutHEO26PFwH",
	"crVKQX+dO29AC7cDuN8F8Y1qoo/cYY2Cnu2iUYjnsTHdUaVhEYJJoAiCSj4++kgkzDEppCAPH+IEDx+O",
	"XdOPj9ufzevr4cPoybw1ZUarPqCbN0YxfxuywltL84DDR2c/KpZnW2t3hu47TYJWdFD5zXmrfZUUsb/Z",
	"J3L/qLpsmZdRo3Y3ARETWWtr8mCqwDFnB58c120SreCoIK0k02sMovMvKvZbNDnBj7USxpW8rcMunNe/",
	"FmdQh2E2KptK+ZR4Pwpb8bEwdz0qsTWWsHi1okWZgzso39+b/Ts8+cvTbO/Jo3+f/WXv2V4KT58939uj",
	"z5/SR8+fPILHf3n2dA8ezb97PnucPX76ePb08dPvnj1Pnzx9NHv63fN/v+eL8VtAm0L3/4V5lJODd0fJ",
	"iQG2wQktWV25xpCxz8lKUzyJ5k2Sj/b9T//bn7BJKopmeP/ryHmEjpZal2p/Or24uJiEXaYLfKMlWlTp",
	"curn6VcMeXdUOzrZKCPcUevDYkgBN9WRwgF+e//q+IQcvDuaNAQz2h/tTfYmjzD1eQmclmy0P3qCP+Hp",
	"WeK+Tx2xjfY/fR6PpkugOebDN38UoCVL/Sd1QRcLkBOXnNb8dP546v0kpp/c+/SzGXURCy+0LlthSe9e",
	"zlan60K7l3XJauVAUy4l17jOjOfER56hJ4198hnWViPrKGuy4BwFdYBdLKBNjrD/ayRX+JwtKtmptVVr",
	"813aTKaILZwqyRurc39H07PQWwUJ8h8VyHVDMI6VhVH9PouZ82kp1KJsG4AbTX+sKk8s+S3ObPY5oNRa",
	"VdRwIi0rCCFp+KrhlXvJ8w+fnv3l82gHQFBv6SpPf6R5/tEWQ4MVKn/aReDVOJKxC4W6caN66NR5H6MF",
	"u/4aJmWt27T9pj5yweHj0DY4wKL7QPPcNBQcYnvwAaMSkBLwED3e2/sCteLHrVE8SXzVovNPb3ChbQva",
	"tZfbHa5fCZxmmCgTlLZLefTNLuWIo+nAcHxib7TP49Gzb3hvjrjhOTQn2DII+evfIr/wMy4uuG9ppJmq",
	"KKhco6wSZPMNpdLPg7fVNMw8OP3UUixn17rLeklXjw63XG/31BBT7OfC6CQ2NN/r1H2oenTZG2HFlFYP",
	"JuTHsDcyZgwtsYEbleRNebBSinOWGRbrbHI+AreB7Z4Ko26il23wWr+7d7/ovXvQ1jq0kinEgGmR+EaY",
	"epan6158fS+xTl76K+V9D1IoXiER1RdNjtstJD9UsXMHBnuHu6FqpwPiTQBvLem0U19+eb5r32/BNdG6",
	"D74gV/7GhbU3NDd0Eiy347FuM4zcCXH/NEJc7Yxgy8tgUq1NYh1mzp1+8glhbkCUcwlxdhDiwpdu0DdI",
	"WHK/wykeTGx2l7DN1diBcyzYKp5hmp47wexLC2b9/FYxMJqsRV9PGEMYlk0CrMvUdGnlq75Uoq5vVPr6",
	"J0bWoLhlIN0uaF2BN/aEKMeJvxjP/FMKTw5pd2LTP7XYZH35NghOreRzzvFzWHaCoNR8UL6n5Xg2W3s6",
	"HBMlpHN/KiUTkun1mDBOMjBnDy2GQmKIdlO03jkZAcf/vjn4L3Q9fXPwX+R7sjeuRTCMYItMb5172jLQ",
	"j6D7PmzqxfqgFgc2ykJ/GAHjpEZS4F0aol4Lnz8OkVbQ1fdDKFtZu2JMPCvoarRREhl/O9LidYWmTuxp",
	"n4pc3Vg0+vtaR22XKkVgRVOdrwnF+2dtfX+xnL5P/tYWN7Qok3CAaLzRhhl9KZVY1NhlvboiAf5YsmQz",
	"fCedRFktdLgki1i3aLtg0kNGFIKrSXl3u/vN7m5fLCWlMGeaYQKJ5j7xd1ULyKaghgN3wGF1Qv5bVOjs",
	"YuvFQSyDLc6Azr1+TieABimoc6zWV2Pn4cPuwh8+dHvOFJnDBXJQyrFhFx0PH/4JRNZVnTiUEi54wrGc",
	"2TmQwEPuTm79Q8utz/aefLOrOQZ5zlIgJ1CUQlLJ8jX5hddJeq4nltc8p+JB2qSN/KfnKd9I0YH4fi3b",
	"ddc2zXQjGbYCpwIVQl110r2Vx03ZCvOWx+QqPmBdjb3pBB3/rFXF7se4Z1iZxIT0wILzYn10uItc/o0Y",
	"QndO8hW51+J786VvgKg/zfvb8afZjZk+3Xt6exCEu/BWaPIDqsu+MEv/orqDOFntyGymM7ECNf00EytM",
	"S7SV+/AO+0GG0OTKDHgRpiQP83Faf+H7rhBcmKbywVYuIlYv1m9t2qQ/Civpmw3q5cYn8zjeZZpbcVl8",
	"IVZRBiFWdwzqqzEog/0/BWOatcnIGQNqK3AThVQzqkubfhvTbigDuYjpjdKP5VY2DTjmpV6TOqLRCD5W",
	"YrOFgPqMycywq2DzBzYk7lACP3KBdtF7xx/uBJhrCTBdgmo4AuYFUdNPaNMM2UHvSL4wLf9EvhCBYViK",
	"wluGBZmDNtKTWW03fi/CVnxS02Gesql+yw07KiDQkZx6uBYXo4Z1RXaMXMaOP9mQsc/jUQoyQnw/+8Rd",
	"5jObY/x5nbDWlylCuzPzmfvrpP2utAlTPjjGpeciZhcvBeXLZvJ+PCGi5SacG+4QfDkE95jaK1dDwR4v",
	"t4g/Q/iMz82ekLcoDuEB9/la/4z62S95I3/pBb0VHKwDjZFYLS3e+UrU4gKqFRApPl2LfVK44ulx0aHt",
	"HfFJr1j2eVrnExsSKt5hgy1CRXNTs6a+dFsPTMsSqFRXvqS3qx5OOjMeHYYOZa30Z3XiswgoBi+XdHn4",
	"t9GO0gxGJoo5WVK1JPOKW0DrSoboW+e9vcR8XFuVzGkQ831yyh8StaTPHj3+7fGz7/yfj599NyCPmXlc",
	"ooS+RNYMZD7bYXYRy/68/hFtUaJG3v5tb+Xldmg8YtkqmusIVj5lW3gunJEGmcM9RUq6HkyRNpBt8A3I",
	"s9ytrGONJgWYC1UtWXn7Na2UZrN4fb+fzC6JOakLNhzxFzX/PAfJ5liksuYLt5zCSgJkUOrlxtwxtsZm",
	"qZfNpoKrAs2Uy9FVSnEOfEzYBCZdq322aHKf50DndY4nIXbxqQ14iaE3TxwB1sOF7CJqvovRD8Ztu1yY",
	"t61UaXxP7WXmkSc798pX1bjor6JxeSt4gvIYcO3fBi20fD3tC6blGgcKzroEDhcaFZtCohgZsi012UkA",
	"g0GreIsHWrXuIBk7cSylOl1W5fQT/gdTpHxukpHYek9Tq4jdJJEd2xY36gtoxySyzW18Vh6nHBZz8oal",
	"Uhxg+jZ3jai10lD0Szrbrr9tqiQUvXIEzxmHpBA8ltDnZ/z6Bj9GE8Shf9FAZ/T0GurbLcTXgr8DVnue",
	"XVjddfE7+WMoea/1YOmsVkJZ+1Oj4xnSf3NaWhm6m2PS+nn6qfWns5e4lmpZ6UxcBH1tAp6NZ8u2uNGz",
	"9VZkYMdt57yKObpzkYHLE9Q/UjXXiEukHr9Nu45wkNJqsdS2JHG03nndMaGpPQo2ybXalhXYtvLZL8+B",
	"0FwCzdZkBsCJmJlFt7OrE6rqGvNIHJY3xpPbNnCVUqSgFGRJWMZuE2h19iWUfPQGPCHgCHA9C1GCzKm8",
	"IrCWSWwGtFuEtwa31hQ6PtCHerfpN21gd/JwG6kE4hkivmhEUebg3jQRFO6IE5S12RfePz/JVbevKrFS",
	"WiQ9s/16wgpMMMQpFwpSwTM1nER927HFtOnBWhTYCu/+pEQLUJmBB67W11RpV6ivlWs2SL5vptiQ9X0o",
	"c6IZ+W913sTe2Knhl1xVqqlhaGUvyKI1vmG1Ya63sKrnEvNg7Fq408K8treNPISlYPy6qmGQxl0HWiwz",
	"XGRxGK1HnSjWR2ULiAYRmwA59q0C7IYalgFAmGoQXedmblPOTIgcKLdvZFGW5vzppOJ1vyE0HdvWB/qX",
	"pm2fuFyUE/L1TIAKBW8H+YXFrC1YuqSKODhIQc+czL5wwUZ9mM1hTBTjqas9MRRIygo4Nq3CI7DlkHbF",
	"vvD4t85Z53B06DdKdINEsGUXhhYcEzT/EGLhZd99Xb3dF1SVtwXtQLxqBE379/SCMp3MhXR1Pehcg4xY",
	"3TtpAynTyj3/7KtYC6fqJjiCYyhunKBcrwojNSwIPlrQ7H7f58ZM9YOQOxn5G328FsQsjFRcM5/ywZy3",
	"Wsb841nM76TnO+n5Tnq+k57vpOc76flOer6Tnr+09Px1vHZJkng+7U3DschRMvomJfxvKDjzNqMpG6G/",
	"FvnxkWBEdHOON3rzaKD51BXJR2+FaOlkGxYQFtxPzXSMkzKnRhqClfZZNDoRSHWxXltnBIOaqIInj8nx",
	"TwfeUWHpLOnttvd9CUyl1zk8cF6PdSEA7/4InGJpYPR+pP71kzqHEhciwXIgyuDqFbY+hHPIjSRvjZ/E",
	"vEX6r6MToPlLh5stj6NWqncz2sdx603m0FbQ0os8fq1UEYpOLZ1M7XOaq+FU7Xa8gpaxPCQ1n7bPJmQN",
	"L0S27pC72bUpbmCb0Bs/BcapjBSr75N3jzS0MMzHEVb/3ff5xp1q+kTbJ7NtFBaveRUvKr+JyqNuJPWG",
	"9YayHk3zDp1E65R0fSdGNYC7GAwNPfs9Ia5a/le9rQhC5I5Yw5n/MIEn3SKgjmlgWyNQOdbzrQaJeMRH",
	"Ty+e/bEvkkiYVsRR3CoxjRbAE8dbkpnI1kmLM7UvmKZ2+NZLJmSNeJjqe8V82XwFfZ0bIqhPP9rEbkN6",
	"WCWOtw4wXusgthvbrbGFIzrOG2D8S3PfIQ4ZgkAc64m9nbtpFi/Jz4K69Hc87Y6nBaexc9kz7nwTu0xk",
	"cjWeJtey4sPs7JWtbKpIeEjvqweGZSFGV7qluc9gVi0WtpxnVwuN6f7qqrRfh8vZ5e7K4C5HHHbwOvT0",
	"ulET3eH6jCNwqrsvJFlIUZUPbPJVvkYFZ1FSvvZGDfPyL6rcVenGSK+b5aF1adme3OiVa8N6uXde/RZo",
	"n9wt2v7dogUL0tr9hYxUPAMZr/u46lTz247xkxVvOPDGWn++6mlvdW7eXbi/32UXIVAbckpbA9oeqHag",
	"vPVTtid3chde/c9xI7yzSY4HGGzfy7ZhCNsvBhmwLLwZOlkB/dXQ5qfv6UWYY/CmhMbdX+tLwDuxfr1G",
	"UigaMVIKmqVUoVKDg74Q8uwLy5J6dRTRIiOYmAq3H3hi3iSTrUIljruTSNmO9fKv8mpWMGXLh35d4bKJ",
	"JjhwAbstbNwpdv8sit0X/vApQrESeedwWhsOnskd2BS90Cse5VLT0qbSH/JfDg6ES7p/o54YveHbDhlB",
	"IntrUIa8JJSkOUNzs+BKyyrVp5yiQatTpr3jrOHNdMOi1EvfJG5TjZg83VCn3AhVc1KbuaIi1RwiBuwf",
	"ALzEpqrFApTucOI5wCl3rRgnFWca58Kq94n16zfXteHoE9uyoGsypzlaZH8HKcjMPCLC9IpoHlKa5bnz",
	"DjHTEDE/5VSTHAzTf8OMQGeG8xaE2uPJ0l2NhXicn6ujm8S1sz/arxhD55bvrQBorLCffbTL+OtUu05Y",
	"Ngj50aFLfXx0iNksG7+QHuy35ixQMJ5Eiczc+M6/qktb5L6R8TwBPWg8TNyun3IjTGtBkNFTfTVy6Bp1",
	"e2fRno4O1bQ2omP79Wv9EMtmsRCJeTLShfl9wfSymmG9aZ/lYroQdcaLaUahEBy/ZVNasqkqIZ2eP9oi",
	"H1yDX5EIu7q7uf88JtmQDsxpqTceS7x0937gXr6BShN/7PISWx1O74o53BVzuEv3f1fM4W5374o53JU6",
	"uCt18M9a6mCyUUJ0Wbe25vTVPdUmJRJSO3PNwMNmrey/fask0xNCTpaG/1NzB8A5SJqTlCorGHHr91yw",
	"xVITVaUpQLZ/ypMWJKko3MT3m//aZ+5ptbf3BMjeg24fq7cIOG+/L4qq+AlNTeR7cjo6HfVGklCIc3C5",
	"QLF5VqH7i+21ddj/VY/7s+xtXUHXVrmypGUJ5lpT1XzOUmZRngvzGFiIjrc2F/gFpAHO5j0iTNv6EIhP",
	"9HJ3PjHUZROJCd39+/0S1W0PutlpbjWt2Z9XwN7Ep/obdnM8cOPYPYZ4xzJug2V8dabxJ8rAepds9Q+2",
	"oNCQ2sqmfg1Jqq53HNE7eRnJqpMNb8YRIK0k02u84WjJfjsD8/8Pho8rkOf+8qtkPtofLbUu96dTLMy0",
	"FEpPR+Zqar6pzkdzP9CFHcFdLqVk55gr+cPn/x8AAP//reBdAswgAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
