// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryRun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryRun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryRun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
