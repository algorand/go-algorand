// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context, params GetSupplyParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
		"round":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"round":  true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSupplyParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
