// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
