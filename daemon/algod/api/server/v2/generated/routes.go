// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"HcEdLqVk55g78cPl/wsAAP//K7GmSonxAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
