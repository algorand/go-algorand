// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{addr}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, addr string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{account-id})
	PostV2RegisterParticipationKeysAccountId(ctx echo.Context, accountId string, params PostV2RegisterParticipationKeysAccountIdParams) error

	// (POST /v2/shutdown)
	PostV2Shutdown(ctx echo.Context, params PostV2ShutdownParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "addr" -------------
	var addr string

	err = runtime.BindStyledParameter("simple", false, "addr", ctx.Param("addr"), &addr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter addr: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, addr, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// PostV2RegisterParticipationKeysAccountId converts echo context to params.
func (w *ServerInterfaceWrapper) PostV2RegisterParticipationKeysAccountId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV2RegisterParticipationKeysAccountIdParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostV2RegisterParticipationKeysAccountId(ctx, accountId, params)
	return err
}

// PostV2Shutdown converts echo context to params.
func (w *ServerInterfaceWrapper) PostV2Shutdown(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV2ShutdownParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostV2Shutdown(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:addr/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:account-id", wrapper.PostV2RegisterParticipationKeysAccountId)
	router.POST("/v2/shutdown", wrapper.PostV2Shutdown)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
