// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"6gAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
