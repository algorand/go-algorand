// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"5QJvr/4nAAD//81+WVTXoAAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
