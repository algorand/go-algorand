// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
