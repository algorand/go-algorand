// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"6MqO4C6XUrJzTFP87sP/DwAA//+73x3xThgBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
