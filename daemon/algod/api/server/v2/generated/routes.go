// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"+n8BAAD//xPzNdQbEQEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
