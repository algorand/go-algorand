// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryRun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryRun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryRun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
