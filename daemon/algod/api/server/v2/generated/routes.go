// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
