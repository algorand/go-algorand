// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Sud2BOfgKyW7wGr1H67+fwAAAP//rYSwcWn0AAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
