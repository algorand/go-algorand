// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/compile)
	TealCompile(ctx echo.Context) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.POST("/v2/compile", wrapper.TealCompile)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+w9/XMTOZb/is63VQOsOw4QZodUTe0FGGZyCwxFMrt7R7hdufvZ1qRb6pHUcTwc//vV",
	"e5L6w622A4SP3PonSLda0nt63x/y21GqilJJkNaMDt+OSq55ARY0/cXTVFXSJiLDvzIwqRalFUqODsM7",
	"ZqwWcj4ajwQ+LbldjMYjyQtoxuD345GG3yqhIRsdWl3BeGTSBRQcJ7arEkfXM10mc5X4KY7cFMdPRu82",
	"vOBZpsGY/i5/lvmKCZnmVQbMai4NT/GVYUthF8wuhGH+YyYkUxKYmjG76AxmMwF5ZvYCkL9VoFctKP3i",
	"m0Hi+VxpLrNkpnTB7ehw9Orp4/v37z9kJ27Qu6uO8uslWuXQh/ixKqZCQoAPavDqo2VWsQxmNGjBLcO9",
	"ItRhoFXMANfpgs2U3gK020QbcpBVMTp8PTIgM9B07imIC/rvTAP8Donleg529Ga8hqZ3CNzMgk6sKCKg",
	"Hftz1GCq3BpGYwnGubgAyfCrPfa8MpZNgXHJXj19zAh5DpsWMk+ug1A1q7dhqg8j4xbC6096xMZAnO2O",
	"8A07fjIEQPgwQoxCWpjTOXT4CL+IsFfzeAozpeGKZ+IGX+uhtNf/oqeSVlqDTFfJXAMnQllw2UfJK48K",
	"s1BVnrEFvyC4eUHy0n/L8Fsnfy54XiGKRKrVUT5XhnGPwQxmvMotCwuzSubIoTibP2gmDCu1uhAZZGMU",
	"YcuFSBcs5cZNQePYUuQ5or8ykA2hOQ7dBjp610YJ7uuD8EEAfb3IaODaggm4JEZI0lwZSKzaIpmDsOUy",
	"Y21Z2ohp835ymp0ugNHi+MJpLMKdRILO8xWzdK4Z44ZxFqTymIkZW6mKLelwcnFO33toEGsFQ6TR4XRU",
	"CGrxIfT1kBFB3lSpHLgk5AWm66NMzsS80mDYcgF24cW9BlMqaYCp6a+QWjz2/zz5+QVTmj0HY/gcXvL0",
	"nIFMVTZ8xn7RmPL61Sg88MLMS56exzVVLgoR2fJzfimKqmCyKqag8byCaLSKabCVlkMbcjNuobOCX/YX",
	"PdWVTOlwm2U71g6SkjBlzld77HjGCn75/f7Yb8cwnuesBJkJOWf2Ug5aOrj29u0lWlUyu4L6tnhgLYVh",
	"SkjFTEDG6lk27MQvs20/Qr7ffhqjorWdMMngdupVtmxHwmWEZpB18Q0r+RxaJLPHfvGSi95adQ6yFnBs",
	"uqJXpYYLoSpTfzSwR1p62Eal3SkLSalhJiI0duLRgdLDjfHitfC6PVXSciEhQ8lLm1YWnCQa3FNrwc1b",
	"u+IZztT62W08tyudGQ1KHGNFtBu+9WwX94I631/BD2qvbcQ8cY97xyHmp6gQZiInZfErnkJAQ2WIlTuI",
	"COrDiLnkttJweCbv4F8sYSeWy4zrDJ8U7tHzKrfiRMzxUe4ePVNzkZ6I+QAy671G3QH6rHD/4HxxoWov",
	"o1bvM6XOq7INUNpx0KYrdvxk6JDdnO/rnR3VXl3bLD69DKby+35hL+uDHNjkIO5KjgPPYaUBd8vTGf1z",
	"OSN64jP9ewyZSLleT5Jj7B3mV/4ZPkKOBUkCiZdlLlKO2JyQ9jt829rJHzTMRoejf5800YKJe2smfl63",
	"YvfYbkFR2tVtBP9RrtLzD1q71KoEbYWDYorz9AmEpmcL4BlolnHL9xpfwBkJA8dMH/5E35GJDzoin3+m",
	"//Cc4WskPm6D7YF2lzBogahWqCFDc8UJQbcSDiAzSrHCWSgMLYv32uXjZnEnl2pB8tqj5c36bJEz+cEZ",
	"RYy+CEAg6C9UBieW28p80DF1V2kmC2rBEDaEdDAh0/KpqizjTKoMmKHBo/HacafcpouqHHA+H7u3p6LA",
	"mZnkUhlIlcxMg9damo5HOTd2yBh4xo11olzIjHDsNozfOB3CDIAcnvcCtBFKxmf+q3sZmztFTEtTGeZn",
	"YKYqS6UtZD131hsQw2u9gMt6LTVrzV1qZVWqciTAysC2mYew1JrfI8tB4hDErbcIaoulDxw5X0hJqygq",
	"O5toELFpIydhVAu7bWdhYCPIkPWXZEoJQ6TY7Kv2UMYjY1VZQpZwm1Sy/m4ITSdu9JH9pRnbJy506chK",
	"yoBlCnB1G/bkd750mHVu4oIb5vfBCn6OGr7Uau51Tn/PyDOJETKFZBPlI/ec4Kg2C2zhpTXp0+HSDp+t",
	"Mcca/UaJbpAItpzCEMBXEYotRfXS+UGnjXVxDeLwCVguclOLvNrZalYhv2w98Lzkhjx1afMV0vBM6MKF",
	"NkjNmPDMCdTMr+Kc+IYtZcY0LLnOwoi9npz1ERSZwWXcPXGhExrARHyjs3o1YVkagg0+OrMXZXcXH3Cb",
	"M7HIEb1AeixEqhV3ASFEPBq0irbhYh4aCo67o9CEzzsMrynkPHHxp4hSce9DfCp4FO2jis8bjmeQ0eoT",
	"WS6AXF6UnmtIbB/yDP0sA0OAlErlCWitdMwv6smZ9ZXORXoOGUOCpJSHF3/fdPeEi7BbeKim9v+Wi5Wb",
	"dsHLEiRkt/cYO5KMmMgHc9dU3dri8hu7af1LWjWrKBTFJSMg985kTG2FQNZHUlGYZjPtuKTGRy7lJtm8",
	"kL2UAwTEl+TB4XRRitxoR57Qly3Z1hPlLaJyu7iK+PyRIv28c8oio1hlI75MNS0Ehftbw8YoK0IYqm8c",
	"CrvH2ClxC9eIuQvQaIZz45S8DxoXYr5A1ZmmANnhmUw6O0lV4Re+1fzXMeJZtb9/H9j+7fVvjEU7xccx",
	"HA+sf/s92x+7V4Qu9j07G52NejNpKNQFZGymVcHadO2+2jrtv9Xznsmfe6KIFXzlIuqBF5mpZjORCof0",
	"XKEkm6s1c0MqegMatwfFFLRhwo5JeBNGyUxz59IwYFw9Xoe7EJkVDTRUHlrzVQhbdGnHMLjkKULJScis",
	"2BIJpaazvpazqkzaE0TSaxtX9O6SC7FZKEwrmPC+fFezFa1HfyvL8y37O8UxQ0HeFrnubTfaesiI7uAq",
	"7H/ESoWnLnyaIcSic2Fsb5Mus2LJV64JMqJ09th/qYqlnPi3rCzURr3SZCmTB4UrkBYNa3rbpMEQ5FCA",
	"tDV27txZB/zOHX/mwrAZLENuDgeuo+POHccEytjHqihFDtcQ0lhws+if9JQbuH+Pnfx09ODuvX/ce/At",
	"AkP2Pi/YdIWK9ZaPODFjVzncjmtHU+U2Pvu3ByFD0p13FAvMtSmHNlzPfRUKOQWU2g5jzOUDAx4/WpKs",
	"sfjlccT0IjjRKokUdyA0e1thpnmvBGpr6uMnYUESSsaQqn43HqHPmq+uQXC6iZgGbyk6a8vzGDmTOcmy",
	"Vj7V84FZGQtFP+DiPv3HgA37KrhaPYtFyVxISAolYRWtwxESntPLqL1DrDbwMQm9oW/XXdHO/te21V3n",
	"Kqf5sfil026RxMs6u3sNh78+71qsrZ1JJmsd8pJxluZoG1BExOoqtWeSU6RhzZxcI4sQPxmOPT0OQ+LB",
	"rkgsyk91JrlBHNbxh72YJJtBJAD4FCCEoEw1n4NZMy/ZDOBM+lFCskoKS2uRdZ64AytBk+DbcyPRoprx",
	"nEJlv4NWbFrZrgqjhJezEF0xAy7D1OxMcsty4May50KeXtJ0wX8MNCPBLpU+r7EQt//nIMEIk8R1w4/u",
	"7U/cLAL4ODAIG/+xC/Hi/LUdgmDi2XJrQeNM/3Prz4evj5L/5snv+8nDP07evD14d/tO7+G9d99//7/d",
	"R/fffX/7z3+InVTYeyyR43d+/MSbd8dPSIc3OcPe3nvTf6oobiFkEiUydLsKISmrv0Zb7BZaIoGAbrMg",
	"icKpn0l7KZGQLnguMm4/jBzWRVyPFx13rFFN5yDWgnIB1jcxt3GukpKn53yOz+fCLqrpXqqKSTBrJ3NV",
	"m7iTjEOhJL3LJrwUE1NCOrm4u0U1foS8YhFxRalSl49qpboi5r0vWu14mjijq1VzuWL0tJ7ATEiB7w/P",
	"ZMYtn0y5EamZVAb0I55zmcLeXLFD5qd8wi2nAMVaXG2oMJXKkfxuymqai5Sdt/VbQ+9Dcaqzs9eI9bOz",
	"N8yueQV9beSXihK+WyBZCrtQlU18bHI4yNEEgmhmFybbtOqY+bndMfvYp58/Lv8oZmjiQOMrhNqNQTJp",
	"AvghqIJn+EJZHwbly1ApVBkw7J8FL18Lad+wxAcAqNrxJ5Xjxv7peRQF66qEjq+3MQ/amiPm3vmIaLIJ",
	"tJJrhKzFCWoW4AwR1SFQD2tYA11tAvajoIyBV3JtRSpKbr11cIWc8cvONzjJNtqLUhs6Rl2icgTYQlKU",
	"yNzgBH2h6HEAvsHzqIwrm0MYg5INKznvlLsQPpWbexNumkMrFm18aoxrEnQBbFf1OrS1OJWAlg3Th210",
	"MdKWLgufQxAXTeaAckdX4cOtoWykopD0E90QnsB1c7jgg9FUl/ONwahkjjBmkMOc+4gcZZM99j1w35gW",
	"1GfyDvt5NkN7nyWxTBs3RqXCpSWCIjBhDUDBf4cx56mwK88Qo43WtimUQROzF6pN8HL+PpuUICj2wcPc",
	"FARp/Q1RWyleOnTcypO26krrwiBckMBaEzXjutTL9UmEAqJQNRRKhUbj9y37aZs3TTuF13xbNVRfbjQM",
	"NG5qvBy19b2+8SgqjoaMh84o5oZMoWfCxBCIYqnvB/W9LQM5kGWTdKRqch7zjs/OXhsgbjkJn7UsCnZL",
	"zBiXq9utwJuGOdrcjZ2KnBocr8/rK1woC8lMaGMTMpGj4OGgp4Z0/lMcGhc9HVQxV0ousrjkoWXPYZVk",
	"Iq/ip+3X/csTXPZFbVqZanoOK1IwwNMFm3KbkuPVXR7HbFjaJcU3AvzMAfyMXxu8V6MlHIoLa4WeTWeN",
	"G0JVa/JkEzNFCDBGHP1TG0RpVLyQzbShoHaqfK9WJcVvFTCRgbT4SvuMTEeyIHZDWr0nOgZS+H5in8Wv",
	"p4/nlck3u5Ih6Ny4HsrdJuqZBnESrOVIvUSQqgHQ2szHBy3L9z0ctfaKPT9tg5OF3ND4Vi6EtPBFzQOe",
	"y8bWrWAlLNxeItMMtmKRDxDL94dMAJkRwVNwqoeqL+oqxXZHYChD6FFX8yElYKbgajtcfpDnRkWmqeSS",
	"S9degt85NPmvDTjdh18tFUrwlJu4xSJMMtPqd4hL5BmeRSQP5FFJGRz6ei9SEbVuZ9TWRdMzF/Db3scg",
	"9b6s+SRyzj7A0fWVB5iYCLnl/lFiO9iTXDrKda0wnbBHnP7bocqJm7+hf7/nXng358spjxXWnp29TnFP",
	"gcBwR23L1yoWPg6nYOp6Dk977HjmakPGzVjhyt1K0E2ytkcMg+R+2iK/G0/yGaSi4HncEcoI+6edlGYm",
	"5sL1E1UGWg0rfiJWKiGtoyLf9OO6ARrUHM/Y/rjVEudPIxMXwohpDjTirhuBTjDBVvte4RMED6RdGBp+",
	"7wrDF5XMNGR2YRxijWLoNp/WnX+1hzEFuwSQbJ/G3X3IbpHnasQF3EYsFq7NanR49yGFM90f+zGJ7BsH",
	"N8mVjATL37xgidMxue5uDtRDfta9aOmla3QeFmEbuMl9ehVeopFe6m3npYJLPo81sJydvS627Ml9S6dJ",
	"xu8aXmTmWhWN1WrFhI2vD5ajfBpIaaD4c9vw9ToFMpBVzKgC6anpY3GLhulc36Mvsg/7Ci/JkS1D3VUr",
	"tfb5HR2ny2NQUzDnBS+gi9Yx465CmUrHfK+XF4h7A6l+0BfxRfTAAQe96b9lt6SSSYG8k91ukmUt+osG",
	"GZTleXRZG2TXeoB689RtM6hfS1MJab89wIVxlmQQsVUHsbwlkz4YxZWOw8krXOqXV8+8YiiUjrU6NNLQ",
	"KwkNVgu4iHLsetKntkxqdREwHzNQftBa6XaKuVfm5KrL6k5aakpWoc+FmKfu3OvaCvgu0qOHHE6NLQP9",
	"ey1YwsDYxv862NrgovncsiUwLqWy3EI4TMZZoTLImfGVbjnMebryuSNzJhHhmdBA5WKioBJ7zsySz+eg",
	"KemoyX4IuWuarQ/7tBJ5ts0z8nM8orGRXO6XzMb2AzBus853XCtpW48jhmD/eu8RAbo5+1gv86kyjqg0",
	"XA6hg/5o3i3kXmkKRttv2kIaro0cv+YyXUQxRLO0mkQj9eELLiXk0a+dyvtCFFLwX9XAngsh46/WScAh",
	"Zg0NDcxdCMOSYf5IIc54ZCCttLCrE+Qq76SX4h/RsNWPNf/6DsDauPe2peuc9lK34famTfZH5QrUCjRm",
	"KAFgqQbxh0telDl44/T7b6Z/gvvfHWT79+/+afrd/oP9FA4ePNzf5w8P+N2H9+/Cve8eHOzD3dm3D6f3",
	"snsH96YH9w6+ffAwvX9wd3rw7cM/fRN6VN1Gm/7Pv1MxSnL08jg5xc02B8VL8RdYuXw6UmcoGOIpxSug",
	"4CIfHYZH/xH4BBmodS+MfzrySmy0sLY0h5PJcrnca38ymVMfSGJVlS4mYZ1+yefLYwYyc54G+bLES8gs",
	"xDsu+ClsTgEMevfqh5NTdvTyeK8RB6PD0f7e/t5dqh8rQfJSjA5H9+kRUf2Czn1ycW8S0miTt94He4dv",
	"5rG4WqhGrzuF+3n2sVMcKa+rnDs5M+OzTWM2dREk5hsgZEZpPRc6QA1cA3ycte6kamRICIL5K7Vex+qN",
	"Y1UAscu06rzIcAd5IyiQ+feTh2/ePvjuXcS4eLPWHHxvf/8zNwQfXOOKXWsnsu5znuORQH3XitvB3c+3",
	"g2NJgWNkAOYY/N149OBz4uBYImnwnNHIlmPc56Bf5LlUSxlGojSuioLrFcla20pntZQlDotzajck5XN1",
	"w+wLrdruVmq/U4I3XYWTHDNT93CWWijUGXT3TwZoM5OEVzoDPW5ViftcK7im1edHf6cIxvOjv7v2i+i9",
	"KK3lXStSl/d/BBvpYni0am4F+CoFwfirvUrm5twF9LHCdNcLs+uFubG9MJ9Zj1/WEWLOpJKJpEKbC2At",
	"r2Wn2D9Ysdd0Wsm6E3kLzfa6hRvd3BgFVM5tJm+pIKBtuveUKF11sk1bfsX3wm0oldOqCAUcis3Apgt/",
	"C8ta0GHoDqmNGn9TDuSjNdTuDp6PuYNn3MFuIJ4dgr/AJUefUltd4Zg/Ss4/4hl7Bb9VYCxL2AsKVhKD",
	"h9vnPrHq+9TwRTXpwf7BjQXohZLA4FIYqvZ1tPiprYNPf0jXZmxQtQAhJTRFtbtwatPBtw2TlFRmMN5n",
	"gefMqEqnwJD50Twpc041Cpc2OKhsU+MzRfn6fdehtW5j8/VeLyBwCjz3TeJecYOxj1S2Wjt73N6Edto9",
	"psh9fpGm6jbEVrlrOGnNvrXw7lqNgH/drvXP6vF0hT7tyBNVw4E7f+dDRFBA4+kPR896bCQk16sxUlhW",
	"pcCo5NPRz2WCg+YgE8/SyVRlq1Cr6eapZVcO2Rz0xPWJb/J6XJ/56FoDSbu7AW7A3QBfnnc/Sn+vQauh",
	"faEiMEf/jS4PPQL9wvluYs8PN4vKZmopW0/qlrFBTgoXiV4jJ+1uM93dZrq7zXR3m+nNu8305pmGW92e",
	"6/NAuwq7JbgbheX+niy5sMlM6YT81YRK7kMwezKYyf4bF/4nCbh3dK1CaQE8/MyEkzR+In9Ra1ON4rNB",
	"vvM5XOMpCug7m7jUU6WvFDxvItJWMYSMVdKKUAiDjFirr68vEr1TzDvFvFPMO8V88xXzlwoiJaEgICTS",
	"Y2l0tosrfbRh0VI4Xt2jskV+2hjvXi96CUHvrsJ/xZftEppNAeY2yi4TF9rqoq2pN3cvx1cIPi+A4q51",
	"MDZSIWQVm2rFsxQVkFXhrrNPHJi+GTeAfsEgclMMe+RzsB1s7Dj/Qzn/USB2+oFFvlxnBqdsiQf2tkaS",
	"NV/aSxmVCpPmhoZoFKx3z971RsN2147urh3dXTu6u3Z0d+3ozc7frN2AUUNKP36zDuyAIrqGXo6vu4Fj",
	"azBt1y6xa5fYtUtcsV3iCtVpu9PdNcPc4GaY/2flt7tS1Wvri9nbaEJN3tpLkW1var+5P7HGrusX1tin",
	"+oG1L/zzahGbtK/+3udugTViiedzkezes5X4j1fpI/5XsT93P+26+2nX3U+77n7adffTrrufdr3ZP+36",
	"pVKSX0cY9VM2Gm5MEb9Qlj0ltfJxHkp93VXMAnGbCHeqkbFY36b2+g2aRHQBqLcjmyvCDieTXKU8Xyhj",
	"JyO08rrXh7VfojjhczeDt9NKLS6ok/fNu/8LAAD//5CUWRlqlgAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
