// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/transactions/dryrun)
	TransactionDryRun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionDryRun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.POST("/v2/transactions/dryrun", wrapper.TransactionDryRun, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
