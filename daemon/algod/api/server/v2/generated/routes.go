// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9a3fbOJLoX8HV7jlJvKLkvHomPqfPXnfSD99J0jmxe3Z227ndEFmSMCYBDgDaUuf6",
	"v9+DAkCCJCjJr6TT7U+JRTwKhUKhUM+Po1QUpeDAtRodfByVVNICNEj8i6apqLhOWGb+ykClkpWaCT46",
	"8N+I0pLxxWg8YubXkurlaDzitICmjek/Hkn4V8UkZKMDLSsYj1S6hIKagfW6NK3rkVbJQiRuiEM7xNGr",
	"0eWGDzTLJCjVh/JHnq8J42leZUC0pFzR1HxS5ILpJdFLpojrTBgnggMRc6KXrcZkziDP1MQv8l8VyHWw",
	"Sjf58JIuGxATKXLow/lSFDPGwUMFNVD1hhAtSAZzbLSkmpgZDKy+oRZEAZXpksyF3AKqBSKEF3hVjA5+",
	"HingGUjcrRTYOf53LgF+g0RTuQA9+jCOLW6uQSaaFZGlHTnsS1BVrhXBtrjGBTsHTkyvCXlTKU1mQCgn",
	"7797SZ4+ffrCLKSgWkPmiGxwVc3s4Zps99HBKKMa/Oc+rdF8ISTlWVK3f//dS5z/2C1w11ZUKYgflkPz",
	"hRy9GlqA7xghIcY1LHAfWtRvekQORfPzDOZCwo57Yhvf6qaE83/WXUmpTpelYFxH9oXgV2I/R3lY0H0T",
	"D6sBaLUvDaakGfTn/eTFh4+Px4/3L//t58Pkf9yfz59e7rj8l/W4WzAQbZhWUgJP18lCAsXTsqS8j4/3",
	"jh7UUlR5Rpb0HDefFsjqXV9i+lrWeU7zytAJS6U4zBdCEerIKIM5rXJN/MSk4rlhU2Y0R+2EKVJKcc4y",
	"yMaG+14sWbokKVV2CGxHLlieGxqsFGRDtBZf3YbDdBmixMB1LXzggn6/yGjWtQUTsEJukKS5UJBoseV6",
	"8jcO5RkJL5TmrlJXu6zIyRIITm4+2MsWcccNTef5mmjc14xQRSjxV9OYsDlZi4pc4Obk7Az7u9UYrBXE",
	"IA03p3WPmsM7hL4eMiLImwmRA+WIPH/u+ijjc7aoJChysQS9dHeeBFUKroCI2T8h1Wbb/8/xj2+JkOQN",
	"KEUX8I6mZwR4KrLhPXaTxm7wfyphNrxQi5KmZ/HrOmcFi4D8hq5YURWEV8UMpNkvfz9oQSToSvIhgOyI",
	"W+isoKv+pCey4ilubjNtS1AzpMRUmdP1hBzNSUFXX++PHTiK0DwnJfCM8QXRKz4opJm5t4OXSFHxbAcZ",
	"RpsNC25NVULK5gwyUo+yARI3zTZ4GL8aPI1kFYDjBxkEp55lCzgcVhGaMUfXfCElXUBAMhPyk+Nc+FWL",
	"M+A1gyOzNX4qJZwzUam60wCMOPVm8ZoLDUkpYc4iNHbs0GG4h23j2GvhBJxUcE0Zh8xwXgRaaLCcaBCm",
	"YMLNj5n+FT2jCr56NnSBN1933P256O76xh3fabexUWKPZOReNF/dgY2LTa3+Ozz+wrkVWyT2595GssWJ",
	"uUrmLMdr5p9m/zwaKoVMoIUIf/EotuBUVxIOTvme+Ysk5FhTnlGZmV8K+9ObKtfsmC3MT7n96bVYsPSY",
	"LQaQWcMafU1ht8L+Y8aLs2O9ij4aXgtxVpXhgtLWq3S2JkevhjbZjnlVwjysn7Lhq+Jk5V8aV+2hV/VG",
	"DgA5iLuSmoZnsJZgoKXpHP9ZzZGe6Fz+Zv4pyzyGU0PA7qJFpYBTFhyWZc5SarD33n02X83pB/s8oE2L",
	"Kd6kBx8D2EopSpCa2UFpWSa5SGmeKE01jvTvEuajg9G/TRutytR2V9Ng8tem1zF2MoKoFW4SWpZXGOOd",
	"EWjUBi5hODN+Qv5g+R2KQozb3TM0xAzvzeGccj1pHiItRlCf3J/dTA2+rQxj8d15WA0inNiGM1BWrrUN",
	"HygSoJ4gWgmiFcXMRS5m9Q8PD8uywSB+PyxLiw+UCYGhuAUrprR6hMunzREK5zl6NSHfh2OjgC14vja3",
	"gpUxzKUwd9eVu75qjZFbQzPiA0VwO4WcmK3xaDDC+21QHD4WliI34s5WWjGNf3BtQzIzv+/U+csgsRC3",
	"w8SFzyeHOftywV+CJ8vDDuX0CccpcSbksNv3emRjRokTzLVoZeN+2nE34LFG4YWkpQXQfbGXKOP49LKN",
	"LKw35KY7MroozMEZDmgNobr2Wdt6HqKQICl0YPgmF+nZLZz3mRmnf+xweLIEmoEkGdU0OFfuvMQva+z4",
	"A/ZDjgAyItH/iP+hOTGfDeEbvmiHNS91hvQrAr16Zh64Vmy2M5kG+PAWpLBvWmLeoleC8mUzeY9HWLTs",
	"wiO+tc9ogj38IszSGyXZ4UzI69FLhxA4aVR/hJpRg+My7uwsNq3KxOEnoj6wDToDNdaWvhQZYqg7fAxX",
	"LSwca3oHWFBm1NvAQnug28aCKEqWwy2c1yVVy/4izHvu6RNy/MPh88dPfnny/CvzICmlWEhakNlagyIP",
	"nRhNlF7n8Ki/MpRnq1zHR//qmVcYtceNjaNEJVMoaNkfyiqi7KVlmxHTro+1Nppx1TWAuxzLEzDsxaKd",
	"WB2rAe0VU+ZOLGa3shlDCMuaWTLiIMlgKzFddXnNNOtwiXItq9t4fICUQkZUIXjEtEhFnpyDVExEtNrv",
	"XAviWniBpOz+bqElF1QRMzdq6SqegZzEKEuvOILGNBRq24Vqhz5Z8QY3bkAqJV330G/XG1mdm3eXfWkj",
	"3yt9FClBJnrFSQazatGSXedSFISSDDvixfFWZGDeHZW6BW7ZDNYAYzYiBIHORKUJJVxkgI+USsX56ICJ",
	"C3XraBLQIWvWS3tPz8AIxCmtFktNqpKgwru3tU3HhKZ2UxK8U9WARrBW5dpWdjprPskl0MwIysCJmDm1",
	"m1MI4iIpauu150SOi0eeDi24SilSUMo8cKzYuhU0387ust6AJwQcAa5nIUqQOZXXBFYLTfMtgGKbGLi1",
	"2OV0lX2od5t+0wZ2Jw+3kUrzxrFUYGQ8c7pz0DCEwh1xcg4SdXZ3un9+kutuX1UOWNSdpHLCCnwqccqF",
	"glTwTEUHy6nSybZjaxq1xCmzguCkxE4qDjzwXH9NlbaaW8YzFK0tu8F57DveTDEM8OCNYkb+u79M+mOn",
	"hk9yVan6ZlFVWQqpIYutgcNqw1xvYVXPJebB2PX1pQWpFGwbeQhLwfgOWXYlFkFU13oOZ9roLw61AeYe",
	"WEdR2QKiQcQmQI59qwC7oVVxABDzDqt7IuEw1aGc2pQ5HiktytKcP51UvO43hKZj2/pQ/9S07RMX1Q1f",
	"zwSY2bWHyUF+YTFr7clLamRgHJkU9MzcTSjRWhVzH2ZzGBPFeArJJso3x/LYtAqPwJZDOvCYcB4rwWyd",
	"w9Gh3yjRDRLBll0YWvDAy+YdlZqlrERJ4m+wvnW1SHeCqIaEZKApM9J28AEZOPLeuj+xNoPumNcTtHYS",
	"Qvvg96TQyHJypvDCaAN/BmtUlb6zxuiTwIR9C5JiZFRzuiknCKg3cZkLOWwCK5rqfG2uOb2ENbkACURV",
	"s4Jpbb0L2oKkFmUSDhB94G+Y0alYrCHX78AuOp9jHCpYXn8rxiMrtmyG76QjuLTQ4QSmUoh8B1V0DxlR",
	"CHZSVZNSmF1nzpnFezx4SmoB6YQY1K/VzPOBaqEZV0D+W1QkpRwFsEpDfSMIiWwWr18zg7nA6jmdUrrB",
	"EORQgJUr8cveXnfhe3tuz5kic7jwHmCmYRcde3v4SnonlG4drlt48ZrjdhTh7aj5MBeFk+G6PGWy9Wnv",
	"Rt5lJ991Bq/VJeZMKeUI1yz/xgygczJXu6w9pJElVcvta8dxd1JqBEPH1m33XQoxvyVFWtwDAB8nzqhv",
	"WpF5xS1QlXLPEbRzeYWGmI9rLw/r3W09AKoCe+P/l9Qp5kbjxnRvG5gLufn8ISJSsmwV89DIYBXbFHfG",
	"8Dn1wLw91gqiZjHkzGIecdICeZa7pXV4BynAHGq1ZKUZsnEoWWtoOaP+34f/efDzYfI/NPltP3nxH9MP",
	"H59dPtrr/fjk8uuv/1/7p6eXXz/6z3+P6hU1m8X1nz8YRIs5cTx+xY+4tWDMhbQPsrWT88T808OtJUAG",
	"pV7GvD9LCQp5o/XiLPWy2VSAjhKllOIc+JiwCUy6PDZbgPLapBzoHL0Q8VEhdrGK1ufB0psnjgDr4UJ2",
	"YmQx+kEbH9Imnmbz6sjXtyC92IGIbOPTv9aV/SrmoeusOyhqrTQUfYWX7frLgLj/3gvLvUMleM44JIXg",
	"sI5GizAOb/BjrLe97wY6o+Qx1Lf7mGjB3wGrPc8um3lT/OJuBwz+XW3ZvoXN747b0XWGTsOoq4G8JJSk",
	"OUNNjuBKyyrVp5ziWzEg14g9yb+Ah7UHL32TuLoiok1wQ51yqgwO6xdkVAc+h8id9R2AVyKoarEApTtS",
	"8xzglLtWjJOKM41zFWa/ErthJUg06kxsy4KuyZzmqOz4DaQgs0q35Ui89ZRmee4Ur2YaIuannGrDg5Qm",
	"bxg/WeFw3oXQ0wwHfSHkWY2F+BW1AA6KqSTO97+3X5H9u+Uv3VWAgSb2s+c3n5rve9hjnncO8qNX7o11",
	"9AoF6Ubl2oP9k+nhCsaTKJEZwahgHB24O7RFHprngCegR43y1u36KdcrbgjpnOYsM8LTdcihy+J6Z9Ge",
	"jg7VtDaio1bxa/0Q8xtYiKSk6RmajUcLppfVbJKKYurfltOFqN+Z04xCITh+y6a0ZFNVQjo9f7xF0L0B",
	"vyIRdnU5Hjmuo25dE+MGji2oO2et0PR/a0EefP/tCZm6nVIPrBuuHTrwn4yoA5yLUMtiZRZvw8isH/Ip",
	"P+WvYM44M98PTnlGNZ3OqGKpmlYK5Dc0pzyFyUKQA+919Ipqesp7LH4w0jPw9yJlNctZSs7Cq7g5mjZ6",
	"pz/C6enPhkBOTz/0zB/9i9NNFT2jdoLkgumlqHTiwhMSCRdUZhHQVe2ejiPb4KJNs46JG9tSpAt/cOPH",
	"WTUtS9X1Vu0vvyxzs/yADJXzxTRbRpQW0jNBwxktNLi/b4V7c0l64WNbKgWK/FrQ8mfG9QeSnFb7+0+B",
	"tNw3f3W8xtDkuoSW4uha3rRdpREu3ApUsNKSJiVdgIouXwMtcffxoi5QRZnnBLu13Ea9kwUO1SzA42N4",
	"AywcV3aBw8Ud214+zjS+BPyEW4htDHdqNP/X3a/AkfTa29VxRu3tUqWXiTnb0VUpQ+J+Z+rws4Xhyd4c",
	"o9iCm0PgIvVmQNIlpGeQYdAQFKVej1vdvcXP3XCedTBlg+uspxtGgKCObQakKjPqZADK111XfAVa+/iD",
	"93AG6xPRBJBcxfe+7RGuhg4qUmpwGRliDY+tG6O7+c56jF6wZekdq9GJ0JPFQU0Xvs/wQbY35C0c4hhR",
	"tDyWhxBBZQQRlvgHUHCNhZrxbkT6seUZ8WZmb76ImsfzfuKaNFKbswCHq0FHbPu9AIzUFReKzKiCjAgX",
	"ZGq9ngMuVim6gAHdU6jm3NG3uKUaxUG23XvRm07Muxda776JgmwbJ2bNUUoB88WQCuoJO3Z/P5PVpOMK",
	"JgRzRziEzXIUk2qXA8t0qGypm20w/BBocQIGyRuBw4PRxkgo2Syp8vGvGCbsz/JOMsAdevFvCto6CkzW",
	"QSxwHZLleW73nMYVtzY4q1BNkFaotd0h4Go8cl5Use0QHAWgDHJY2IXbxp5QmoiCZoMMHD/O5znjQJKY",
	"9ZsqJVJmA5iba8bNAUY+3iPE6p7IziPEyDgAGy1EODB5K8KzyRdXAZK7iAjqx0bbUvA3xF0BrX+TEXlE",
	"aVg44wOeaZ4DUOcyUd9fHccdHIYwPiaGzZ3T3LA5p0RtBumFEKHY2gkYcjbKR0Pi7AbVn71YrrQmexVd",
	"ZzWhzOSBjgt0GyDeLErEtkAhvtzTt8bV0F26y9QD1/cQrh4GwUfXAqCjiWjy87iX39YXWvtu7t9kDUsf",
	"N9G03jUzRvtD9BPdpQH89RXBdbjQu+51HX2kt22X7UipQH6KsWJzRvqq0b4CVkEOKBEnLQkiOYspzI1g",
	"D8huj3234OWO8ViUrx8FBnEJC6Y0NKorcyt5XeynNndRjP8WYj68Ol3KuVnfeyFqHm3jDK35LlzmJ1/B",
	"udCQzJlUOkG9X3QJptF3Cl+U35mmcUGhbXK3qVBYFucNOO0ZrJOM5VWcXt28f3tlpn1bK2FUNTuDNYqD",
	"QNMlmWHqnqgjzoapra/WxgW/tgt+TW9tvbudBtPUTCwNubTn+ELORYfzbmIHEQKMEUd/1wZRuoFB4sX/",
	"CnIdC1kKhAZ7ODPTcLJJ9dg7TJkfe9NDKYBi+I6yI0XXEryWN66CofeBee4xHWS+6ccNDJwBWpYsW3UU",
	"gXbUwecivdJr30cWd7CAu+sG24KBQOkXc02VoNpB5I10a3MY8XBtk50wc9IO9Q4ZQjgVUz4DXx9RhrQx",
	"TdQ2XJ0Azf8G67+btric0eV4dDO9YQzXbsQtuH5Xb28Uz2gQs3qklhngiiinZSnFOc0Tp10dIk0pzh1p",
	"YnOvjP3ErC6uwzv59vD1Owf+5XiU5kBlUosKg6vCduUXsyobrz5wQHyGL/Pg8TK7FSWDza/jiEON7MUS",
	"XDalQBrtZX9otO3BUXQa2nncLr9V3+oMA3aJGwwEUNb2gUZ3Zc0DbZMAPacs90ojD+2ADR0Xt1sKkShX",
	"CAe4sWkhsBAlt8pueqc7fjoa6trCk8K5NuR7KmxKM0UE77pkGRESdVFIqgXF3A1WJdBnTrwqEnP8EpWz",
	"NK5g5DNliINbw5FpTLDxgDBqRqzYgB2SVywYyzRTOzx0O0AGc0SR6fOADOFuJlwu2oqzf1VAWAZcm08S",
	"T2XnoGKyDKdq7l+nRnboz+UGturpZvibyBhh3pLujYdAbBYwQjNVD9xX9ZPZL7RWx5gfAn38Fazd4Yy9",
	"K3GDpdrRh6Nm6zK0bJubwtSxff5nCMOmGduet9Y/Xl0ClYE5onlomUrmUvwG8XcePo8jfus+UwtDr8nf",
	"gE8i4T9dFlNrd5p0us3sg9s9JN2EWqi2hX6A6nHnA5sUZsXw6lnK7VbbtJAtv5A4wYS+XFM7fkMwDuae",
	"/1tOL2Y0ljLECBkGpsPG+tlSJGtBfGePe6fzZi55zoQEhtS6LbMRXSXIJqSkHz18TYHBTruzqNBIBki1",
	"oUwwtsavXInIMBW/oNxmFzX97FFyvRVY5ZfpdSEkxmOquM47g5QVNI9LDhlivx2/mrEFs7k1KwVB8kY3",
	"kE1KbKnIJcC09uUGNUdzsj8O0sO63cjYOVNslgO2eGxbzKhCTl4rououZnnA9VJh8yc7NF9WPJOQ6aWy",
	"iFWC1EIdPm9qy80M9AUAJ/vY7vEL8hBtVoqdwyODRXc/jw4ev0Clq/1jP3YBuCS6m7hJhuzkvxw7idMx",
	"Gu3sGIZxu1En0ehCm/l8mHFtOE226y5nCVs6Xrf9LBWU0wXE3SSKLTDZvribqEjr4IVnNm2v0lKsCdPx",
	"+UFTw58GfD4N+7NgkFQUBdOFs2woURh6ajIz2kn9cDYHsEsf5OHyH9FAWHr7SOcR+WmVpvZ+i60azbhv",
	"aQFttI4JtUG4OWtM9z7jFznyofyYT6lOo2RxY+YyS0cxBy35c1JKxjU+LCo9T/5K0iWVNDXsbzIEbjL7",
	"6lkkh1Q7bQy/GuCfHO8SFMjzOOrlANl7GcL1JQ+54ElhOEr2qPGxDk7loCUz7i3mOXrXWXDz0LsKZWaU",
	"ZJDcqha50YBT34jw+IYBb0iK9XquRI9XXtknp8xKxsmDVmaHfnr/2kkZhZCxxC7NcXcShwQtGZyj41p8",
	"k8yYN9wLme+0CzeB/vNaHrzIGYhl/izHHgLfVCzP/t7EjHTS8EnK02VU7z8zHX9p0iTXS7bnOJpHZEk5",
	"hzw6nL0zf/F3a+T2/6fYdZ6C8R3bdtPr2eV2FtcA3gbTA+UnNOhlOjcThFhtO9HXXpf5QmQE52mSVjRU",
	"1s8YGKTQ+lcFSseC9vCD9fxA/Y55F9gMTgR4hlL1hHxvy5wsgbRi6lGaZUWV2/hsyBYgneKxKnNBszEx",
	"45x8e/ia2FltH5vz02aQWqAw115F510fZLjZzYfQp++M+zfvPs5mh0uzaqUxxYXStChjoSumxYlvgPEx",
	"oa4TxbwQOxPyykrYystvdhJDD3MmCyOZ1qNZHo80Yf6jNU2XKLq2uMkwye+e+sxTpQoyw9eJXuskNXju",
	"DNwu+5lNfjYmwrwvLpiy1S3gHNrRMnXomHs6+eiZ9vJkxbmllCiP3hTaeB20e+CsQdurQ6OQdRB/RcHF",
	"Zg68aia4Y+wVzfrQTSvXSwlvo4rrHKW+alFKueAsxZwLQT2NGmRXKWMXW8EO6Sm6yih/xN0JjRyuaDK7",
	"2p3IYXEwvZ1nhA5xfWVl8NVsqqUO+6fGkgxLqskCtHKcDbKxz8no9CWMK3BJh7BoSsAnhWzZX5BDRk16",
	"Sa36vSIZoe/8gAD8nfn21j2P0Kn0jHEUhBzanP+q1WhgIn9tpCemyUKAcutph+arn02fCYanZ7D6MPGJ",
	"/3EMa74wy7a2uv5Qh95y5yxlpu1L05ZYr8P655abop30sCzdpMMZO6PygF7xQQRHLDCJV4EHyK3HD0fb",
	"QG4bTe54nxpCg3M02EGJ93CPMOrslZ10vec0ryxFYQtiXV2i8ZWMR8B4zTg0ZSkiF0QavRJwY/C8DvRT",
	"qaTaioA78bQToDla6WIMTWmnor3pUJ0NRpTgGv0cw9vYJN4cYBx1g0Zwo3xdV8Mw1B0IEy+xDI9DZD+N",
	"JkpVTojK0O24k1gzxjgM4/ape9sXQP8Y9GUi211Lak/OVW6ioUiyVMTkzW9XkFbWCC2U90ImKYZmB/dF",
	"VKPZpIiNbEOYptajFl3EZ2v8N5ZjaRglzkp8ZT8lbxLGjlcWWNsj9cRNQ0yJYotkd0wgM785Opqpr0dh",
	"Tf9bJbFcLNqAfOJcKJvYS7hHMcbyreHYYVxzL3GY5el12DF6BQmfbR7fa3XAXJsd4B3SyySG2ug6cfhm",
	"fcBwCvAx3joDvoFBBhhqLzZr3hjyEEwHHVqpdnElmpImfUWfJ9i83bERrHuBzRduSw1GVTtDLgXWo8B8",
	"7vXeTSTrCbg49kaEel+VPkB/845wpKTM2e4aZtHHrHOZ7Tsx7+JM12xwdxHOERUHia2klyBwM4X0HJED",
	"Z3qbx22ye0D7YW0YRXMNZuFeAHdpuNsuhjs7Os3nkGp2vsXx+7+MsNw4FY+9OG1rPAR+4Kx2nPEVKa8o",
	"5TcAbfLL3ghPkDXjxuAMuX2ewfqBIi1qiCaWG3tCvU68JGIAM4okhkSEihke7Pvf6YKZqikDseANfbY7",
	"NMmcBjP6BmEM15zLkyShYWjDhinPRewBsdNcpuuVAn7QB2TIN7yfU3P49nqFKUxVnY29LjkZ+HGYd2I3",
	"39uFi9dEN/1a5eUjN0H533xMjp3FljJtcg6jgvGCysy3iErMXhhPBrytuv7L1k2cxYGe1zOzxi2j78Ib",
	"yXOAzjdpLhTji2TIg6ntCRFWQ0J7D+omMFkpwjUH6XKNa18pNtHCu3FsgmMTKlzlnusgQQ1m7bPADUb8",
	"vm9CmjG5E7V1gp0tK1wgkVBQA50MAo+H59yE7Jf2u/dZ9cl9Oqm0IuN6ek22Rg57hxymekgMqX5O3G25",
	"3Rf2Ok8Vxrkt5aBiUcjcoDJUYpVSZFVqL+jwYIB/0u0c47+BlUSl/LS/yp7AlmPGi9dBZMEZrKdWaEqX",
	"lDepR9rH2iYjtGsIIvk6u32rr7i4wJov7AIWtwLn53wJjUelEHkyoLU66gdTd8/AGUvPICPm7vCm7IGs",
	"vuQhKktqs8TFcu2Dh8sSOGSPJoSYt1RR6rW3ULTTiHUm5w/0pvlXOGtW2fwG7pE2OeVxLwxbefuG/M0P",
	"s5mrKTDM74ZT2UG2RCuvBgK5Jb2I5LjetYxZxGbQzTvcEJWFIialXDN0bafz3X+oRUg/DDrY8v45a73q",
	"bKKcjp1ASLjl112gIL3i664fTrHr8nAdyNUqBf117rwBLdwO4H4XxDeqiT5yhzUKeraLRiGe1MN0R5WG",
	"RQhmxCEIKvn18a9Ewhwz5Amyt4cT7O2NXdNfn7Q/m9fX3l70ZH4yZUarWpqbN0Yxfx+yK1vb6YALQ2c/",
	"KpZn2wij5ZDSZKtEl4tfnOvOZ8mX+Yt9IvePqksdeBU1ancTEDGRtbYmD6YKXE128DJx3SbRenYK0koy",
	"vcaIIv+iYr9EI7W/r5UwrgRn7YPuXKBtsXvnEdWobJr65N8LW/+uMHc9KrE1JvT/dkWLMgd3UL5+MPsL",
	"PP3rs2z/6eO/zP66/3w/hWfPX+zv0xfP6OMXTx/Dk78+f7YPj+dfvZg9yZ48ezJ79uTZV89fpE+fPZ49",
	"++rFXx744uAW0Kbw9j8wqWxy+O4oOTHANjihJavreBgy9gkqaYon0bxJ8tGB/+l/+xM2SUXRDO9/HTn3",
	"uNFS61IdTKcXFxeTsMt0gW+0RIsqXU79PP36Ce+OatcdG3KBO2q9Mgwp4KY6UjjEb++/PT4hh++OJg3B",
	"jA5G+5P9yWPMA10CpyUbHYye4k94epa471NHbKODj5fj0XQJNMfk4OaPArRkqf+kLuhiAXLiMnWan86f",
	"TL3lf/rRvU8vzaiLWKyVdUIKSwz3Elg6XRfak6yTUSshlHL5icZ1mjAnPvIMfUPsk8+wthpZR1mTEuQo",
	"qFvrAqNspPjBz5HEyXO2qGSn8lCtzXc5BJkitoykJG+szv0dTc9C/4tYIXjHymJ14J2XRqEWZduk2Wj6",
	"YzVKYplAcWazzwGl1qqihhNpWUEIScNXDa/cT158+Pj8r5ejHQBBvaWrhPsrzfNfbWkoWKHyp12UWo2H",
	"KqCPG9VDp+70GG2y9dcwQ2Xdpu0J9CsXHH4d2gYHWHQfaJ6bhoJDbA8+dAruP9nfv4Pa1ePWKJ4kPmsR",
	"7Ge3uNC2Be3Gy+0O11v0NzTDrIGgtF3K4y92KUccTQeG4xN7o12OR8+/4L054obn0JxgyyD+qX+L/MTP",
	"uLjgvqWRZqqioHKNskqQ2jSUSi8Hb6tpmIZt+rGlWM5udJf1MlAevdpyvT1QQ0yxnxigk+XNfK/zmKHq",
	"MSzurx5NyPdh7+tV8G9gC+v4D1y2wWv9/t6903v3sK11aEWWx4BpkfhGmHqWp5tefH2/p06S7mslwQ7y",
	"yV0jK8+dZgrtltUeql+4A4O9x91Q7ccB8SaAt5Z02nkA757v2vdbcE207oM75MpfuLD2huaGToLldnyw",
	"bbqFeyHuTyPE1c4IttYGZhjaJNZhGtHpR58d4xZEOZcdZAchLnzpBn2D7A0PO5zi0cSmugjbXI8dOMeC",
	"reIZ5iy5F8zuWjDrJ/uJgdGkcPl8whjCsGyyAV2lwEUree+VshZ9odLXnxhZg+KWgXS7oHUN3tgTohwn",
	"vjOe+YcUnhzS7sWmP7XYZH35NghOrUxczvFzWHaCoPB2UMuk5Xg2W3s6HBOF9f3NT6VkQjK9HhPGSQbm",
	"7KHFUEgMOm5KeDsnI+D43zeH/0DX0zeH/yBfk/1xLYJhTFZkeuvc05aBvgcdKTH/zfqwFgc2ykK/GwHj",
	"pEbSQAl4LXwyLURaQVdfD6FsZe2KMfGsoKvRRklk/OVIizcVmjrRlH0qckU0bQl5V/il7VKlCKxoqvM1",
	"oXj/rK3vLxYX95mwOuXQu7X5Y/FGG2b0dSViUWNX9eqKhKz36uIPlAseolKXcQ6LuGwXTHrIiEJwPSnv",
	"fne/2N3ti6WkFOZMM0yJ0Nwn/q5qAdlUF3DgDjisTsh/iwqdXWzxLIil88QZ0LnXz+kE0CAfb46ly2rs",
	"7O11F7635/acKTKHC+SglGPDLjr29v4AIuuqzqJICRc84Vjb6RxI4CF3L7f+ruXW5/tPv9jVHIM8ZymQ",
	"EyhKIalk+Zr8xOu0MzcTy2ueU/EgEdBG/tPzlG+k6EB8v5HtumubZrqRDFuBU4EKoS7B597K4yaHv3nL",
	"Y7oQH7Cuxt50go5/1qpi92PcM6xMYkJ6YMH5Zn30ahe5/AsxhO6ctipyr8X35q5vgKg/zftP40+zGzN9",
	"tv/s00EQ7sJbocl3qC67Y5Z+p7qDOFkFzObKFpXGYhKyFheIuJGpmBM6dqlGMfflmtSBQoafWEZoiw30",
	"uYaZYVd+8TvWz+9QZjdCl1303vOFe75wI77QJaiGI2C4vZp+RFNByA56R/Ib0/IPZGIM7C1SFN7gIsgc",
	"dLq0aQi6YTERtuKz3w3zlE054m/Z/odAR3Lk4lpc6AfmLt8xIBA7/mAjMS7HoxRkhPh+9PlwzGc2x7DO",
	"OrOhL4WA5hzmswPXiYFd+nSmvM+5y3pDzC5eCcqXzeT9MB1Ey23YDO8RfDUE95jaty5Psz1ebhF/BK90",
	"n8Q3IW9RHMID7hP7/RHVHnd5I9/1gt4KDtYubSRWS4v3JshaXMBqKogUnwXBGh5dgda46NA2On7UK5Zd",
	"Tus0PUNCxTtssEWoaG5q1tSwbKtXaFkCleral/R2c9hJZ8ajV6GfRiurUJ1PKAKKwcsVLYn/sYsZ8Y9r",
	"rWvfwEuqlvH4btygdYlFGEwrMq+43aq6XhQ67Xg3EjEf1+pqww/E/OCU7xFVFdgb/7+kzx8/+eXJ869G",
	"43rFroHBRvP5QyT+mGWraOoNWPkMQiE9OZ0hHqoHipR0PZixZyD51RuQZ7kv1N02jpACzEWklqz8HIXH",
	"2Sxee+cHg2gxJ3VG7CP+Tc13zkGyORaQqs/TJ86oIgEyKPVyYyoDW/+q1MtmU8FVaGTKpYwppTgHPiZs",
	"ApOuESlbNMllc6DzOuWIELu4eNXnwdKbJ44A6+FCdhHR3sXoB8MIXWq2T62MaFyh7CXgkSc7/Pizair0",
	"Z9FUvBU8QTkGuPYydQstn09rgVlixoFisK4xwIVGhaCQKH6FbEtNdhJcYNBI0+KB1uVwkIydGJNSnS6r",
	"cvoR/4MR+5dNbLwtqDG1CsxNksyxbXGrril2TCLb3MYniXBKVTEnb1gqxSFmE3LXiForDUW/3KLt+sum",
	"Ug3RK0fwnHFICsFj+SV+xK9v8GM0XxGauwc6o+PBUN9ukZwW/B2w2vPswupuit/J70M5eiNBv7NaCWXt",
	"3od+EEj/zWlpJYxtjknr5+nH1p/OzuBaqmWlM3ER9LX5IDaeLdviVs/WW5GBHbedgiXmd8lFBi5tRf9I",
	"1VwjLpJ6/DbtOsJBSqvFUttygdFapHXHhKb2KNicq2pbkkrbyidjOwdCcwk0W5MZACdiZhbdTvZLqKrr",
	"vyJxWN4Yz7XYwFVKkYJSkCVhnaBNoNXJQFDy0RvwhIAjwPUsRAkyp/KawFomsRnQboG8Gtxaw+b4QB/q",
	"3abftIHdycNtpBKIZ4j4pBFFmYN71ERQuCNOUNZmd7x/fpLrbl9VYimaSLZQ+/WEFZjvglMuFKSCZ2o4",
	"p++2Y4tZfIO1KLDVV/1JiVb4MAMPXK2vqdKuElIr9WGQC9pMsSEJ8VAiLzPy3+s0Xr2xU8MvuapUUyTK",
	"yl6QRetvwmrDXG9hVc8l5sHYtXBnawNvG3kIS8H4ddmoIKuwDrQ/ZrjI4jB4hDpRLFLDPgSiQcQmQI59",
	"qwC7oYplABCmGkTXqULblBPU7VValKU5fzqpeN1vCE3HtvWh/qlp2ycu53SPfD0ToELB20F+YTFrK8It",
	"qSIODlLQMyezL5zvex9mcxgTxXjqUqEPxTWxAo5Nq/AIbDmkXbEvPP6tc9Y5HB36jRLdIBFs2YWhBccE",
	"zd+FWHjVd19XcXeHKua2oB2IV42gaf+eXlCmk7mQLs081hyPWKs7Wawo067SvXsVa+FUxK5quWUobpyg",
	"HqIKHYctCD54xex+31fFTPWdkDsZxxs9thbELIxUXDMfgWzOWy1j/v4szffS8730fC8930vP99LzvfR8",
	"Lz3fS893LT1/Hm9XkiSeT3vbcCyQiYy+SAn/C4oV+pTBPY3QX4v8+EgwIro5xxu9YDTQfOqqEKO7QrTm",
	"pnWnDysap2Y6xkmZUyMNwUr7oG4yowq+euadMurakTbtveE1psHTJ+T4h0Pnf2AdHsS80/ahr8im9DqH",
	"R85bsM5L7d0GgVOsVIleg9S/flLnUWKF+TnLgSiDq2+x9Ss4h9xI8tb4ScxbpP86OgGav3S42fI4amUe",
	"Lmj567j1JHNYK2jpJR6/VKoIRaeWXt5gM8qQS4sdr6Bl1KvFCaqjcZ1geMixBbnGNyJbd06C2dAp7m37",
	"DDQuDIxTGSkU3Kf8HtVogcXCXeXr3pPw8tYdbvr03KfAbcQXr84SL+i76QAM15s2m9kbyno7zTs0FM2o",
	"33WrGNUA7mJLNKTu94S4SsWf9SIjCJE7fQ3T/t3EcnTL1Tl+gm2NrOW40pcad+ERHz29ePbHvpwXYVoR",
	"R3GrxDRaAE8cb0lmIlsnLa7VvnuaKrdb7x90MNtwtuobqK6KPnhZfZ67JCisPNrEfUPyWCWO1Q7wYetK",
	"thsXrrGFIzpGHGzAXTPjIYYZgkAcJ4q9srv5wa7I3oKCyvcs7p7FBaexc/cz7rwYu0xkcj0WhzXIh7mb",
	"rWgPioSH9KF6ZFgWYnSlWzp+rPe/sHXouvpqzFNVl1P8PFzOLndXBnc14rCD18GdN41L6A7XZxyB+91D",
	"IclCiqp8ZLMG8jWqQouS8rU3f0CiWFHlrrwsxlLdLg+tayL2xEivhhvW4L3zirpAT+XeIu3fLVqwkqLd",
	"X8hIxTOQ8YJlq04Zqu0YP1nxhgNvLFLly/X1Vufm3YX7+112wQS1yae0xUvtgWodJufRbE/u5D6A+c9x",
	"I7yz2TkHGGzfH7dhCNsvBhmwLLwZOums/NXQ5qfv6UWYHOu2hMbdH+9G5F5rqAXuSO4vI0ZKQbOUKlR/",
	"cNAXQp7dsSypV0cRfTOCiTkc+yEq5oky2SpU4rg7iZTtaCr/SK9mBVO27t3nFS6buINDFxLbwsa9CviP",
	"ogL+xh8+RSiW0O0cTmvtwTO5A5uiF3rFo1xqWtoc0EOezsGBcNmib9Vnozd823UjyMBsTc+Ql4SSNGdo",
	"mBZcaVml+pRTNH116gt33Dq8QW9YlHrpm8StrxHjqBvqlBuhak5qg1hUpJpDxNT9HYCX2FS1WIDSHU48",
	"BzjlrhXjWNkf58JyzYmNADDXteHoE9uyoGsypznabn8DKcjMPCLCvGBoSFKa5bnzIzHTEDE/5VSTHAzT",
	"f8OMQGeG87aG2jfK0l2NhYEy9LYAZBJX1n5vv2K0nVu+txegWcN+9nEx489TpjVh2SDkR69czs6jV5iG",
	"rfEg6cH+ydwKCsaTKJGZG995YnVpizw0Mp4noEeNL4rb9VNuhGktCDJ6qq9HDl3zb+8s2tPRoZrWRnSs",
	"xH6tH2L5IhYiMU9GujC/L5heVjMslOrzSEwXos4pMc0oFILjt2xKSzZVJaTT88db5IMb8CsSYVf3N/cf",
	"x3gb0oE5LfXGY22C7t4P3Mu3kCL9950Xfatr6n0W8vss5Pd5qu+zkN/v7n0W8vsc3fc5uv+sObonGyVE",
	"l9dqa9Zc3VNtUiIhtTPXDDxs1sqv27dKMj0h5GRp+D81dwCcg6Q5SamyghG3HtIFWyw1UVWaAmQHpzxp",
	"QZKKwk38sPmvfeaeVvv7T4HsP+r2sXqLgPP2+6Koip/Q1ES+Jqej01FvJAmFOAeXbRObZxV6w9heW4f9",
	"X/W4P8re1hV0bZUrS1qWYK41Vc3nLGUW5bkwj4GF6Ph1c4FfQBrgbIYkwrRNbI74RH945xNDXd6RmNDd",
	"v9+vUJbxsJvH5j5x2K0I2Jv4VH/Dbo8Hbhy7xxDvWcanYBmfnWn8gXKc3qcz/Z0tKDSktvKV30CSqgt1",
	"RvROXkay6mTDm3EESCvJ9BpvOFqyX87A/P+D4eMK5Lm//CqZjw5GS63Lg+kUK4oshdLTkbmamm+q89Hc",
	"D3RhR3CXSynZOWYj/nD5/wMAAP//Z9xTHhUYAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
