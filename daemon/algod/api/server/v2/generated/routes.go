// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AQAA//9ABOdBwOQAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
