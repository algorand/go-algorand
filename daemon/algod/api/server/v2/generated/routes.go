// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightblockheader/proof)
	GetProofForLightBlockHeader(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	StateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProofForLightBlockHeader converts echo context to params.
func (w *ServerInterfaceWrapper) GetProofForLightBlockHeader(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProofForLightBlockHeader(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightblockheader/proof", wrapper.GetProofForLightBlockHeader, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.StateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"4N2H/x8AAP//s3jwxaYlAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
