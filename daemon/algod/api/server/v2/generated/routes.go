// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get the proof over a block for a given round
	// (GET /v2/LightBlockHeader/proof/{round})
	LightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// get a state proof for a given round
	// (GET /v2/stateproofs/{round})
	StateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// LightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) LightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LightBlockHeaderProof(ctx, round)
	return err
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/LightBlockHeader/proof/:round", wrapper.LightBlockHeaderProof, m...)
	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.StateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9a3fbOJLoX8HV7jlJvKLkvHomPqfPXnfSD99J0jmxe3Z227ndEFmSMCYBDgDaUufm",
	"v9+DAkCCJCjJz6S7/SmxiEehUKgq1AsfR6koSsGBazU6+DgqqaQFaJD4F01TUXGdsMz8lYFKJSs1E3x0",
	"4L8RpSXji9F4xMyvJdXL0XjEaQFNG9N/PJLwr4pJyEYHWlYwHql0CQU1A+t1aVrXI62ShUjcEId2iKNX",
	"o08bPtAsk6BUH8ofeb4mjKd5lQHRknJFU/NJkQuml0QvmSKuM2GcCA5EzIlethqTOYM8UxO/yH9VINfB",
	"Kt3kw0v61ICYSJFDH86XopgxDh4qqIGqN4RoQTKYY6Ml1cTMYGD1DbUgCqhMl2Qu5BZQLRAhvMCrYnTw",
	"80gBz0DibqXAzvG/cwnwGySaygXo0YdxbHFzDTLRrIgs7chhX4Kqcq0ItsU1Ltg5cGJ6TcibSmkyA0I5",
	"ef/dS/L06dMXZiEF1RoyR2SDq2pmD9dku48ORhnV4D/3aY3mCyEpz5K6/fvvXuL8x26Bu7aiSkH8sBya",
	"L+To1dACfMcICTGuYYH70KJ+0yNyKJqfZzAXEnbcE9v4RjclnP+z7kpKdbosBeM6si8EvxL7OcrDgu6b",
	"eFgNQKt9aTAlzaA/7ycvPnx8PH68/+nffj5M/sf9+fzppx2X/7IedwsGog3TSkrg6TpZSKB4WpaU9/Hx",
	"3tGDWooqz8iSnuPm0wJZvetLTF/LOs9pXhk6YakUh/lCKEIdGWUwp1WuiZ+YVDw3bMqM5qidMEVKKc5Z",
	"BtnYcN+LJUuXJKXKDoHtyAXLc0ODlYJsiNbiq9twmD6FKDFwXQkfuKAvFxnNurZgAlbIDZI0FwoSLbaI",
	"Jy9xKM9IKFAaWaUuJ6zIyRIITm4+WGGLuOOGpvN8TTTua0aoIpR40TQmbE7WoiIXuDk5O8P+bjUGawUx",
	"SMPNaclRc3iH0NdDRgR5MyFyoByR589dH2V8zhaVBEUulqCXTuZJUKXgCoiY/RNSbbb9/xz/+JYISd6A",
	"UnQB72h6RoCnIhveYzdpTIL/Uwmz4YValDQ9i4vrnBUsAvIbumJFVRBeFTOQZr+8fNCCSNCV5EMA2RG3",
	"0FlBV/1JT2TFU9zcZtqWomZIiakyp+sJOZqTgq6+3h87cBSheU5K4BnjC6JXfFBJM3NvBy+RouLZDjqM",
	"NhsWSE1VQsrmDDJSj7IBEjfNNngYvxw8jWYVgOMHGQSnnmULOBxWEZoxR9d8ISVdQEAyE/KT41z4VYsz",
	"4DWDI7M1fiolnDNRqbrTAIw49Wb1mgsNSSlhziI0duzQYbiHbePYa+EUnFRwTRmHzHBeBFposJxoEKZg",
	"ws2Xmb6InlEFXz0bEuDN1x13fy66u75xx3fabWyU2CMZkYvmqzuwcbWp1X+Hy184t2KLxP7c20i2ODGi",
	"ZM5yFDP/NPvn0VApZAItRHjBo9iCU11JODjle+YvkpBjTXlGZWZ+KexPb6pcs2O2MD/l9qfXYsHSY7YY",
	"QGYNa/Q2hd0K+48ZL86O9Sp6aXgtxFlVhgtKW7fS2ZocvRraZDvmZQnzsL7KhreKk5W/aVy2h17VGzkA",
	"5CDuSmoansFagoGWpnP8ZzVHeqJz+Zv5pyzzGE4NATtBi0YBZyw4LMucpdRg7737bL6a0w/2ekCbFlOU",
	"pAcfA9hKKUqQmtlBaVkmuUhpnihNNY707xLmo4PRv00bq8rUdlfTYPLXptcxdjKKqFVuElqWlxjjnVFo",
	"1AYuYTgzfkL+YPkdqkKM290zNMQM783hnHI9aS4iLUZQn9yf3UwNvq0OY/HduVgNIpzYhjNQVq+1DR8o",
	"EqCeIFoJohXVzEUuZvUPDw/LssEgfj8sS4sP1AmBoboFK6a0eoTLp80RCuc5ejUh34djo4IteL42UsHq",
	"GEYozJ24cuKrthi5NTQjPlAEt1PIidkajwajvN8ExeFlYSlyo+5spRXT+AfXNiQz8/tOnX8fJBbidpi4",
	"8PrkMGdvLvhLcGV52KGcPuE4I86EHHb7Xo1szChxgrkSrWzcTzvuBjzWKLyQtLQAui9WiDKOVy/byMJ6",
	"TW66I6OLwhyc4YDWEKorn7Wt5yEKCZJCB4ZvcpGevZNCzG8ckGboGDTIEfFrqClMaphugAfNzDh9VoDD",
	"kyXQDCTJqKbBWXdnOK5AYMcfsB9yKZCRW8aP+B+aE/PZHEbDq+2wE3KCHEfZ8+ds/Zm5dFtV3s5kGqAx",
	"QJDC3rOJuR9fCsqXzeQ9vmXRsgvf+tZe7Qn28IswS28Md4czIa9Gwx3i5KQxRxJqRg2O8Lizs9i0KhOH",
	"n4hJwzboDNR4gPqabYih7vAxXLWwcKzpLWBBmVFvAgvtgW4aC6IoWQ43cF6XVC37izB3zKdPyPEPh88f",
	"P/nlyfOvzCWplGIhaUFmaw2KPHSqPVF6ncOj/spQx65yHR/9q2feiNUeNzaOEpVMoaBlfyhrHLOC1DYj",
	"pl0fa20046prAHc5lidg2ItFO7F2XwPaK6aMnC5mN7IZQwjLmlky4iDJYCsxXXZ5zTTrcIlyLaubuBCB",
	"lEJGzDN4xLRIRZ6cg1RMRCzt71wL4lp4Jans/m6hJRdUETM3Wg4rnoGcxChLrziCxjQUaptstUOfrHiD",
	"GzcglZKue+i3642szs27y760ke8NUYqUIBO94iSDWbVo6dNzKQpCSYYdUXC8FRkYyV+pG+CWzWANMGYj",
	"QhDoTFSaUMJFBnhxqlScjw643dDej24KHbJmvbRyegZGSU9ptVhqUpUEjfC9rW06JjS1m5KgTFUDVsra",
	"vGxb2emsSyeXQDOjvAMnYuZMgc5IiYuk6EHQnhM5Lh65zrTgKqVIQSlz6bKq9FbQfDu7y3oDnhBwBLie",
	"hShB5lReEVgtNM23AIptYuDWapezn/ah3m36TRvYnTzcRirNvctSgdHxzOnOQcMQCnfEyTlItCPe6v75",
	"Sa66fVU54OV3msoJK/D6xikXClLBMxUdLKdKJ9uOrWnUUqfMCoKTEjupOPCACeE1VdpakxnPULW27Abn",
	"sbYFM8UwwIMSxYz8dy9M+mOnhk9yValasqiqLIXUkMXWwGG1Ya63sKrnEvNg7Fp8aUEqBdtGHsJSML5D",
	"ll2JRRDVte3FuVv6i0MLhZED6ygqW0A0iNgEyLFvFWA39HQOAGLuYXVPJBymOpRTu1fHI6VFWZrzp5OK",
	"1/2G0HRsWx/qn5q2feKiuuHrmQAzu/YwOcgvLGatj3tJjQ6MI5OCnhnZhBqtNXv3YTaHMVGMp5Bsonxz",
	"LI9Nq/AIbDmkA5cJF0UTzNY5HB36jRLdIBFs2YWhBQ/cbN5RqVnKStQk/gbrG7eQdCeIWm1IBpoyo20H",
	"H5CBI++t+xPrx+iOeTVFaycltA9+TwuNLCdnCgVGG/gzWKP59p11kJ8EbvUb0BQjo5rTTTlBQL3bzQjk",
	"sAmsaKrztRFzeglrcgESiKpmBdPaRjy0FUktyiQcIHrB3zCjM7FY57LfgV1sPsc4VLC8/laMR1Zt2Qzf",
	"SUdxaaHDKUylEPkO5vEeMqIQ7GQ+J6Uwu85cgI2PwvCU1ALSKTFoX6uZ5wPVQjOugPy3qEhKOSpglYZa",
	"IgiJbBbFr5nBCLB6TmcobzAEORRg9Ur8srfXXfjenttzpsgcLnxUmmnYRcfeHt6S3gmlW4frBm685rgd",
	"RXg7Wj6MoHA6XJenTLZe7d3Iu+zku87gtbnEnCmlHOGa5V+bAXRO5mqXtYc0sqRquX3tOO5ORo1g6Ni6",
	"7b5f2Q7fN6TFoxLwcuICDUwrMq+4BapS7jqCvjdv0BDzcR15YiPODwiGJSypt8a5P588/2o0bsIJ6u9G",
	"JtuvHyIaJctWsaCRDFaxPXFHDG9TD8zVY60g6qlDxizmkbgxkGe5W1mHdZACzJlWS1aaIZsYl7WGVnzs",
	"/334nwc/Hyb/Q5Pf9pMX/zH98PHZp0d7vR+ffPr66//X/unpp68f/ee/R82Kms3i5s8fzC6JOXEsfsWP",
	"uHVgzIW097G1U/PE/O7h1hIgg1IvYwGppQSFrNEGlpZ62WwqQMeGUkpxDnxM2AQmXRabLUB5Y1IOdI6B",
	"kXinELs4auvjYOnNE0eA9XAhO/GxGP2g2xFpEw9z4+C6cb2xGXqzZy3iKA3dbnFfqbks5esbULrsQES2",
	"6cAbGZT9KuZhFLI74GqtNBR9O53t+svALeW91/F7zEDwnHFICsFhHU28YRze4MdYbyumBzqjwjTUt3sH",
	"asHfAas9zy5EeF384m4HculdHSRwA5vfHbdjog3jr9HEBHlJKElzhgYowZWWVapPOcUrbstD3CMLf3Ef",
	"Nnq89E3iVpaIEcQNdcqpMjisL75R0/0cIqL2OwBv+1DVYgFKd5T9OcApd60YJxVnGucqzH4ldsNKkOiL",
	"mtiWBV2TOc3RRvMbSEFmlW6rvyislWZ57uzFZhoi5qecasM7lSZvGD9Z4XA+GtPTDAd9IeRZjYW4aF0A",
	"B8VUEpdX39uvKLbc8pdOhGHOjv3s+eRdyysPeyyI0UF+9MpdDY9eof7fWIp7sN+Z+bBgPIkSmdHnCsYx",
	"Fr5DW+ShucV4AnrU2Jzdrp9yveKGkM5pzjKj812FHLosrncW7enoUE1rIzrWIL/WD7Fwh4VISpqeobd7",
	"tGB6Wc0mqSim/ko8XYj6ejzNKBSC47dsSks2VSWk0/PHW/Tza/ArEmFXn8Yjx3XUjSsCbuDYgrpz1nZY",
	"/7cW5MH3356Qqdsp9cBGNNuhg1DUiBXDRVu1HG1m8TYjz4Z0n/JT/grmjDPz/eCUZ1TT6YwqlqpppUB+",
	"Q3PKU5gsBDnwAVyvqKanvMfiB5Nmg9A5UlaznKXkLBTFzdG0iVD9EU5PfzYEcnr6oee16QtON1X0jNoJ",
	"kguml6LSicv0SCRcUJlFQFd1pD+ObPO0Ns06Jm5sS5Euk8SNH2fVtCxVN/C3v/yyzM3yAzJULqzVbBlR",
	"WkjPBA1ntNDg/r4V7qoo6YVPE6oUKPJrQcufGdcfSHJa7e8/BdKKhP3V8RpDk+sSWvauKwUmd21duHCr",
	"UMFKS5qUdAEqunwNtMTdR0FdoGU1zwl2a0Xg+tgQHKpZgMfH8AZYOC4dTYiLO7a9fMpufAn4CbcQ2xju",
	"1DgsrrpfQUzulberE9fb26VKLxNztqOrUobE/c7UmXwLw5O9F0mxBTeHwCU9zoCkS0jPIMP8KyhKvR63",
	"untHpZNwnnUwZfMUbYAeJtOgaXAGpCoz6nQAytfdrAYFWvtUjvdwBusT0eTiXCaNoR1cr4YOKlJqIIwM",
	"sYbH1o3R3Xzn9MaA4rL0MeoY++jJ4qCmC99n+CBbCXkDhzhGFK3g7yFEUBlBhCX+ARRcYaFmvGuRfmx5",
	"Rr2ZWckXMU953k9ck0Zrc47rcDUY026/F4BJz+JCkRlVkBHh8nVtAHnAxSpFFzBgMwutszuGabcsujjI",
	"NrkXlXRi3hVoPXkTBdk2Tsyao5QC5oshFTRvdsIV/EzWAYArmBAsw+EQNstRTaojJSzTobJlJbd1BYZA",
	"ixMwSN4oHB6MNkZCzWZJlU8lxoxrf5Z30gFuMSFiU/7bUeBpD9Kq6+w2z3O757Rnb3ZZcD71zee7hcbm",
	"HXLXxiMX/BXbDsFRAcogh4VduG3sCaVJzmg2yMDx43yeMw4kiTntqVIiZTYXvBEzbg4w+vEeIdb2RHYe",
	"IUbGAdjo2MKByVsRnk2+uAyQ3CWXUD82usSCvyEewWjDsozKI0rDwhkfCKjzHIC6SI9afnXijXAYwviY",
	"GDZ3TnPD5pzxtxmkl42Famsn98q5Vh8NqbMbTH9WsFxqTVYUXWU1oc7kgY4rdBsg3qxKxLZAIb7c1bfG",
	"1ZAs3WXqAfE9hKuHQR7XlQDoWCKaUkfu5rf1htaWzX1J1rD0cZOY7CNKY7Q/RD/RXRrAX98QXGdeveuK",
	"6+glve1ybSedBfpTjBWbM9I3jfYNsApyQI04aWkQyVnMYG4Ue0B2e+y7BTd3TG2jfP0o8ONLWDCloTFd",
	"GankbbF37aajmEovxHx4dbqUc7O+90LUPNqmbFq3Y7jMO1/BudCQzJlUOkG7X3QJptF3Cm+U35mmcUWh",
	"HSlgq8qwLM4bcNozWCcZy6s4vbp5//bKTPu2NsKoanYGa1QHgaZLMsMqSNH4oQ1T2xCzjQt+bRf8mt7Y",
	"enc7DaapmVgacmnP8Ts5Fx3Ou4kdRAgwRhz9XRtE6QYGiYL/FeQ6lmkVKA32cGam4WST6bF3mDI/9lZn",
	"rYViWEbZkaJrCW7LG1fBMGrCXPeYDooI9dMdBs4ALUuWrTqGQDvq4HWRXuq275O0O1jA3XWDbcFAYPSL",
	"RdRKUO18/Ea7teWgeLi2yU6YOWlnzYcMIZyKKV/MsI8oQ9pYcWsbrk6A5n+D9d9NW1zO6NN4dD27YQzX",
	"bsQtuH5Xb28Uz+gQs3aklhvgkiinZSnFOc0TZ10dIk0pzh1pYnNvjL1jVhe34Z18e/j6nQP/03iU5kBl",
	"UqsKg6vCduXvZlU29X/ggPhiaebC43V2q0oGm1+nP4cW2YsluMJUgTbaK6TRWNuDo+gstPO4X36rvdU5",
	"BuwSNzgIoKz9A43tyroH2i4Bek5Z7o1GHtoBHzoubrdqLFGuEA5wbddC4CFKbpTd9E53/HQ01LWFJ4Vz",
	"bSidVdjqcIoI3g0lMyok2qKQVAuKZTCsSaDPnHhVJOb4JSpnadzAyGfKEAe3jiPTmGDjAWXUjFixAT8k",
	"r1gwlmmmdrjodoAM5ogi05dUGcLdTLiyvhVn/6qAsAy4Np8knsrOQcW6I87U3BenRnfoz+UGtubpZvjr",
	"6BhhCZiuxEMgNisYoZuqB+6r+srsF1qbY8wPgT3+Et7ucMaeSNzgqXb04ajZhgwt2+6msApvn/8ZwrAV",
	"27aXAPaXV1eLZmCOaElfppK5FL9B/J6H1+NIuL0vesMw2vM34JNI1lKXxdTWnaYycTP74HYPaTehFart",
	"oR+getz5wCeFxTy8eZZyu9W2wmYrLiROMGEs19SO3xCMg7kX/5bTixmNVToxSoaB6bDxfrYMyVoQ39nj",
	"3tm8matDNCGBI7Vuy2wiWgmyyYTpJz1fUWGw0+6sKjSaAVJtqBOMrfMrVyIyTMUvKLeFWk0/e5RcbwXW",
	"+GV6XQiJaaQqbvPOIGUFzeOaQ4bYb6fdZmzBbJnSSkFQB9MNZOs7WypytUStf7lBzdGc7I+DSrtuNzJ2",
	"zhSb5YAtHtsWM6qQk9eGqLqLWR5wvVTY/MkOzZcVzyRkeqksYpUgtVKH15vaczMDfQHAyT62e/yCPESf",
	"lWLn8Mhg0cnn0cHjF2h0tX/sxwSAq0e8iZtkyE7+y7GTOB2j086OYRi3G3USTYq0ReSHGdeG02S77nKW",
	"sKXjddvPUkE5XUA8TKLYApPti7uJhrQOXnhmKyArLcWaMB2fHzQ1/Gkg5tOwPwsGSUVRMF04z4YShaGn",
	"psilndQPZ8spu6pHHi7/ER2EpfePdC6Rd2s0tfIttmp0476lBbTROibU5g7nrHHd++Jp5MhXIMAyUHX1",
	"J4sbM5dZOqo56Mmfk1IyrvFiUel58leSLqmkqWF/kyFwk9lXzyKlr9rVbvjlAL9zvEtQIM/jqJcDZO91",
	"CNeXPOSCJ4XhKNmjJsY6OJWDnsx4tJjn6N1gwc1D76qUmVGSQXKrWuRGA059LcLjGwa8JinW67kUPV56",
	"ZXdOmZWMkwetzA799P610zIKIWP1aJrj7jQOCVoyOMfAtfgmmTGvuRcy32kXrgP95/U8eJUzUMv8WY5d",
	"BIIChQNFAuusun7fiuXZ35t8k07lQUl5uoz6DGam4y9NteoaXZYHREunLCnnkEeHs/L2Fy+XI5rDP8Wu",
	"8xSM79i2W1HQLrezuAbwNpgeKD+h2RqmczNBiNV2AH4dsZkvREZwnqZOR0Oh0b3yhav+VYHSsURF/GCj",
	"RtA2ZO4UtmgVAZ6hRj4h39vXZpZAWmUEUBNmRZXblHTIFiCd0bIqc0GzMTHjnHx7+JrYWW0fW3rVFs1a",
	"oCLYXkXHJhAU9dkt/tBXUY3HRu8+zuZgTbNqpbGqh9K0KGNpL6bFiW+AuTWhnRRVxBA7E/LKaufK6352",
	"EkMPcyYLo9XWo1n5gDRh/qM1TZeo9rY40TDJ717tzVOlCgr01/V267o8eO4M3K7gm633NibC3E0umLKP",
	"jMA5tDNt6rQzd+3ymTft5cmKc0spUf6+KS3yKmj3wFlnuDelRiHrIP6SSo8tlnjZ4nfH2Cta6KJbSa9X",
	"md9mUtdlWf3jUSnlgrMUy0wEz5rUILsHS3bxM+xQkaNryPJH3J3QyOGK1u+rQ5EcFgcr+nlG6BDXN3QG",
	"X82mWuqwf2p8GWNJNVmAVo6zQTb2ZSidrYVxBa7OEr5dE/BJIVu+G+SQUXdgUpuNL0lGGHc/oDx/Z769",
	"dVcrDEg9YxyVKIc2F/tqrSH4noI2mhfTZCFAufW0yxGon02fCabkZ7D6MPHvL+AY1vVhlm39fP2hDr3X",
	"z3nZTNuXpq1N0m5+boU42kkPy9JNOlykNKoP6BUfRHDEe5N483mA3Hr8cLQN5LbRXY/y1BAanKOzD0qU",
	"wz3CqAt2dioUn9O8shSFLYgNk4nmZjIeAeM149C8DhIREGlUJODG4Hkd6KdSSbVVAXfiaSdAc/TwxRia",
	"0s68e92hOhuMKME1+jmGt7GpNTrAOOoGjeJG+bp+lMRQd6BMvMTXkBwi+5VDUatySlSGIcudWqIxxmEY",
	"t69W3BYA/WPQ14lsdy2pPTmXkURDWWipiOmb364grawDWygfwUxSTOsO5EXUGtpUxY1sQ1iZ16MWw8tn",
	"a/w3VlZqGCXOw3zpGCfvTsaOl1ZY2yP11E1DTIlii2R3TCAzvz46mqmvRmFN/xslsVws2oDccf2XTewl",
	"3KMYY/nWcOwwJ7pXK83y9DplGSOKhC+wj/e1OtmuzQ5QhvSKp6Elu66VvtmWMFz1fIxSZyCuMKh6Q61g",
	"s66RoejCdDAYlmqXk6IpaUpf9HmCLVUeG8GGJtgS6fbFx6hZaCgcwUYjmM+93rupZD0FF8feiFAf59IH",
	"6G8+iI6UlDm/X8Ms+ph14bb9AOhdAvGaDe4uwgWx4iCxlfRqIm6mkF4QcxCIb0vXTXZPhj+snaro6sHC",
	"4wvgrvJ4Ozxx5yCp+RxSzc63BI3/l1GWm4DksVen7bMWQQw5q4Nu/MOgl9TyG4A2xXRvhCeouHFtcIZC",
	"Rs9g/UCRFjVEa+mNPaFeJdcSMYDVSBJDIkLFnBb2/u/syEzVlIFY8E5C2x2aAlaDRYyDFIgrzuVJktAw",
	"LWLDlOcidoHYaS7T9VLJQhg/MhRX3i8jOiy9XmHVVlUXoK9f/gxiQMw9sVvj7sLlemKIf23y8lmfoPxv",
	"Pp/HzmJflG3KLKOB8YLKzLeIasxeGU8GIrW6sc82xJzFgZ7XM7MmpKMf/hupkYCBO2kuFOOLZCj6qR1F",
	"ET5Khb4itE1gfVaEaw7SlVfX/sHeRAsfArIJjk2ocA8oXQUJarBSoQVuMFv4fZMOjYWhqH2u2fnBwgUS",
	"CQU10MkgaXl4zk3Ifmm/+3hXXxioU4YrMq6n12Rr1rEP5mGqh8SQ6ufEScvtcbRXuaowzu3rFSqWwcwN",
	"KkMjVilFVqVWQIcHA/yVbuf6ABtYSVTLT/ur7ClsOVbLeB1kJZzBemqVpnRJeVO2pH2sbQFGu4YgC7Cz",
	"2zd6i4srrPnCLmBxI3B+zpvQeFQKkScDVqujfiJ29wycsfQMMmJkh3eDDxQyJg/RWFK7JS6Wa594XJbA",
	"IXs0IcTcpYpSr72Hol2CrDM5f6A3zb/CWbPK1kZwl7TJKY9HcNgH0K/J3/wwm7maAsP8rjmVHWRLpvNq",
	"IAlc0otIWe9dX26L+Ay6pZYborJQxLSUK6a97XS++xe1COkH5Uk3337CrFifuJYKae/7qC35W3hXeXkz",
	"9OSZ2QUfyOA63310yCYEhAAGxVg9v/tMMHfo7E2N9mApMVoLc1O2bPZZ6wJv6yl1XEJCwg1f5ANb+CUv",
	"8v2sm12Xh+vADa0U9Ne581lr4TZyzJq17WqF6iN32HikZ7sYj+K1X0x3tF5ZhGDhJIKgkl8f/0okzLGQ",
	"oiB7ezjB3t7YNf31SfuzuWjv7UWZ8J3ZrVpvAbp5YxTz96EQAusmH4hW6exHxfJs68OqYexRU9QUo2t+",
	"cRFen6Ws6i/WGtI/qq7C5GUs5t1NQMRE1tqaPJgqiCraIaDIdZtEX2tUkFaS6TUmnvnLM/slmtD/fW1v",
	"cw/M1qkKLlJeizOoUxcb61ylfBm574V93bEwEhH9FRqfq/h2RYsyB3dQvn4w+ws8/euzbP/p47/M/rr/",
	"fD+FZ89f7O/TF8/o4xdPH8OTvz5/tg+P51+9mD3Jnjx7Mnv25NlXz1+kT589nj376sVfHvjn+C2gzVP3",
	"/8Daw8nhu6PkxADb4ISWrH6lxpCxr2NKUzyJ5vqZjw78T//bn7BJKopmeP/ryEVRjpZal+pgOr24uJiE",
	"XaYLvI4nWlTpcurn6b8O8u6ojtKymTm4ozYAx5ACbqojhUP89v7b4xNy+O5o0hDM6GC0P9mfPMZy4SVw",
	"WrLRwegp/oSnZ4n7PnXENjr4+Gk8mi6B5lj73vxRgJYs9Z/UBV0sQE5cQVfz0/mT6Wu2WOrgHeEpKj/T",
	"j3gn/mRmWNj0vBr8owy91O1u71wB+yDL/+Dnj3Y7DawNtn10SHOWtKwgzCrflH/x6QMGYeO9FNf/ZH9/",
	"iDvV7aaRN6U/jUfP9h/fWN3btucoUv32iKNh2GwysUSMEDy7OwiOA902vF9xoa2VyED03KLzrnBiJADN",
	"Cba00z+9Q4SAPGcpkBMoSiGpZPma/MTroLQg2afPVX/iZ1xccA+54clVUVC5Ro6rm9dKiMBbonux2r6K",
	"HxQlxq7mHPpgq+lHZxIMz16Ho2P38HH9Xr1h515AF76N62zV71OunNy4rurobuw8w3A8a2UzKkb71Dtj",
	"ylHwYnvvyPfq3M/ZopKd9+1qB6or+coUsY8VS+I0/Xc0PQtD3pCT/KsCuW5YiVMpQt7hK/C5wLhCLcp2",
	"FElzv4i9hBUr3BzhYY11fpiLNfqN0Vn2kxcfPj7/66fRDoCgq8i9t/4rzfNf7QOEsEJ7u8/4dRld40i1",
	"ObzFjhtrL3ZotmmMYTD117CgcN2mHXz5Kxccfh3aBgdYdB9onpuGgkNsDwaY+Y0c/zre2AbT1KN4krjC",
	"QH1Jbz9FXjXxBckHnjR5dots9prL3co2v6EZFnkFpW9bit72UqJC+fnveG/6EvXKEoz2S+pPNkiraVg1",
	"c/qx5cvLriXLegWDj15tEW8P1BBT7Ndx6RTlNN/rspPo7XGVR2HFlFaPJuT7sDcyZkyLsklHleTNk3yl",
	"FOcsMyzWhUH47PEGtgcqzBiLCtvAQHovd29V7h62rX+tQiAxYFokvhGmXW8xV3xdj5Zl902FK71ZEJT/",
	"vEIRtVst7Nwxvgy+krsDg73H3dALwwPqTQBvrem0y7bePt91N6dGTLTkwS1y5d+5svaG5oZOguV20l5s",
	"dZx7Je5Po8TV8V/WCoEF4TapdVj1efrRFzO6AVXOFXPaQYkLb7pB36DYzsMOp3g0sZWJwjZXYwculmur",
	"eoYlpu4Vs9tWzPq12WJgNBW3Pp8yhjAsm+Jtl3mPqFVr/VJF5n6n2tefGFmD6paBdLuidQXe2FOiHCe+",
	"NZ75h1SeHNLu1aY/tdpkw6c3KE6twoku1n5Yd3Iuo5zZ/MtIbL7CEF87+pgoIV3EaSmZkEyvx4RxkoE5",
	"e+i5FxLrPGhZ8dQa+u0UwPG/bw7/gdH+bw7/Qb4m++NaBcM02Mj0Np6yrQN9D7ofNqy+WR/W6sBGXeiL",
	"UTBOaiQFAf0h6rXwtQ8RaQVdfT2EspX178fUs4KuRhs1kfHvR1u8rtLUSWDvU5F78xiDb/w7Xe0oVkVg",
	"RVOdrwlF+bO26RaqmjWFC9vqhhZlEg4QTfHcMKN/BiiWqHvZQNpIlRB8bmczfCedIm8tdLgCofjm1nbF",
	"pIeMKARX0/Lud/d3u7t9tZSUwpxphlVoGnniZVULyOYxGAfuQI7AhPy3qDDozL51CLHqyzgD5lP4OZ0C",
	"GpRPz/GlyRo7e3vdhe/tuT1niszhAjko5diwi469vT+Ayrqqi95SwgVPOD7Fdw4kiFS911u/aL31NqOg",
	"bns1txlURWueU/Gg9tpG/tNLTmq06EB9v5bvuuubZrrRDFu5qoEJoX4x1d2Vx82TK+YujxWafI0QNfau",
	"EwzAtV4Vux/jnmNlElPSAw/ON+ujV7vo5b8TR+jOlQIjci2+N7ctAaLxNO/vJp7mC4xKDXfhrdDkuy8k",
	"EvXqTCpOVgGzubRHpfGYhKzF5X5vZCrmhI5dZWgsVbwmdW6m4SeWEdq3Yfpcw8ywK7/4gu3zO7yKHqHL",
	"Lnrv+cI9X7gWX+gSVMMRMDZcbc25+B5sxsUfyMUY+FukKLzDRZA56HTpYuY76Wl3llJyRf8fAj1Uvtul",
	"YOFTEzvmYAdJNuj0Ahkhvh99CTLzmc0xk74uJutfrkF3DvPF3Os67u61C6Z8zLnL+CVmFy8F5ctm8n66",
	"HKLlJnyG9wi+HIJ7TO1bl+xtj5dbxB8hKt3XTU/IW1SH8ID7Wqp/RLPHbUrk217QW8HB+qWNxmpp8d4F",
	"2Uoga3LG8G3bJmtsSHVoOx0/6hXLPk3rymhDSsVA7uaQpGbNk8Nt8wotS6BSXVlIb3eHnXRmPHoVxmm0",
	"CrnVJdwioBi8XNKT+B+jHbUZTPgRc7KkaknmFbeA1o/bYchKkx04ro215jSI+QE55XtELenzx09+efL8",
	"K//nk+dfDehjZh5XB6CvkTUDmc92mF3Usj+u27GtStTIO7jrrbzcDo1HLFtFqzbByhefC8+Fs30ic3ig",
	"SEnXg8XeBuomvgF5ltcprO2E4QKMQFVLVt59IRul2Sz+5NsPZpfEnNSPKRzxb2r+eQ6SzfHdwpov3HEx",
	"LgmQQamXG0uj2GcXS71sNhXcw8BMuWpjpRTnwMeETWDSdYZli6YueQ50XlerEmKXULWAlxh688QRYD1c",
	"yC6q5rsY/WA6pKvqeddGlSakywozjzzZkSuf1eKiP4vF5a3gCepjwLW/G7TQ8vmsL1hgbBwYOOvnabjQ",
	"aNgUEtXIkG2pyU4KGAw6m1o80IZODpKxU8dSqtNlVU4/4n+wAsinptaGfYtpag2xmzSyY9viRkNs7JhE",
	"trmNLzrjjMNiTt6wVIpDLETnxIhaKw1F/5Vf2/WXTa/8REWO4DnjkBSCx+rV/Ihf3+DHaKk7dNsPdMYA",
	"iqG+3bfZWvB3wGrPswuruy5+J1+GkfdaF5bOaiWUdZgixnMg/TenpVVrvDkmrZ+nH1t/On+Ja6mWlc7E",
	"RdAXfaD2+G+1pwaV5L7UwjUNiH/iwjUvRZVntkwNq19hKVtFClsVVe6r2NxEwMUCZWAX2fHiNbaazEaJ",
	"ZlvcqER7KzKw47YLqcWitrnIwBW96QuyWlbH74GeqzXtOip5SqvFUtu3oaMPz9cdE5pa5mGL5KttVcVt",
	"K1899xwIzSXQbE1mAJyImVl0+3UGQlX92D+yZKuRxItjN3CVUqSgFGRJ+LDjJtDqUkJ439Ab8ISAI8D1",
	"LEQJMqfyisBa0bwZ0O5ryDW4tX3eSd8+1LtNv2kDu5OH20glEC9C0I4gijIHZ0mIoHBHnOANl93y/vlJ",
	"rrp9VYlvB0bKu9uvJ6zAajmccqEgFTxTw48wbDu2+OxCsBYF9ql9f1KiT7KZgQcU2tdUafd0ZatWdfB4",
	"h5liw6sRQ+U4zch/r4tx9sZODb/kqlLNq572xgNZ9LF1WG2Y6y2s6rnEPBi7vlJpQSoF20YewlIwfv3O",
	"Z/AMhA5sx2a4yOIw9Yy6C1AflS0gGkRsAuTYtwqwG9o1BwBhqkF0Xdu9TTkzIXKg3FqmRFma86eTitf9",
	"htB0bFsf6p+atn3icik7yNczASq87jrILyxm7RO+S6qIg4MU9MzdlBcuc6YPszmMiWI8dW/XDGVFsgKO",
	"TavwCGw5pN3LVnj8W+esczg69BslukEi2LILQwuOXe++CDX7snps11p+iw6q9vU2UK8mHa1wekGZTuZC",
	"uneB6FyDjNzNOjXwKNPKaZzWFqWFczARHMExFDdO8IC1CtMOLAg+9c3sfj/SzUz1nZA7hdY0XjAtiFkY",
	"qbhmvn6BOW+1jvnlxanca8/32vO99nyvPd9rz/fa8732fK8937b2/Hli5UmSeD7tAzJiaZBk9LvU8O8t",
	"1RtuI4Ga6i4JRkU353hjDJ0GmuOCWI7CtYw+km6TcfDpGiUqmQJJzXSMkzKnRhuClfYlIciMKvjqWf2s",
	"kn/s2z5eY3iNafD0CTn+4dCHBy1d/Eq77UP/hK7S6xweuVjj+nUJH3QMnOLT4hhzTP3tJ3VhXFaZn7Mc",
	"iDK4+hZbv4JzyI0mb0MOiLmL9G9HJ0Dzlw43Wy5HrbrlZrRfx607mUNbQUuv8vi1UkUohpJ1yo7Paa6G",
	"647b8Qpaxopq1HzaXpuQNXwjsnWH3M2uTXED24TeRAcxTuU6Ev3XI+8eaWhhmI8jrP6979ONh7L1ibZP",
	"ZtsoLP5mnooeyk1UHg3eqjesN5SNI5x36CT6+E03YmlUA7iLm97Qs98T8t72+6zSiiBE7og1nPmL8fF2",
	"HxF2TAPbGoXKsZ7fa2qWR3z09OLZH/tHVvE1QEdxq8Q0WgBPHG9JZiJbJy3O1BYwGVNUKShm24VMyBrx",
	"MNVyxXzZLII+j4R4FSxuE7sN6WGVON46wHhtWOZubLfGFo7oOG+A8dvmvkMcMgSBONYTuzt3awZekp81",
	"06zvedo9TwtOY0fYM+4igrtMZHI1nibXsuLD7Oxb+zKyIuEhfageGZaFGF3pluU+g1m1WNjngLtWaKxd",
	"V79q/Xm4nF3urgzucsRhB68Tvq+bq9Qdrs84glDWh0KShRRV+chWEuVrNHAWJeVr79QwN/+iyt0r/5hf",
	"ebM8tH6auqc3euPasF3unTe/BdYnJ0Xbv1u04IPWdn8hIxXPQMYfE111nojcjvGTFW848MYHJP2ryb3V",
	"uXl34f5+l11eTu3IKe0b8vZAtQ6Tyw6wJ3dyX9TgzyER3tmKvQMMth/b3jCE7YJBBiwLJUOnxJ0XDW1+",
	"+p5ehAXzbkpp3P22vgSUifXtNVIP0KiRUtAspQqNGhz0hZBnt6xL6tVRxIqMYGJd1366l7mTTLYqlTju",
	"TiplO8PS38qrWcGUfZP28yqXTQ7PoUuTb2Hj3rD7RzHsfuMPnyKUSHrRPZzWh4Nncgc2RS/0ike51LS0",
	"deGH4peDA+EqyN9oJEZv+HZARlCV3TqUIS8JJWnO0N0suNKySvUpp+jQChbWL5Fau+mGVamXvkncpxpx",
	"ebqhTrlRquakdnNFVao5RBzY3wF4jU1ViwUo3eHEc4BT7loxTirONM5VsFSKxGbTGHFtOPrEtizomsxp",
	"jh7Z30AKMjOXiLBWILqHlGZ57qJDzDREzE851SQHw/TfMKPQmeG8B6GOeLJ0V2Mhnl3rHmdO4tbZ7+1X",
	"zFx1y/deAHRW2M8+x2z8eZ5QT1g2CPnRK1fH9+gVlmZs4kJ6sN9ZsEDBeBIlMiPxXXxVl7bIQ6PjeQJ6",
	"1ESYuF0/5UaZ1oIgo6f6auTQder2zqI9HR2qaW1Ex/fr1/ohVkNmIRJzZaQL8/uC6WU1w0fMfW2Z6ULU",
	"dWamGYVCcPyWTWnJpqqEdHr+eIt+cA1+RSLs6l5y/4GewA7owJyWeuPxvZLu3g/I5Rt4NuHLfitha8Dp",
	"/csE9y8T3Neuv3+Z4H53718muK/bf1+3/89at3+yUUN0te62VtLWPdMmJRJSO3PNwMNmrZrbfa8k0xNC",
	"TpaG/1MjA+AcJM1JSpVVjLiNey7YYqmJqtIUIDs45UkLklQUbuKHzX/tNfe02t9/CmT/UbePtVsEnLff",
	"F1VV/ISuJvI1OR2djnojSSjEObgKvNg8qzD8xfbaOuz/qsf9Ufa2rqBra1xZ0rIEI9ZUNZ+zlFmU58Jc",
	"BhaiE63NBX4BaYCz1cYI0/axA8QnRrm7mBjqavjElO6+fL/EU62H3ZpQd1pM8I+rYG/iU/0NuzkeuHHs",
	"HkO8Zxl3wTI+O9P4A9U9vi9x/IUtKHSktt4wuIYmVT/eG7E7eR3JmpMNb8YRIK0k02uUcLRkv5yB+f8H",
	"w8cVyHMv/CqZjw5GS63Lg+kUXxlaCqWnIyOamm+q89HIB7qwIzjhUkp2jhXKP3z6/wEAAP//4XvvGSMj",
	"AQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
