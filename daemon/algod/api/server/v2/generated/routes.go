// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetProofForLightBlockHeader(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProofForLightBlockHeader converts echo context to params.
func (w *ServerInterfaceWrapper) GetProofForLightBlockHeader(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProofForLightBlockHeader(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetProofForLightBlockHeader, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"+/j/AwAA//92ZqolGSgBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
