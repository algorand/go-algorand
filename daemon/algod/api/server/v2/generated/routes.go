// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
