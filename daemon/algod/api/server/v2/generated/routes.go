// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"0oUdwRn4SskuMN39h6v/HwAA///NV4MpsvsAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
