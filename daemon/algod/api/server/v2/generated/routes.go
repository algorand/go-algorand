// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
