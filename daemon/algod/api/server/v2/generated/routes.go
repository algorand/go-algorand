// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"wo7gDpdSsnPMSvnh8v8FAAD//wv9yovcDwEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
