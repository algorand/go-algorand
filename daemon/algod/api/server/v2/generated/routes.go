// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//6ElSqLFkwAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
