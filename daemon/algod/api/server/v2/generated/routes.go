// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"bXx/+f8CAAD//y2lxjHn6wAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
