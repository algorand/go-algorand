// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/boxes/{box-name})
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, boxName string) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Path parameter "box-name" -------------
	var boxName string

	err = runtime.BindStyledParameter("simple", false, "box-name", ctx.Param("box-name"), &boxName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box-name: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, boxName)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/boxes/:box-name", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"nh8BAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
