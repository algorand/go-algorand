// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
