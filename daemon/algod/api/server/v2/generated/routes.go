// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"yBp12QAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
