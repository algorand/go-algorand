// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
