// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"5QAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
