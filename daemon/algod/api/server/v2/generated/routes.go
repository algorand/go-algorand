// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{addr}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, addr string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{account-id})
	PostV2RegisterParticipationKeysAccountId(ctx echo.Context, accountId string, params PostV2RegisterParticipationKeysAccountIdParams) error

	// (POST /v2/shutdown)
	PostV2Shutdown(ctx echo.Context, params PostV2ShutdownParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "addr" -------------
	var addr string

	err = runtime.BindStyledParameter("simple", false, "addr", ctx.Param("addr"), &addr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter addr: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, addr, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// PostV2RegisterParticipationKeysAccountId converts echo context to params.
func (w *ServerInterfaceWrapper) PostV2RegisterParticipationKeysAccountId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV2RegisterParticipationKeysAccountIdParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostV2RegisterParticipationKeysAccountId(ctx, accountId, params)
	return err
}

// PostV2Shutdown converts echo context to params.
func (w *ServerInterfaceWrapper) PostV2Shutdown(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV2ShutdownParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostV2Shutdown(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:addr/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:account-id", wrapper.PostV2RegisterParticipationKeysAccountId)
	router.POST("/v2/shutdown", wrapper.PostV2Shutdown)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
