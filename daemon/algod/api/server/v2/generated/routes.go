// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys)
	router.POST("/v2/shutdown", wrapper.ShutdownNode)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
