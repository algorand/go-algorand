// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/transactions/dryrun)
	TransactionDryRun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionDryRun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.POST("/v2/transactions/dryrun", wrapper.TransactionDryRun, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9f3PbOJLoV8HprmqSnCg5v2Y3rpq654knM36bZFKxZ2/fxXm7ENmSsCYBDgBa0uT5",
	"u79CAyBBEpTk2Ekms/4rsQg0Go3uRnej0fgwSkVRCg5cq9Hhh1FJJS1Ag8S/aJqKiuuEZeavDFQqWamZ",
	"4KND/40oLRlfjMYjZn4tqV6OxiNOC2jamP7jkYRfKyYhGx1qWcF4pNIlFNQA1pvStK4hrZOFSByIIwvi",
	"5Hh0teUDzTIJSvWx/JnnG8J4mlcZEC0pVzQ1nxRZMb0keskUcZ0J40RwIGJO9LLVmMwZ5Jma+En+WoHc",
	"BLN0gw9P6apBMZEihz6ez0UxYxw8VlAjVS8I0YJkMMdGS6qJGcHg6htqQRRQmS7JXMgdqFokQnyBV8Xo",
	"8N1IAc9A4mqlwC7xv3MJ8BskmsoF6NH7cWxycw0y0ayITO3EUV+CqnKtCLbFOS7YJXBiek3Iq0ppMgNC",
	"OXn74jl5/PjxMzORgmoNmWOywVk1o4dzst1Hh6OMavCf+7xG84WQlGdJ3f7ti+c4/qmb4L6tqFIQF5Yj",
	"84WcHA9NwHeMsBDjGha4Di3uNz0iQtH8PIO5kLDnmtjGt7oo4fhfdFVSqtNlKRjXkXUh+JXYz1EdFnTf",
	"psNqBFrtS0MpaYC+O0ievf/wcPzw4Orf3x0l/+P+fPr4as/pP6/h7qBAtGFaSQk83SQLCRSlZUl5nx5v",
	"HT+opajyjCzpJS4+LVDVu77E9LWq85LmleETlkpxlC+EItSxUQZzWuWa+IFJxXOjpgw0x+2EKVJKccky",
	"yMZG+66WLF2SlCoLAtuRFctzw4OVgmyI1+Kz2yJMVyFJDF4fRQ+c0O+XGM28dlAC1qgNkjQXChItdmxP",
	"fsehPCPhhtLsVep6mxU5WwLBwc0Hu9ki7bjh6TzfEI3rmhGqCCV+axoTNicbUZEVLk7OLrC/m42hWkEM",
	"0XBxWvuoEd4h8vWIESHeTIgcKEfiebnrk4zP2aKSoMhqCXrp9jwJqhRcARGzf0KqzbL/79OfXxMhyStQ",
	"ii7gDU0vCPBUZMNr7AaN7eD/VMIseKEWJU0v4tt1zgoWQfkVXbOiKgivihlIs15+f9CCSNCV5EMIWYg7",
	"+Kyg6/6gZ7LiKS5uM2zLUDOsxFSZ082EnMxJQdffHYwdOorQPCcl8IzxBdFrPmikmbF3o5dIUfFsDxtG",
	"mwULdk1VQsrmDDJSQ9mCiRtmFz6MXw+fxrIK0PFABtGpR9mBDod1hGeM6JovpKQLCFhmQn5xmgu/anEB",
	"vFZwZLbBT6WESyYqVXcawBGH3m5ec6EhKSXMWYTHTh05jPawbZx6LZyBkwquKeOQGc2LSAsNVhMN4hQM",
	"uN2Z6W/RM6rg2ydDG3jzdc/Vn4vuqm9d8b1WGxslViQj+6L56gQ2bja1+u/h/IVjK7ZI7M+9hWSLM7OV",
	"zFmO28w/zfp5MlQKlUCLEH7jUWzBqa4kHJ7zB+YvkpBTTXlGZWZ+KexPr6pcs1O2MD/l9qeXYsHSU7YY",
	"IGaNa9Sbwm6F/cfAi6tjvY46DS+FuKjKcEJpyyudbcjJ8dAiW5jXZcyj2pUNvYqztfc0rttDr+uFHEBy",
	"kHYlNQ0vYCPBYEvTOf6zniM/0bn8LUZMw7luh8VogIsSvHW/mZ+MrIN1BmhZ5iylhppT3DcPPwSY/IeE",
	"+ehw9O/TJkQytV/V1MG1I7aX7R4Upd7cN9P/PhfpxUeNXUpRgtTMzmJm4PQZBMGTJdAMJMmoppPGl7Dm",
	"xcAyY8efsB86ByAjmv1n/A/NiflsmI9qb7UYi40pY7uIIL6SGUPHqk87kmmABpgghbVtiLFJroXl82Zw",
	"q5dqRfLOkeV9F1pkTX6w5hTBHn4SZuqNs3Q0E/Lj+KTjUnLSuICEGqi10Wdm3l5ZbFqViaNPxIy0DTqA",
	"mqhbX5uEFOqC34dWAf821DnV9BNQRxmot0GdNqDPRJ1juZEVvwXxBimFjJg1Rn9ybME0FGqXTrL4nK25",
	"9VqxvwVIpaSb3vTtsG6QfebenrA3mhQpjce95iSDWbUgjFsJxsCpFAWhJMOOKHCvRQanmupK3QI3NcAa",
	"ZIz6CVGgM1FpQgkXmWEM0zjOZwMhIvRN0aXWIevqpdVvMzBGR0qrxVITs1uLPtuFMaiEpnYFEtRFasCi",
	"rl0h28oOZ8MPuQSabcgMgBMxc2arM6hxkhS9Xe0D2Y7LG7RqU6uFVylFCkpBlrio/U7U/AkALrLeQibE",
	"G/GtByFKkDmVH4mrFprmO/DENn1sVbNbOVO/j/V+w29bv+7g4SpSaSx3ywRmazSSnIOGIRLupElVDkR5",
	"nXY8Y4URCcIpFwpSwTMVBZZTpZNdomAatVS4WdaA+2Lcj4AHfJmXVGnrTTCe4TZvRRjHwT44xDDClyAV",
	"EzwO+a/2Ywx2anQPV5UiDgJRVVkKqSGLzcG4oMNjvYZ1PZaYB7BLKbRIRW4WulKwC/IQlQL4jlh2JpZA",
	"VDt3tna3+5PDyKHRrZsoKVtINITYhsipbxVQN4x0DSBibMK6JzIOUx3OqcNr45HSoiyNTtJJxet+Q2Q6",
	"ta2P9C9N2z5zUd3oykyAGV17nBzmK0tZG+NcUkUcHqSgF0bfl1IsnNvTx9kIY6IYTyHZxvlGLE9Nq1AE",
	"dgjpgAHjTlGC0TrC0eHfKNMNMsGOVRia8DWtqTc2iHfWOLi3YCAcg6YsV7URUEcKm1EwqNg98F1RhWFm",
	"rvON4eE5k4WNy+Peofxv1sTI3Cg2At2IJc+IhBWVmW/Rt3Bd+J9nsI7rWxv3xwaExRGd16MxTVIfKXdH",
	"C5P4voHBbYucih174AfDjwVLpaD2NMMQ3u5Zug7YSyiowQ7j6m6PHR6T8UViD08iu5X97g9XfFArXKo4",
	"XL88g4JWr8hqCRivNdqzQ8RwkeeklKBgaCKlEHlS2+zd0FxPz3RHumDpBWTEMCRaPU79fdPGyQxC7plF",
	"VXXwcrXceIOqLIFDdn9CyBEnKETO6elsdZ3B+Td62/hrHDWr8ByFcoKTnJzz2LblT2FuyEUezHbesWkJ",
	"NxzKAtk+kF7zAQaiKwwiGnBRjtwayjjFnoFu66nygKksFvuozx/xrJ62VpllaO026ktVs4LhgX3QbGx0",
	"hT9D6btLTE8IOUNpMeaqgkuQNMfTSOWjPEyRghmvR1VpCpAdnvOkhUkqCjfwvea/VhDPq4ODx0AO7nf7",
	"KG3sFGeZWxno9v2OHIztJyQX+Y6cj85HPUgSCnEJmfVOQr62vXaC/bca7jn/uaeKSEE31q/xskhUNZ+z",
	"lFmi58JosoXomBtc4BeQBj0w3oEiTI9ReSNF0Uyz69IIYHx7vA0HOgLVGGhm85CSbnzkvM07isCapmaW",
	"FJXMhqwMo9R81t/ltCiTEEA0LrRlRBexs+dDPhTykXLXDYqMR9ad247fWceha5EjYNfJbqOtR4woBvuI",
	"/xEphVl15s7I/UFqzpTuIek8SwzX1gwZ2XQm5P+IiqQU5besNNRGvZBoKaMHZUbAXdSP6WyThkKQQwHW",
	"38YvDx50J/7ggVtzpsgcVj6xxDTskuPBAysEQunnoihZDrcQdltSteyv9IwqePyInP509PTho78/evqt",
	"mQza+7Qgs43ZWO+5Qw+i9CaH+/HdEUNwUejfPvHH+224O+OViHANex8OOQOjtS3FSBMWNHS8sSbpiPj6",
	"JGJ64TyNVRJJqjSzmeycM8Lda6oB6JNjPyAqJaVwq74aj4zPmm9uQXFaQESCsxRVK3qj7FcxD5OBnByo",
	"jdJQ9EOQtuvfB2zYt97V6lksgueMQ1IIDpto/ivj8Ao/Ru0dFLWBzqj0hvp2XdEW/h202uPss5o3pS+u",
	"dsASb+rUpFtY/C7cTvQ5TINCax3yklCS5gwje4IrLatUn3OKkYaOOdlhCx8/GY49PfdN4sGuSCzKgTrn",
	"VBka1vGHSUyTzSESWXwB4ENQqlosQHXMSzIHOOeuFeOk4kzjWGidJ3bBSpCo+Ca2pbGo5jTHUNlvIAWZ",
	"Vbq9hWG2hrUQbSjcDEPE/JxTTXKgSpNXjJ+tEZz3Hz3PcNArIS9qKsTt/wVwUEwl8b3hR/v1J6qWfvqm",
	"oVc2rrON9hr4TUrHRkMrHfT/3vuvw3dHyf/Q5LeD5Nl/Tt9/eHJ1/0Hvx0dX3333/9o/Pb767v5//Uds",
	"pTzusVwCh/nJsTPvTo5xD2+i4D3cP1sUt2A8iTKZcbsKxjElrcNb5J6xRDwD3W/i6W7Vz7lec8NIlzRn",
	"GdUfxw5dFdeTRSsdHa5pLUQnKOfn+j7mNi5EUtL0Ag86Rwuml9Vskopi6s3a6ULUJu40o1AIjt+yKS3Z",
	"VJWQTi8f7tgab6CvSERdYbaOPX4Msi0i5r07Kmp5mgaizTa36UrG0zqGOePMfD885xnVdDqjiqVqWimQ",
	"39Oc8hQmC0EOiQN5TDXFAEUnrjZ0IQRzaR02ZTXLWUouwv2t4fehONX5+TtD9fPz971jnv5u5IaKMr4d",
	"IFkxvRSVTlxscjjI0QSCELINk20bdUwcbLvMLvbp4Mf1Hy1LleQipXmiNNUQn35Z5mb6wZ6pCHbCLBSi",
	"tJBesxh14wIuZn1fC3fQJenKp8BWChT5R0HLd4zr9yRxwYGjsnxpYJ4aPP7hBNho3U0JLUdwa55Og2ID",
	"TMW8QJy5NVP2TAFqQCPUU9vL3wNRcdKZT0g7bGNkrTkF+VhCGVA/idys7kfTKYARpU6ll4kRquislOEt",
	"FIjg5hJdGA3jj6aMU2+4z2XSz4CkS0gvIMP4O0Ywx63u/kTY6Wsvs0zZ5HebgYQZmuiszoBUZUbdjkb5",
	"ppsqp0Brnx/4Fi5gcyaaBM/r5MZdjUcuyJ4YnhmSkNLQI1CtYt6WFx+o7yy+O2LAQHhZkkUuZk6sarY4",
	"rPnC9xmWIKvvb0F6YkxRk2ELv5dURghhmX+ABB8xUQPvRqwfm15JpWYpK+3890sIfNPqY4Ds0upRPS7m",
	"XXXd06ZR9W0bJzOq4pobzBezHkaGuskXfiQb96H2cAwvUDrGneUQnPIoJ9lUognhp21vhA2hFucSkLzZ",
	"Tj0abYqE+/bSnc6xy+ZMDk9l99nhdh4SGS7yx+msHRxnZtwcLungOcVg5vJJcEYeXIip85K9YusKw7jO",
	"Ubd3U33+sk9a9pnKo/G1so7HI5cKFVsOwXF7zyCHBXVheUyycoziUPtGBQtk8Ph5PjdOP0lix+1UKZEy",
	"ezbZ6HI3Bhjr7wEhNlxB9oYQY+MAbYxnImDyWoSyyRfXQZIDwwAo9bAxEhr8DbvjWM0lYWdX7rT/+rqj",
	"EaJxk8Rvl7EfUxmPoippyDRvtSK2yQx6DkKMRY1q6kcZ+rEMBTngdpy0NGtyEYs9GasCkA1PfbfAXif3",
	"2Nxs8veDsLaEhfFoGy/QSKsPa3xeT/xSaEjmTCqdoAManZ5p9EKhMfjCNI2rnxapiL1lyLK49sFhL2CT",
	"ZCyv4qvtxv3LsRn2de24qGp2ARvcZICmSzLDW7FmF2oNb9psGdqmnGyd8Es74Zf01ua7Hy+ZpmZgKYTu",
	"jPGVcFVHn2wTpggDxpijv2qDJN2iXtD3OYZcx7K9G/sRtxBUzvaawqC73hOmzMPeZn4FWAxrXgspOpfA",
	"0N06C5uIY3Ntgkul/ZRiWpZDaT3WP2DZuuNDW+CDfnmCo13HZrfGf58gNWotuDvo0rjP0bw7CT4EYBc6",
	"2EntpWEeTrXPAYYz8QL1rvmdAc3/Apu/mrY47uhqPLqZx96hT4NKDXhv2kQMqjeUyY73F7BR+GtAv+38",
	"FDE8/cJcOxiylT0s2B2zf1PzZZQrMLps3dhW+O+aDELLUopLmifuzHRIrqS4dHKFzf0R6+c3AtIcqLRR",
	"tK04Y7vy94GzXadkL26KCmII4MZxtCAOmdyqhPd4Kb5aO/g+HGHLlePC3qpXRPBuioQxtdATRAekoBvj",
	"59noaV8AeFUkhgkSlbM07t7zmTJ8xKsCLx1sNBBsPGC0GYgVG4hx84oFsEwztccZSQfJYIwoMTH0soV2",
	"M+HKIVWc/VoBYRlwbT5JlzLVck6MgebzXnvkG9iMHWCXZluDjyd+7rcBG1ADW6/Xq9u23DASG0lo9o6Z",
	"n2gdQjY/BAG0a5ykhCP21O6WUxDHH46b7Rnvsh1RDasX9UOqhjHsTffdpZO8e7+0iA6MES2FhHHGWLau",
	"z+NB8fPRSOvaYu50fc01DEz7JOIe6zUdfUQaM7Ntdh/NlYiAqfiKclvZxPSzNHS9FVjf2vRaCYn3bhRE",
	"z2aZSuZS/AZxj29uFiqSxeVIiflX2HsSuc/QVZ119KKpWeXpG+IxyNpD1kLwkbRPugYkHLk8CDFjWqoP",
	"BFFu2dpWYWkdWsaFI0w0mFr4jXA4nHvJGTldzWjsZrbZ1g1OR81hRitkpQXxnf0qqDob2/FecC5St2X2",
	"skoJskm17BseQ+x+FrDfV8/yGaSsoHk8gpkh9dvXFTO2YLaUTaUgqJXiANkaYJaLXL0Ze1zUkOZkTg7G",
	"QTUmtxoZu2SKzXLAFg9tixlVuGvVYcm6i5kecL1U2PzRHs2XFc8kZHqpLGGVIIK7lUJHpY4Rz0CvADg5",
	"wHYPn5F7GB1X7BLuGyo6W2R0+PAZJiPYPw5im52rWbVNr2SoWP7bKZY4H+PxgIVhNikHdRK9OGULDQ6r",
	"sC3SZLvuI0vY0mm93bJUUE4XED/1LHbgZPviamJwrUMXntkqWUpLsSFMx8cHTY1+GkhIMurPouGy7Qsj",
	"QFoQJQrDT00hFDuoB2dLbrkqDR4v/xGPIkp/a6LjlH1ef8Tu5bFZ44HRa1pAm6xjQu39Qrz44e6lOoU4",
	"GUjUBXkZH0QOLLDfN11fco8LnhRGdrL7TapbwH+xgfGwKzqs9rqrm16yHfS+ppaBkgwStmoRlgY66aNJ",
	"XMn4PGllhvrl7Uu3MRRCxq7uN9rQbRIStGRwGZXYbspWbZnU24WnfMxAsQUOjsoyYnj7T7j6ykc0aFm6",
	"gNfcHghhM5LSPJ9cK4aza9WCTb1H4E8RGGwot8VX8QUhfq1A6ditLPxgk4LQzzVEciQCnuGOOyH2FpNZ",
	"5tY9FNzpWFHl9k4DZAuQjtZVmQuajYmBc/bD0UtiR1XuyiXensFiFAt7I65mqciaBEUE9ksX8JV/4ilE",
	"16zWYXgtAsnMWWm816s0LcpYxqVpceYbYFrnJWW5P6THDSCkzYQc271Xec1uB2luPpJ6OCft+ULgTXOq",
	"NU2XuKm1tgDLnFFP2R0CDmctv3EtfNKyCkq01dWu6pv59mqjFsQsHXIAz0COiTCWx4opW2YSLqGd5Fln",
	"PDujyid9tqcnK84tn8R3iC0Z+R9Ddo+cPf7yQaEoZh3CX1NlKFHJFK7LkafYK3pPqluMph7T1ZzcJ4tq",
	"jxtZXa3kJdQJWEQ6IgwXnJA7MgwWuvF6zM18QPXbr2ZV7PLaPzUWNzS+1AK0cooJsrG/dONcIcYVuFIJ",
	"WH40UHNm2+gek93u1oFZbgM7/gvzDXd75jJTLhjHG6SObC4JxjorWBJPGw+JabIQoNx82jd71DvTZ3K2",
	"5icG4/cTX0IPYdjYq5m2DXz3QR35MPgbdztKSPLctCUYcW1+bp2p2EGPytINGhNlVa9wrNLS8PnKln0y",
	"IG4NP4S2hd22nqXhdmgYDS7xTAhK3EZ7jDFwD/0H4xdajrLXWe3JdjSvn/EIGi8Zh6bAY0TDp1GdjguD",
	"8jrQT6WS6nS5t1I6A5rjEUNMIyntoi83BdVZYCQJztGPMbyMTb2tAcVRN2iy7inf1HUlDXcHptlzLGjr",
	"CNkvqIVGkbOBMsxd6pTYiikOY436ImdtDd4Xg75JY7trSa3kXGcrseeLfagZU8aiL2Z5JFvjuP4YXJDE",
	"tLDZBv+N3QIenoE7kbp2FoE/fsKO1zYP25B65p1Z+0SxxUeuStP/FpelIwPhGsW4/wejVsLLdL0L3Vbx",
	"1EX58JRX+KKS6BPU+ddtnkVFF6NDUAdwu983XNFvjKpxIF/lbXPdkFrta8NrQ1kr6WCSFdUug1JTsq14",
	"ib34G4Ngj/LshWNbWT7qWw8d39nTO/O513s/u6FnhSHsrQT1p8F9hP7iUypISZmLHTciEs0GiTLAXhki",
	"zQJHMjtGHkhsJh+Zy7SX7PWpFBHs8Ex9B3tetEhqLz10LEkh4ZZJG2yh1yRtP1tg3+nhPJBjKgX9ee69",
	"AC3aDtB+H8I3eqFP3GFx1rN9xDmeO266oz6xBPG3G/ra5LNpg1a9AjdubNX/Olgwz15vopqsgFDOBUqU",
	"CzISSgqRQU6Uq5+Sw4KmG3cjUZ3zlHKSMQlYhIQVWLiNErWiiwVIvMoqMWjkgwsILbJaFcuzXWzjYHyP",
	"bSM3hL/kHd++EFtkr2VOdJcWJ7r9Tms9zKe6x5qKorChgRb5o7c56xtiGDVB9Jtig9tCfzNJufVEehRC",
	"KEH1+0jVsSXlHPJob3sU84U4pKD/FAM4F4zHP3VZwBKmQ4Zmzu0Z+iE9/Eh5h/FIQVpJpjeYLuU9E/b3",
	"aLr2j7X8utLm9aGzO/O0j0m404BG2pv6/z8KW/akMO4Sug4aK9v8sKZFmYPTo999M/sTPP7zk+zg8cM/",
	"zf588PQghSdPnx0c0GdP6MNnjx/Coz8/fXIAD+ffPps9yh49eTR78ujJt0+fpY+fPJw9+fbZn77xxfct",
	"ok1h+79hiYPk6M1JcmaQbRaKluwvsLG3tA13+jIUNEXNDQVl+ejQ//S/vJwYAQreC3O/jtzhymipdakO",
	"p9PVajUJu0wXWF0w0aJKl1M/Tr+Q0JuTOh5vDzJQlmyw1Qg67hdM55hYg9/e/nB6Ro7enEwadTA6HB1M",
	"DiYPsSpJCZyWbHQ4eow/Idcvcd2nS6C5NpJxNR5NC9CSpcr95VT4xFXgMD9dPpr6COD0g8skuDJwFrHU",
	"MV8RrQ4h9+96j+02Y7zaugJacKtJuctOYzKzSVLEFeHjGQZ5bQKM2fxq8pxkwXuEjcbxZyfuOcV3X9EL",
	"QbHyXLFL87E3H+t0++E3P4Jn0fxTaE//fBU5zXvfec7h0cHBJ3jCYdyC4ulyy29BPLlF1Nu+940n0AXX",
	"m8Yrmht+gvq9Lzuhh1/thE44XngxCoxYBX01Hj39ilfohBuBojnBlkH+Tl9F/sIvuFhx39JszlVRULnB",
	"rTe4aR/aTleDqridOeeuLA7rZwgKyAW3nFtHIrON57MxUXWh6FIyYUwIfB0vg1QCxQ1fSDwKbErRubuc",
	"YCtjvzr6G547vDr6m63xGH05LBje1jttK/cfQUdKJX6/aV6/2arpv5T6HP9uH1v7evbCm25BdwU37wpu",
	"frUFNz+l0RKxMtZ1IislXPCE40X+SyCBE/spzY4vbyfssbE/PXj8+YY/BXnJUiBnUJRCUsnyDfmF1ykv",
	"NzM0armpeJCEtFWGeiXSG1uhMVLsayvTD5gBEvqKvU0dnxj7A/lpQRUTKQp/r16QOeh06V4/68TEht5u",
	"3GqBbEsdv/GOeff23U3evtvD07gj8Od5XPBrdvm/pxnx+bsJeY2xdBRwnxT0R4wAPDl48tVO6LXgQGDN",
	"FFY3srx4F9WojQ28ZIVE8ZVgw9KjtengXlSafmieOLtqAtE2CX1qy09vsyts+erRrbqOdyXHv4KS41/e",
	"O7mRhHRmKyF8pw3cJYxGWnxxpH7FoPZZjWuulpXOxCo42WmK0A1Kkn+x8xYl6e7Z0LtnQ++eDb17NvTu",
	"2dC7Z0Pvng39up8N/frCwd0g3if0etombGDKNCac/Xu6okwncyHt9pRgdYxIALU9+n9Tpl1NFudbaWGU",
	"BZgdGutrWEXj4AS3c1V4IOKKC/vnMlmB6altS9AM9ULIveK1TRBUC2ImRiqumU/2wSL03p77/QU/7yzV",
	"O0v1zlK9s1TvLNU7S/XOUv1jWaqfMW2gdXyTeEXtsytiuRXkLrniD5Rc0RjYtXmNBrkxh418bz0E0UDz",
	"qStggefFQg2m2ofFMFIzHOOkzCkWuVtrnzpItr17izqo/+yuf1lx69u7fU/hDGju3gh2Vjwo/b3INp11",
	"NehNEdNrume9GWuBz1m5gh891+HqVtMh/nUfLf5y+pMgRo6pGl3xL68sP0o5eTJGxYhxKjdjw2FZlQK+",
	"seD4Z52YRgvgiRPpZCayjS/26wqv1Aqsk1rqFVhbU7ylqzBRdZuyCMm6TiyabdI2l/zsx/EeimQJtka3",
	"F6xIHq4hihQ0S41Fr4WvE/WJlczX8Zj3F1QIzYWYI5dZ1KLGnXb4o5hS33vhU4TiS4Qd4Qxqt012ailJ",
	"V3rNo1pqauv3DCurQCKO5eZttb++uh6l2yUdd4jmPSHJQoqqvG8LPvMNRqGKkvKNj7MaxwmLOOK7YraE",
	"1e3qrp3apCkFiZ2/oOq4UwwfK4hvpLhkGcTLerozCB1lzZvJZVNbNZqh0nta+3YzVW7n5e5zHnm6u3dE",
	"0Hvd/DCSCG+bxKOOkaCgA3XOKdYtrgNB0eIn0UfgXwD4WKCqFgvAN+s7r8Gfc9eK8aZGcsFSKRKbp+Uf",
	"ip/YlgXdkDnNMWb5G0hBZpVu3zvAQInSLM/dmQQ+Oi/m5xyrkRhj7BXjZ2sE9zFPy/friETf6//J+MBu",
	"+t4fjr7W/yWrkEQxPzl299pOjvGaR3Mc0cP9s4XT/ev70bi/O9Xr8ha554rEIwPdbw423Kqfc71GSwD1",
	"rC8EfV126IY9e7JopWN7VZZWdNTP9VNVaLl8uMM4uIG+IhF1dbdx/oFufnVeEakXHl897679wL58CxfN",
	"f9+3y3emOdzd5b67y313l3vPu9x7XFW5W927m/pf8U39u2o8v+N7a5/SdPvUs/m91wCYbLUQpx/0mmW7",
	"K8aFUFlmHz+SkNqRawUeNhsTpmtzqp+RyfSEkDN82YiaPQAuQdIcH7RT/jIzU6Rgi6UmqkpTgOzwnCct",
	"TGyhRTPwvea/1s09rw4OHgM5uE/aXWzYIlC8/a5oqeInW6P7O3I+Oh91AUkoxCW4UgLYOqvwmM522gn1",
	"3xzYc/6z7C1cQTc2tLKkZQlmU1PVfM5SZgmeC+MKLEQnm4kL/ALSIAdGnyrC9Ng9BsuUzQJzOQfUlSCP",
	"mdz93f0ahfuOOswSTyQ2bHfNMk7/uU8Np38V8/oYNGW5qvObI94U+jVdzlpR1QhurVPGPi1W+d/ciYQb",
	"JWcXEGYcYqr6isrMt4iUf7cvoMbfFT5r3nDEt95ZHNF5PRprnuOsXziNp8TmQkFikVOxWtX4wSgADIFS",
	"jIBS91ybf4PIwDAyRA12EvP23dvBg2MyvkiGXgN+br+74ph1CKwTcI7A9cszmENYr4h/g5SpHhHDRZ4T",
	"d303PqBRT8nAmykn/RTK7kgXLL2AjBiG9G/iDdiK5J4rG+petVotNz5X3Oq7+xNCjrh9ldI/cNUOaXYG",
	"59/obeOvQw3dVn2RRJ8U2CXIG3KRB7OddxQYFrvhUBbI9oH0mg8wEF1FPKd9K4VEHKWO2xIwlcViHw/l",
	"67c7un0+3vDoQro9y+OL2x53p82fsqjK1uyE10KTF7it3MxDqWtJxywQi4Qvb47GYl3Y/N17YxLhG7HO",
	"jmyqdR9Op/i+0FIoPR0ZK69dyTv8aNQJXVgIzk4rJbvEqkXvr/5/AAAA//8iycJLw8sAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
