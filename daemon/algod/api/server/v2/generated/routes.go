// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{addr}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, addr string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{account-id})
	PostV2RegisterParticipationKeysAccountId(ctx echo.Context, accountId string, params PostV2RegisterParticipationKeysAccountIdParams) error

	// (POST /v2/shutdown)
	PostV2Shutdown(ctx echo.Context, params PostV2ShutdownParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "addr" -------------
	var addr string

	err = runtime.BindStyledParameter("simple", false, "addr", ctx.Param("addr"), &addr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter addr: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, addr, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// PostV2RegisterParticipationKeysAccountId converts echo context to params.
func (w *ServerInterfaceWrapper) PostV2RegisterParticipationKeysAccountId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV2RegisterParticipationKeysAccountIdParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostV2RegisterParticipationKeysAccountId(ctx, accountId, params)
	return err
}

// PostV2Shutdown converts echo context to params.
func (w *ServerInterfaceWrapper) PostV2Shutdown(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV2ShutdownParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostV2Shutdown(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:addr/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:account-id", wrapper.PostV2RegisterParticipationKeysAccountId)
	router.POST("/v2/shutdown", wrapper.PostV2Shutdown)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9e3MbN5L4V8GPv62K7eWQsq1kY1Wl9uR4k9Vt7LgsJbt3lm8DzjRJRDPABMCIYnz6",
	"7lfdAObBwZCyLb9S/CsxB0A3Gv3uBvR6lKqiVBKkNaOj16OSa16ABU3/4mmqKmkTkeG/MjCpFqUVSo6O",
	"wjdmrBZyMRqPBP5acrscjUeSF9CMwfnjkYbfKqEhGx1ZXcF4ZNIlFBwXtusSR/uVrq/HI55lGozpQ/1R",
	"5msmZJpXGTCruTQ8xU+GrYRdMrsUhvnJTEimJDA1Z3bZGczmAvLMTALSv1Wg1y2sPfAboZholUMfz29V",
	"MRMSAlZQI1UTmFnFMpjToCW3DCEgrmGgVcwA1+mSzZXegapDoo0vyKoYHb0cGZAZaKJ+CuIS9OjVOLaZ",
	"uQWdWFFEtnLiqa3BVLk1jMbSnhbiEiTDWRP2tDKWzYBxyV589y17+PDhI0S84NZC5plkcBcN9PYe3PTR",
	"0SjjFsLnCO7GQJxFj/ELO3kyBDZMjBy0kBYWoAnADOZKww2p4wbfKnna8N+CPmmlNch0nSw0cCL0ksv+",
	"Rl74DZilqvKMLfklYcsLknI/l+FcJ2WXPK9wYyLV6jhfKMO433cGc17llgXArJI5cjSu5knOhGGlVpci",
	"g2yMgrpainTJUm7cEjSOrUSeI9EqA9kQceK723Gi9STE663oQRv6dInR7GsHJeCK2DdJc2UgsWqHJgvK",
	"icuMtXVPo9bMm+k1drYERsDxg9PLRDuJzJ3na2bpXDPGDeMsaLExE3O2VhVb0eHk4oLm+90g1QqGRKPD",
	"6ahctD1D5OsRI0K8mVI5cEnECwLYJ5mci0WlwbDVEuzSq0sNplTSAFOzXyG1eOz/efrjM6Y0ewrG8AU8",
	"5+kFA5mqbPiMPdCYsv/VKDzwwixKnl7ENX0uChFB+Sm/EkVVMFkVM9B4XkGhWcU02ErLIYTcijv4rOBX",
	"iVaVzG5gXyxSpKVHTQmpmAvIWL3KEC4NmF34CPlm+DRWr4VOWGQQnRrKDnQkXEUOBWUDv7CSL6B1JhP2",
	"k1cN9NWqC5C1BmGzNX0qNVwKVZl60gCOBHq7qyOVhaTUMBdXfSRPPTlQPN0Yr78Kb/JSJS0XEjJUbYS0",
	"suBEfRCnFsCoxZutbdzY3fBM52rzLLee443OkAYlToAi5gS/evGKO8ud+Tdwl9uwjVgk7ufe8YjFGWrg",
	"uchJO/+KpxLIUBkhFxuECPraiIXkttJwdC7v4b9Ywk4tlxnXGf5SuJ+eVrkVp2KBP+Xupx/UQqSnYjFA",
	"zBrXqL9K0wr3H1wvrsXsVdTh+0Gpi6psbyjt+P2zNTt5MnTIbs03Yzd7VZN9YMnBnZYcB17AWgPuladz",
	"+s/VnE6fz/Xvsa0jn3kzQtHRsYuwXvjf8CeUN5CkTnhZ5iLluPcpGYej1y1M/qRhPjoa/f9pEwJO3Vcz",
	"9es6iF0i34GitOu7o+vx6HGu0ou3gu335SxhDMoLvmIzXN5bywnC+5vWSr8RnFKrErQVjloQ5kcURy1u",
	"L/2whvrDWLZo8UxlcGq5rcxbEaS7brNYUJ+GuFpIx5PIzHymKss4kyoDZmjwaLyx4ZTbdFmVA7HLt+7r",
	"mShwZSa5VAZSJTPTMHutZcajJTeJWcsUssQImUJiLNe2KvsL/52bUxp4iuNO3TAmZIb7b3lF3KldtuS4",
	"z6LMgaIhnMTC4uOe5zUe5dzYIfP9AzfWKdsGHpIO53hwBkBGd0jrXoI2Qsn4yj+7j7G1UzxzaSrD/ArM",
	"VGWptIWsrzucyR+G9Qyualhq3lq71MqqVOXol1UGdq08RKXW+p5YbieOQNx6G177GP3NUTyCPL2OkrKD",
	"REOIbYichlERTtmCiDANoZ3zIwwJRZR1jFVlCVnCbVLJet4QmU7d6GP7UzO2z1wY5ZBfkwHLFCB0G3Dy",
	"mK8cZV3khOzu8WAFv0AbXGq18EmnPs4ovV7ktnE+yjEJXFsEdkj1hubr6IstEt8RwR1EHcL/DfXrc5CZ",
	"kIuzxpzfgp59ApaL3NS6tHRA2k7DhJ30E4grbigWlTZfI0vOhS5c8E5+pgm/OU2deSguTG2kTGZMw4rr",
	"LIyY9BS4zxHIDK7i8YFLDtAAjIljiM5raMKyNITTPv8wiUqvi4AdciaWG6EPyF6FSLXiLuWBhEcPUhEa",
	"LqrXUHDEjoJvnw8ehinkInEZloi1ct9DBia48O2jiq8bjmdQbuoTWS2BYk5UhhtEbB/yHAMdA0MbKZXK",
	"k9rV2AxEempjE9KFSC8gY8iQlLr22uyLLk4IhN3BQzV1ALZart2yS16WICG7O2HsWDISIp9k3LBcG8Dl",
	"F3Yb/CuCmlWUbOGS0SYn5zJmhUKq5h25KCyznXdcmvsdQblFtgOyV3KAgfiqQ0yfxXFpK0rzePorzR5z",
	"A18d1kMKl/xhJW95u+MdPmqLyRxWN1Gn31NGmncQFRll5xp1ZqpZISgt3Ro2Rt3h8kAm4oUKO2HsjKSH",
	"a6TkJWieUwqTbLhPkxZisUTLmKYA2dG5TDqYpKrwgO80/+sE87w6OHgI7ODu5hxj0Q3xiQUnE5tzv2EH",
	"Y/eJyMW+Yeej81FvJQ2FuoSMzbUqWJvP3aydy/6/et1z+WNPNbGCr10OOcgmM9V8LlLhiJ4r1GwLteFN",
	"SEVfQCN6UMwwghd2TMqcKEpemDuXRiDj5vI24pLIquh/oTHRmq9D3qDLO4bBFU9xl5yUzpqtkFFqPutb",
	"PavKpL1ApLTTgtgF1cgdCB9kbIgfv6EACguFiUSLtaARBvRvZXm+A+MzHNPKr3awbjHwZLeX1iNPFIOb",
	"KIRjVirkA+FT7ZVMyTvIhbE9JF11wVIBtmbRiFmasP9SFUs5SXRZWai9eKXJNaaQCSGQnQ0wvffSUAhy",
	"KEDamjr37m1u/N49zwXCsDmsQn0KB26S4949JxbK2HeWiQ1mvTqJOBXEW8Rwfadsyc1yt4andW9yiK39",
	"sJMnASCJlzHkFl2PRxhc5etbUAFuIabB+0DOj/C8QVFPTlLZqoX58zNrY6Ho5yjc1H8PeGcvQhDRs8VK",
	"5kJCUigJ62ingJDwlD5GLTmxyMBkEtahuZsxUwf/DbS6cG5ymu9K34lLCLs8XitFGNGhvoOjY84xCnKF",
	"a5cRR3P2BOZCCvx+dC4zbvl0xo1IzbQyoB/znMsUJgvFjphf8gm3nLzCjWBmqKuDqpwem7Ka5SJlF23S",
	"N5p3KDg4P3+JPt35+StmNxRtn1AeVJQtHIBkJexSVTbxAeGwZ9l437Syi022QR0zv7bT+D7g9OvHnU4K",
	"1Ex80/gJd+3GsCXkTRIkeLJ4hs+U9bEnX4UCZIXe2S8FL18KaV+xxHtZ1Dbxd5UjYr/4OAs19bqEjlnc",
	"mj9urRGzmD4MTbZtreQad9YqLaOj6vYZwtihrR7Vew18tW2z77TL2PZKrq1IRcmtz+7dINf+vDMHF9nF",
	"e1FuU/NNpnIM2CJSlMnc4GTGDUSPA/ALnkdlnHuFewzGJkByBp+7vAn1annTMsuhlQAwPr2IsUKLVK4F",
	"Zgi1OJeAlo3QBzS6FGlrl6VP3IjLJl1D+bebyOHO/AFyUUicim6cJBBuDpd8MIR1GfzYHpXMcY8Z5LDg",
	"Puyh2oCnvt/cF6a163N5j/04n6MpYkksW8mNUalwuaBgCEyAAaj47zHmjCi78Qox3mihTd4hLcyeqTbD",
	"y8WbIClrz96vTX5l698widmOeIH0pJVrbrWr1OVPBEjb2lA147rA7ZoMQ5k01EZDQXQ0ftPiZtu5aHoR",
	"veXbaaH6eqMRoHFTyXbc1ndIxqOoOhpyHjqjmBsy88awpbhjBES11K9r9INBAzmQc5t0tGpyEXPczs9f",
	"GiBpOQ3TWh4FuyPmjMv13VYso2EhjAUNWWME6maAzQpwya0FjYD+585fj14eJ//Nk98Pkkd/nr56fXh9",
	"917vxwfX33zzv92fHl5/c/evf4ox6KWykMyFNja55HmswH1+/hIHfWfI5n+HQ+Oqp0Mq5jrURBbXPAT2",
	"AtZJJvIqftoe7j+eINhntWtlqtkFrMnAAE+XbMZtuiQL1AGPY7aAdlW3rRv+wW34B35r+70ZL+FQBKyV",
	"shswPhOuuo5JOLktWzp5Zsp3LVdS/FYBExlIi5+0zzx1hBs3GMoJPekdKF34hX31ol4+nk9HUDfzxZ67",
	"oZta1CFRr/RqiCbBYY3UiYJiCxutPW38oeV8vkGs1IbYC5W2xDnIkE14U0nh/f4twcPW9uhgqJcOl4Eq",
	"CjrcsYrGcejrROsZ3HKn56m+xM7IFTKdLvhQaOnxUTOREkgzcNUrl/HkuVGRZSq54tK1iOI8RxA/GyPo",
	"EICtFKrLlJu4eyBMMtfqd4irvzlSPZLH8kSjDBTNnkRKuJtGvTblTQd6oO8gbz6vpSByiu4j6wajAyJK",
	"bNqKryg9Hxw2Lh1fuhbWTnEtzt3tHNvUrd9wt8e5l/HJ+WrG04sooVPEKTAVYtR2La1iYXKgvKmrVJ7f",
	"2MncVbzGzVjhavIl6Cbl3GOAQRY/a7HcZ8/mGaSi4Hk80siI+medNGwmFsL1AVcGWn2wfiFWKiGt46JM",
	"mDLna9dU2JDmZM4Oxq1Wdn8ambgURsxyoBH33QiMMmlvdXATpuD2QNqloeEPbjB8WclMQ2aXxhHWKIZx",
	"6VndsV+78DOwKwDJDmjc/UfsDoWGRlzCXaRi4dqjR0f3H1HvsPvHQUxR+ob/bbokI2XyT69M4nxMsbFb",
	"A62MX3US7Q+Za4DfYVhtbZEmN/UmskQjvabbLUsFl3wR64M9P39Z7MDJzaXTJO9ygy4yc1cMjNVqzYSN",
	"wwfLUT8lS26WcTPq0PBVxwIFyCpmVIH81LTDOqBhOXdfwflvNV7hI0WKZagmt3LqHz6ScP2nsV1TtuQZ",
	"L6BL1jFG7ZRcFk0LuVeIk3h534C+jAPRAwccbKWfy+5IJZMCZSe76/VZl/+iUbyyPI+CtUF3bWaAty/d",
	"kl0cmAzSrurQjrfUzltTsdLxrfAKQf304gev+wulY82fjcLzdkCD1QIuo0K5Wbbw1q5lEQJxYz5Iq8g0",
	"5In0hnR7V9tXhKhJBfKScZbmAmUvVdJYXaX2XHLql9vo69nwIELeYLiD8tswJN6yGemo9EudS07MUnfR",
	"RU9uDhEm+Q4guACmWizAbHRRsDnAufSjhGwYk5pSEpeuLEEzVBITN7LgazbnOTV8/g5asRkefLsuS0bM",
	"NUK4W2oIhqn5ueSW5YAx81Mhz65oudA2FQpKEuxK6YtO/qUvGAuQYIQZ0Kbfu69/52YZto8Dg0n2k107",
	"94fXhR78yZNBxE+e+CaGkydUl26uqvRQ763+vlqRCyGTKI+hgvMeyCZroUK1Nf/cZUHcw6GfS3slkY8o",
	"OcLt23HDph7piaITjg2maZ/DRvdo2GpP7YxHV8lCJSVPL/gCf18Iu6xmk1QVU54vlOYymy5UUv9/xqFQ",
	"kr5lU16KKdrx6eV9JOjPg63WrjLGLVsB41Iqyy0Epc44K1QGOTO+NSeHBU/XXmuZc4mKNxMaqL9FFNTy",
	"y5lZ8cUCNPGPplAhaCFara/QZpXIs10pDr/GYxobkcqPIlc+tdD97E/OX4OpxYyyb24TLjl0sw6b7mo/",
	"hwU2OdHRcIjvXJhdQ39fzIbupCvfdU4rWvIOUkdLMEK/6WpvjH2EWzSX6TJKOFqldQstkslZcikhj852",
	"zvBHYqiC/6oGcC6EjH/aZAFHmA0yNHvu7jCADOvH/B7qqEtIavutP+j1R+lYmMXua0Y4KNIRMh4ZSCst",
	"7PoU5d7nA0vx72iS+vtawyyBZ6AbN8sHuu52qPcPG33UXP37XvGcoiCMrKjcZ6mJ629XvChz8JHyN1/M",
	"/gIPvz7MDh7e/8vs64MvD1I4/PLRwQF/dMjvP3p4Hx58/eXhAdyff/Vo9iB7cPhgdvjg8KsvH6UPD+/P",
	"Dr969Jcvwr07h2hzS+5f5Pgkx89PkjNEtuENXop/wNp1yaBAhLYlnlJqFAou8tFR+Ok/gmiizLaeefC/",
	"jry7PVpaW5qj6XS1Wk3aU6YLarVPrKrS5TTA6ffMPT9hIDOX9qDEGokv8gWJqyt1CJsj8GP69uJvp2fs",
	"+PnJpNFAo6PRweRgQqZJlSB5KUZHo4f0Ewnaks59evlgGorm09c+IXSNXxaxFH5o8K1vP/a7asbOtKW8",
	"bhztVMiNry2P2cwlq5nvMZcZFfFd7hJjhXrDJ1lTDzxp1FbIt/vXZF7GWjhjPT+xd2TqKujwrdhGN6G+",
	"OUgevXr95dfXkTDo1cYVygcHBx/42uThLUJs66cI1Kc8xwOB+rkGB//+h4J/IsnXROZnTrivx6MvP9z+",
	"TyQyBc+Zuzra5Oe6CPTm/SQvpFrJMA2VclUUXK9J5dpWDbtlpnFYX2CvuzlyX50fFmFoNci2mnk6Id9s",
	"Hc5zzEx9863UQqHdoEdEMsAI37ie5wz0uNVq67srwF31e3r8L0qpPj3+l+tqD2oBVUQMvLvx0ZX/78FG",
	"msMfr49r0b1NZXA7mmDcz2AECg30aVsVctxEsYJffTNErytptrxS0bkSvi2h/M7qat/Av2/g/wM18H9Q",
	"23lVF4g4k0omkhrZLoG1QpO9MX13Y1qzayXre5Y7WLd3F7IxiY0hprSdmb6mTFPba+7ZLnrJYpeR+oTf",
	"ddrSk6pVETqlFJuDTZf+YY2NFMPQkzRbbe17NV39yLg9PpDjFt4VeX9K5QYov4NAPuYZewG/VWAsS9gz",
	"ShsR8cNDQ+9VP73fvUWV3eHB4We5mWdKAoMrYajV2fHf+1Xe7/tw3o8loJYOok6oTLTvItV6PYdsAXrq",
	"LkNtU+vuMtXoVl3o/QW4T/4C3Mf3ym5PHDY2rqH90g0wJwqNaITG436Ds5m+bt5jJmeoVMYOZ5TZHaWZ",
	"Bgmru/6pErdypLmbqSaecClRL7etG0dd2XyujP35wQu/ZOcWwT9gbUI2MdvlkqGf80uzrV+oTa3MuIUx",
	"+l+/8Dxv/UYResjOTG73zeoYZnOA0DdH/XE+YkYbcAGhSdxRpZtgYU8c/5j6bYq6nWAOg++XurJrW295",
	"Jrx/cBDzz3o4u1S/x5g08EolOVxC3j/0ISQ6Fwm2P1sYI1keb/Fvly4i/Bcex627/gdfcWzfNnij83yi",
	"5BeWrbjwT8+04g+rfBfZ8HuWCU7c/p7sbXvLwxloVP58YegZES0uuYXRq6A/zLKymVrJYf1A1wR47tv0",
	"qHGuLodYxcICtUKYsB9pKmUo/CuljNO72Kqy3dd5Q5/ExjMY/g3mGSyEJAAkQgTF9aPyVtbBP3Y1pHNO",
	"wwZ7miX6gqPDMi5WHyLmectTrC8TDnpG4cHAW/SM9q8W7l8t3L9auH+1cP9qYavU+3llhyPvDX+QyL8b",
	"5LWMQxPZuH9P0ZFK5konlCdIyP6HDO90sKr6Ty78s9/cJxisQj0APDzt7nSIX8gHPE13hK+U+Hv34eU+",
	"UUDfzUBQ3yl9o4xyk6a1yvmWlbQiNGagiNUm8tNLz+6N/974743/3vjvjf/H7/PqVIKSEA2H6nWsds32",
	"xevbc1xaBs27E2jMUUq21jE2G05CwqXrULzgq1a/jrf3YOxjla23UO8qmQlJeL6O/k0L93G82+VDJ2W2",
	"tlC32/Q7hFC1z7TiWYpmxapwkaTnnFy/o8/xOT69+LHUAGuaP499m3OHFnsF8M4K4HHgefrjZBtPQPvU",
	"vReFCd0wQQFagEy8CCczla3DxRbNV/ZKRpXDtHkDJZrQ69/O3HcN7rsG912DTdfgH6EcvPGISH1lmv4q",
	"wual6QE9cgvd5592y/nOlMsn2OM9/nw6DW83abT/+yv7v7+y//sr+7+/8sf8+ys36MHcq8O9Otyrw706",
	"3P85qv2fo/oj/zmqP9QtlP2tjdu/vzfZmq+YvrZXItv97sXnq0nYbSkS9r70yEfWIpEEUD/78ybPj2ww",
	"S7zFBtnuDR8b+PNNXhrYJ3j2Ec0+otlHNPuIZh/R7COazzOi+RhdHZ9CMfP9XcLf2l/zTFn2HRmYWwxc",
	"6ofyYo6Jwyi8xkg+ZP0O48tX6CnRO+bevWweFzyaTnOV8nypjJ2O0PnrPjzY/viqvsX1Orhv4TbX9avr",
	"/wsAAP//63RfQp+VAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
