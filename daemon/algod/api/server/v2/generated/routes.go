// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
