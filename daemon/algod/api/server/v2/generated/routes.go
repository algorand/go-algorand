// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
