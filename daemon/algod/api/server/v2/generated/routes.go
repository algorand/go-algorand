// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
