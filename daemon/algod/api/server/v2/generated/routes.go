// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"XErJzjF34ofL/xcAAP//K/9iFjLyAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
