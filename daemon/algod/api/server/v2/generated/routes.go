// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Get the state proof transaction for a given round
	// (GET /v2/transactions/state-proof)
	StateProof(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.GET("/v2/transactions/state-proof", wrapper.StateProof, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
