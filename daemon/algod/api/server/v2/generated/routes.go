// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"cIdLKdk55k78cPn/AgAA//9JLTjIifEAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
