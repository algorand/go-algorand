// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//GQiLU1LXAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
