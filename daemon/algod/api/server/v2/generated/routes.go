// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetProofForLightBlockHeader(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	StateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProofForLightBlockHeader converts echo context to params.
func (w *ServerInterfaceWrapper) GetProofForLightBlockHeader(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProofForLightBlockHeader(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetProofForLightBlockHeader, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.StateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
