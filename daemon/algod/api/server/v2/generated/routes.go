// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// get a state proof for a given round
	// (GET /v2/stateproofs/{round})
	StateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.StateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
