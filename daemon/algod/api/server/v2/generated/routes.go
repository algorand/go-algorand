// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
