// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"MgEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
