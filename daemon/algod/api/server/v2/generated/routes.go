// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{id})
	GetApplicationByID(ctx echo.Context, id uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryRun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id uint64

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, id)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryRun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryRun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
