// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
