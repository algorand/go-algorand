// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/transactions/dryrun)
	TransactionDryRun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionDryRun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.POST("/v2/transactions/dryrun", wrapper.TransactionDryRun, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"GbBRr6W5AAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
