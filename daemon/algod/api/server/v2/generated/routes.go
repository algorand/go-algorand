// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
