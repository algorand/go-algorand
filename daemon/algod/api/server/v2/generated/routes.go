// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+w9/XPbNpb/Ck63M02youUkTrfxTGfPbZrWt0maid3dvYtzuxD5JKEmARYALak5/+83",
	"7wHghwjKTuJ8+FY/JSZBAO/hfX9Ab0epKkolQVozOnw7KrnmBVjQ9BdPU1VJm4gM/8rApFqUVig5Ogzv",
	"mLFayPloPBL4tOR2MRqPJC+gGYPfj0cafquEhmx0aHUF45FJF1BwnNiuSxxdz7RK5irxUxy5KY6fjC63",
	"vOBZpsGY/i5/lvmaCZnmVQbMai4NT/GVYUthF8wuhGH+YyYkUxKYmjG76AxmMwF5ZvYCkL9VoNctKP3i",
	"20Hi+VxpLrNkpnTB7ehw9Orp9w8fPnzMTtygy+uO8uslWuXQh/h7VUyFhAAf1ODVR8usYhnMaNCCW4Z7",
	"RajDQKuYAa7TBZspfQXQbhNtyEFWxejw9ciAzEDTuacgLui/Mw3wOySW6znY0ZvxBpouEbiZBZ1YUURA",
	"O/bnqMFUuTWMxhKMc3EBkuFXe+x5ZSybAuOSvXr6PSPkOWxayDy5DkLVrN6GqT6MjFsIrz/qERsDcbY7",
	"wjfs+MkQAOHDCDEKaWFO59DhI/wiwl7N4ynMlIZrnokbfKOH0l7/s55KWmkNMl0ncw2cCGXBZR8lrzwq",
	"zEJVecYW/ILg5gXJS/8tw2+d/LngeYUoEqlWR/lcGcY9BjOY8Sq3LCzMKpkjh+Js/qCZMKzU6kJkkI1R",
	"hC0XIl2wlBs3BY1jS5HniP7KQDaE5jh0W+joso0S3Nd74YMA+nKR0cB1BSZgRYyQpLkykFh1hWQOwpbL",
	"jLVlaSOmzbvJaXa6AEaL4wunsQh3Egk6z9fM0rlmjBvGWZDKYyZmbK0qtqTDycU5fe+hQawVDJFGh9NR",
	"IajFh9DXQ0YEeVOlcuCSkBeYro8yORPzSoNhywXYhRf3GkyppAGmpr9CavHY//Pk5xdMafYcjOFzeMnT",
	"cwYyVdnwGftFY8rrV6PwwAszL3l6HtdUuShEZMvP+UoUVcFkVUxB43kF0WgV02ArLYc25Ga8gs4Kvuov",
	"eqormdLhNst2rB0kJWHKnK/32PGMFXz17f7Yb8cwnuesBJkJOWd2JQctHVz76u0lWlUyu4b6tnhgLYVh",
	"SkjFTEDG6lm27MQvc9V+hHy3/TRGRWs7YZLB7dSrXLEdCasIzSDr4htW8jm0SGaP/eIlF7216hxkLeDY",
	"dE2vSg0XQlWm/mhgj7T0sI1Ku1MWklLDTERo7MSjA6WHG+PFa+F1e6qk5UJChpKXNq0sOEk0uKfWgtu3",
	"ds0znKnNs9t6btc6MxqUOMaKaDd869ku7gV1vr+GH9Re24h54h73jkPMT1EhzEROyuJXPIWAhsoQK3cQ",
	"EdSHEXPJbaXh8Ezew79Ywk4slxnXGT4p3KPnVW7FiZjjo9w9eqbmIj0R8wFk1nuNugP0WeH+wfniQtWu",
	"olbvM6XOq7INUNpx0KZrdvxk6JDdnO/qnR3VXl3bLD5dBVP5Xb+wq/ogBzY5iLuS48BzWGvA3fJ0Rv+s",
	"ZkRPfKZ/jyETKdfrSXKMvcP8yj/DR8ixIEkg8bLMRcoRmxPSfodvWzv5g4bZ6HD075MmWjBxb83Ez+tW",
	"7B7bHShKu76L4H+Xq/T8vdYutSpBW+GgmOI8fQKh6dkCeAaaZdzyvcYXcEbCwDHThz/Rd2Tig47I55/p",
	"Pzxn+BqJj9tge6DdJQxaIKoVasjQXHFC0K2EA8iMUqxwFgpDy+Kddvl9s7iTS7Ugee3R8mZztsiZ/OCM",
	"IkZfBCAQ9BcqgxPLbWXe65i6qzSTBbVgCBtCOpiQaflUVZZxJlUGzNDg0XjjuFNu00VVDjif37u3p6LA",
	"mZnkUhlIlcxMg9damo5HOTd2yBh4xo11olzIjHDsNozfOB3CDIAcnvcCtBFKxmf+q3sZmztFTEtTGeZn",
	"YKYqS6UtZD131hsQw2u9gFW9lpq15i61sipVORJgZeCqmYew1JrfI8tB4hDErbcIaoulDxw5X0hJ6ygq",
	"O5toELFtIydhVAu7bWdhYCPIkPWXZEoJQ6TY7Kv2UMYjY1VZQpZwm1Sy/m4ITSdu9JH9pRnbJy506chK",
	"yoBlCnB1G/bkd750mHVu4oIb5vfBCn6OGr7Uau51Tn/PyDOJETKFZBvlI/ec4Kg2C1zBSxvSp8OlHT7b",
	"YI4N+o0S3SARXHEKQwBfRyi2FNVL5wedNtbFDYjDJ2C5yE0t8mpnq1mF/LLNwPOSG/LUpc3XSMMzoQsX",
	"2iA1Y8IzJ1Azv4pz4hu2lBnTsOQ6CyP2enLWR1BkBqu4e+JCJzSAifhGZ/VqwrI0BBt8dGYvyu4uPuA2",
	"Z2KRI3qB9FiIVCvuAkKIeDRoFW3DxTw0FBx3R6EJn3cYXlPIeeLiTxGl4t6H+FTwKNpHFZ83HM8go9Un",
	"slwAubwoPTeQ2D7kGfpZBoYAKZXKE9Ba6Zhf1JMzmyudi/QcMoYESSkPL/6+6u4JF2F38FBN7f8tF2s3",
	"7YKXJUjI7u4xdiQZMZEP5m6ouo3F5Vd22/orWjWrKBTFJSMg985kTG2FQNYHUlGYZjvtuKTGBy7lJtm+",
	"kF3JAQLiS/LgcLooRW61I0/oy5Zs64nyFlG5XVxHfP5IkX7eOWWRUayyEV+mmhaCwv2tYWOUFSEM1TcO",
	"hd1j7JS4hWvE3AVoNMO5cUreB40LMV+g6kxTgOzwTCadnaSq8Avfaf7rGPGs2t9/CGz/7uY3xqKd4uMY",
	"jgc2v/2W7Y/dK0IX+5adjc5GvZk0FOoCMjbTqmBtunZfXTntv9Xznsmfe6KIFXztIuqBF5mpZjORCof0",
	"XKEkm6sNc0MqegMatwfFFLRhwo5JeBNGyUxz59IwYFw93oS7EJkVDTRUHlrzdQhbdGnHMFjxFKHkJGTW",
	"bImEUtNZX8tZVSbtCSLpta0renfJhdgsFKYVTHhXvqvZitajv5Xl+RX7O8UxQ0HeFrnuXW209ZAR3cF1",
	"2P+IlQpPXfg0Q4hF58LY3iZdZsWSr1wTZETp7LH/UhVLOfFvWVmojXqlyVImDwpXIC0a1vS2SYMhyKEA",
	"aWvs3Lu3Cfi9e/7MhWEzWIbcHA7cRMe9e44JlLHfq6IUOdxASGPBzaJ/0lNu4OEDdvLT0aP7D/7x4NHX",
	"CAzZ+7xg0zUq1js+4sSMXedwN64dTZXb+OxfH4QMSXfeUSww16Yc2nA993Uo5BRQajuMMZcPDHj8YEmy",
	"weKr44jpRXCiVRIp7kBo9q6Emea9FqitqY+fhAVJKBlDqvpyPEKfNV/fgOB0EzEN3lJ01pbnMXImc5Jl",
	"rXyq5wOzNhaKfsDFffqPARv2VXC1ehaLkrmQkBRKwjpahyMkPKeXUXuHWG3gYxJ6Q99uuqKd/W9sq7vO",
	"dU7zQ/FLp90iiZd1dvcGDn9z3o1YWzuTTNY65CXjLM3RNqCIiNVVas8kp0jDhjm5QRYhfjIce/o+DIkH",
	"uyKxKD/VmeQGcVjHH/ZikmwGkQDgU4AQgjLVfA5mw7xkM4Az6UcJySopLK1F1nniDqwETYJvz41Ei2rG",
	"cwqV/Q5asWlluyqMEl7OQnTFDLgMU7MzyS3LgRvLngt5uqLpgv8YaEaCXSp9XmMhbv/PQYIRJonrhh/d",
	"25+4WQTwcWAQNv5jF+LF+Ws7BMHEs+XWgsaZ/ufOnw9fHyX/zZPf95PHf5y8eXtwefde7+GDy2+//d/u",
	"o4eX39798x9iJxX2Hkvk+J0fP/Hm3fET0uFNzrC39970HyuKWwiZRIkM3a5CSMrqb9AWu4OWSCCguyxI",
	"onDqZ9KuJBLSBc9Fxu37kcOmiOvxouOODarpHMRGUC7A+ibmNs5VUvL0nM/x+VzYRTXdS1UxCWbtZK5q",
	"E3eScSiUpHfZhJdiYkpIJxf3r1CNHyCvWERcUarU5aNaqa6Iee+LVjueJs7oatVcrhg9rScwE1Lg+8Mz",
	"mXHLJ1NuRGomlQH9Hc+5TGFvrtgh81M+4ZZTgGIjrjZUmErlSH43ZTXNRcrO2/qtofehONXZ2WvE+tnZ",
	"G2Y3vIK+NvJLRQnfLZAshV2oyiY+Njkc5GgCQTSzC5NtW3XM/NzumH3s088fl38UMzRxoPEVQu3GIJk0",
	"AfwQVMEzfKGsD4PyZagUqgwY9s+Cl6+FtG9Y4gMAVO34k8pxY//0PIqCdV1Cx9fbmgdtzRFz73xENNkG",
	"Wsk1QtbiBDULcIaI6hCohzWsga62AftBUMbAK7m2IhUlt946uEbO+GXnG5zkKtqLUhs6Rl2icgTYQlKU",
	"yNzgBH2h6HEAvsHzqIwrm0MYg5INKznvlLsQPpWbexNumkMrFm18aoxrEnQBbFf1OrS1OJWAlg3Th210",
	"MdKWLgufQxAXTeaAckfX4cMrQ9lIRSHpJ7ohPIHr5nDBB6OpLucbg1HJHGHMIIc59xE5yiZ77HvgvjIt",
	"qM/kPfbzbIb2PktimTZujEqFS0sERWDCGoCC/x5jzlNh154hRhutbVMogyZmL1Sb4OX8XTYpQVDsg4e5",
	"KQjS+huitlK8dOi4lSdt1ZXWhUG4IIG1IWrGdamX65MIBUShaiiUCo3G71r20zZvmnYKr/mu1FB9udEw",
	"0Lip8XLU1vf6xqOoOBoyHjqjmBsyhZ4JE0MgiqW+H9T3tgzkQJZN0pGqyXnMOz47e22AuOUkfNayKNgd",
	"MWNcru+2Am8a5mhzN3YqcmpwvD6tr3ChLCQzoY1NyESOgoeDnhrS+U9xaFz0dFDFXCm5yOKSh5Y9h3WS",
	"ibyKn7Zf9y9PcNkXtWllquk5rEnBAE8XbMptSo5Xd3kcs2VplxTfCvAzB/AzfmPwXo+WcCgurBV6Np01",
	"bglVbciTbcwUIcAYcfRPbRClUfFCNtOWgtqp8r1alRS/VcBEBtLiK+0zMh3JgtgNafWe6BhI4fuJfRa/",
	"nj6eVybf7FqGoHPjeih3m6hnGsRJsJYj9RJBqgZAazMfH7Qs33dw1Nor9vy0LU4WckPjW7kQ0sIXNQ94",
	"Lltbt4KVsHB7iUwz2IpFPkAs3x8yAWRGBE/BqR6qvqirFNsdgaEMoUddzYeUgJmCq+1w+UGeGxWZppJL",
	"Ll17CX7n0OS/NuB0H361VCjBU27iFoswyUyr3yEukWd4FpE8kEclZXDo671IRdSmnVFbF03PXMBvex+D",
	"1Puy5pPIOfsAR9dXHmBiIuSW+0eJ7WBPcuko17XCdMIecfpvhyonbv6G/v2ee+HdnC+nPFZYe3b2OsU9",
	"BQLDHbUtX6tY+DicgqnrOTztseOZqw0ZN2OFK3crQTfJ2h4xDJL7aYv8bj3JZ5CKgudxRygj7J92UpqZ",
	"mAvXT1QZaDWs+IlYqYS0jop804/rBmhQczxj++NWS5w/jUxcCCOmOdCI+24EOsEEW+17hU8QPJB2YWj4",
	"g2sMX1Qy05DZhXGINYqh23xad/7VHsYU7BJAsn0ad/8xu0OeqxEXcBexWLg2q9Hh/ccUznR/7Mcksm8c",
	"3CZXMhIsf/OCJU7H5Lq7OVAP+Vn3oqWXrtF5WIRt4Sb36XV4iUZ6qXc1LxVc8nmsgeXs7HVxxZ7ct3Sa",
	"ZPxu4EVmrlXRWK3WTNj4+mA5yqeBlAaKP7cNX69TIANZxYwqkJ6aPha3aJjO9T36Ivuwr/CSHNky1F21",
	"Umuf3tFxujwGNQVzXvACumgdM+4qlKl0zPd6eYG4N5DqB30RX0QPHHDQm/5bdkcqmRTIO9ndJlnWor9o",
	"kEFZnkeXtUF2bQaot0/dNoP6tTSVkPbrA1wYZ0kGEVt1EMtbMum9UVzpOJy8wqV+efXMK4ZC6VirQyMN",
	"vZLQYLWAiyjHbiZ9asukVhcB8zED5QetlW6nmHtlTq66rO6kpaZkFfpciHnqzr2urYDvIj16yOHU2DLQ",
	"v9eCJQyMbfyvg60NLprPLVsC41Iqyy2Ew2ScFSqDnBlf6ZbDnKdrnzsyZxIRngkNVC4mCiqx58ws+XwO",
	"mpKOmuyHkLum2fqwTyuRZ1d5Rn6O72hsJJf7ObOx/QCM26zzHTdK2jbjiCHYv9l7RIBuzz7Wy3ysjCMq",
	"DZdD6KA/mncLuVeagtH2m7aQhmsjx6+5TBdRDNEsrSbRSH34gksJefRrp/I+E4UU/Fc1sOdCyPirTRJw",
	"iNlAQwNzF8KwZJg/UogzHhlIKy3s+gS5yjvppfhHNGz1Y82/vgOwNu69bek6p73Ubbi9aZP9UbkCtQKN",
	"GUoAWKpB/GHFizIHb5x++9X0T/Dwm4Ns/+H9P02/2X+0n8LBo8f7+/zxAb//+OF9ePDNo4N9uD/7+vH0",
	"Qfbg4MH04MHB148epw8P7k8Pvn78p69Cj6rbaNP/+XcqRkmOXh4np7jZ5qB4Kf4Ca5dPR+oMBUM8pXgF",
	"FFzko8Pw6D8CnyADte6F8U9HXomNFtaW5nAyWS6Xe+1PJnPqA0msqtLFJKzTL/l8ecxAZs7TIF+WeAmZ",
	"hXjHBT+FzSmAQe9e/XByyo5eHu814mB0ONrf29+7T/VjJUheitHh6CE9Iqpf0LlPFsBzi5xxOR5NClSa",
	"qfF/eRG+52ul8NHFg0lIuk3eeo/tEueZx6JwoXa97ivuZ+XHTs2kvK6J7mTYjM9NjdnUxZuYb5eQGSUB",
	"XaAB9XWNnuOsdYNVI3FCyMxfwPU6Vp0cqxmIXb1VZ1GG+80bsYKiYj95/Obto28uI6bIm41W4gf7+5+4",
	"ffjgBlfs2kaRdZ/zHI8E6ptZ3A7uf7odHEsKMyO7MCcOLsejR58SB8cSSYPnjEa23Og+B/0iz6VayjAS",
	"ZXdVFFyvSTLbVvKrpVovBzm1G8Dymb1h9oVWJXirEKBTsDddh5McM1N3fJZaKNQwdFNQBmhhkz5QOgM9",
	"btWU+8wsuBbX50d/p3jH86O/u2aN6C0qreVd41KX938EG+l5+G7d3CHwRQqC8Rd78cztuTnoQ4XprnNm",
	"1zlzaztnPrEeX9XxZM6kkomkspwLYC0fZ6fY31ux13Raybpv+Qqa7fUWN7q5MQqo+NtM3lL5QNt07ylR",
	"uhjlKm35Bd8it6WwTqsilHsoNgObLvydLRshiqEbp7Zq/G0Zkw/WULsbez7kxp5xB7uBeHYI/gxXIn1M",
	"bXWNY/4gOf8dz9gr+K0CY1nCXlBokxg83FX3kVXfx4YvqkkP9g9uLUAvlAQGK2GoNtjR4se2Dj7+Id2Y",
	"sUG1BYSU0ELV7tmpTYccsjnoievM3GY5uM7O0Y06Y7tu3FvQjfv57f0P4oENaDW0rzAD5ui/4YdQldsv",
	"Ve0Gx/1ws6hsppatUHrTpDHISeHqvhvkpN39gbv7A3f3B+7uD7x99wfevnBS5OLgj2XFdRV2S3A3Csv9",
	"PVlyYdHZS8jmS6jINRIQ6q7+Ny78HeDc24pWobAAHu51d4LGz+NvRmwSuj6g6lsNw715oqC63a7ew6We",
	"Kn2t+FMT1LGKIWCsklaEXDLyYa29vrxgzk4v7/TyTi/v9PLt18ufMMnSCb4lIacWclGxTBTbpaI+2K5o",
	"KRyv7lHZIj9tDRlZ4PnEX05H0XVlBuvETn84esaMqnQKLMXlhGRlzqkTZmVDYQPbdr0e8Xz/dr9wgdPW",
	"K/76dsgp8NxfRehtBDD2O5WtN44Rtzehnb6j8deD2Cr3Yy+0Zt8wubzR5NG/7t2In09eMdqRJ6qGN3fC",
	"6X2EU0BjlI2E5Ho9RgrLqhQYNRY7+lklOGgOMvEsnUxVtg4dwW6eRoBtFL4EAdaVFK/4sl1Gs01YtNG6",
	"Stw2u6htKtTdy/E1BMkCiIdqxopUCSFStOJZiha0VeF2tI8sZG7HnaGfUSA0BbFHPg/bwcZOOryvdPgu",
	"EDv9JCNfbjKD8xaIB/aulAqaL+1KRqXCpLnTIRrF793Md7PR/N1FpbuLSncXle4uKt1dVHq7888bd2bU",
	"kNLP5WwCO6CIbqCf48tu4rgyG7Brmdi1TOxaJq7ZMnGNCrXd6e4aYm5xQ8z/sxLcXbnqjfXG7G01oSZv",
	"7UpkVze2394fZWM39Zts7GP9JNtn/kG2iE3aV3/vcr/ABrHEC1KQ7N6xnfiP1+kl/lexP3c/Brv7Mdjd",
	"j8Hufgx292Owux+Dvd0/Bvu5UpJfRhj1YzYbbk0Rv1CWPSW18mEeSn3lVcwCcZsIt7CRsVjfv/b6DZpE",
	"dGWotyObS8UOJ5NcpTxfKGMnI7TyuheOtV+iOOFzN4O300otLqib983l/wUAAP//U4iEHJyWAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
