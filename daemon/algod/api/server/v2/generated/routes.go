// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"

	"github.com/algorand/oapi-codegen/pkg/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"rSpBuRYBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
