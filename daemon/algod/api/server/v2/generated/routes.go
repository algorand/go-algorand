// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/3J4yrYy9wAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
