// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"9gAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
