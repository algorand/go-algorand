// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/compile)
	TealCompile(ctx echo.Context) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.POST("/v2/compile", wrapper.TealCompile)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys)
	router.POST("/v2/shutdown", wrapper.ShutdownNode)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+w9/XMTOZb/is63VQOs2w4QZodUUXsBhpncAkORzO7eYW5G7n62NemWeiR1bA+X//1K",
	"T1J/qm2HhI/c+ieIWy09Pb3vD/WHQSyyXHDgWg2OPgxyKmkGGiT+ReNYFFxHLDF/JaBiyXLNBB8c+WdE",
	"acn4fDAcMPNrTvViMBxwmkE1xrw/HEj4vWASksGRlgUMBypeQEbNxHqdm9HlTKtoLiI3xbGd4uT54HLD",
	"A5okEpTqQvkTT9eE8TgtEiBaUq5obB4psmR6QfSCKeJeJowTwYGIGdGLxmAyY5AmauQ3+XsBcl3bpVt8",
	"85ZoOheS8iSaCZlRPTgavH3x7OHDh4/JqR10uesot14kRQrdHT8T2ZRx8PuDcnvl0RItSAIzHLSgmhhY",
	"za79QC2IAirjBZkJuWXTFoj6zoEX2eDo3UABT0DiucfALvC/MwnwB0SayjnowfthC02XZnMzDTLSLAts",
	"7cSdowRVpFoRHIt7nLML4MS8NSKvCqXJFAjl5O2LZwSRZ7GpIXHk2ruravX6nsrDSKgG//iTHrFSEGa7",
	"Y/OEnDzv24B/MUCMjGuY4zk0+Mi8EWCv6ucpzISEHc/EDr7RQ6mv/0VPJS6kBB6vo7kEioSyoLyLkrcO",
	"FWohijQhC3qB+6YZykv3LjHvWvlzQdPCoIjFUhync6EIdRhMYEaLVBO/MCl4ajjUzOYOmjBFcikuWALJ",
	"0Iiw5YLFCxJTZafAcWTJ0tSgv1CQ9KE5vLsNdHRZR4mB66PwgRv6epFR7WsLJmCFjBDFqVAQabFFMnth",
	"S3lC6rK0EtPqanKanC2A4OLmgdVYiDtuCDpN10TjuSaEKkKJl8pDwmZkLQqyxMNJ2Tm+73ZjsJYRgzQ8",
	"nIYKMVq8D30dZASQNxUiBcoReZ7puijjMzYvJCiyXIBeOHEvQeWCKyBi+hvE2hz7f57+9JoISV6BUnQO",
	"b2h8ToDHIuk/Y7doSHn9poQ58EzNcxqfhzVVyjIWAPkVXbGsyAgvsilIc15eNGpBJOhC8j6A7Ixb6Cyj",
	"q+6iZ7LgMR5utWzD2jGkxFSe0vWInMxIRldPDoYOHEVompIceML4nOgV77V0zNrbwYukKHiyg/rW5sBq",
	"CkPlELMZg4SUs2yAxC2zDR7GrwZPZVTUwPGT9IJTrrIFHA6rAM0Y1jVPSE7nUCOZEfnZSS58qsU58FLA",
	"kekaH+USLpgoVPlSD4y4dL+NitAJDVEuYcYCNHbq0GGkhx3jxGvmdHssuKaMQ2IkLwItNFhJ1AtTbcHN",
	"oO14hjPRPruN57bTmeGgyDJWQLuZp47twl5Q4/0d/KD62orNI/tz5zjY/MwohBlLUVn8Zk7Bo6FQyMoN",
	"RHj1odicU11IOJrwe+YvEpFTTXlCZWJ+yexPr4pUs1M2Nz+l9qeXYs7iUzbvQWYJa9AdwNcy+4+ZLyxU",
	"9Spo9b4U4rzI6xuKGw7adE1Onvcdsp3zqt7ZcenV1c3is5U3la/6hl6VB9kDZC/ucmoGnsNagoGWxjP8",
	"ZzVDeqIz+UcImYZynZ5Ex9g5zG/db+Ynw7HAUSDRPE9ZTA02x6j9jj7UIPmThNngaPDv4ypaMLZP1djN",
	"a1dsHtsdyHK9vmu2/zQV8flHrZ1LkYPUzO5iaubpEghOTxZAE5AkoZqOKl/AGgk9x4wv/ojvoYkPMiCf",
	"f8L/0JSYx4b4qPa2h7G7mDIWiKiFGhJjrlghaFcyA9CMEiSzFgoxlsWVoHxWLW7lUilI3jm0vG/PFjiT",
	"761RRPANvwmz9dcigVNNdaE+6piaq1STebWgEBuM2z0ZpqVTUWhCCRcJEIWDB8PWccdUx4si73E+n9mn",
	"ZywzMxNOuVAQC56oCq+lNB0OUqp0nzHwkiptRTnjCeLYAmzesTqEKADeP+8FSMUED8/8d/swNHdsMM1V",
	"oYibgagiz4XUkHTcWWdA9K/1GlblWmJWmzuXQotYpIYACwXbZu7DUm1+hyy7E4sgqp1FUFos3c2h82Uo",
	"aR1EZQOIChGbADn1o2rYrTsLPYAYhizfRFOKKSTFCq7SQxkOlBZ5DklEdVTw8r0+NJ3a0cf652psl7iM",
	"S4dWUgIkEWBW1x4mB/nSYta6iQuqiIODZPTcaPhcirnTOV2YDc9EivEYok2Ub7jn1Iyqs8AWXmpJnwaX",
	"NvisxRwt+g0SXS8RbDmFvg3vIhRriuqN9YPOKuviBsThc9CUpaoUeaWzVa2Cflk78LykCj11rtO1oeEZ",
	"k5kNbaCaUf43K1ATt4p14iu25AmRsKQy8SNGHTnrIig8gVXYPbGhExxAWBjQWbka0yT2wQYXnRkF2d3G",
	"ByxwKhQ5wgeGHjMWS0FtQMgg3hi0AsGwMQ8JGTXQYWjC5R3612R8Htn4U0Cp2Oc+PuU9ivpRhef1x9PL",
	"aOWJLBeALq+Rni0k1g95ZvwsBX0byYVII5BSyJBf1JEz7ZXOWXwOCTEEiSkPJ/6+acJkFiF3zKGq0v9b",
	"LtZ22gXNc+CQ3B0RcswJMpEL5rZUXWtx/o3etP4KV00KDEVRTnCTowkPqS0fyLomFflpNtOOTWpccyk7",
	"yeaF9Ir3EBBdogdnpgtS5EY78hTfrMm2jiivEZWFYhfx+QNG+mnjlFmCscpKfKlimjEM99eGDY2s8GGo",
	"rnHI9IiQM+QWKg3mLkAaM5wqq+Rd0Dhj84VRnXEMkBxNeNSAJBaZW/hO9V/LiJPi4OAhkIO77XeUNnaK",
	"i2NYHmi/+4QcDO0jRBd5QiaDyaAzk4RMXEBCZlJkpE7X9q2t0/5bOe+E/9QRRSSjaxtR97xIVDGbsZhZ",
	"pKfCSLK5aJkbXOATkAY8yKYgFWF6iMIbMYpmmj2XigHD6vEm3IXArMZAM8pDSrr2YYsm7SgCKxqbXVIU",
	"MmuyNIRS0llXy2mRR/UJAum1jSs6d8mG2DRkqhZMuCrflWyF6+HfQtN0C3xnZkxfkLdGrqPtRlsHGUEI",
	"dmH/Y5ILc+rMpRl8LDplSneAtJkVjb5ySZABpTMi/yUKElPk37zQUBr1QqKljB6UWQG1qF/T2SYVhiCF",
	"DLgusXPvXnvj9+65M2eKzGDpc3NmYBsd9+5ZJhBKPxNZzlK4gZDGgqpF96SnVMHDB+T0x+NH9x/88uDR",
	"t2YzaO/TjEzXRrHecREnovQ6hbth7aiKVIdn//bQZ0ia8w5Cgbk65SDA5dy7UMgZGKltMUZsPtDj8dqS",
	"pMXiq5OA6YX7NFZJoLjD7Ga0dc84705brU198twviEJJKVTVl8OB8VnT9Q0ITjsRkeAsRWttOR5DZzJF",
	"WVbLpzo+UGulIesGXOyrv/TYsG+9q9WxWARPGYcoExzWwTocxuEVPgzaO8hqPS+j0Ot7t+2KNuBvgdVc",
	"Z5fTvC5+8bRrJPGmzO7ewOG3523F2uqZZLTWIc0JJXFqbAOMiGhZxHrCKUYaWuZkiyx8/KQ/9vTMDwkH",
	"uwKxKDfVhFNlcFjGH0YhSTaDQADwBYAPQaliPgfVMi/JDGDC3SjGScGZxrXQOo/sgeUgUfCN7EhjUc1o",
	"iqGyP0AKMi10U4VhwstaiLaYwSxDxGzCqSYpUKXJK8bPVjid9x89zXDQSyHPSyyE7f85cFBMRWHd8IN9",
	"+iNVC799M9ALG/eyDfGa+Us7xGzTnC3VGqSZ6X/u/PXo3XH03zT64yB6/Ofx+w+Hl3fvdX58cPnkyf82",
	"f3p4+eTuX/8UOikPeyiR4yA/ee7Mu5PnqMOrnGEH9s70nyqKmzEeBYnMuF0Z45jVb9EWuWMsEU9Ad4mX",
	"RP7UJ1yvuCGkC5qyhOqPI4e2iOvwouWOFtU0DqIVlPN7fR9yG+ciyml8Tufm9znTi2I6ikU29mbteC5K",
	"E3ecUMgEx2fJmOZsrHKIxxf3t6jGa8grEhBXmCq1+ahaqitg3rui1YanaWa0tWo2V2w8recwY5yZ50cT",
	"nlBNx1OqWKzGhQL5lKaUxzCaC3JE3JTPqaYYoGjF1foKU7EcyUGTF9OUxeS8rt8qeu+LU00m7wzWJ5P3",
	"RLe8gq42cksFCd8uEC2ZXohCRy422R/kqAJBOLMNk21adUjc3PaYXezTzR+WfxgzVOFNm0dm13aMIZMq",
	"gO+DKuYMXwvtwqB06SuFCgWK/JrR/B3j+j2JXAAAqx1/FKkB7FfHo0awrnNo+Hob86C1OULunYuIRpu2",
	"llNpdlbjBDHz+/QR1b6tHpV79XS1abPX2mVoezmVmsUsp9pZBzvkjN803jGTbKO9ILUZx6hJVJYAa0gK",
	"EpkdHBlfKHgcYJ6Y8yiULZsze/RK1q9kvVNqQ/hYbu5MuGkKtVi0cqkxKlHQ+W3bqtc+0MJUApJXTO/B",
	"aGKkLl0WLofALqrMAeaOduHDraFsQ0U+6ceaITxm1k3hgvZGU23ON7RHwVOzxwRSmFMXkcNsssO+29w3",
	"qrbrCb9HfprNjL1PolCmjSolYmbTEl4RKL8GGMF/jxDrqZCdZwjRRg1sDGXgxOS1qBM8n18FSA4MYx/U",
	"z41BkNrfELSVwqVDJ7U8aa2utCwMMgvitlqiZliWetk+CV9A5KuGfKnQYHjVsp+6eVO1UzjNt1VDdeVG",
	"xUDDqsbLUlvX6xsOguKoz3hojCJ2yBQ6JkwIgUYsdf2grrelIAW0bKKGVI3OQ97xZPJOAXLLqX+tZlGQ",
	"O2xGKF/frQXeJMyNzV3ZqYZTveP1eX2FC6EhmjGpdIQmcnB7ZtALhTr/hRkaFj0NVBFbSs6SsOTBZc9h",
	"HSUsLcKn7db923Oz7OvStFLF9BzWqGCAxgsypTpGx6u5vBmzYWmbFN+44Zd2wy/pje13N1oyQ83CUhjP",
	"prHGLaGqljzZxEwBAgwRR/fUelEaFC9oM20oqJ0K16tVcPZ7AYQlwLV5JF1GpiFZDHZ9Wr0jOnpS+G5i",
	"l8Uvpw/nldE328kQtG5cB+UWiHKmXpx4azlQL+Glqt9oaeabH2qW7xUctfqKHT9tg5NluKHyrWwIaeGK",
	"mns8l42tW95KWFhYAtP0tmKhDxDK9/tMAJoR3lOwqgerL8oqxXpHoC9D6FBX9SImYKZgaztsfpCmSgSm",
	"KfiSctteYt6zaHJvK7C6z7y1FEaCx1SFLRamopkUf0BYIs/MWQTyQA6VmMHBt0eBiqi2nVFaF1XPnMdv",
	"HY5e6n1T8kngnF2Ao+kr9zAxEnLN/cPEtrcnKbeUa1thGmGPMP3XQ5VjO39F/w7mTng3pcspDRXWTibv",
	"YgOTJzADUd3y1YL4l/0pqLKew9EeOZnZ2pBhNZbZcrccZJWs7RBDL7mf1cjv1pN8AjHLaBp2hBLE/lkj",
	"pZmwObP9RIWCWsOKm4jkgnFtqcg1/dhugAo1JzNyMKy1xLnTSNgFU2yaAo64b0cYJxj3Vvpe/hWzPeB6",
	"oXD4gx2GLwqeSEj0QlnEKkGM23xWdv6VHsYU9BKAkwMcd/8xuYOeq2IXcNdgMbNtVoOj+48xnGn/OAhJ",
	"ZNc4uEmuJChY/uEES5iO0XW3cxg95GYdBUsvbaNzvwjbwE321V14CUc6qbedlzLK6TzUwDKZvMu2wGTf",
	"xdNE47eFF57YVkWlpVgTpsPrg6ZGPvWkNIz4s2C4ep3MMJAWRInM0FPVx2IX9dPZvkdXZO/h8g/Rkc19",
	"3VUttfb5HR2ry0O7xmDOa5pBE61DQm2FMpaOuV4vJxBHPal+kBfhRWTPAXu96d4ld7jgUWZ4J7lbJctq",
	"9BcMMghN0+Cy2suudoB689R1M6hbS1Mwrr89NAubWaJexBYNxNKaTPpoFBcyvE9amKV+fvvSKYZMyFCr",
	"QyUNnZKQoCWDiyDHtpM+pWVSqguP+ZCB8r2UQtZTzJ0yJ1tdVnbSYlOy8H0uyDxl517TVjDPAj16hsOx",
	"saWnf6+2Fz8wBPjfe1sbbDSfarIEQjkXmmrwh0koyUQCKVGu0i2FOY3XLnekJtwgPGESsFyMZVhiT4la",
	"0vkcJCYdJdoPPneNs3X3Pi1YmmzzjNwcT3FsIJf7JbOx3QCMBdb6jq2StnYc0Qf7271HuNHN2cdymU+V",
	"cTRKw+YQGugP5t187hWnIAh+1RZScW3g+CXl8SKIIZyl1iQaqA9fUM4hDb5tVd4XopCM/iZ6YM4YDz9q",
	"k4BFTAsN1Z6bO/RL+vkDhTjDgYK4kEyvTw1XOSc9Z78Ew1Y/lPzrOgBL497ZlrZz2knditurNtkfhC1Q",
	"y4wxgwkAjTWI369olqfgjNMn30z/Ag+/O0wOHt7/y/S7g0cHMRw+enxwQB8f0vuPH96HB989OjyA+7Nv",
	"H08fJA8OH0wPHxx+++hx/PDw/vTw28d/+cb3qFpAq/7Pf2IxSnT85iQ6M8BWB0Vz9jdY23y6oU5fMERj",
	"jFdARlk6OPI//YfnE8NAtXth3K8Dp8QGC61zdTQeL5fLUf2V8Rz7QCItingx9ut0Sz7fnBDgifU00JdF",
	"XjLMgrxjg59MpxjAwGdvvz89I8dvTkaVOBgcDQ5GB6P7WD+WA6c5GxwNHuJPSPULPPfxxYOxT6ONPzgf",
	"7NI8mYfiar4avewU7ubZh1ZxxLSscm7kzJTLNg3J1EaQiGuA4Amm9WzowGjgcsMnSe1OqkqG+CCYu1Lr",
	"XajeOFQFELpMq8yL9HeQV4LCMP9B9Pj9h0ffXQaMi/et5uAHBwefuSH48AZXbFo7gXVf0dQcCZR3rVgI",
	"7n8+CE44Bo4NAxDL4JfDwaPPiYMTbkiDpgRH1hzjLgf9zM+5WHI/0kjjIsuoXKOs1bV0Vk1ZmmFhTm2G",
	"pFyurp99oVbbXUvtN0rwpmt/kkOiyh7OXDJhdAbe/ZOAsZlRwguZgBzWqsRdrhVs0+qr439iBOPV8T9t",
	"+0XwXpTa8rYVqcn7P4AOdDE8XVe3AnyVgmD41V4lc3vuArquMN33wux7YW5tL8xn1uOrMkJMCRc84lho",
	"cwGk5rXsFftHK/aSTgtediJvodlOt3ClmyujAMu51fgDFgTUTfeOEsWrTrZpy6/4XrgNpXJSZL6AQ5AZ",
	"6HjhbmFpBR367pDaqPE35UCuraH2d/Bc5w6eYQO7nnj2CP4Clxx9Sm21wzFfS84/pQl5C78XoDSJyGsM",
	"ViKD+9vnPrHq+9T7C2rSw4PDW7uh14IDgRVTWO1rafFTWwef/pBuzNjAagFEim+KqnfhlKaDaxtGKSlU",
	"wGg4A5q6bmynIUHppyJZt5CsYaXHeUpZC72Bi/MC3ctKFDIGYuSKEXB43yWu2VXLlzeqbf9128M/q2vR",
	"lK4IkSOqitT3jsXH8LpH49n3xy87bMQ4leuhobCkiIFgbaWln1VkBs2BR46lo6lI1r4o0s5TCokUkjnI",
	"sW3I3uRe2IbuwY1GbPZN+LegCf/L8+61FGVrtxLqNxcCsfRfKU1fjN+tUG9l0LxKDSdUyR2sEeGwvOuu",
	"kbPTBrodiKhCWDYj6NS5D2uXMYF25Pytm7TRWPM3WG+NmRvX+tfqGzO/YkVknlANQ+Py/0rTtPYbhqZ9",
	"cmL08aH1nTz+GYCvz0QnyQVijR14Dr5XwuKgmVkgzy2VqPK2sPJegxn03rdv27/r8smR2v2Dg1A8oAOz",
	"zW87iNEcW4oohQtIu0fdB0SrZeIqsf2zZo9+vdOlnq8PUJ3/mEPZ/NJ7zXezfeMq0D0X/BtNlpS52wBr",
	"AS8tXLmiv8fe5kFcTR3Kh/67zyMz5eZPI9xs4OY2XI5j9BCdK7yLTrILqmHw3ks1tSh0Ipa8X3BhTw1N",
	"XcUq1pCWZQpaED9BKalGxIc90rW/WZ9Q/GiNKHTzgxe+WbN1l5r7rMkU5ozjAsjluIotzaa1CLy7UrUr",
	"BE8dZK/tDbQtuRe8MdzCGOb7TxEE3P0W1Y1nWDb99ppo/iroGzTR9vdR7++j3t9Hvb+P+vbdR337Yg5b",
	"42k3F0NseoI1wV15QvbvsTG1opmQEUYcI9TMPh057q1F+gdl7qMy1IUqtTDSAqj/UJCVNG4i5yNV9YQu",
	"n+/urvAXMbMMugaAWeqFkDulP6ucohbWLi24ZmnN+CzV19eXS9wr5r1i3ivmvWK+/Yr5S2UnIu9Q+lKo",
	"UCEU2Scsrm1Y1BSOU/dG2Rp+2pixbJcthtOWb+myXgS5KXNZR9kqsjmTJtqqjiH7cLhDVnMBmNArs3yB",
	"Gk8tyFQKmsRGAWnhb6v8xBnP23GH8xfMTlbtDMeuiqaBjT3nfyznP/XEjp/Ipcs2M1hlizww2pqilHSp",
	"VzwoFcbVHTvBKFjnptSbjYbtL47eXxy9vzh6f3H0/uLo210Y0LrDqNwpfr6svdkeRXQD3Xhfdwve1mDa",
	"vuFt3/C2b3jbseFth/ri/enu2xlvcTvj/7MGin2zwY11No42mlDjD3rFku3Xktzej2SSm/pGJvlUn8j8",
	"wh/IDNikXfV3ldthWsQSzucasrviZRB/3uUmiH8V+3P/ce79x7n3H+fef5x7/3Hu/ce5b/fHub9USvLr",
	"CKN+ylbxjSni10KTF6hWruehlBcWhiwQC4S/FRONxfI+zHfvjUmEVzg7O7K65PFoPE5FTNOFUHo8MFZe",
	"8wLI+sP3Zd3+B2+n+fr9y/eX/xcAAP//lyQB2iycAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
