// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
