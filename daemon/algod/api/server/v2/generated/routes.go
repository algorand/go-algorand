// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys)
	router.POST("/v2/shutdown", wrapper.ShutdownNode)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
