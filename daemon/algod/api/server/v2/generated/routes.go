// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/transactions/dryrun)
	TransactionDryRun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionDryRun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.POST("/v2/transactions/dryrun", wrapper.TransactionDryRun, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
