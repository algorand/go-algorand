// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
