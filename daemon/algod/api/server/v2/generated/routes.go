// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
