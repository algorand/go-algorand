// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
