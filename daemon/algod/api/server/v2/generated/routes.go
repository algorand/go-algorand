// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"HwAA//8lx6pdWdcAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
