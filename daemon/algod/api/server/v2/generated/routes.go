// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"include": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "include" -------------
	if paramValue := ctx.QueryParam("include"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9e3fbOJLvV8HV7jl5rCg5r56Jz+mz13l0t3eSdE7snp277dw0RJYkjEmAA4C21Ln+",
	"7vegAJAgCUryI69u/5VYxKNQKBQKVYUfPo5SUZSCA9dqtP9xVFJJC9Ag8S+apqLiOmGZ+SsDlUpWaib4",
	"aN9/I0pLxhej8YiZX0uql6PxiNMCmjKm/ngk4V8Vk5CN9rWsYDxS6RIKahrW69KUrltaJQuRuCYObBOH",
	"L0YXGz7QLJOgVJ/Kn3m+JoyneZUB0ZJyRVPzSZFzppdEL5kirjJhnAgORMyJXrYKkzmDPFMTP8h/VSDX",
	"wShd58NDumhITKTIoU/nc1HMGAdPFdRE1RNCtCAZzLHQkmpiejC0+oJaEAVUpksyF3ILqZaIkF7gVTHa",
	"/3WkgGcgcbZSYGf437kE+B0STeUC9Oj9ODa4uQaZaFZEhnbouC9BVblWBMviGBfsDDgxtSbkdaU0mQGh",
	"nLz74Tl59OjRUzOQgmoNmROywVE1vYdjstVH+6OMavCf+7JG84WQlGdJXf7dD8+x/yM3wF1LUaUgvlgO",
	"zBdy+GJoAL5iRIQY17DAeWhJv6kRWRTNzzOYCwk7zoktfKOTEvb/RWclpTpdloJxHZkXgl+J/RzVYUH1",
	"TTqsJqBVvjSckqbRX/eSp+8/Phg/2Lv4t18Pkv9xfz55dLHj8J/X7W7hQLRgWkkJPF0nCwkUV8uS8j4/",
	"3jl5UEtR5RlZ0jOcfFqgqnd1ialrVecZzSsjJyyV4iBfCEWoE6MM5rTKNfEdk4rnRk2Z1py0E6ZIKcUZ",
	"yyAbG+17vmTpkqRU2SawHDlneW5ksFKQDclafHQbFtNFyBJD15X4gQP6epnRjGsLJ2CF2iBJc6Eg0WLL",
	"9uR3HMozEm4ozV6lLrdZkeMlEOzcfLCbLfKOG5nO8zXROK8ZoYpQ4remMWFzshYVOcfJydkp1nejMVwr",
	"iGEaTk5rHzWLd4h9PWZEmDcTIgfKkXl+3fVZxudsUUlQ5HwJeun2PAmqFFwBEbN/QqrNtP/X0c9viJDk",
	"NShFF/CWpqcEeCqy4Tl2ncZ28H8qYSa8UIuSpqfx7TpnBYuQ/JquWFEVhFfFDKSZL78/aEEk6EryIYJs",
	"i1vkrKCrfqfHsuIpTm7TbctQM6LEVJnT9YQczklBV9/vjR05itA8JyXwjPEF0Ss+aKSZvreTl0hR8WwH",
	"G0abCQt2TVVCyuYMMlK3soES1802ehi/HD2NZRWQ4xsZJKfuZQs5HFYRmTFL13whJV1AIDIT8ovTXPhV",
	"i1PgtYIjszV+KiWcMVGputIAjdj1ZvOaCw1JKWHOIjJ25NhhtIct49Rr4QycVHBNGYfMaF4kWmiwmmiQ",
	"pqDDzYeZ/hY9owq+ezy0gTdfd5z9uejO+sYZ32m2sVBil2RkXzRf3YKNm02t+jsc/sK+FVsk9ufeRLLF",
	"sdlK5izHbeafZv48GyqFSqDFCL/xKLbgVFcS9k/4ffMXSciRpjyjMjO/FPan11Wu2RFbmJ9y+9MrsWDp",
	"EVsMMLOmNXqawmqF/ce0F1fHehU9NLwS4rQqwwGlrVPpbE0OXwxNsm3zsoJ5UB9lw1PF8cqfNC5bQ6/q",
	"iRwgcpB3JTUFT2EtwVBL0zn+s5qjPNG5/N38U5Z5jKdGgN1Gi04B5yw4KMucpdRw7537bL6a1Q/2eECb",
	"ElPcSfc/BrSVUpQgNbON0rJMcpHSPFGaamzp3yXMR/ujf5s2XpWpra6mQeevTK0jrGQMUWvcJLQsL9HG",
	"W2PQqA1awmhm/IT6weo7NIUYt7NnZIgZ3ZvDGeV60hxEWoqgXrm/up4aflsbxvK7c7AaZDixBWegrF3b",
	"lCAZ1RSJpY3AezcTGptBWSP5F+O6H2Md38SUojW+FLmxJ7ZOhin8kysbzqP5fafK38Ychrztzh6eSrbO",
	"m/N+hDN2pcnayFDb7oaB1GM4l7S09LsvdptgHA8XtpCl9Zr6YselHKU5kPVgspGqKwv7VoGMUoKz16Hh",
	"WS7S0xtYcDPTTl/usXmyBJqBRPEKBNsJbHw7woo/YT1ckiAjNuvP+B+aE/PZSCvV/jxmzqJmeSkiAs9x",
	"Zo5w1jC0PZkCeLQUpLCnNmJOW5ei8nnTeW+RWrbsskhf2oMiwRp+EGbojRvoYCbk1eSlIwicNM4tQk2r",
	"wXIZd2YWi1Zl4vgTOSDbAp2GmnhC304KOdRtPsarFheONP0EXFCm1ZvgQruhm+aCKEqWww2s1yVVy/4g",
	"zInl0UNy9NPBkwcPPzx88p0xuUspFpIWZLbWoMhdZygSpdc53OuPDC22Ktfx1r977F0i7Xa3cggJrtve",
	"ZUUdg9EMlmPEOgANdS/kWlY3YTaClEJGDrEoOlqkIk/OQComIv7It64EcSWMHrIH6c7vllpyThUxfaN/",
	"peIZyEmM83rFkTSmoVDbNgrb9PGKN7xxDVIp6bo3A3a8kdG5fneZkzbz/XFdkRJkolecZDCrFi2jaC5F",
	"QSjJsCIqxDciA2NzV+oGtEDTWEOMmYiQBDoTlSaUcJGZBW0Kx/XDQHACvaLozNWhytFLu//MwBx3U1ot",
	"lpqYc6KITW1TMaGpnZQE9wo14MupnXC2lO3OOr5zCTRbkxkAJ2LmHCbOlYODpOhn1T6E6rRTxCZt0VVK",
	"kYJSxnK25thW0nw5O8t6A5+QcCS47oUoQeZUXpFYLTTNtxCKZWLk1uaE8zL1qd6t+00T2O08nEYqgfil",
	"aWwXs7pz0DDEwh15cgYSvS2fdP58J1edvqociIW6HfiYFXgE4JQLBangmYo2llOlk23L1hRqmQlmBMFK",
	"ia1UbHjgHPiKKm19boxnaDJadYP92AOi6WKY4MEdxbT8d7+Z9NtOjZ7kqlL1zqKqshRSQxYbA4fVhr7e",
	"wKruS8yDtuvtSwtSKdjW8hCXgvYds+xILIOorg/QzindHxzG18w+sI6yskVEw4hNhBz5UgF3w3jQACHm",
	"fFHXRMFhqiM5dRBqPFJalKVZfzqpeF1viE1HtvSB/qUp2xcuqhu9ngkwvWtPk6P83HLWRgKX1Nh22DIp",
	"6KnZm9BSs87BPs1mMSaK8RSSTZJvluWRKRUugS2LdMBIdrkGQW+dxdGR36jQDQrBllkYGvCAxf6WSs1S",
	"VqIl8TdY3/hxv9tB9ORPMtCU5ZCR4AMqcNS9dX1ivb3dNq9maO1khPbJ71mhkeHkTOGG0Sb+FNbog3tr",
	"w4jHQfDxBizFSKtmdVNOkFAfnDAbclgEVjTV+dpsc3oJa3IOEoiqZgXT2saF24akFmUSNhA9uG7o0bkO",
	"bAjOz8AuvowjbCoYXn8qxiNrtmym77hjuLTY4QymUoh8Bx9njxlRCnbygZJSmFlnLg3Bx6q9JLWIdEYM",
	"+o1q5XlHtdiMIyD/R1QkpRwNsEpDvSMIiWoWt1/Tg9nA6j6ZtXQaDkEOBVi7Er/cv98d+P37bs6ZInM4",
	"97k7pmCXHffv4ynprVC6tbhu4MRrltthRLfjid5sFM6G6+qUydbTvWt5l5l822ncd4prSiknuGb411YA",
	"nZW52mXsoYwsqVpuHzu2u5NDI2g6Nm4771KI+Q2MlmWrWMA6g1VspE5w8Yxyxxj0awXRIAaqOzGP5KyA",
	"PM3RASLmnQVJCjArRS1ZaZps4utrDa3cvP979z/3fz1I/ocmv+8lT/9j+v7j44t793s/Prz4/vv/1/7p",
	"0cX39/7z32P2qtJsFneW/UTV0lDqFOeKH3Lr7p4LaU85a2c8ifnnprsjYmYyPeeDIe203GITghEWnGyU",
	"OWMb5+sb2GNtQ0RCKUGhRgzPlMp+FfMwNc9JnlorDUXfLWOrfhgwSt95k64npYLnjENSCA7raDY64/Aa",
	"P8ZqW608UBn3x6G6XZO3RX+HrHY/u0zmdfmLsx2oobd1ouANTH633Y5HLkxKRI8C5CWhJM0Z+hsEV1pW",
	"qT7hFE80gbhGvPn+nDZ8xn3ui8QP1ZEzr2vqhFNleFifc6Ke2jlEPBg/APijrqoWC1C6Y9vNAU64K8U4",
	"qTjT2Fdh5iuxE1aCRJf6xJYs6JrMaY5H8t9BCjKrdNvawdwppc2J2boHTTdEzE841SQHqjR5zfjxCpvz",
	"KUpeZjjocyFPay7Edf4COCimkrgi/dF+RX3qhr90uhUT2e1nr28+9wbgaY9l9jjKD1+4k8DhCzT3Gsdg",
	"j/bP5i0qGE+iQna8BFIwjgmiHdkid43R6gXoXuNidLN+wvWKG0E6oznLqL6aOHRVXG8t2tXRkZrWRHQO",
	"/36s72NR24VISpqeYtButGB6Wc0mqSim/gQ0XYj6NDTNKBSC47dsSks2VSWk07MHW8yxa+grElFXF+OR",
	"0zrqxv0FruHYgLp91m43/7cW5M6PL4/J1M2UumPT/GzTQX5W5NDqEjRacRUzeHtNxeY5nvAT/gLmjDPz",
	"ff+EZ1TT6YwqlqpppUA+oznlKUwWguz7nI8XVNMT3lPxgzfJMN3FUVNWs5yl5DTcipulaW8H9Fs4OfnV",
	"CMjJyfuek76/cbquomvUdpCcM70UlU5c+nMi4ZzKLEK6qtNfsWV7eWFTr2Pi2rYS6dKrXftxVU3LUnWz",
	"4frDL8vcDD8QQ0Wwks0hUlpIrwSNZrTU4Py+ES5MIem5z52vFCjyW0HLXxnX70lyUu3tPQJyUJZNgt1v",
	"TtcYmVyX0HJvXClbr+vawIFbgwpWWtKkpAtQ0eFroCXOPm7UBTrS8pxgtVZymw9xY1PNADw/hifA0nHp",
	"BCQc3JGt5e+xxYeAn3AKsYzRTo1/+qrzFeTRXXm6Orl4vVmq9DIxazs6KmVE3M9Mfb1lYXSyDxootuBm",
	"EbibQDMg6RLSU8jwUgIUpV6PW9V9XMrtcF51MGUv79g8I8wwR0/QDEhVZtTZAJSvu6m+CrT2+c3v4BTW",
	"x6JJUL9Mbm8741QNLVSU1GAzMsIaLlvXRnfyXYzTUErLkixyMXOruxaL/VoufJ3hhWx3yBtYxDGhaCVs",
	"DjGCyggjrPAPsOAKA22SQa+1AGKDNEbOzO5/Ee+J3wGIK9LYbi5aGY4Js1Ht9wLwPqA4V2RGFWREuKts",
	"vUTdStEFDLh0QpfcjvmdLTceNrJt94vud2Le3dZ6u06UZFs4MWOOyguYL0ZgzCLvxqh9T9briyOYELyh",
	"7hg2y9FYqsPjVvVQ2XKN2iu3Q6TFxRgkb8wOT0abI6F9s6TK37LDy4h+Re9kCXzCVOZNV0MOg/BqcOOw",
	"vvjhNW93tY7rS0D28r+/IOJvhfirIKPxpa51jEcu4yc2HYKjGZRBDgs7cFvYC4oj7Y4KJsjQ8fN8njMO",
	"JIlFaqlSImX2mmSz2bg+wFjJ9wmxHiiycwsxMQ7IxmgGNkzeiHBt8sVliOTAMPxBfdsYBwn+hnjams3F",
	"2Wp5YiKVVwLURfi9fgrMz7sty9FHxO4NmaUbXHhDO0qfEruT3A3tl6bjqHW1odvN+3qMDQoH7c6hdb9D",
	"G9suXV9p5NcgoOMWaMA43DFs63GpvUX2N5RGs46bq3M+m29ABDtyEJ2fAc71/bH1nYm33f0yelZuB7ra",
	"9zUCMyamC42I9z2UfT+oghzQME1aW3hyGvNbG/saUN8d+WrBAZrcZXNj7t4LoqcSFkxpaDxIZlvwLtHP",
	"68U7ExqSOZNKJ+i8ig7PFPpB4bHoB1M0vs+1o5sWL4Bl8TWF3Z7COslYXsVn2/X7txem2ze1J0FVs1NY",
	"ozUDNF2SGeJbRHMeNnRt02I2DviVHfAremPj3U2WTFHTsRRCd/r4RqSqo7E2LaaIAMaEoz9rgyzdoF5w",
	"13sBuY7degh2TFRxZme213IG/We9xZT5tjfZ+QEVw7rdthQdS3Dk2zgKhjFpc1phOoCH6KdoD6wBWpYs",
	"W3W8WbbVwdMOvdSR1d8O7AVlR3VjWzgQeK5iWYASvPfNTmlgnFmgDx6ObbITZ447dzoDhRB2xZSHqeoz",
	"yog2Yqls49Ux0PxvsP67KYvDGV2MR9dzfsV47Vrcwuu39fRG+YxRHesMafmyL8lyWpZSnNE8cS7CIdGU",
	"4syJJhb3HsXPrOrijqjjlwev3jryL8ajNAcqrd20cVRYrvxmRmWsOiEHFoiHwTHHIm/rWkMsmPz6KmLo",
	"VjxfgoMcCWw5o8WccNnl1biMg6Xo3IzzeHB5q9PQebftEDd4uaGsndyN68X6uNt+bXpGWe59Hp7agUAw",
	"Dm63e/ZRrRA2cG3/eGDpJzeqbnqrO746GunaopPCvjaAohQW90cRwbsZhsaERFcKimpB10aC7Hm4r5x4",
	"VSRm+SUqZ2ncP8ZnyggHt9EPU5hg4QFj1LRYsYFgGq9Y0JYppnY4IHaIDPqIMtPf5R/i3Uw4wMaKs39V",
	"QFgGXJtPEldlZ6HiJXnnKe1vp8Z26PflGrbe1ab569gYIfZAd8dDIjYbGGGspUfui/rA6QdauzHMD4E7",
	"+RIh27DH3pa4Idzq5MNJs817WbZjJiG+Yl//GcGwWDzbwR29f8zBRwz0EQVrHNwtDoZ3ClP7EntEsyUg",
	"ueFmMLZO+1yJSDMVP6fcYq+ZepaHrrYC6zMwtc6FxDtPKu6rYyqZS/E7xE+yczNRkSRox0o0F7H2JHKX",
	"pKtEa79Pg6rp+RvSMSjaQ5Zc6Klqh9QHVjhKeRBEQhAB70ml3Iq1xYlrJXLEF0eYfDW17TeLw9HcS1jL",
	"6fmMxhAWjEFlaDpowpUtn68WxFf2s+Dc043sBZHPuiyzF4VKkM1Nhf6l1CsaR9+WyGeQsoLmcSspQ+63",
	"r0VmbMEs2F6lIEBzcw1ZlFIrRQ4RzwaEG9YczsneOEBmcbORsTOm2CwHLPHAlphRhbtW7devq5jhAddL",
	"hcUf7lB8WfFMQqaXyjJWCVIbsHiUq4MsM9DnAJzsYbkHT8ldDC8pdgb3DBedLTLaf/AUHbP2j73YZudQ",
	"NTfplQwVy387xRKXY4yv2TbMJuVanUQvrVko5GEVtmE12aq7rCUs6bTe9rVUUE4XEM9rKLbQZOvibKLT",
	"sMMXnlkcT6WlWBOm4/2DpkY/DSRpGvVnySCpKAqmMXKsBVGiMPLUQLXZTn1zFhTUoa14uvxHjOWV9tgA",
	"3QPz53UQ2708NmqMuL6hBbTZOibU3u3MWRNldwpxQg79DXGEn6lRZyxvTF9m6GjSYdB9TkrJuMZDVKXn",
	"yV9JuqSSpkb9TYbITWbfPY5A7rRRNvjlCP/sfJegQJ7FWS8HxN5bE64uucsFTwqjUbJ7TVJ0sCoHg47x",
	"9C6v0bvZfZub3tUANa0kg+JWtcSNBpr6WoLHNzR4TVGsx3Mpebz0yD67ZFYyLh60MjP0y7tXzsoohIzh",
	"hTTL3VkcErRkcIaZZvFJMm1ecy5kvtMsXIf6LxtlaU4AtVnm13LsIPCsYnn29+aSRwe1TFKeLqMxjpmp",
	"+KHBTa2HbNdxFJ5iSTmHPNqc3TM/+L01svv/U+zaT8H4jmW7aGR2uJ3BNYS3yfRE+Q4Ne5nOTQchV9tZ",
	"73WaZL4QGcF+GiyERsr6AGsBMtO/KlA6huGOH2yKB/qyzLnAAgMR4Bla1RPyo333YAmkdVUbrVlWVLm9",
	"9gvZAqRzslZlLmg2Jqad45cHr4jt1dax+NQWmGiBxlx7FB0fRgCcslu6n0c7jCck797O5gxJM2qlETlB",
	"aVqUsbsmpsSxL4AXWkK/Lpp5IXcm5IW1sJW332wnRh7mTBbGMq1bszoeZcL8R2uaLtF0bWmTYZHfHVHL",
	"S6UKoKJrMMsa+wTXnaHbgWpZTK0xEeZ8cc6UhbuHM2hfb6nvermjk7/u0h6erDi3khLV0ZvuIl6F7Z44",
	"G7z3rt8oZR3GX9JwUaKSKVwWYOwIa0XBBLpoZT2MaHuvtoZ09M+YpJQLzlK8yh8A7NckO+j8XeIiO6Ae",
	"dN1Sfom7FRpZXFGMtDrlyHFxEDXNK0LHuL5jNvhqJtVKh/1TI0b7kmqyAK2cZoNs7HHwnL+EcQUOywZf",
	"UQj0pJCtWBNqyGj4Mqnd3JcUI0x2HzCAfzDf3rjjEeZ/njKOhpBjm0s1tR4NRPbWxnpimiwEKDee9uV0",
	"9aupM8EL2hms3k88Eji2YUM1Ztg2Ltlv6sBHKV1U0JR9bsoSm15Y/9xKrLedHpSl6zR6t7ye4RiS3yCD",
	"I9GmxLv7A+bW7YetbRC3jekFuJ8aQYMzDE5CiftwTzBqUMQOuukZzSsrUViC2LSe6IVIxiNkvGIcGpz6",
	"yAaRRrcEnBhcrwP1VCqptibgTjrtGGiOEcmYQlPauWiv21RngpElOEbfx/A0NniOA4qjLtAYbpSva3h8",
	"I92BMfEc3+VwjOyjM6JV5YyoDDOEO3iNMcVhFLdHOm1vAP1l0LeJbHUtqV05l9mJhq5+pSJmb75cQVrZ",
	"gLuwIDG0LEmKd6mD/SLq0WTKHJ6KWR7JfXtRfwxAUDGbe7bGf2PQPcMscRHxS+dk+fA3Vry0wdpuqWdu",
	"GmFKFFtccZqb+jc6z7lYtAn5vA6FjWs8FJnY6n5p1GZ4G7gHCmUVa31ZF9OQhEfIttDu/ppZe02iIo8e",
	"Shuw482H8mHY4jGq/oFkxHcNDgW1u4uNMQylJKaDGbRUu3sYmpIG9KG/MC3WcKwFm89gMY7tA2BR/8pQ",
	"DoNNYTCfe7V3s4t6Via2vZGhPjmmT9DffOYdKSlzAbRmxfY563J0+1nTu2TvNRPcHYTLfMVGYiPpgb9t",
	"lpBe5nOQ+24xuia7XwNvAvIYM0GE5QVwB7HczmncObNqPodUs7Mtmeb/bSzWJot57G1ai0sfJJ6zOlPH",
	"vxN3SVO7IWhTIvhGegKsiWuTM5RnegrrO4q0pCEKGjb2gnqV+4XIAcThSIyICBXz/ttDuHPIMlVLBnLB",
	"R9tsdWggkAbRWut0rxji1U59eZEk1NlZNZzUEECsiFnxO/Vlql7qZg6mZAwlo/fxEod3rxcIT6lqpO36",
	"IbggmcIc1rqwY+fufiPeC6j9Tv6mIyj/m79CY3uxDww2eLLo5TunMvMlomart4iTgfSubsK0zUtncaLn",
	"dc+syY3o5wxH0AEwFybNhWJ8kQylTLXTEWpf/h1lgy7oIEAgSqRrDtLhSGv/fmOihc+l2ETHJla410au",
	"wgQ1CB5niRu8IfuuuQKMkEjUvt7pAkrhAImEghrqZHBRd7jPTcx+br/7JFkPidMBoIq06+U12XrT1mfF",
	"MNVjYij1c+J2y+3Jt1c5LzDOLUy/it3a5YaVoSeplCKrUrtBhwsD/Llq5zvxG1RJ1MpP+6PsGWw54kS8",
	"Cq4ynMJ6ao2mdEl5A9jRXtYWrd+OIbh415ntGz1KxQ3WfGEHsLgROr/kSWg8KoXIkwHX0WH/8nF3DZyy",
	"9BQyYvYOH08eQGwld9FjUccGzpdrj09flsAhuzchxJylilKvfZigDb7V6Zzf0Zv6X2GvWWXxANwhbXLC",
	"46kQ9j3ca+o338xmrWYfiL9mV7aRLdeKV3xAtdHzCH7xrk8vRRz3XUzZRqgsFTEr5Yp35XZa3/2DWkT0",
	"w1sOW84/p61TnYWX6TjrhYQbPt0FXspLnu769zd2HR6OA7VapaA/zp0noMXbAd7vwvjGNdFn7rBHQc92",
	"8SjEQTBMdXRpWIYgggxBUslvD34jEubuce7797GD+/fHruhvD9ufzenr/v3oyvxszozWC0+u35jE/H0o",
	"uGsDmAN5BJ35qFiebROMVlZIg/GIeQ8fXP7MF0GZ/GCPyP2l6gD3LuNG7U4CMiYy1lbnQVdBvscOqR6u",
	"WiSxAzebtJJMr/EKkz9RsQ/Rq+E/1k4Y92xgnQju8pDtE9QuLalx2TSvBv8o7MNfhdnr0bGuEaz95YoW",
	"ZQ5uoXx/Z/YXePTXx9neowd/mf1178leCo+fPN3bo08f0wdPHz2Ah3998ngPHsy/ezp7mD18/HD2+OHj",
	"7548TR89fjB7/N3Tv9zxT/ZaQpvncP+BUKzJwdvD5NgQ2/CElqx+o8GIsYd1pCmuRHMmyUf7/qf/7VfY",
	"JBVF07z/deRy1EZLrUu1P52en59PwirTBZ7REi2qdDn1/fSx8d8e1vkz9t4DzqhNjTCigJPqROEAv717",
	"eXRMDt4eThqBGe2P9iZ7kweInlwCpyUb7Y8e4U+4epY471MnbKP9jxfj0XQJNNdL90cBWrLUf1LndLEA",
	"OXH4luans4dTH36ffnTn0wvT6iJ2uctmAkXeMm3wBZyvC4M6/iX6ALhHOTyfcQ2r5cxHnmGChj3yGdVW",
	"M+swaxA8DoO3Nt1NLHs1ff/XCNzwnC0q2XlVpvbmO+Q9psh/Hf38hghJXluf+1uanoZJELHnmZ0qi73O",
	"7FIlCrUo23HFxtMfe38ihp8ZeTy8cRUNvxve6FWjK/eSp+8/PvnrxWgHQvx1AC28w8ffU3O5+eMIQBAa",
	"cuPG3YAVmqkZYyaA/xhCOdZF2hk4v9E8/22I8Y6sKOdpnpuCgkOM6+87D18/3Nv7BC/sjluteCH4ok/1",
	"Pr7BgbZjZtcebre53qBf09wsNSM5TVDg8d6Db3ZAhxxDBkbTE7uTXYxHT77hGTrkRtfQnGDJ4PJRf/f4",
	"hZ9ycc59SWPFVEVB5RptlAAINLRGLwZ3qWkIujn92HIoZ59yD7ujhrRgD+LR3hVGzB18qwhWTOl7tVfe",
	"QjW3H28f2vqCs/PtLvhJd8GD9pS0LpbHiGkJ3kaaenGg625K/VSgDtzflYCcAzC2K4DyfBVP9u+g9m55",
	"N/TK3oDpEXnzvwOiFy4bmx+DUJU9VdtVk4cv/niWSjfv18IZ3Noufxrbpb/Lb7ZmEORy+tFjM3xqCyY8",
	"19kF2RzctlosDtdj0FZB/I5bK+VTWyl94JsYGQ3Yx5ezTJCGZYOMc5kXC1owsJdC8PlGTZE/MbMGbQ9D",
	"6ZDVgctgq73hdNYf1NLwGvnWxvgz2xg2z2uDldGCSnJJgcOGBgQP7gbvQrSSkmZrL4djoupX2UvJhGR6",
	"PSaMkwyMVsJokpB4K7R5utcloIB9hv71wT8wLfH1wT/I92RvXBsveGkm0r1N/GgbIT+Cjjwt/Wx9UO/H",
	"G42Rr2aHP66ZNPD0sxYe7QiZVtDV90MsW9mYU8w+KuhqtNEUGH875tp1rZbbB8q/2QfKd1Dkt7N7+/z8",
	"N/v8/Ldtsq5qmDtKuOAJx3dyzoAE2VO3dutXbbc+2Xv0zY7mCOQZS4EcQ1EKSSXL1+QXXuOCXM8sr3VO",
	"xQOklo36p5dF3VjRgfl+rfhm2/c8Jkw3lmHrUk1whq+fM3OYUOMGUN4coRHPwV+wVmMPrI5JYTYIaudj",
	"3INdn8SM9CCe8GyNzsStdvk3EpbbGVcosq/F5+ZT7wA9Op7RjHjgqE+sm3dTpo/3Hn8+CsJZeCM0+QH9",
	"VZ9YpX9S30FcrAJlc+nwg3c5tVWLu6S2UamYFTp2WJAITrgm9SUSo0+sIrTI932tYXrYVV98xQ7yHZ4s",
	"jchll723euFWL1xLL3QFqtEIeBVbTT+irz5UB70l+cyU/APF+IKAhxSFj3gIMgedLu0V9e6ViYha8fBk",
	"wzplE4j3DQfgkOgIiCmOxV0LQHDpHS+LYcWfbJb+xXiUgowI388eK8V8ZnO88ldDz3msegRsZR6+tUZu",
	"dfjWTBEjoFoQh4hCzCxeisrnTef9KxzIlpsI2t0y+HIM7im1lw5I1y4vN4hv3fER7JYkIW/QHMIF7pHX",
	"/ohuj0+5I3/qAb0RHGzOi7FYrSzehiBrcwGfu0Cm+BvyNvDoXguNmw7toONHvWLZxbSGcBkyKt5igS1G",
	"RbNTs+ZBxbZ7hZYlUKmuvElvD4cdd3o8fBEmSrQQZ2qsmQgphi+XjCT+xy5hxD9utK775uYqinUAKw/Z",
	"Ek6Sc8ShpN5RpKTrQYiUAbSh1yBPcwcf1Ik4kAKMdldLVn5+lH2l2Sz+4shPVOGDxzUO8CF/Vi/mM5Bs",
	"js/m1EL6BUHpzWR6zgdD2sWQeBubELwW5cClPveRuUnYsarKx4lkR2t80fO0/iLn6TeCJ7jbAtfe8mux",
	"5cudrRHnYhy4r2qoci40uq2ERCMh1ANqstP2CoOhhJZSsdlsg2LsNtuU6nRZldOP+B+8c3zR3O61uPxT",
	"62bbtN8e2RI3mkBh2ySygX4Ir7k715+Yk9csleIA8VCcXlZrpaHov9pmq37YhPge1eGC54xDUggeuyH/",
	"M359jR+jiCsYlB2ojOHxobrdtzZa9HfIavezi6q7Ln8nX4cL71rmaGe0Eso6CQ2j9Sj/zWppQV42y6T1",
	"8/Rj+3V46w13JdWy0pk4D+raG+0b15YtcaNr643IwLbbBpGIZQdykYG7eN9fUrXWiGf+ev425Sy+E1MO",
	"ESul1WKp7atj0ScN64oJTe1SsKiRahvMni3l4aTOgNBcAs3WZAbAiZiZQbfhSglV9TOSKBxWN8bR4hq6",
	"SilSUAqyJHxuZBNpNZwBegj1Bj4h4Uhw3QtRgsypvCKxVklsJrT7zlZNbu0HcnqgT/Vu3W+awG7n4TRS",
	"aU4eVgrwJU1RlDloGGLhjjxB45V94vnznVx1+qoSX7SI4B3ar8eswPv7nHKhIBU8U8OopNuWLeKQBmNR",
	"YB9x9Csl+lCAaXhga31FlXYPqrTA2wI0W9PFBhjVISgi0/LfayCiXtup0ZdcVap5a8baXpBFn/GD1Ya+",
	"3sCq7kvMg7Zr484+Mbqt5SEuBe3Xr88EuKg68FGY5iKDO2d5jtHauCXSIqJhxCZCjnypgLuhI2CAEKYa",
	"Rtdgh23JCZ7/VFqUpVl/Oql4XW+ITUe29IH+pSnbFy6XGo56PROgQsPbUX5uOWsfllpSRRwdpKCnzmZf",
	"uAztPs1mMSaK8dSBOQ9df2EFHJlS4RLYski7Zl+4/FvrrLM4OvIbFbpBIdgyC0MDjhmaX4VZeNlzX9ej",
	"8AkdoW1DOzCvGkPT/j09p0wncyEdUDY+XRyJqXZweCjT7sFsdyrWwjky3ePHVqG4doJn1VSY3mpJ8Fcs",
	"zOz3MypMVz8IuVMIt/G2akHMwEjFNfM3TM16q23Mry8eems931rPt9bzrfV8az3fWs+31vOt9fyprecv",
	"k5NJksTraX/hJnbdhoy+SQv/G7rR8jmvoDRGf23y4yHBmOhmHW/M1dBA86l7zBSD6tGn+2zSd/gwamq6",
	"Y5yUOTXWEKy0v3pMZu2n0f2LfBa42+gaU+DRQ3L008GTBw8/PHzyndE+S/s6e1j2rn9TSul1DvdcTluN",
	"rOuT24BTfPoPc9uoP/2kPu/BWvNzlgNRhlkvsfgLOIPcmPI2+knMYaR/PDoGmj93zLFaCZR+JrJ1R3DM",
	"+KfIirbINCF0xqmMPM/ZF5Qek7XAJ3rde7O9E9TFjWZRxDMH+hO2ba7izzHEn9HcJC9bMwXcy+qu7V2i",
	"ZmZOPTuJe9rzi6psghQ5MWvU01eTW999WsotHCxrrAq3/r7VPHjP+OjCw2U79k/vEKYVcRK3SkyhBfDE",
	"qYVkJrK1e4bZvxTc0rL2CddhJWvfRwX3ALVbBnfVPaNmkaMr3XL1RJ/Qd24LBNWo3wX6MorTPh66UW9e",
	"XTps4/VVlOtmUXab62uNIA3jrpBkIUVV3rPQQnyNR+KipHzt3WDGViyqvAFDnIxuVlPXr/v09Ozub/uH",
	"5xW8xt/93bIF3wRyD/tn9mX/+NMb3ffnt3O8eV1523ML/uGZyEvwA+++9yfRz7JLfaxdf6V9hivyHnPn",
	"9eXb61Z/ii3hrRRnzBycoxq2n5fVKITJ1p1BBioLt4YO+IbfG9r69B09P269kb2bTl0lzvC8tlW6BDTI",
	"aistglRi9kspaJZShTdKOOhzIU8/scWqV4cRvwOSiYhT/dxfs4FPthqW2O5O9mQ799t1iJAwyr7g8mWt",
	"yyb/9MBd4Glx49YV8EdxBTzzi08Rio/BdRan9frhmtxBTdFzveJRLTW1ILGDGW/BgnDgkjcau+s13w7h",
	"NSFMF4KAvCSUpDnDAIXgSssq1Secogu081JeJ7znHbvDptRzXyTuhY84yV1TJ9wYVXNSO0ajJtUcIiGP",
	"HwC8xaaqxQKU7mjiOcAJd6UYxzdqsS98eDCxmaBmuzYafWJLFnRN5jRHH/7vIAWZmVNEiGKCDkWlWZ67",
	"eKLphoj5Caea5GCU/mtmDDrTnPc51TFyK3c1FwYeVLVPGSVxL8SP9iteY3DD934jdG/Zz80b0l/kwbEk",
	"9ia3o/zwhUMYO3yBoDFNJLFH+2cLLxWMJ1EhMzu+i8h3ZYvcNTaeF6B7TUzSzfoJN8a0FgQVPdVXE4du",
	"GKC3Fu3q6EhNayI60QI/1vex260LkZgjI12Y3xdML6sZPvnlb71OF6K+ATvNKBSC47dsSks2VSWk07MH",
	"W+yDa+grElFXtzv3H8eJH8qBWS31xCM+e3fuB/blGwB0/bpRXLemKN1ipt5ipt6iat5ipt7O7i1m6i2i",
	"6C2i6J8VUXSy0UJ0KBxbMf50z7VJiYTU9lwr8LBYCw2wH5ZkekLI8dLof2r2ADgDSXOSUmUNI24z5Qq2",
	"WGqiqjQFyPZPeNKiJBWF6/hu8197zD2p9vYeAdm7161j/RaB5u3XRVMVP2GoiXxPTkYno15LEgpxBg4b",
	"DItnFcaKba2tzf6vut2fZW/qCrq2zpUlLUsw25qq5nOWMsvyXJjDwEJ08vu4wC8gDXEWeoIwbWFYkZ+Y",
	"F+myc6i7fx4zuvv7+yVecTro4hncwpx88peH+xN2czpwY9s9hXirMj6HyvjiSuMPhMh2C772lQ0oDKS2",
	"0FWvYUnVb4FF/E7eRrLuZKObsQVIK8n0Gnc4WrIPp2D+/97ocQXyzG9+lcxH+6Ol1uX+dIr450uh9HRk",
	"tqbmm+p8NPsDXdgW3OZSSnaG2InvL/5/AAAA//9fwzrTdQoBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
