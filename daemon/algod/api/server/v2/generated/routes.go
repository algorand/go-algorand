// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys)
	router.POST("/v2/shutdown", wrapper.ShutdownNode)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
