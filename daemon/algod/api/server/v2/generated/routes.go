// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
