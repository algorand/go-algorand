// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
