// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"include": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "include" -------------
	if paramValue := ctx.QueryParam("include"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
