// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//yx5m6sZ8wAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
