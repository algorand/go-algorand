// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"9wAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
