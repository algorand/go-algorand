// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"include": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "include" -------------
	if paramValue := ctx.QueryParam("include"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
