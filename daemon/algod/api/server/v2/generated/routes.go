// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/transactions/dryrun)
	TransactionDryRun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionDryRun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.POST("/v2/transactions/dryrun", wrapper.TransactionDryRun, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9/XcbN5Lgv4Ll7XuxvWxS/sjMWO/l7SlxktFN7PjZmtm5s3y7YHeRxKgb6ABoUYzP",
	"//u9KgD9iSYpS46jWf1ki40uFAqF+kJV9YdJqopSSZDWTI4/TEqueQEWNP3F01RV0iYiw78yMKkWpRVK",
	"To7DM2asFnI1mU4E/lpyu55MJ5IX0IzB96cTDb9UQkM2Oba6gunEpGsoOAK22xJH15CukpVKPIgTB+L0",
	"xeTjjgc8yzQYM8TyZ5lvmZBpXmXArObS8BQfGbYRds3sWhjmX2ZCMiWBqSWz685gthSQZ2YWFvlLBXrb",
	"WqWffHxJHxsUE61yGOL5nSoWQkLACmqk6g1hVrEMljRozS3DGRDXMNAqZoDrdM2WSu9B1SHRxhdkVUyO",
	"300MyAw07VYK4pL+u9QAv0JiuV6Bnbyfxha3tKATK4rI0k499TWYKreG0Vha40pcgmT41oy9rIxlC2Bc",
	"sjc/fMeePn36HBdScGsh80w2uqpm9vaa3OuT40nGLYTHQ17j+UppLrOkHv/mh+9o/rd+gYeO4sZA/LCc",
	"4BN2+mJsAeHFCAsJaWFF+9DhfnwjciianxewVBoO3BM3+FY3pT3/F92VtNIaZLpNVho4McqayyFJ3nhS",
	"mLWq8oyt+SWtmxck5fy7DN91UuOS5xWSSKRaneQrZRj3FMxgyavcsjAxq2SOJxSh+Y1mwrBSq0uRQTZF",
	"wbNZi3TNUm4cCBrHNiLPkfyVgWyMzPHV7eCjj22SIF6fRA9a0O+XGM269lACruggJGmuDCRW7ZHMQdhy",
	"mbG2LG3EtLmenGZna2A0OT5weoZoJ5Gh83zLLO1rxrhhnAWpPGViybaqYhvanFxc0Pt+NUi1giHRaHM6",
	"KgR17xj5BsSIEG+hVA5cEvHCoRuSTC7FqtJg2GYNdu3FvQZTKmmAqcU/ILW47f/r7c+vmNLsJRjDV/Ca",
	"pxcMZKqy8T32k8aU1z+Mwg0vzKrk6UVcU+WiEBGUX/IrUVQFk1WxAI37FUSjVUyDrbQcQ8hB3MNnBb8a",
	"TnqmK5nS5jbTdmwUZCVhypxvZ+x0yQp+9c3R1KNjGM9zVoLMhFwxeyVH7ROcez96iVaVzA5Q3xY3rKUw",
	"TAmpWArIWA1lByZ+mn34CHk9fBqjooVOADKKTj3LHnQkXEV4Bo8uPmElX0GLZWbsr15y0VOrLkDWAo4t",
	"tvSo1HApVGXql0ZwpKl3W5ZSWUhKDUsR4bG3nhwoPdwYL14Lr9tTJS0XEjKUvIS0suAk0ShOrQl32/FD",
	"/bzgBv7wbEx7N08P3P2l6u/6zh0/aLdpUOKOZEQv4lN/YONeT+f9A/ye9txGrBL382AjxeoMVclS5KRm",
	"/oH7F8hQGRICHUIExWPESnJbaTg+l4/wL5awt5bLjOsMfyncTy+r3Iq3YoU/5e6nn9RKpG/FaoSYNa5R",
	"R4JeK9w/CC8uju1V1F7+SamLqmwvKO04ZIstO30xtskO5nUZ86T24toG9dlVMLKv+4a9qjdyBMlR2pUc",
	"B17AVgNiy9Ml/XO1JH7iS/1rjJjIuV7DkiPsHeQ3/jf8Cc86SBJlvCxzkXKk5pz05vGHFib/qmE5OZ78",
	"j3kTHZi7p2bu4boZu9v2AIrSbh/i8r/NVXrxSXOXWpWgrXCrWCCcIYMQeLYGnoFmGbd81ngRzrwY2WZ6",
	"8c/0HjkHoCOS/Wf6D88ZPkbm4zZYLWixCYO2i2qFFjI0dJz4dDPhADLAFCucbcPQJrkWlt81kzu5VAuS",
	"d54s7/vQInvyvTOnGL0RFoFLf6G3upK3sEWgtdIR1YRnQNIIYaEwB/NVvSiuNd8Olk5AD1l5d4FB0RlW",
	"opd0JVkGi2rFhHRUpziPVgXjLKMXiUivVAZvLbeV+SRCdRFqgDXIIMu0UeALVVnGmVQZMEODJ9MewVNu",
	"03VVjvj237mnZ6JAyExyqQykSmamYb5a5UwnOTd2zNb6iRvr9J2QGTGiQxjfcYqWGQA5DvcStBFKxiH/",
	"zT2MwU6R0tJUhnkIzFRlqbSFbBAt8PbZ+Fyv4KqeSy1bsEutrEpVjqe0MrAP8hiVWvA9sdxKHIG49QZX",
	"bRAOF0e+LXLSNkrKDhINIXYh8jaMalG37YuNIIJSq36TLFVhiBUbvGoHcDoxVpUlZAm3SSXr98bI9NaN",
	"PrF/bcYOmQs9ZjJCM2CZApzdBpw85htHWeeFr7lhHg9W8As0g0qtVl4xD3HGM5MYIVNIdnE+np63OKp9",
	"BPacpZ6c6pzSzjnrHY4e/0aZbpQJ9uzC2IIPkZ8tbf7auZlnjQl2C+LwBVguclOLvNqXbWYht7cfjd9w",
	"Q4EQafMt8vBS6MJFjkgXm/CbE6iZn8XFSJpjKTOmYcN1FkbMBnLWB6hkBldx789FpmgAE3FEl/VswrI0",
	"xHJ88GsWPe4u/OKQM7HAHD1AfixEqhV38TYkPFr9itBwISUNBUfsKPLjL2PG5xRylbjwXkSpuOch/Bfc",
	"rvZWxeGG7Rk9aPWObNZAEQWUnj0itjd5iW6sgbGFlErlSW2R9J3HgZzpz3Qh0gvIGDIk3QN58fdVFyec",
	"hD3ATTW1e71Zbx3YNS9LkJA9nDF2IhkdIh8r76m63uTyK7tr/iuaNaso0sclo0XOzmVMbYU44Q25KIDZ",
	"zTvuzuiGUzkguyeyV3KEgfiG3FwEF+XIncb2W3qzJdsGorzFVA6LQ8Tnj3SRwju7LDIKBTfiy1SLQtBt",
	"SmvYFGVFiPINjUNhZ4yd0WnhGil3CRp9FW6ckvcx+UKs1qg60xQgOz6XSQeTVBV+4gfNf91BPK+Ojp4C",
	"O3rYf8dYtFN8mMidgf6737CjqXtE5GLfsPPJ+WQASUOhLiFzBnebr91be8H+Sw33XP48EEWs4Ft3YRHO",
	"IjPVcilS4YieK5RkK9UzN6SiJ6ARPSgWoA0TdkrCmyhKZprbl+YAxtXjbbgLEahooKHyQMcoxHa6vGMY",
	"XPEUV8lJyGzZBhml5rOhlrOqTNoAIreXO2f0PqWLYAZH7xPPXd/1m06ssjzfg98ZjhmLobfYdbbfaBsQ",
	"I4rBIcf/hJUKd134W5wQ6s+FsQMk3cWVpYBCzZARpTNj/1tVLOV0fsvKQm3UK02WMnlQOANp0TCnt00a",
	"CkEOBTrfYbpHj/oLf/TI77kwbAmbcPWJA/vkePTIHQJl7I1PQI81r04jJgNdEKE2jWRqrLlZzyaxSGM3",
	"hHB6mAncWg87fREmpMNkDKmYj9MJ+lr59hYOvAPENHgLx1kJnjfICcrpDLauWf3+ma2xUAwDBe7V/xyx",
	"vd4EF2GgaZXMhYSkUBK20aQaIeElPYzqaWKRkZfpsI6923ehOvj30OrOc8hu3pS+tNstlnhdX/rewub3",
	"4fZiRO0LZrIyIS8ZZ2mOOo08eaur1J5LTh5yzwzqsUXw+8djJt+FIfEgTSSG4kGdS26QhrXfPIvZp0uI",
	"BK5+AAihE1OtVmB6ZhFbApxLP0pIVklhaS6yKhO3YSVotthamLmRaAkseU4hnl9BK7aobFf00j2Ys2xc",
	"jgNOw9TyXHLLcuDGspdCnl0RuOD3BJ6RYDdKX9RUiNutK5BghElQOA2X/aN7+mdu1mH5ODAIG/+yi98i",
	"/OaybGsB95ZbCxoh/d8H/3787iT5Pzz59Sh5/m/z9x+efXz4aPDjk4/ffPP/uj89/fjNw3//19hOBdxj",
	"tzQe89MX3iw5fUG6p7lKHOA+AP+5oo+FkEmUydBdKISky/4eb7EHqEEDAz1kQRKFXT+X9koiI13yXGTc",
	"fho79EXc4Cy609Hjms5G9IJJYa3vY+7OSiUlTy/4Cn9fCbuuFrNUFfNgjs1XqjbN5hmHQkl6ls15Kebo",
	"3s4vH+9RjTeQVywiruge1F0KtO6xImapz0DteEgI0aWwuYtg9BBewFJIgc+Pz2XGLZ8vuBGpmVcG9Lc8",
	"5zKF2UqxY+ZBvuCWk2PdiweNZZlSlpLHpqwWuUjZRVu/Nfw+Fl85P3+HVD8/f89sz5odaiM/VZTx3QTJ",
	"Rti1qmziY2rjznkTwCDILryza9Yp87DdNvuYnYcfl3+8LE2Sq5TnibHcQnz5ZZnj8ls60zB6ie73mLFK",
	"B8mC4sYHCnB/XynrQ3t8E5KLKnSG/6vg5Tsh7XuWeKf2pCx/QphvEY//8gcYpe62hI4Ds/OmqkGxAWZi",
	"3gut3JkpB16uNqAJ6lv3VkguNXHS4SOiHY3Bs9ZE7z+VUAjqzyrH3f1kOrVgxKjjw6EJUmmMJ0pcV0uY",
	"qGWXQ0JItbdcHwymkGVZslWuFp6RakIc15QI74zzjJNwt8AvO8mwY4dLriOEcNs9QoJPWCjCu9Fmx5ZX",
	"cm1FKkq3/sMugV933kEg++RYVHKpZV9ADeRHVGC5wcmCm7isAnyC+1EZl5mJawwGW5jJeejcXWNQHYJn",
	"3EUOrXi88deDXJPSDMt2idVjqMW5BLRsFEhAo0uRtqZa+3sUcdncntD92SEyfW84H7koXHyKbhhT4Lw5",
	"XPLRiPJoFtRp6zazlVxb5zghbNqU3mGY1vlursQj5EKFBKiQ9TSZXiuDaYr603HmRdTZbVVy8BUaR+E2",
	"uMbYzIsqt8KIlZnnaiVS/F/Iul4AS9eQXsSvvX16QIwVlCRlmkEOK+6Dt5R44JnUk+Ur02IOpMHPyyW6",
	"2CyJXcpyY1Qq3A1WELMmzAFoaz1izAUH2MEQYkeohTZFvQgwe6XackGuroOkBEFhMh5gU7ys9Tfsjxo1",
	"dT7eittrbQ3lVnOAp00yotvGYQRjOomKwzFDuDOKuSELGJjjseOBYnHo0w8jBwZyICs96Uj1OPOfn78z",
	"QGz4NrzWso7ZA7FkXG4ftoKfGlboPzY+F0qKEET4bf3eS2UhWQptbELuXnR5OOgHQ6bXDzg0Lvo6pGKu",
	"WkJkcclH017ANslEXsV328/7lxc47avaTTDV4gK2pOCAp2u24DalIEJ3ehyzY2qXmLBzwT+5Bf/Eb229",
	"h/ESDsWJtUIvvTPHHeGqnjzZdZgiDBhjjuGujZI0Kl5ahulQqjQPfYqDy2JoFZQMU9N4WY4lTDh7XmRX",
	"PS/PAR/1HBOa7To2tjPWh+K7Rq0Ddw9dGgcvmtGkITip5Nm2tY8rGJLtpQ4FKu4mFU/tW98Z8PwvsP0b",
	"jqV5Jx+nk5v5lD36NKjUgA+mTcQIec2F7nlrLTZq/9qi325+ihiKYWOu7a7vZA8Hds/qX9d8GeUKin86",
	"t7MToLomg/Cy1OqS5wlltfFi7FxpdenPFQ1nfvhvrzjTHLh2cZ6dONO48veBs9un5CBuih7ENoAbR3pa",
	"kbLkVk/4gJfiu7WH79sz7Cg3KlxFnWFK9i+f0Twhz42M9oJv0c9x8b3hAZBVkSATJCYXadwdlwuDfCSr",
	"AsHjYEaDRwwdhFiJkSisrEQLFg4zB0Txe0i25ogSk0IlO2i3UL4LQCXFLxUwkYG0+Ej7ZJSOQY9GTcgo",
	"HJBvRBl7wD6BsQYfT6k7TAEjqBHVG+TqLpXbjhVGUkWDMxMWWgc58YdWwOsasf72jAOxuyNO7/nDc7O7",
	"hVz7crlI0f4w8QUZw1W57e8YEFzitUN0ZI5oBwCKC8byIE9CKTIevxA9dO4gZaXWJS7tRhQhPXPAes2L",
	"lJiyAJfz6vKmeG5UBEwlN1y6qmZ8z9HQv23A+aP41kahV5VyA9HbQ2GSpVa/QtxLWuJGRfJjPCkps4Xe",
	"nkUyxfuis/b4m1YNgb5tPEZZe8xaaD1k3buYkRNOXN4KCVPCXwiecOnY2lVgd67V4oejfRU+d/Cbw+Fx",
	"HqQP5Hyz4LGqLFTriFNgMMSoHeaxioWXwy6YOs/V8x47Xbqc2WkzVrgygBJ0k8Q2NDzG2L0dhLvzLJ9B",
	"Kgqex6N+GVH/rKNtM7ESroy9MtCqk/aAWKmEtI6LfK25KyVtSHO6ZEfTVicGvxuZuBRGLHKgEY/diAU3",
	"pLXqUF79Ci4PpF0bGv7kgOHrSmYaMrs2jrBGMSX9TpGjUsd0F2A3AJId0bjHz9kDimYbcQkPkYreFpkc",
	"P35O1+Xuj6OYsvP9KnbJlYwEy394wRLnYwrnOxiopDzUWbQkxfXXGRdhO06Te/WQs0QjvdTbf5YKLvkq",
	"Vv18fv6u2IOTe5d2kwJSPbrIzHXIMFarLRM2Pj9YjvJpJGUGxZ9Dw+cxF3iArGJGFchPTRG0mzSAc+02",
	"fIVmwCs8pKuDMuSj95yy39Yfcbo8tmq64HnFC+iSdcq4q9yilHrfYsALxFm8QMCAvoxPokc2OOhN/y57",
	"IJVMCjw72cMmGavFf7GJ6XIqOq0NsqufALEb9KGmFkJJRglbdQjLWzLpk0lc6fg6eYVT/fXNT14xFErH",
	"SkAbaeiVhAarBVxGT2w/qai2TGp1ESgfM1BcoexJWUYM7/CIdt+EiAYvSx/wWrpLFBrGUp7ns2vFcPbt",
	"WkupDwj8OQKDDeV2+CqhsPiXCoyN1bvQA5e2Qn4uEsmTCGRGGnfGXH0IbnMnw580nSiq3GWLQ7YC7Wld",
	"lbni2ZQhnLPvT35iblbji9moLoGKmleu1qhmqcie+Mvnm1dnuySXg+E0vBaBhGs2liomjeVFGcsJxBFn",
	"YQAlHl5ykYdLdVIAbdrM2Aune02Q7G6SpqaM1dP5056vFNXwcmt5uial1lEBjjmjnrK/OBvPq33tR4S0",
	"WtNqz1J3uqhrnl3RmFUMt444QGagp0yh5bERxrWYgkvopiHWObneqAppid3l6UpKxydxDbEjZ/xTyB6Q",
	"c1dGISgUxaxH+GuKDKMqncJ1OfItvRWtQOk3Majn9P2mDukuckCtS18qhRPqD1jkdEQYrnWr7MkwHWuY",
	"EOSYX/mI6HdPcVfc9ro/LTU2Ql9qBdZ4wQTZlJJeRA7eFRLSgC9Cp9ZjLTGHaqN1B0AC7nZVB7UwGtH4",
	"P+Az0vbCZ5JcCEm1eZ5sPmnFOSvUDseihyQsWykwfj3d2hPzDt+ZnV3JU8T4/Sy0zyEYLvaKy3aB7yGo",
	"kxAGf+3isDj2OxzLKOLa/Ny5U3GTnpSlnzSaJ1LvcKxDx/j9yg492SJuDb8NLcZu32utdLtSYlBl5or7",
	"6j5xdEGiQi8WUqd1X6oun+Cz6Pp885V446z24sLAGOLtkH9M3dflJJzVl2is5EKjF9u94HFh7ug9YBT/",
	"g+8GHXKRO71JALJvZe4y49Dl0TrIsKkMDNd5cNpgh7YR6dusbTdmJJ1cG8oBcdFniwdM7AJtcXrevDw8",
	"JNFUNHydfBZHkJAsObQKRu8a3FUDPh5MfpiQ6zcFonV6GH7e2K7/bbRTissP5pZtgHEpFQke7wMxzgqV",
	"Qc6ML5zNYcXTrU/pN+cS/ZRMaKDqU1FQxw7OzIav0IRdgSQbJmPB9iFokd2qRJ7tYxsP41saGymx+ZJF",
	"MsND7JDtWhEjXDZiDTii7C4Kqaf5XIUgqSoKZ7l0yB8thwjmnjPqCP2my8wuz2ShuUzXUQoRlFZjvki7",
	"iTWXEvLo2y5S9IU4pOD/UCM4F0LGH/VZwBGmR4Zmzd0VhikD/Eh95HRiIK20sFu6zQ0Wl/jPaAbWj/X5",
	"9V3X6pi4D8m6Ppc+WNGc9qY14Y+K5xSvQ9OQkkQtlTR/f8WLMgcvR7/5avFHePqnZ9nR08d/XPzp6Ouj",
	"FJ59/fzoiD9/xh8/f/oYnvzp62dH8Hj5h+eLJ9mTZ08Wz548+8PXz9Onzx4vnv3h+R+/Cn0BHaJNz72/",
	"U41gcvL6NDlDZJuN4qX4C2xdmRNyZ6jj5ClJbii4yCfH4af/Gc4JHqBWF2//68THfiZra0tzPJ9vNptZ",
	"+5X5itrKJFZV6Xoe5hlWkL8+rcMFLs5CZ8n5gnjQSV8Im9O9Hz178/3bM3by+nTWiIPJ8eRodjR7TGW9",
	"JUheisnx5Cn9RFy/pn2fr4HnFk/Gx+lkXoDVIjX+Ly/CZ76EFX+6fDIPDsr8g7/o+IhwVrGb7dAKo/Zw",
	"h8VSU6dmUl63WOgkqxufvzxlC3eHy3z3FZmRD+ru51D51eQ5zVpfCWgkTgjt+I8cvLtDzYtjfRliVWex",
	"LzHUucvj7UgbCYhS7Sh5/v7D13/6GAk2vu91mnxydPQZuktOO1ACXW65TeWzW0S969/ceAF9cINlvOQ5",
	"8hPUrcjdgh7f2QWdSsphRQHGnID+OJ18fYd36FTigeI5o5Gt68WhiPyrvJBqI8NIVM5VUXC9JdVrW4n6",
	"Ldvp46go7l7s+yqEcfkMrc4hraKpTsRmsQ18NmWm7hBYaqHQhKDG/RmkGjgpfKUpUtn0IPHlGeBaIr48",
	"+TuFRV6e/N0194k2NW9N7xpddYX7j2AjPXK+3TaNeXdK+i8lPqe/2z7wd0cX3lQF3Xdauu+0dGc7LX1O",
	"oyViZVzVeTacSSUTSbV5l8BaTuznNDu+vJ3wWRV7zaeVbN1J7uTZQS/KRjc3RgE1XTHzD3Qh1PbNBkqU",
	"uo3/E/lFrSJkrYpQmqbYEmy69o3QezGosc847NT4uzLJbqyh7tvg36QN/gGW/T2Bf5vvDNxlF/tbnrGQ",
	"zpOwVxS7pgMePgDzz+hxPzt6dmcX9EpJYHAlDDUIcLx4H0WojQ3KuSaihNZl7V5Ztengss7mriPiLsvB",
	"dVSc3Kozdt8F8w50wfzy9v6NzkBvtRran7wAn3XZnIfQQWBYVt+9/fDDzbqymdq07kqaTi2jJyl86uUW",
	"T9L992buvzdz/72Z++/N3L3vzdy9cFLka3yfy4rrKuyW4G4Ulvt7vuHCorOXkM2XUPFfJCDUnf0/uPAf",
	"1uTeVrQKhQXw8JlVJ2g8nFbxgWkHVH2/sfCdFVFQeltX7+FUPyh9UPypCepYxXBhrJJWhGQBPIe19vr9",
	"BXPu9fK9Xr7Xy/d6+e7r5d/wkqUTfEvCnVq4i4rdRLH7q6gb2xUthePVPSpbPE87Q0b9e+NSmYij+4Zv",
	"2rfQ7qCAsd+qbLuDZFfJQkjCs022JoPXPZzuN8LQiKD+QP4+KnbJbhVbaMWzFBWQVaFGbWA8fLzVC567",
	"8ambL3f+WZPtduKvMTrUuD/5n3ryvw3MbhinLuG9w9Cq05zRNRKenBXIxJ/dZKGybWg/pPnGXsmoVJi7",
	"Cuhx4dDiwBd6+6Y6XD5cj7Dd8u09R+GB0mylVVU+dM1d5JaSxoqSy21wOlCvUsE29d3llt+6rNh7epuy",
	"b3r5Cx7V+4P4qQfxtVaXAs3dWAm/d8htlDVvdi6bPgrR4PTgQy+3G6S+/+7V/Xev7r97df/dq/vvXt3t",
	"a9Vei7x6pfQJnv5iRxTRLZQp/L5rE/YGue8rAe4rAe4rAQ6sBDgg8ep+d+/rPO5wncd9Lec/ZS3nLZR8",
	"zHaaUPMP9kpk+wvy21BF5lpfakjdzLWEaw+bMmFre2N4YS3sjLEz6mvJUUjCJWieUztjE3LXhWGFWK0t",
	"M1WaAmTH5zLpYOL6WODED5r/OsfHf6nw6CHrvuIc2ZZkGr5Kphw9cm2mvmHnk/NJH5CGQl2Crxyh0VlF",
	"Le7cS3uh/osHey5/1oONQ6+cnO01L0tAqW+q5VKkwhE8V2grr1Tv+lMqegIakQMUOIYJO/WfAhDGXRv7",
	"/o/cd9GK2aRD9XeNvggnPWaJ51kg212zSvbfDimR/e9if74Ay0Vu6vSPiLtBhn+fszb+W47ER7VMCV91",
	"BBN+C9+Gc7Pk4gLaKQqUybPhOgsjIh35XP/7+FclzpoO3vSlHxFHdFnPJppm7HV/+2hcI82VgfGvf75p",
	"vu5JQTFOMTHum/WGDpQIA88QR+x06xuc43MKuUrGvgXxnXsePpocgiK9EGQEbtieZO9HNEMHemEGRGxv",
	"8pL5XO74hCieEpIKuz6oWQud/kwXIr2AjCFDho7II8YUe+C7svieppv11kdBvLx7OGPsRLqe5KG9aTfI",
	"1ZtcfmV3zX/VltBd0RdpeU2fOtU35KIAZjfvGEAWu+FUDsjuieyVHGEgvom4FocWhkU8iZ5d32Iqh8Uh",
	"Jvzdtzv673y64dGHdHuWxxe3Pe7vHz9nDd3O++pXyrIfSK3czEOpW3XFLBCHROgeR8Zi3Tfu3Xs0iegL",
	"Ad6ObJqhHc/n9HGztTJ2PkErr9sorf0QxQlfOQjeTiu1uKQi1fcf/38AAAD//4cB+6i4rAAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
