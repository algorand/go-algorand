// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9e3fbNpb4V8FPvzmnSUaUnMTtND6nZ9Zt2o53mjQndmdmN87OQOSVhJoEWAC0rGb9",
	"3ffcC4APEZScxHl4V38lJkHg4r5fgN6MUlWUSoK0ZnT0ZlRyzQuwoOkvnqaqkjYRGf6VgUm1KK1QcnQU",
	"3jFjtZCL0Xgk8GnJ7XI0HkleQDMGvx+PNPxWCQ3Z6MjqCsYjky6h4DixXZc4up7pKlmoxE9x7KY4eTq6",
	"3vKCZ5kGY/pQ/izzNRMyzasMmNVcGp7iK8NWwi6ZXQrD/MdMSKYkMDVndtkZzOYC8sxMwiZ/q0CvW7v0",
	"iw9v6boBMdEqhz6c36liJiQEqKAGqiYIs4plMKdBS24ZroCwhoFWMQNcp0s2V3oHqA6INrwgq2J09Gpk",
	"QGagiVopiEv671wD/A6J5XoBdvR6HNvc3IJOrCgiWzvx2NdgqtwaRmNpjwtxCZLhVxP2rDKWzYBxyV7+",
	"8B17/PjxE9xIwa2FzDPZ4K6a1dt7cp+PjkYZtxBe93mN5wulucySevzLH76j9U/9Bm86ihsDcWE5xjfs",
	"5OnQBsKHERYS0sKC6NDhfvwiIhTN4xnMlYYb0sQNvlWitNf/pFRJK61BputkoYEToyy57KPkpUeFWaoq",
	"z9iSX9K+eUFazn/L8FunNS55XiGKRKrVcb5QhnGPwQzmvMotCwuzSuYooTibJzQThpVaXYoMsjEqntVS",
	"pEuWcuOmoHFsJfIc0V8ZyIbQHN/dFj66bqME4XonfNCGPl9kNPvagQm4IkFI0lwZSKzaoZmDsuUyY21d",
	"2qhp83Z6mp0tgdHi+MLZGcKdRIbO8zWzRNeMccM4C1p5zMScrVXFVkScXFzQ9343iLWCIdKIOB0TgrZ3",
	"CH09ZESQN1MqBy4JeUHo+iiTc7GoNBi2WoJdenWvwZRKGmBq9iukFsn+76c/P2dKs2dgDF/AC55eMJCp",
	"yoZp7BeNGa9fjUKCF2ZR8vQibqlyUYgIyM/4lSiqgsmqmIFGegXVaBXTYCsthwByM+7gs4Jf9Rc905VM",
	"ibjNsh0fBVlJmDLn6wk7mbOCX31zMPbgGMbznJUgMyEXzF7JQf8E194NXqJVJbMbmG+LBGsZDFNCKuYC",
	"MlbPsgUSv8wueIR8O3gap6IFTphkEJx6lR3gSLiK8AyKLr5hJV9Ai2Um7BevueitVRcgawXHZmt6VWq4",
	"FKoy9UcDMNLS2z1LqSwkpYa5iPDYqUcHag83xqvXwtv2VEnLhYQMNS8BrSw4TTQIU2vB7X583z7PuIGv",
	"Doesd/P2htSfq02qb6X4jahNgxInkhG7iG+9wMajns73N4h72msbsUjc4x4hxeIMTclc5GRmfkX6BTRU",
	"hpRABxHB8BixkNxWGo7O5QP8iyXs1HKZcZ3hk8I9elblVpyKBT7K3aOf1EKkp2IxgMwa1mggQZ8V7h+c",
	"L66O7VXUX/5JqYuqbG8o7QRkszU7eTpEZDfn2zLmcR3FtR3qs6vgZL/tF/aqJuQAkIO4KzkOvIC1BoSW",
	"p3P652pO/MTn+vcYMpFzvYWlQNgHyC/9M3yEsg6SVBkvy1ykHLE5Jbt59KYFyR80zEdHo/8/bbIDU/fW",
	"TP28bsUu2e5BUdr1fdz+t7lKL95p7VKrErQVbhcznKfPIDQ9WwLPQLOMWz5pogjnXgyQmT78C31HwQHo",
	"iGb/mf7Dc4avkfm4DV4LemzCoO+iWqmFDB0dpz7dSjiAHDDFCufbMPRJ3grK75rFnV6qFckrj5bXm7NF",
	"aPK9c6cYfRE2gVt/rjI4tdxW5p3I1F2lmSwYFEPYENLtCYWWz1RlGWdSZcAMDR6NN8idcpsuq3IgbP3O",
	"vT0TBc7MJJfKQKpkZhq81tp0PMq5sUNuxE/cWKfKhcwIxw5g/MbZEGYA5PC8l6CNUDI+89/cy9jcKWJa",
	"msowPwMzVVkqbSHrBcLe9Rhe6zlc1WupeWvuUiurUpUjA1YGds08hKXW/B5ZbicOQdx6X6L2dfqbo7AN",
	"OWkdRWUHiAYR2wA5DaNa2G2HGQOAoEDWX5ITJgyxYgNXHduMR8aqsoQs4TapZP3dEJpO3ehj+0szts9c",
	"GAySf5UByxTg6jbA5CFfOcy6AHPJDfNwsIJfoIUvtVp4m9OHGWUmMUKmkGzjfJSeUxzVFoEdsrShfTpS",
	"2pGzDeHY4N8o0w0ywQ4qDG34JkqxZaheuAjqrPEubkEdPgXLRW5qlVeHac0qFNFtJppX3FCML22+Rh6e",
	"C124pAiZGROeOYWa+VVc+N+IpcyYhhXXWRgx6elZn3uRGVzFAxuXdKEBTMQBnderCcvSkKbweZ1JVNxd",
	"ZsEBZ2I5J3qB/FiIVCvuUkmIeHRoFYHhsiUaCo7QUVLD1xmG1xRykbjMVcSouPchsxUiijap4vMG8gwK",
	"Wk2R1RIoWEbtuYHENpHnGKEZGNpIqVSegNZKx+Kinp7ZXOlCpBeQMWRIKnF49fdFFyZchN1Dopo6clwt",
	"127aJS9LkJDdnzB2LBkJkU8Db5i6jcXlF3bb+le0alZREotLRpucnMuY2QopsPfkojDNdt5x5ZD3XMpN",
	"sn0heyUHGIivKILD6aIcudWPPKUvW7qtp8pbTOWguIn6/JFqBLxDZZFRlrNRX6aaFYIKBa1hY9QVIYHV",
	"dw6FnTB2RtLCNWLuEjS64dw4I+/TzYVYLNF0pilAdnQukw4kqSr8wvea/zpBPK8ODh4DO7i/+Y2x6Kf4",
	"DIiTgc1vv2EHY/eK0MW+Yeej81FvJg2FuoSMzbUqWJuv3Vc7p/1/9bzn8ueeKmIFX7tcfJBFZqr5XKTC",
	"IT1XqMkWasPdkIregEbwoJiBNkzYMSlvwii5aY4ujQDGzeNthAuRWdFBQ+OhNV+HtEWXdwyDK57iLjkp",
	"mTVbIaPUfNa3claVSXuCSGFu64o+XHLJOQuFaSUT3lbuarGi9ehvZXm+A74zHDOUHm6x62S309ZDRhSC",
	"m4j/MSsVUl34AkXIYufC2B6QriZjKVauGTJidCbsP1TFUk7yW1YWaqdeafKUKYLCFciKhjW9b9JgCHIo",
	"QNoaOw8ebG78wQNPc2HYHFahqocDN9Hx4IETAmXse0vABmtenURcBqp9oDWNNCEsuVlORrEkWofKOO9N",
	"iNjaDzt5GhYkYTKGTMz1eISxVr6+BYF3EzEN3sNxXoLnDQqCcpLBVgXR08+sjYWinyhwn/5zwPd6GUKE",
	"nqVVMhcSkkJJWEf7RYSEZ/QyaqeJRQY+JmEd+nYzhOrAvwFWd52bUPN98UvUbrHEi7qeeQvE35x3I0fU",
	"rp2Slwl5yThLc7RpFMlbXaX2XHKKkDfcoA22CHH/cM7kuzAknqSJ5FD8VOeSG8RhHTdPYv7pHCKJqx8A",
	"QurEVIsFmA23iM0BzqUfJSSrpLC0FnmViSNYCZrN1hYmbiR6AnOeU4rnd9CKzSrbVb1U4nGejSvf4zJM",
	"zc8ltywHbix7JuTZFU0X4p7AMxLsSumLGgtxv3UBEowwCSqn/rZ/dG//ws0ybB8HBmXjP3apSZy/qQOt",
	"LSBtubWgcab/uvfno1fHyX/y5PeD5Mkfp6/fHF7ff9B7+Oj6m2/+u/vo8fU39//8hxilAuyxAoSH/OSp",
	"d0tOnpLtaapkPdh703+o7GMhZBJlMgwXCiGpjr3BW+weWtDAQPdZ0ESB6ufSXklkpEuei4zbd2OHTRXX",
	"k0UnHRtc0yHERjIp7PV1LNxZqKTk6QVf4POFsMtqNklVMQ3u2HShatdsmnEolKR32ZSXYorh7fTy4Q7T",
	"+B76ikXUFZX4XB2lVaKJuKW+ubITIeGMrjvL1TgxQngKcyEFvj86lxm3fDrjRqRmWhnQ3/KcyxQmC8WO",
	"mJ/yKbecAuuNfNBQAyU14HhoymqWi5RdtO1bw+9D+ZXz81eI9fPz18xueLN9a+SXijK+WyBZCbtUlU18",
	"Tm04OG8SGDSzS+9sW3XM/NyOzD5n5+eP6z/KdZn4pvEV7tqNQTZpEs8hGYA0fK6sT9/xVeiNqTDg/VfB",
	"y1dC2tcs8YEr9ff9ReUI2L+8jKJiXZfQiVG21u9ac8TCEp/JS7ZtreQad9aSBIz93T5DJnBoq0f1XgNf",
	"bdvse+0ytr2SaytSUXLrvYMb1DpfdL7BSXbxXpTb1HyTqRwDtpAUZTI3OJlxA1FyAL5BelTGNYrhHoOR",
	"DSu5qIq71DO1RXsXbpZDK4dqfEmHa1J0Yduuz3MItDiXgJaN0Acwuhhpa5elz32LyybjTTWPm8jhzhQs",
	"clEoVolu6kngujlc8sEs4GBTxkmrAtXq9atbLnBuIsqGMIzr9hvXcR5aM0I/RmjCGI3fqqFiPPJl1Rg5",
	"lMyRHBnksOA+6UUFW88oHrQvTItACMfP8zmGJiyJFbO4MSoVLvMfbJYJawDaqAeMuaCK3XiGGBu3wKZs",
	"AU3Mnqu2bMrF2wApQVB6gYe5Kc/Q+ht2R9tN67+3fjutVF93NEI0bvqTHBn7kd94FFVJQw5EZxRzQ2bQ",
	"c2NiLIqqqR8L9SMuAzmQd5N0NGtyEYuQz89fGSA2PA2ftbwKdk/MGZfr+62kkYYF+t2Nr4rSGoKvjxsv",
	"XCoLyVxoYxNyk6Pbw0E/GLL7P+DQuPrpoIq5BmqRxbUPLXsB6yQTeRWntl/3r09x2ee1e2Wq2QWsycgA",
	"T5dsxm1KwVd3eRyzZWlX0N264Z/chn/it7bfm/ESDsWFtcLoprPGHeGqDX2yTZgiDBhjjj7VBlEaVS/k",
	"N21pI50pf0KpkuK3CpjIQFp8pX01oaNZELuhJNxTHQPlZz+xr0DX08drohSf3cgZdKFcD+UOiHqmQZwE",
	"jzlS6w9aNWy0dvXxQcv7fYtgrb1iL1bbEmihNDTxlUsjLX0rb+RAUb9yUQlpXQfu7tNMwTYvHaADa0RP",
	"J1GQECtkH4djEmi8Qyjh7BK1FdTtd+1DcqG+3mO95kOqLMzANS24whfPjYpMU8kVl+7EBX7ncOi/NuAM",
	"I361UqjeU24gmv4RJplr9TvE1fUcCRUpcHhUUmmCvp5EWn02nZDa9WiOkQX8tuEYZO0XtRBF6OwzIN1g",
	"ekDCictb8SFVbIMXx6Vja3c6pJMXiQtHO5c5dfM3wuFh7uV/c76a8VjH6Pn5qxRhCgyGELX9TatY+DhQ",
	"wdSNCp732MncNT2Mm7HC9XGVoJsqZI8ZBtn9rMV+d57lM0hFwfN4+JER9s86tbpMLIQ7YlMZaJ3h8BOx",
	"UglpHRf5czCuzb1BzcmcHYxbp8Q8NTJxKYyY5UAjHroRGCXT3uqIJ3yC2wNpl4aGP7rB8GUlMw2ZXRqH",
	"WKMYxtVn9WG4OsCbgV0BSHZA4x4+YfcotDXiEu4jFgt38mh09PAJ5TvdHwcxY+fP0m3TKxkplr97xRLn",
	"Y4rt3RxopPysk2hPoTv7O6zCtkiT+/QmskQjvdbbLUsFl3wRO5lxfv6q2AGT+5aoSZ7xBl5k5k7vGavV",
	"mgkbXx8sR/00UPNA9efA8I0oBQqQVcyoAvmpOaDhFg3TuaOAvns8wBVeUh6hDA1Frdrbx4+CnC2P7Zqy",
	"Pc95AV20jjGUpwqkaI4/eYU4iXd4GdCX8UX0AIGD3fTfsntSyaRA2cnuN9W0Fv/FFqZMVXRZG3TXZgZ7",
	"+9Q3dbVwlmQQsVUHsbylk94ZxZWO75NXuNQvL3/yhqFQOtbD32hDbyQ0WC3gMiqxm1Wh2jOpzUXAfMxB",
	"+V5rpds16F7/jmubqg+X0jldFQ5wkPDUh9m6vgK+i5yoQwmnExvx03btvYSBMcD/Ntiz79L93LIVMC6l",
	"stxCICbjrFAZ5Mz4Fq4cFjxd++KSOZeI8ExooD4oUVDvOGdmxRcL0FSV1OQ/hOI2zdbf+6wSebYrbPJz",
	"fEtjI8XeT1mu7WdnHLAusNzo1WqJeKcasHmohja6vTxZL/OhSpJoNFyRoYP+aGEuFGdpCkbgN+cdGqmN",
	"kF9zmS6jGKJZWqcfI43PSy4l5NGvncn7RBxS8F/VAMyFkPFXmyzgELOBhmbP3R2GJcP8kU6d8chAWmlh",
	"16coVT6CL8U/ozmtH2v59Ufbaufe+5buMLHXuo20N+c/f1Q8J8cDnRlKu1tqrvv+ihdlDt45/eaL2Z/g",
	"8deH2cHjh3+afX3w5UEKh18+OTjgTw75wyePH8Kjr788PICH86+ezB5ljw4fzQ4fHX715ZP08eHD2eFX",
	"T/70RTh86QBtDjb+g7pVkuMXJ8kZAtsQipfir7B2BXfkztBRxFNKZkDBRT46Co/+LcgJClDrqhT/dOSN",
	"2GhpbWmOptPVajVpfzJd0AGHxKoqXU7DOv1exhcnDGTmIg2KZUmWUFhIdlxmVNicEhj07uX3p2fs+MXJ",
	"pFEHo6PRweRg8pAazEqQvBSjo9FjekRcvyS6T5fAc4uScT0eTQs0mqnxf3kVPvHNVPjo8tE0VOWmb3zE",
	"do3zLGIputCUXR+Y7Zftx87MpLxu9u2U4IyvCI3ZzCWjmD8HIDOqErpEA9rrGj0nWesqpkbjhHyav0nq",
	"VaztNtZUELtDqi6xDB+kbtQKqoqD5MnrN19+fR1xRV5vnJF9dHDwkc/FHt7iil3fKLLuM54jSaC+rMRB",
	"8PDjQXAiKQeN4sKcOrgej778mDg4kcgaPGc0shVG9yXoF3kh1UqGkai7q6Lgek2a2bYqYy3Tej0oqd0E",
	"li/7DYsvtFqcW50CnY6+2TpQcsxMfZSx1EKhhaHLczJAD5vsgdIZ6HGrWdrXQ8Gd3Xx2/A/Kdzw7/oc7",
	"hRC9WKS1vDuR05X9H8FGmvm/XTeH4z9LRTD+bO9iuTuX6byvMt0fCdkfCbmzR0I+sh2/qvPJnEklE0nN",
	"MJfAWjHO3rC/s2Gv+bSS9YHcHTzbOzTb2ObGKaDucDN9Q70Fbde9Z0Tpxo9d1vIzvlhtS+edVkXoBVFs",
	"DjZd+stINlIUQ1cpbbX42yom722h9lfRvM9VNOMOdgPz7BH8Ce76+ZDW6gZkfi89/y3P2Ev4rQJjWcKe",
	"U2qTBDxcwvaBTd+H3l/Ukh4eHN7ZDT1XEhhcCUMduY4XP7R38OGJdGvOBvUWEFLCGav2oZ7adcghW4Ce",
	"uqOb2zwHd/RzdKvB2P647h04rvvp/f33koGN3Wpo380FzPF/Iw+hZbffx9pNjvvhZlnZTK1aqfTmaMSg",
	"JIU76W5RkvYX4+0vxttfjLe/GO/uXYx399JJkRtxP5QX1zXYLcXdGCz393TFhcVgLyGfL6Em10hCqLv6",
	"37nwl1tz7ytahcoCeLjq3CkaP4+/8q8p6PqEqj/gFy6EEwX17XbtHi71g9I3yj81SR2rGG6MVdKKUEtG",
	"Oayt1+eXzNnb5b1d3tvlvV2++3b5IxZZOsm3JNTUQi0qVoli+1LUe/sVLYPjzT0aW5SnrSmjzbpxqUwk",
	"0H3JV+0qtBMUMPZbla23oOwqmQlJcL6J/ZqXfzne7YShEzFbWwj1qFiR3So204pnKRogq8LtQz3n4fpW",
	"Czx3406+Tyf/rOknO/ZljA429pL/rpL/bWB2+pEvvtoUBmdsSQYmVEZCyVmATLzsJjOVrcMxW81X9kpG",
	"tcK0OS8dTYL1br663WTY/iLA/UWA+4sA9xcB7i8CvNvlm40j5/VO6WcUNjc7YIhuoR368+6B3plM23cc",
	"7zuO9x3HN+w4vkGDx566+37yO9xP/r+sg23f7XVrreWTrS7U9I29Etnuc6F398d62G39Vg/7UD/V84l/",
	"qCfik/bN39scz91glng9F9nuLU/j/fEmR/H+r/if+x8J3P9I4P5HAvc/Erj/kcD9jwTe7R8J/FQlyc8j",
	"jfohz+psLRE/V5b9QGbl/SKU+saYmAfigAiXGJGzWF9f9Oo1ukR04573I5s7eY6m01ylPF8qY6cj9PK6",
	"9/W0X6I64Qs3g/fTSi0u6TDc6+v/CQAA//+1F1nlpJAAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
