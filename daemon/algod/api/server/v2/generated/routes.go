// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//8YbKCxl8wAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
