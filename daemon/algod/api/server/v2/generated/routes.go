// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Get the state proof transaction for a given round
	// (GET /v2/transactions/state-proof/{round})
	StateProof(ctx echo.Context, round uint64) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.GET("/v2/transactions/state-proof/:round", wrapper.StateProof, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
