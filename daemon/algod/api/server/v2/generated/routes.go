// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"9AAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
