// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/transactions/dryrun)
	TransactionDryRun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionDryRun converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionDryRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionDryRun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.POST("/v2/transactions/dryrun", wrapper.TransactionDryRun, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//QNztyaK5AAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
