// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"A13aEdzlUkp2jrkT31/+/wAAAP//7ZUVmiMKAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
