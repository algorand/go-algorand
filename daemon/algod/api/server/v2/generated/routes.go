// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{addr}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, addr string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{account-id})
	PostV2RegisterParticipationKeysAccountId(ctx echo.Context, accountId string, params PostV2RegisterParticipationKeysAccountIdParams) error

	// (POST /v2/shutdown)
	PostV2Shutdown(ctx echo.Context, params PostV2ShutdownParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "addr" -------------
	var addr string

	err = runtime.BindStyledParameter("simple", false, "addr", ctx.Param("addr"), &addr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter addr: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, addr, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// PostV2RegisterParticipationKeysAccountId converts echo context to params.
func (w *ServerInterfaceWrapper) PostV2RegisterParticipationKeysAccountId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV2RegisterParticipationKeysAccountIdParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostV2RegisterParticipationKeysAccountId(ctx, accountId, params)
	return err
}

// PostV2Shutdown converts echo context to params.
func (w *ServerInterfaceWrapper) PostV2Shutdown(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV2ShutdownParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostV2Shutdown(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:addr/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:account-id", wrapper.PostV2RegisterParticipationKeysAccountId)
	router.POST("/v2/shutdown", wrapper.PostV2Shutdown)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9+3MbN9Lgv4LjbVVsL4eUbSUbq8q1J8dJVrex47KU7N5Z/jbgTJNENANMAIwoxp/+",
	"96+6AcyDgyHlWH6l+FNiDoBuNPrdDejNKFVFqSRIa0ZHb0Yl17wAC5r+xdNUVdImIsN/ZWBSLUorlBwd",
	"hW/MWC3kYjQeCfy15HY5Go8kL6AZg/PHIw2/VUJDNjqyuoLxyKRLKDgubNcljvYrXV+PRzzLNBjTh/qj",
	"zNdMyDSvMmBWc2l4ip8MWwm7ZHYpDPOTmZBMSWBqzuyyM5jNBeSZmQSkf6tAr1tYe+A3QjHRKoc+nt+o",
	"YiYkBKygRqomMLOKZTCnQUtuGUJAXMNAq5gBrtMlmyu9A1WHRBtfkFUxOno1MiAz0ET9FMQl6NHrcWwz",
	"cws6saKIbOXEU1uDqXJrGI2lPS3EJUiGsybsWWUsmwHjkr387hv28OHDR4h4wa2FzDPJ4C4a6O09uOmj",
	"o1HGLYTPEdyNgTiLHuMXdvJ0CGyYGDloIS0sQBOAGcyVhhtSxw2+VfK04f8B+qSV1iDTdbLQwInQSy77",
	"G3npN2CWqsoztuSXhC0vSMr9XIZznZRd8rzCjYlUq+N8oQzjft8ZzHmVWxYAs0rmyNG4mic5E4aVWl2K",
	"DLIxCupqKdIlS7lxS9A4thJ5jkSrDGRDxInvbseJ1pMQrz9ED9rQp0uMZl87KAFXxL5JmisDiVU7NFlQ",
	"TlxmrK17GrVm3k6vsbMlMAKOH5xeJtpJZO48XzNL55oxbhhnQYuNmZiztarYig4nFxc03+8GqVYwJBod",
	"Tkflou0ZIl+PGBHizZTKgUsiXhDAPsnkXCwqDYatlmCXXl1qMKWSBpia/QqpxWP/v6c/PmdKs2dgDF/A",
	"C55eMJCpyobP2AONKftfjcIDL8yi5OlFXNPnohARlJ/xK1FUBZNVMQON5xUUmlVMg620HELIrbiDzwp+",
	"1Qd6piuZ0uE2YDs2HVlJmDLn6wk7mbOCXz0+GHt0DON5zkqQmZALZq/koD1H2LvRS7SqZHYD82fxwFpq",
	"3pSQirmAjNWrbMHEg9mFj5Bvh09jlFvohEUG0amh7EBHwlWEZ1B08Qsr+QJaLDNhP3nNRV+tugBZKzg2",
	"W9OnUsOlUJWpJw3gSKC3e2JSWUhKDXMR4bFTTw7UHm6MV6+Ft8ipkpYLCRlqXkJaWXCaaBCnFsCoQZ6t",
	"bdwW3/BM52rzLLee443OkAYlTtAi1g6/ejGM+/Kd+Tfw5tuwjVgk7ufe8YjFGRqIucjJePyKpxLIUBkS",
	"7Q4hgjkxYiG5rTQcnct7+C+WsFPLZcZ1hr8U7qdnVW7FqVjgT7n76Qe1EOmpWAwQs8Y16k7TtML9B9eL",
	"K1l7FfVHf1DqoirbG0o7YclszU6eDh2yW/Pt2M1e1WQfWHJwpyXHgRew1oB75emc/nM1p9Pnc/17bOvI",
	"Z97KUfB27ALAl/43/AnlDSSpE16WuUg57n1KtuvoTQuTv2iYj45G/3vaRKhT99VM/boOYpfId6Ao7fru",
	"6Ho8epKr9OIPwS61KkFb4XYxw3XiuqcRg1d+WEMVZ+ZjOH7rTDyjGd4dmCDG32qt9DtgCmH+dkzdsJtg",
	"2qLmc5XBqeW2Mn+IpN11m8WCAjYkF0I6rkZx4DNVWcaZVBkwQ4NH440Np9ymy6ocCM6+cV/PRIErM8ml",
	"MpAqmZlGXGo9NR7l3Nghs/sDN9YpSSEz3CU4hHGO087MAMjhdS9BG6FkfOWf3cfY2ilSWprKML8CM1VZ",
	"Km0h68u8M9XDsJ7DVQ1LzVtrl1pZlaocXa7KwK6Vh6jUWt8Ty+3EEYhbb3tr36C/OQpzkJPWUVJ2kGgI",
	"sQ2R0zCqRd22Wz6AiDANoZ3TIgyxYoNXHQuMR8aqsoQs4TapZD1viEynbvSx/akZ22cuDJ7IH8mAZQoQ",
	"ug04ecxXjrIuIFtywzwerOAXaDtLrRY+l9XHGWUmMUKmkGzjfJSeUxzVFoEdsrShbzpS2pGzDeHY4N8o",
	"0w0ywY5TGNrwW6rBFy7iOGvs9i2ow6dguchNrfLqsKaBQhHQZiJzxQ3FxNLma+ThudCFSyKQQ2nCb06h",
	"Zh6KC5cbsZQZ07DiOgsjJj0963MVMoOreCDgkhQ0AGPzGKLzGpqwLA1hvc+DTKLi7iJxh5yJ5WjoA/Jj",
	"IVKtuEu9IOHRVVSEhssuaCg4YkdJAJ+XHoYp5CJxmZ6IUXHfQyYo+Orto4qvG45nUNDqE1ktgYJL1J4b",
	"RGwf8hwjGgNDGymVypPaI9iMOHp6ZhPShUgvIGPIkJRC9+rviy5OCITdwUM1daS1Wq7dskteliAhuzth",
	"7FgyEiKf7NwwdRvA5Rd2G/wrgppVlPThktEmJ+cyZrZCyugduSgss513XLr9HUG5RbYDsldygIH4qkNM",
	"n01y6TNKN3n6K82ecANfHdZDCpeEYiVvOaXjHa5ki8kcVjdRp99TZpx3EBUZZQkbdWaqWSEoPd4aNkbd",
	"ERJAfWdR2AljZyQ9XCMlL0HznFKpZPR9urYQiyWa0jQFyI7OZdLBJFWFB3yn+V8nmOfVwcFDYAd3N+cY",
	"i36LzyA4mdic+5gdjN0nIhd7zM5H56PeShoKdQkZm2tVsDafu1k7l/1f9brn8seeamIFX7tcdpBNZqr5",
	"XKTCET1XqNkWasP9kIq+gEb0oJhhqC7smJQ5UZTcNncujUDGzeVthA+RVdFhQ2OiNV+HBEGXdwyDK57i",
	"LjkpnTVbIaPUfNa3elaVSXuBSImpBbELqpE7EORr9sSP31AAhYXCRIK6WtAIA/q3sjzfgfEZjhlKuLYY",
	"eLLbreuRJ4rBTRTCMSsV8oHwKf+QF86FsT0kXZXDUiG4ZtGIWZqw/6cqlnKS6LKyULv9SpMvTTEWQiA7",
	"G2B676WhEORQgLQ1de7d29z4vXueC4Rhc1iFOhkO3CTHvXtOLJSx7ywTG8x6dRJxKoi3iOH6TtmSm+Vu",
	"DU/r3uQQW/thJ08DQBIvY8gtuh6PMBrL17egAtxCTIP3gZwf4XmDwqScpLJVk/PnZ9bGQtFPJbip/xnw",
	"zl6GIKJni5XMhYSkUBLW0Y4FIeEZfYxacmKRgckkrENzN4OsDv4baHXh3OQ035W+E5f5dQm7Vi4wokN9",
	"J0nHnGMU5AroLvWN5uwpzIUU+P3oXGbc8umMG5GaaWVAP+E5lylMFoodMb/kU245eYUbwcxQdwlVWz02",
	"ZTXLRcou2qRvNO9QcHB+/gp9uvPz18xuKNo+oTyoKFs4AMlK2KWqbOIDwmHPsvG+aWUXm2yDOmZ+bafx",
	"fcDp1487nRSomfim8RPu2o1hS8ibrEnwZPEMnyvrY0++CoXQCr2zXwpevhLSvmaJ97KofeMfKkfEfvFx",
	"FmrqdQkds7g1UdxaI2YxfRiabNtayTXurFXiRkfV7TOEsUNbPar3Gvhq22bfaZex7ZVcW5GKklufDrxB",
	"Uv1FZw4usov3otym5ptM5RiwRaQok7nByYwbiB4H4Bc8j8o49wr3GIxNgOQMPnd5E+oZ86ZllkMrAWB8",
	"PhJjhRapXCvOEGpxLgEtG6EPaHQp0tYuS5+4EZdNuoYSdjeRw535A+SikGkV3ThJINwcLvlgCOsS7bE9",
	"KpnjHjPIYcF92EMpfE99v7kvTGvX5/Ie+3E+R1PEklh6kxujUuFyQcEQmAADUPHfY8wZUXbjFWK80UKb",
	"vENamD1XbYaXi7dBUtaevV+b/MrWv2ESsx3xSuhJKzndapup65wIkLa1oWrGdSXbNTuGemgogobK52j8",
	"tlXMtnPR9ER6y7fTQvX1RiNA46Zk7bit75CMR1F1NOQ8dEYxN2TmjWFLcccIiGqpXwjpB4MGciDnNulo",
	"1eQi5ridn78yQNJyGqa1PAp2R8wZl+u7rVhGw0IYCxqyxgjUVf/NUm/JrQWNgP7rzt+PXh0n/58nvx8k",
	"j/46ff3m8Pruvd6PD64fP/7v7k8Prx/f/ftfYgx6qSwkc6GNTS55Hqtkn5+/wkHfGbL53+HQuOrpkIq5",
	"TjmRxTUPgb2AdZKJvIqftof7z6cI9nntWplqdgFrMjDA0yWbcZsuyQJ1wOOYLaBdJWLrhn9wG/6B39p+",
	"b8ZLOBQBa6XsBozPhKuuYxJObsuWlp2Z8t3TlRS/VcBEBtLiJ+0zTx3hxg2GckJPegdKF35hX72ol4/n",
	"0xHUzXyxF27ophZ1SNQrvR6iSXBYI3WioNjCRmtPG39oOZ9vESu1IfZCpS1xDjJkE95UUni/f0vwsLVN",
	"OxjqpcNloIqCDnesonEc+kvRega33Ol5qi+xM3KFTKcbPxRaenzUTKQE0gxc9cplPHluVGSZSq64dK2q",
	"OM8RxM/GCDoEYCuF6jLlJu4eCJPMtfod4upvjlSP5LE80SgDRbMnkZrvplGvTXnTCR/o28ZjkE9f1BIR",
	"OVH3kXUD0wFxJZZtxVqUqg/OG5eOR11bbafQFuf0dr5t6tZvON3j3Mv+5Hw1467Np0f0FHEKDIYYtd1M",
	"q1iYHE7B1BUrz3vsZO6qX+NmrHAF/RJ0k37uMcMgu5+12O+zZ/kMUlHwPB51ZET9s05KNhML4XqTKwOt",
	"5le/ECuVkNZxkW8gdp2EDWlO5uxg3Gqv96eRiUthxCwHGnHfjcCIk/ZWBzphCm4PpF0aGv7gBsOXlcw0",
	"ZHZpHGGNYhijntW3CGp3fgZ2BSDZAY27/4jdoTDRiEu4i1QsXMv26Oj+I2oYdv84iClNfwlhm17JSLH8",
	"yyuWOB9TnOzWQIvjV51Em0vmGuB3GFZhW6TJTb2JLNFIr/V2y1LBJV/Eml/Pz18VO3Byc+k0ydPcoIvM",
	"3LUHY7VaM2Hj8MFy1E/Jkptl3KQ6NHwFskABsooZVSA/NT2wDmhYzt2hcL5cjVf4SFFjGSrLrfz6h48q",
	"XNNpbNeUOXnOC+iSdYwRPCWaRdM37hXiJF7qN6Av40D0wAEHu+nnsjtSyaRA2cnuen3W5b9oRK8sz6Ng",
	"bdBdm9ng7Uu3ZBcHJoO0qzq04y2184epWOn4VniFoH56+YPX/YXSsX7NRuF5O6DBagGXUaHcLGHUzkdt",
	"EQJxYz5Iq+A05In0hnTbTdvXlqhhBfKScZbmAmUvVdJYXaX2XHJqttvo8dnwIEIOYbj98pswJN7vGWnH",
	"9EudS07MUrfgRU9uDhEm+Q4guACmWizAbHRUsDnAufSjhGwYkxpUEpe6LEEzVBITN7LgazbnOXWL/g5a",
	"sRkefLtGS0bMNUW4m3MIhqn5ueSW5YDx8zMhz65oudBCFYpLEuxK6YtOLqYvGAuQYIQZ0Kbfu6//4GYZ",
	"to8Dg0n2k10H9ofXhR78ydNBxE+e+oaGk6dUo27up/RQ763+vvqYCyGTKI+hgvMeyCZroUK1Nf/cZUHc",
	"w6GfS3slkY8oUcLtH+OGTT3SE0UnHBtM0z6Hja7UsNWe2hmPrpKFSkqeXvAF/r4QdlnNJqkqpjxfKM1l",
	"Nl2opP7/jEOhJH3LprwUU7Tj08v7SNCfB/u0XZWMW7YCxqVUllsISp1xVqgMcmZ8m04OC56uvdYy5xIV",
	"byY0UK+LKKhfmDOz4osFaOIfTaFC0EK0Wl+hzSqRZ7vSHX6NJzQ2IpUfRa58mqH72Z+cv/tSixll4twm",
	"XKLoZt023dV+Dgv07oQQXYb4zoXcNfT3xWzoTrpSXue0ouXvIHW0BCP0m5b4xthHuEVzmS6jhKNVWlfP",
	"IlmdJZcS8uhs5wx/JIYq+K9qAOdCyPinTRZwhNkgQ7Pn7g4DyLB+zO+h7rqEpLbfBoRef5SOhVnsvhmE",
	"gyLdIeORgbTSwq5PUe59brAU/4kmrL+vNcwSeAa6cbN8oOuuhHr/sNFHzX2/7xXPKQrCyIpKf5Yaur69",
	"4kWZg4+UH38x+xs8/PowO3h4/2+zrw++PEjh8MtHBwf80SG//+jhfXjw9ZeHB3B//tWj2YPsweGD2eGD",
	"w6++fJQ+PLw/O/zq0d++CJftHKLN1bh/k+OTHL84Sc4Q2YY3eCn+CWvXMYMCEVqYeEppUii4yEdH4af/",
	"E0QTZbb19IT/deTd7dHS2tIcTaer1WrSnjJdUNt9YlWVLqcBTr9/7sUJA5m5tAcl1kh8kS9IXF3ZQ9gc",
	"gR/Tt5ffnp6x4xcnk0YDjY5GB5ODCZkmVYLkpRgdjR7STyRoSzr36eWDaSigT9/4hNA1flnE0vmh2be+",
	"8tjvsBk705byuom0Uy03vs48ZjOXuGa+31xmVNB3eUyMFeoNn2RNbfCkUVsh9+5fuHkVa+eM9f/E3rap",
	"K6LDV2Eb3YT65iB59PrNl19fR8Kg1xv3Jh8cHHzgu5KHtwixrZ8iUJ/xHA8E6ickHPz7Hwr+iSRfE5mf",
	"OeG+Ho++/HD7P5HIFDxn7rZnk5/rItCb95O8kGolwzRUylVRcL0mlWtb9eyWmcZhfYG97ubIfaV+WISh",
	"1SzbauzphHyzdTjPMTP1tblSC4V2gx42yQAjfOP6nzPQ41bbre+0AHdP8Nnxvyml+uz4367DPfroQwu8",
	"u/3Rlf/vwUYaxZ+sj2vRvU1lcDuaYPzJPpLx+bxy8q7adH/XYH/X4E901+CDmvarun7FmVQykdRzdwms",
	"FTntbf272/qaXStZXwndwbq9a5uNxW78BMoqmukbSoS1nfqeaaXXNXbZ0E/4Kawt7bNaFaGpS7E52HTp",
	"n+rYyIAMPZOz1RXYVqp9Z9N1uw+XjDvQAjE/iZdS3p9Su8Gm30EhPOEZewm/VWAsS9hzyqrR4YfHl96r",
	"fny/e4sq28ODw89yM8+VBAZXwlBXuOO/92s83vfhvB9LRB0vRJ1QuGlf26rtSg7ZAvTU3RvbZlbcvbPR",
	"rbrw+7uCn/xdwY/vFd6eOGxsXEP7FSFgThQa0Qg92v1ecDN90zyhTc5YqYwdTrizO0ozDRJWd/2rLm7l",
	"SB88U0084zLGXm5bl7O6svlCGfvzg5d+yc6Fi3/C2oRka7bLJUQ/65dmW79QF1+ZcQtj9P9+4Xne+o0S",
	"GCF5NbndZ8ZjmM0BQlshtQ/6iB1twAWEfnpHlW7+iT11/GPqZzzqbos5DD4566rSbb3lmfD+wUHMP+zh",
	"7CohHmPSwCuV5HAJef/Qh5Do3Ll4uyTQWbd1oH0bol3ZifBfeM+4viAx+LJl+2LGW53nUyW/sGzFhX+l",
	"pxX/WOWb7Ibf+Exw4vYngN/VW7/5u1Oo/PnC0IsrWlxyC6PXQX+YZWUztZLD+oFuVPDcdzFSX2FdLbKK",
	"hQVqhTBhP9JUypD4l1sZp6fMVWW7DyqHNpKNF0P8s9kzWAhJAEiECIpr1+WtrId/SGxI55yGDfY0S/RV",
	"S4dlXKzeR8x1S6dY37sc9IzCE4i36Bnt32Hcv8O4f4dx/w7j5/cO4+eWRI48lfxBAvRuLNbS4U0A4v49",
	"RX8nmSudUDifkJkOieDpYG34X1z4F8u5zwNYhYoDeHiV3ikdv5CPS5oeD19Q8S8JhLcIRQF9bwBBfaf0",
	"jRLPTTbXKucCVtKK0F6CMllbsk8vi7u30XsbvbfRexv9+dvoD1Zo7dRVkhBbhlp0rBLN9qXo2/MvWnbH",
	"W320uShWW6sCm+0jIX3Rtfsv+arVfePNMhj7RGXrLdS7SmZCEp5von81w30c7/bM0JeYrS3UzTP9fh+0",
	"BTOteJaiHbIq3Frp+RDXt1rg/TzefPxYaoA1nabHvqe6Q4u9AnhnBfAk8Dz9dbaNt6d9ItyLwoSus6AA",
	"LUAmXoSTmcrW4RaN5it7JaPKYdo8vhJNj/Wvgu57APc9gPsewKYH8M9QXN14saS+n01/jmHzhvaAHrmF",
	"VvdPu799Z2Zk31D+cRvK93/sZf/HXvZ/7GX/x17+nH/s5QZdjHt1uFeHe3W4V4f7v321/9tXf+a/ffWn",
	"usexv/dw+zfwJltzFNM39kpkux/W+Hw1CbstRcLelx75yFokkvTpZ3ze5n2TDWaJd78g273lawZ/vclT",
	"BvsEzz6i2Uc0+4hmH9HsI5p9RPN5RjQfo5PjUyhgvr9r7Ft7ap4ry74jA3OLgUv9El/MMXEYheceyYes",
	"H3p89Ro9JXoo3buXzeuFR9NprlKeL5Wx0xE6f92XDdsfX9f3oN4E9y3ch7p+ff0/AQAA//+qmAfxlJYA",
	"AA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
