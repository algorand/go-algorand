// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                 true,
		"format":                 true,
		"exclude-creatable-data": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude-creatable-data" -------------
	if paramValue := ctx.QueryParam("exclude-creatable-data"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-creatable-data", ctx.QueryParams(), &params.ExcludeCreatableData)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-creatable-data: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9e3fbOJLvV8HV7jl5rCg5r56Jz+mz13l0t3eSdE7snp277dw0RJYkjEmAA4C21Ln+",
	"7vegAJAgCUryI69u/5VYxKNQKBQKVYUfPo5SUZSCA9dqtP9xVFJJC9Ag8S+apqLiOmGZ+SsDlUpWaib4",
	"aN9/I0pLxhej8YiZX0uql6PxiNMCmjKm/ngk4V8Vk5CN9rWsYDxS6RIKahrW69KUrltaJQuRuCYObBOH",
	"L0YXGz7QLJOgVJ/Kn3m+JoyneZUB0ZJyRVPzSZFzppdEL5kirjJhnAgORMyJXrYKkzmDPFMTP8h/VSDX",
	"wShd58NDumhITKTIoU/nc1HMGAdPFdRE1RNCtCAZzLHQkmpiejC0+oJaEAVUpksyF3ILqZaIkF7gVTHa",
	"/3WkgGcgcbZSYGf437kE+B0STeUC9Oj9ODa4uQaZaFZEhnbouC9BVblWBMviGBfsDDgxtSbkdaU0mQGh",
	"nLz74Tl59OjRUzOQgmoNmROywVE1vYdjstVH+6OMavCf+7JG84WQlGdJXf7dD8+x/yM3wF1LUaUgvlgO",
	"zBdy+GJoAL5iRIQY17DAeWhJv6kRWRTNzzOYCwk7zoktfKOTEvb/RWclpTpdloJxHZkXgl+J/RzVYUH1",
	"TTqsJqBVvjSckqbRX/eSp+8/Phg/2Lv4t18Pkv9xfz55dLHj8J/X7W7hQLRgWkkJPF0nCwkUV8uS8j4/",
	"3jl5UEtR5RlZ0jOcfFqgqnd1ialrVecZzSsjJyyV4iBfCEWoE6MM5rTKNfEdk4rnRk2Z1py0E6ZIKcUZ",
	"yyAbG+17vmTpkqRU2SawHDlneW5ksFKQDclafHQbFtNFyBJD15X4gQP6epnRjGsLJ2CF2iBJc6Eg0WLL",
	"9uR3HMozEm4ozV6lLrdZkeMlEOzcfLCbLfKOG5nO8zXROK8ZoYpQ4remMWFzshYVOcfJydkp1nejMVwr",
	"iGEaTk5rHzWLd4h9PWZEmDcTIgfKkXl+3fVZxudsUUlQ5HwJeun2PAmqFFwBEbN/QqrNtP/X0c9viJDk",
	"NShFF/CWpqcEeCqy4Tl2ncZ28H8qYSa8UIuSpqfx7TpnBYuQ/JquWFEVhFfFDKSZL78/aEEk6EryIYJs",
	"i1vkrKCrfqfHsuIpTm7TbctQM6LEVJnT9YQczklBV9/vjR05itA8JyXwjPEF0Ss+aKSZvreTl0hR8WwH",
	"G0abCQt2TVVCyuYMMlK3soES1802ehi/HD2NZRWQ4xsZJKfuZQs5HFYRmTFL13whJV1AIDIT8ovTXPhV",
	"i1PgtYIjszV+KiWcMVGputIAjdj1ZvOaCw1JKWHOIjJ25NhhtIct49Rr4QycVHBNGYfMaF4kWmiwmmiQ",
	"pqDDzYeZ/hY9owq+ezy0gTdfd5z9uejO+sYZ32m2sVBil2RkXzRf3YKNm02t+jsc/sK+FVsk9ufeRLLF",
	"sdlK5izHbeafZv48GyqFSqDFCL/xKLbgVFcS9k/4ffMXSciRpjyjMjO/FPan11Wu2RFbmJ9y+9MrsWDp",
	"EVsMMLOmNXqawmqF/ce0F1fHehU9NLwS4rQqwwGlrVPpbE0OXwxNsm3zsoJ5UB9lw1PF8cqfNC5bQ6/q",
	"iRwgcpB3JTUFT2EtwVBL0zn+s5qjPNG5/N38U5Z5jKdGgN1Gi04B5yw4KMucpdRw7537bL6a1Q/2eECb",
	"ElPcSfc/BrSVUpQgNbON0rJMcpHSPFGaamzp3yXMR/ujf5s2XpWpra6mQeevTK0jrGQMUWvcJLQsL9HG",
	"W2PQqA1awmhm/IT6weo7NIUYt7NnZIgZ3ZvDGeV60hxEWoqgXrm/up4aflsbxvK7c7AaZDixBWegrF3b",
	"lCAZ1RSJpY3AezcTGptBWSP5F+O6H2Md38SUojW+FLmxJ7ZOhin8kysbzqP5fafK38Ychrztzh6eSrbO",
	"m/N+hDN2pcnayFDb7oaB1GM4l7S09LsvdptgHA8XtpCl9Zr6YselHKU5kPVgspGqKwv7VoGMUoKz16Hh",
	"WS7S0xtYcDPTTl/usXmyBJqBRPEKBNsJbHw7woo/YT1ckiAjNuvP+B+aE/PZSCvV/jxmzqJmeSkiAs9x",
	"Zo5w1jC0PZkCeLQUpLCnNmJOW5ei8nnTeW+RWrbsskhf2oMiwRp+EGbojRvoYCbk1eSlIwicNM4tQk2r",
	"wXIZd2YWi1Zl4vgTOSDbAp2GmnhC304KOdRtPsarFheONP0EXFCm1ZvgQruhm+aCKEqWww2s1yVVy/4g",
	"zInl0UNy9NPBkwcPPzx88p0xuUspFpIWZLbWoMhdZygSpdc53OuPDC22Ktfx1r977F0i7Xa3cggJrtve",
	"ZUUdg9EMlmPEOgANdS/kWlY3YTaClEJGDrEoOlqkIk/OQComIv7It64EcSWMHrIH6c7vllpyThUxfaN/",
	"peIZyEmM83rFkTSmoVDbNgrb9PGKN7xxDVIp6bo3A3a8kdG5fneZkzbz/XFdkRJkolecZDCrFi2jaC5F",
	"QSjJsCIqxDciA2NzV+oGtEDTWEOMmYiQBDoTlSaUcJGZBW0Kx/XDQHACvaLozNWhytFLu//MwBx3U1ot",
	"lpqYc6KITW1TMaGpnZQE9wo14MupnXC2lO3OOr5zCTRbkxkAJ2LmHCbOlYODpOhn1T6E6rRTxCZt0VVK",
	"kYJSxnK25thW0nw5O8t6A5+QcCS47oUoQeZUXpFYLTTNtxCKZWLk1uaE8zL1qd6t+00T2O08nEYqgfil",
	"aWwXs7pz0DDEwh15cgYSvS2fdP58J1edvqociIW6HfiYFXgE4JQLBangmYo2llOlk23L1hRqmQlmBMFK",
	"ia1UbHjgHPiKKm19boxnaDJadYP92AOi6WKY4MEdxbT8d7+Z9NtOjZ7kqlL1zqKqshRSQxYbA4fVhr7e",
	"wKruS8yDtuvtSwtSKdjW8hCXgvYds+xILIOorg/QzindHxzG18w+sI6yskVEw4hNhBz5UgF3w3jQACHm",
	"fFHXRMFhqiM5dRBqPFJalKVZfzqpeF1viE1HtvSB/qUp2xcuqhu9ngkwvWtPk6P83HLWRgKX1Nh22DIp",
	"6KnZm9BSs87BPs1mMSaK8RSSTZJvluWRKRUugS2LdMBIdrkGQW+dxdGR36jQDQrBllkYGvCAxf6WSs1S",
	"VqIl8TdY3/hxv9tB9ORPMtCU5ZCR4AMqcNS9dX1ivb3dNq9maO1khPbJ71mhkeHkTOGG0Sb+FNbog3tr",
	"w4jHQfDxBizFSKtmdVNOkFAfnDAbclgEVjTV+dpsc3oJa3IOEoiqZgXT2saF24akFmUSNhA9uG7o0bkO",
	"bAjOz8AuvowjbCoYXn8qxiNrtmym77hjuLTY4QymUoh8Bx9njxlRCnbygZJSmFlnLg3Bx6q9JLWIdEYM",
	"+o1q5XlHtdiMIyD/R1QkpRwNsEpDvSMIiWoWt1/Tg9nA6j6ZtXQaDkEOBVi7Er/cv98d+P37bs6ZInM4",
	"97k7pmCXHffv4ynprVC6tbhu4MRrltthRLfjid5sFM6G6+qUydbTvWt5l5l822ncd4prSiknuGb411YA",
	"nZW52mXsoYwsqVpuHzu2u5NDI2g6Nm4771KI+Q2MlmWrWMA6g1VspE5w8Yxyxxj0awXRIAaqOzGP5KyA",
	"PM3RASLmnQVJCjArRS1ZaZps4utrDa3cvP979z/3fz1I/ocmv+8lT/9j+v7j44t793s/Prz4/vv/1/7p",
	"0cX39/7z32P2qtJsFneW/UTV0lDqFOeKH3Lr7p4LaU85a2c8ifnnprsjYmYyPeeDIe203GITghEWnGyU",
	"OWMb5+sb2GNtQ0RCKUGhRgzPlMp+FfMwNc9JnlorDUXfLWOrfhgwSt95k64npYLnjENSCA7raDY64/Aa",
	"P8ZqW608UBn3x6G6XZO3RX+HrHY/u0zmdfmLsx2oobd1ouANTH633Y5HLkxKRI8C5CWhJM0Z+hsEV1pW",
	"qT7hFE80gbhGvPn+nDZ8xn3ui8QP1ZEzr2vqhFNleFifc6Ke2jlEPBg/APijrqoWC1C6Y9vNAU64K8U4",
	"qTjT2Fdh5iuxE1aCRJf6xJYs6JrMaY5H8t9BCjKrdNvawdwppc2J2boHTTdEzE841SQHqjR5zfjxCpvz",
	"KUpeZjjocyFPay7Edf4COCimkrgi/dF+RX3qhr90uhUT2e1nr28+9wbgaY9l9jjKD1+4k8DhCzT3Gsdg",
	"j/bP5i0qGE+iQna8BFIwjgmiHdkid43R6gXoXuNidLN+wvWKG0E6oznLqL6aOHRVXG8t2tXRkZrWRHQO",
	"/36s72NR24VISpqeYtButGB6Wc0mqSim/gQ0XYj6NDTNKBSC47dsSks2VSWk07MHW8yxa+grElFXF+OR",
	"0zrqxv0FruHYgLp91m43/7cW5M6PL4/J1M2UumPT/GzTQX5W5NDqEjRacRUzeHtNxeY5nvAT/gLmjDPz",
	"ff+EZ1TT6YwqlqpppUA+oznlKUwWguz7nI8XVNMT3lPxgzfJMN3FUVNWs5yl5DTcipulaW8H9Fs4OfnV",
	"CMjJyfuek76/cbquomvUdpCcM70UlU5c+nMi4ZzKLEK6qtNfsWV7eWFTr2Pi2rYS6dKrXftxVU3LUnWz",
	"4frDL8vcDD8QQ0Wwks0hUlpIrwSNZrTU4Py+ES5MIem5z52vFCjyW0HLXxnX70lyUu3tPQJyUJZNgt1v",
	"TtcYmVyX0HJvXClbr+vawIFbgwpWWtKkpAtQ0eFroCXOPm7UBTrS8pxgtVZymw9xY1PNADw/hifA0nHp",
	"BCQc3JGt5e+xxYeAn3AKsYzRTo1/+qrzFeTRXXm6Orl4vVmq9DIxazs6KmVE3M9Mfb1lYXSyDxootuBm",
	"EbibQDMg6RLSU8jwUgIUpV6PW9V9XMrtcF51MGUv79g8I8wwR0/QDEhVZtTZAJSvu6m+CrT2+c3v4BTW",
	"x6JJUL9Mbm8741QNLVSU1GAzMsIaLlvXRnfyXYzTUErLkixyMXOruxaL/VoufJ3hhWx3yBtYxDGhaCVs",
	"DjGCyggjrPAPsOAKA22SQa+1AGKDNEbOzO5/Ee+J3wGIK9LYbi5aGY4Js1Ht9wLwPqA4V2RGFWREuKts",
	"vUTdStEFDLh0QpfcjvmdLTceNrJt94vud2Le3dZ6u06UZFs4MWOOyguYL0ZgzCLvxqh9T9briyOYELyh",
	"7hg2y9FYqsPjVvVQ2XKN2iu3Q6TFxRgkb8wOT0abI6F9s6TK37LDy4h+Re9kCXzCVOZNV0MOg/BqcOOw",
	"vvjhNW93tY7rS0D28r+/IOJvhfirIKPxpa51jEcu4yc2HYKjGZRBDgs7cFvYC4oj7Y4KJsjQ8fN8njMO",
	"JIlFaqlSImX2mmSz2bg+wFjJ9wmxHiiycwsxMQ7IxmgGNkzeiHBt8sVliOTAMPxBfdsYBwn+hnjams3F",
	"2Wp5YiKVVwLURfi9fgrMz7sty9FHxO4NmaUbXHhDO0qfEruT3A3tl6bjqHW1odvN+3qMDQoH7c6hdb9D",
	"G9suXV9p5NcgoOMWaMA43DFs63GpvUX2N5RGs46bq3M+m29ABDtyEJ2fAc71/bH1nYm33f0yelZuB7ra",
	"9zUCMyamC42I9z2UfT+oghzQME1aW3hyGvNbG/saUN8d+WrBAZrcZXNj7t4LoqcSFkxpaDxIZlvwLtHP",
	"68U7ExqSOZNKJ+i8ig7PFPpB4bHoB1M0vs+1o5sWL4Bl8TWF3Z7COslYXsVn2/X7txem2ze1J0FVs1NY",
	"ozUDNF2SGeJbRHMeNnRt02I2DviVHfAremPj3U2WTFHTsRRCd/r4RqSqo7E2LaaIAMaEoz9rgyzdoF5w",
	"13sBuY7degh2TFRxZme213IG/We9xZT5tjfZ+QEVw7rdthQdS3Dk2zgKhjFpc1phOoCH6KdoD6wBWpYs",
	"W3W8WbbVwdMOvdSR1d8O7AVlR3VjWzgQeK5iWYASvPfNTmlgnFmgDx6ObbITZ447dzoDhRB2xZSHqeoz",
	"yog2Yqls49Ux0PxvsP67KYvDGV2MR9dzfsV47Vrcwuu39fRG+YxRHesMafmyL8lyWpZSnNE8cS7CIdGU",
	"4syJJhb3HsXPrOrijqjjlwev3jryL8ajNAcqrd20cVRYrvxmRmWsOiEHFoiHwTHHIm/rWkMsmPz6KmLo",
	"VjxfgoMcCWw5o8WccNnl1biMg6Xo3IzzeHB5q9PQebftEDd4uaGsndyN68X6uNt+bXpGWe59Hp7agUAw",
	"Dm63e/ZRrRA2cG3/eGDpJzeqbnqrO746GunaopPCvjaAohQW90cRwbsZhsaERFcKimpB10aC7Hm4r5x4",
	"VSRm+SUqZ2ncP8ZnyggHt9EPU5hg4QFj1LRYsYFgGq9Y0JYppnY4IHaIDPqIMtPf5R/i3Uw4wMaKs39V",
	"QFgGXJtPEldlZ6HiJXnnKe1vp8Z26PflGrbe1ab569gYIfZAd8dDIjYbGGGspUfui/rA6QdauzHMD4E7",
	"+RIh27DH3pa4Idzq5MNJs817WbZjJiG+Yl//GcGwWDzbwR29f8zBRwz0EQVrHNwtDoZ3ClP7EntEsyUg",
	"ueFmMLZO+1yJSDMVP6fcYq+ZepaHrrYC6zMwtc6FxDtPKu6rYyqZS/E7xE+yczNRkSRox0o0F7H2JHKX",
	"pKtEa79Pg6rp+RvSMSjaQ5Zc6Klqh9QHVjhKeRBEQhAB70ml3Iq1xYlrJXLEF0eYfDW17TeLw9HcS1jL",
	"6fmMxhAWjEFlaDpowpUtn68WxFf2s+Dc043sBZHPuiyzF4VKkM1Nhf6l1CsaR9+WyGeQsoLmcSspQ+63",
	"r0VmbMEs2F6lIEBzcw1ZlFIrRQ4RzwaEG9YczsneOEBmcbORsTOm2CwHLPHAlphRhbtW7devq5jhAddL",
	"hcUf7lB8WfFMQqaXyjJWCVIbsHiUq4MsM9DnAJzsYbkHT8ldDC8pdgb3DBedLTLaf/AUHbP2j73YZudQ",
	"NTfplQwVy387xRKXY4yv2TbMJuVanUQvrVko5GEVtmE12aq7rCUs6bTe9rVUUE4XEM9rKLbQZOvibKLT",
	"sMMXnlkcT6WlWBOm4/2DpkY/DSRpGvVnySCpKAqmMXKsBVGiMPLUQLXZTn1zFhTUoa14uvxHjOWV9tgA",
	"3QPz53UQ2708NmqMuL6hBbTZOibU3u3MWRNldwpxQg79DXGEn6lRZyxvTF9m6GjSYdB9TkrJuMZDVKXn",
	"yV9JuqSSpkb9TYbITWbfPY5A7rRRNvjlCP/sfJegQJ7FWS8HxN5bE64uucsFTwqjUbJ7TVJ0sCoHg47x",
	"9C6v0bvZfZub3tUANa0kg+JWtcSNBpr6WoLHNzR4TVGsx3Mpebz0yD67ZFYyLh60MjP0y7tXzsoohIzh",
	"hTTL3VkcErRkcIaZZvFJMm1ecy5kvtMsXIf6LxtlaU4AtVnm13LsIPCsYnn29+aSRwe1TFKeLqMxjpmp",
	"+KHBTa2HbNdxFJ5iSTmHPNqc3TM/+L01svv/U+zaT8H4jmW7aGR2uJ3BNYS3yfRE+Q4Ne5nOTQchV9tZ",
	"73WaZL4QGcF+GiyERsr6AGsBMtO/KlA6huGOH2yKB/qyzLnAAgMR4Bla1RPyo333YAmkdVUbrVlWVLm9",
	"9gvZAqRzslZlLmg2Jqad45cHr4jt1dax+NQWmGiBxlx7FB0fRgCcslu6n0c7jCck797O5gxJM2qlETlB",
	"aVqUsbsmpsSxL4AXWkK/Lpp5IXcm5IW1sJW332wnRh7mTBbGMq1bszoeZcL8R2uaLtF0bWmTYZHfHVHL",
	"S6UKoKJrMMsa+wTXnaHbgWpZTK0xEeZ8cc6UhbuHM2hfb6nvermjk7/u0h6erDi3khLV0ZvuIl6F7Z44",
	"G7z3rt8oZR3GX9JwUaKSKVwWYOwIa0XBBLpoZT2MaHuvtoZ09M+YpJQLzlK8yh8A7NckO+j8XeIiO6Ae",
	"dN1Sfom7FRpZXFGMtDrlyHFxEDXNK0LHuL5jNvhqJtVKh/1TI0b7kmqyAK2cZoNs7HHwnL+EcQUOywZf",
	"UQj0pJCtWBNqyGj4Mqnd3JcUI0x2HzCAfzDf3rjjEeZ/njKOhpBjm0s1tR4NRPbWxnpimiwEKDee9uV0",
	"9aupM8EL2hms3k88Eji2YUM1Ztg2Ltlv6sBHKV1U0JR9bsoSm15Y/9xKrLedHpSl6zR6t7ye4RiS3yCD",
	"I9GmxLv7A+bW7YetbRC3jekFuJ8aQYMzDE5CiftwTzBqUMQOuukZzSsrUViC2LSe6IVIxiNkvGIcGpz6",
	"yAaRRrcEnBhcrwP1VCqptibgTjrtGGiOEcmYQlPauWiv21RngpElOEbfx/A0NniOA4qjLtAYbpSva3h8",
	"I92BMfEc3+VwjOyjM6JV5YyoDDOEO3iNMcVhFLdHOm1vAP1l0LeJbHUtqV05l9mJhq5+pSJmb75cQVrZ",
	"gLuwIDG0LEmKd6mD/SLq0WTKHJ6KWR7JfXtRfwxAUDGbe7bGf2PQPcMscRHxS+dk+fA3Vry0wdpuqWdu",
	"GmFKFFtccZqb+jc6z7lYtAn5vA6FjWs8FJnY6n5p1GZ4G7gHCmUVa31ZF9OQhEfIttDu/ppZe02iIo8e",
	"Shuw482H8mHY4jGq/oFkxHcNDgW1u4uNMQylJKaDGbRUu3sYmpIG9KG/MC3WcKwFm89gMY7tA2BR/8pQ",
	"DoNNYTCfe7V3s4t6Via2vZGhPjmmT9DffOYdKSlzAbRmxfY563J0+1nTu2TvNRPcHYTLfMVGYiPpgb9t",
	"lpBe5nOQ+24xuia7XwNvAvIYM0GE5QVwB7HczmncObNqPodUs7Mtmeb/bSzWJot57G1ai0sfJJ6zOlPH",
	"vxN3SVO7IWhTIvhGegKsiWuTM5RnegrrO4q0pCEKGjb2gnqV+4XIAcThSIyICBXz/ttDuHPIMlVLBnLB",
	"R9tsdWggkAbRWut0rxji1U59eZEk1NlZNZzUEECsiFnxO/Vlql7qZg6mZAwlo/fxEod3rxcIT6lqpO36",
	"IbggmcIc1rqwY+fufiPeC6j9Tv6mIyj/m79CY3uxDww2eLLo5TunMvMlomart4iTgfSubsK0zUtncaLn",
	"dc+syY3o5wxH0AEwFybNhWJ8kQylTLXTEWpf/h1lgy7oIEAgSqRrDtLhSGv/fmOihc+l2ETHJla410au",
	"wgQ1CB5niRu8IfuuuQKMkEjUvt7pAkrhAImEghrqZHBRd7jPTcx+br/7JFkPidMBoIq06+U12XrT1mfF",
	"MNVjYij1c+J2y+3Jt1c5LzDOLUy/it3a5YaVoSeplCKrUrtBhwsD/Llq5zvxG1RJ1MpP+6PsGWw54kS8",
	"Cq4ynMJ6ao2mdEl5A9jRXtYWrd+OIbh415ntGz1KxQ3WfGEHsLgROr/kSWg8KoXIkwHX0WH/8nF3DZyy",
	"9BQyYvYOH08eQGwld9FjUccGzpdrj09flsAhuzchxJylilKvfZigDb7V6Zzf0Zv6X2GvWWXxANwhbXLC",
	"46kQ9j3ca+o338xmrWYfiL9mV7aRLdeKV3xAtdHzCH7xrk8vRRz3XUzZRqgsFTEr5Yp35XZa3/2DWkT0",
	"w1sOW84/p61TnYWX6TjrhYQbPt0FXspLnu769zd2HR6OA7VapaA/zp0noMXbAd7vwvjGNdFn7rBHQc92",
	"8SjEQTBMdXRpWIYgggxBUslvD34jEubuce7797GD+/fHruhvD9ufzenr/v3oyvxszozWC0+u35jE/H0o",
	"uGsDmAN5BJ35qFiebROMVlZIg/GIeQ8fXP7MF0GZ/GCPyP2l6gD3LuNG7U4CMiYy1lbnQVdBvscOqR6u",
	"WiSxAzebtJJMr/EKkz9RsQ/Rq+E/1k4Y92xgnQju8pDtE9QuLalx2TSvBv8o7MNfhdnr0bGuEaz95YoW",
	"ZQ5uoXx/Z/YXePTXx9neowd/mf1178leCo+fPN3bo08f0wdPHz2Ah3998ngPHsy/ezp7mD18/HD2+OHj",
	"7548TR89fjB7/N3Tv9zxT/ZaQpvncP+BUKzJwdvD5NgQ2/CElqx+o8GIsYd1pCmuRHMmyUf7/qf/7VfY",
	"JBVF07z/deRy1EZLrUu1P52en59PwirTBZ7REi2qdDn1/fSx8d8e1vkz9t4DzqhNjTCigJPqROEAv717",
	"eXRMDt4eThqBGe2P9iZ7kweInlwCpyUb7Y8e4U+4epY471MnbKP9jxfj0XQJNNdL90cBWrLUf1LndLEA",
	"OXH4luans4dTH36ffnTn0wvT6iJ2uctmAkXeMm3wBZyvC4M6/iX6ALhHOTyfcQ2r5cxHnmGChj3yGdVW",
	"M+swaxA8DoO3Nt1NLHs1ff/XCNzwnC0q2XlVpvbmO+Q9psh/Hf38hghJXluf+1uanoZJELHnmZ0qi73O",
	"7FIlCrUo23HFxtMfe38ihp8ZeTy8cRUNvxve6FWjK/eSp+8/PvnrxWgHQvx1AC0IrOxL6nHoMhv8wMBk",
	"BIb0rrvc5pKKu5UbXKFx46SIdtNM8L2BiXBkWqgYI0GJC6L3XvduLkW97zyB/XBv7xO8tTtuteLF4Ys+",
	"2vv4Bgfajp5de7jd5nqDfk1zI2BGVJrwwOO9B9/sgA45Bg+Mzid2T7sYj558wzN0yI3WoTnBksE1pP4+",
	"8gs/5eKc+5LGnqmKgso1Wis6plQmWCy+X01D+M3px5ZrOfuUu9kdFVFsDjEkpsoUou/gq0WwYkrfq/3z",
	"FrS5/Yz70CYYnKJv98NPuh8etKekdcU8RkxL8DbS1IsIXXdT6icFdYD/rgTpHMCyXQGe56t4vH8HtXfL",
	"u6H39gZMj8jr/x04vb6xiKCVPVXbVZOHL/54lko3A9gCG9zaLn8a26W/y2+2ZhDucvrRozR8agumf1jD",
	"X3azWBzCx6Ctgkget1bKp7ZS+hA4MTIa2I8vZ5kgDcsGI+cybxe0AGEvheXzjZoif2JmDdoehtIhqwOX",
	"wVZ7w+msP6il4TXyrY3xZ7YxbMbXBiujBZrk0gOHDQ0Int4NXohopSfN1l4Ox0TV77OXkgnJ9HpMGCcZ",
	"GK2EcSUh8X5o84ivS0UB+yD964N/YILi64N/kO/J3rg2XvD6TKR7mwLSNkJ+BB15ZPrZ+qDejzcaI1/N",
	"Dn9cM2ngEWgtPO4RMq2gq++HWLay0aeYfVTQ1WijKTD+dsy161ott0+Vf7NPle+gyG9n9/Yh+m/2Ifpv",
	"22Rd1YB3lHDBE44v5pwBCfKobu3Wr9pufbL36JsdzRHIM5YCOYaiFJJKlq/JL7xGCLmeWV7rnIoHmC0b",
	"9U8vn7qxogPz/VrxzbbveUyYbizD1vWa4AxfP2zm0KHGDbS8OUIjsoO/aq3GHmId08NsENTOx7gHwD6J",
	"GelBPOHZGp2JW+3ybyQstzPCUGRfi8/Np94BenQ8oxnxEFKfWDfvpkwf7z3+fBSEs/BGaPID+qs+sUr/",
	"pL6DuFgFyubS4QfvcmqrFnddbaNSMSt07FAhEaZwTerrJEafWEVoMfD7WsP0sKu++Iod5Ds8XhqRyy57",
	"b/XCrV64ll7oClSjEfBStpp+RF99qA56S/KZKfkHivEFAQ8pCh/xEGQOOl3ay+rdyxMRteKByoZ1yiY4",
	"7xsOwCHREThTHIu7IIAw0zteG8OKP9l8/YvxKAUZEb6fPWqK+czmePmvBqHzqPUI3co8kGuN4eqQrpki",
	"RkC1IA4bhZhZvBSVz5vO+5c5kC03EbS7ZfDlGNxTai8dpK5dXm4Q37rjI9gtSULeoDmEC9xjsP0R3R6f",
	"ckf+1AN6IzjYnBdjsVpZvA1B1uYCPnyBTPF35W3g0b0bGjcd2kHHj3rFsotpDeYyZFS8xQJbjIpmp2bN",
	"04pt9wotS6BSXXmT3h4OO+70ePgiTJRoYc/UqDMRUgxfLhlJ/I9dwoh/3Ghd9/XNVRT1AFYevCWcJOeI",
	"Q0m9o0hJ14NgKQO4Q69BnuYOSKgTcSAFGO2ulqz8/Hj7SrNZ/O2Rn6jCp49rROBD/qxezGcg2Rwf0KmF",
	"9AvC05vJ9JwPhrSLIfE2NiF4LcrBTH3uI3OTsGNVlY8TyY7W+KLnaf1FztNvBE9wtwWuveXXYsuXO1sj",
	"4sU4cF/VoOVcaHRbCYlGQqgH1GSn7RUGQwktpWKz2QbF2G22KdXpsiqnH/E/ePv4ornnaxH6p9bNtmm/",
	"PbIlbjSBwrZJZAMCEV54d64/MSevWSrFASKjOL2s1kpD0X+/zVb9sAn7ParDBc8Zh6QQPHZX/mf8+ho/",
	"RrFXMCg7UBnD40N1u69utOjvkNXuZxdVd13+Tr4OF961zNHOaCWUdRIaRutR/pvV0gK/bJZJ6+fpx/Y7",
	"8dYb7kqqZaUzcR7UtXfbN64tW+JG19YbkYFttw0nEcsO5CIDdwW/v6RqrRHP/PX8bcpZpCemHDZWSqvF",
	"Utv3x6KPG9YVE5rapWDxI9U2wD1bygNLnQGhuQSarckMgBMxM4NuA5cSquoHJVE4rG6M48Y1dJVSpKAU",
	"ZEn48Mgm0mpgA/QQ6g18QsKR4LoXogSZU3lFYq2S2Exo98WtmtzaD+T0QJ/q3brfNIHdzsNppNKcPKwU",
	"4Juaoihz0DDEwh15gsYr+8Tz5zu56vRVJb5tEUE+tF+PWYH39znlQkEqeKaG8Um3LVtEJA3GosA+5+hX",
	"SvTJANPwwNb6iirtnlZpwbgFuLamiw2AqkOgRKblv9eQRL22U6MvuapU8+qMtb0giz7oB6sNfb2BVd2X",
	"mAdt18adfWx0W8tDXArar9+hCRBSdeCjMM1FBnfO8hyjtXFLpEVEw4hNhBz5UgF3Q0fAACFMNYyuYQ/b",
	"khM8BKq0KEuz/nRS8breEJuObOkD/UtTti9cLjUc9XomQIWGt6P83HLWPjG1pIo4OkhBT53NvnAZ2n2a",
	"zWJMFOOpg3Ueuv7CCjgypcIlsGWRds2+cPm31llncXTkNyp0g0KwZRaGBhwzNL8Ks/Cy576uR+ETOkLb",
	"hnZgXjWGpv17ek6ZTuZCOshsfMQ4ElPtIPJQpt3T2e5UrIVzZLpnkK1Cce0ED6ypML3VkuCvWJjZ72dU",
	"mK5+EHKnEG7jbdWCmIGRimvmb5ia9VbbmF9fPPTWer61nm+t51vr+dZ6vrWeb63nW+v5U1vPXyYnkySJ",
	"19P+wk3sug0ZfZMW/jd0o+VzXkFpjP7a5MdDgjHRzTremKuhgeZT96wpBtWjj/jZpO/widTUdMc4KXNq",
	"rCFYaX/1mMzaj6T7t/kshLfRNabAo4fk6KeDJw8efnj45DujfZb2nfaw7F3/upTS6xzuuZy2GmPXJ7cB",
	"p/gIIOa2UX/6SX3eg7Xm5ywHogyzXmLxF3AGuTHlbfSTmMNI/3h0DDR/7phjtRIo/Uxk647gmPFPkRVt",
	"kWlC6IxTGXmosy8oPSZrgY/1updneyeoixvNoohnDvQnbNtcxR9miD+ouUletmYKuDfWXdu7RM3MnHp2",
	"EvfI5xdV2QQpcmLWqKevJre++8iUWzhY1lgVbv19q3nwnvHRhYfLduwf4SFMK+IkbpWYQgvgiVMLyUxk",
	"a/cgs38zuKVl7WOuw0rWvpQK7ilqtwzuqntGzSJHV7rl6ok+pu/cFgiqUb8Q9GUUp31GdKPevLp02Mbr",
	"qyjXzaLsNtfXGkEaxl0hyUKKqrxnoYX4Go/ERUn52rvBjK1YVHkDhjgZ3aymrt/56enZ3V/5D88reI2/",
	"+7tlC74O5J74z+wb//FHOLov0W/nePPO8raHF/wTNJE34QdegO9Pop9ll/pYu/5K+yBX5GXmzjvMt9et",
	"/hRbwlspzpg5OEc1bD8vq1EIk607gwxUFm4NHfANvze09ek7en7cei17N526SpzheW2rdAlokNVWWgSp",
	"xOyXUtAspQpvlHDQ50KefmKLVa8OI34HJBMRp/q5v2YDn2w1LLHdnezJdu636xAhYZR9y+XLWpdN/umB",
	"u8DT4satK+CP4gp45hefIhSfhessTuv1wzW5g5qi53rFo1pqakFiBzPeggXhwCVvNHbXa74dwmtCmC4E",
	"AXlJKElzhgEKwZWWVapPOEUXaOfNvE54zzt2h02p575I3AsfcZK7pk64MarmpHaMRk2qOURCHj8AeItN",
	"VYsFKN3RxHOAE+5KMY6v1WJf+ARhYjNBzXZtNPrElizomsxpjj7830EKMjOniBDFBB2KSrM8d/FE0w0R",
	"8xNONcnBKP3XzBh0pjnvc6pj5Fbuai4MPK1qHzVK4l6IH+1XvMbghu/9Rujesp+b16S/yNNjSex1bkf5",
	"4QuHMHb4AkFjmkhij/bPFl4qGE+iQmZ2fBeR78oWuWtsPC9A95qYpJv1E26MaS0IKnqqryYO3TBAby3a",
	"1dGRmtZEdKIFfqzvY7dbFyIxR0a6ML8vmF5WM3z8y996nS5EfQN2mlEoBMdv2ZSWbKpKSKdnD7bYB9fQ",
	"VySirm537j+OEz+UA7Na6olHfPbu3A/syzcA6Pp1o7huTVG6xUy9xUy9RdW8xUy9nd1bzNRbRNFbRNE/",
	"K6LoZKOF6FA4tmL86Z5rkxIJqe25VuBhsRYaYD8syfSEkOOl0f/U7AFwBpLmJKXKGkbcZsoVbLHURFVp",
	"CpDtn/CkRUkqCtfx3ea/9ph7Uu3tPQKyd69bx/otAs3br4umKn7CUBP5npyMTka9liQU4gwcNhgWzyqM",
	"FdtaW5v9X3W7P8ve1BV0bZ0rS1qWYLY1Vc3nLGWW5bkwh4GF6OT3cYFfQBriLPQEYdrCsCI/MS/SZedQ",
	"d/88ZnT39/dLvOJ00MUzuIU5uREDe5Oe6k/YzenAjW33FOKtyvgcKuOLK40/ECLbLfjaVzagMJDaQle9",
	"hiVVvwUW8Tt5G8m6k41uxhYgrSTTa9zhaMk+nIL5/3ujxxXIM7/5VTIf7Y+WWpf70yniny+F0tOR2Zqa",
	"b6rz0ewPdGFbcJtLKdkZYie+v/j/AQAA///Mx4TzfwoBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
