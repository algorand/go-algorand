// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{addr}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, addr string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{account-id})
	PostV2RegisterParticipationKeysAccountId(ctx echo.Context, accountId string, params PostV2RegisterParticipationKeysAccountIdParams) error

	// (POST /v2/shutdown)
	PostV2Shutdown(ctx echo.Context, params PostV2ShutdownParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "addr" -------------
	var addr string

	err = runtime.BindStyledParameter("simple", false, "addr", ctx.Param("addr"), &addr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter addr: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, addr, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// PostV2RegisterParticipationKeysAccountId converts echo context to params.
func (w *ServerInterfaceWrapper) PostV2RegisterParticipationKeysAccountId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV2RegisterParticipationKeysAccountIdParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostV2RegisterParticipationKeysAccountId(ctx, accountId, params)
	return err
}

// PostV2Shutdown converts echo context to params.
func (w *ServerInterfaceWrapper) PostV2Shutdown(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV2ShutdownParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostV2Shutdown(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:addr/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:account-id", wrapper.PostV2RegisterParticipationKeysAccountId)
	router.POST("/v2/shutdown", wrapper.PostV2Shutdown)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"fFXf3Hod3Ldwg+v61fX/BQAA//+b8XxK0ZYAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
