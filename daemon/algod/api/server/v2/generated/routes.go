// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets a proof of a light block header for a given round
	// (GET /v2/lightblockheader/{round}/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// get a state proof for a given round
	// (GET /v2/stateproofs/{round})
	StateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/lightblockheader/:round/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/stateproofs/:round", wrapper.StateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
