// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9e3fbOJIo/lXw0+45eawoO8+d+Jw++3PidI93knRO7O6dnXZuByJLEsYUwAFAW+rc",
	"fPd7UABIkAQl+hHn0f4rsYhnoVCod30cpWJZCA5cq9Hex1FBJV2CBol/0TQVJdcJy8xfGahUskIzwUd7",
	"/htRWjI+H41HzPxaUL0YjUecLqFuY/qPRxL+VTIJ2WhPyxLGI5UuYEnNwHpdmNbVSKtkLhI3xL4d4vBg",
	"9GnDB5plEpTqrvJnnq8J42leZkC0pFzR1HxS5JzpBdELpojrTBgnggMRM6IXjcZkxiDP1MRv8l8lyHWw",
	"Szd5/5Y+1UtMpMihu84XYjllHPyqoFpUdSBEC5LBDBstqCZmBrNW31ALooDKdEFmQm5Zql1EuF7g5XK0",
	"99tIAc9A4mmlwM7wvzMJ8Ackmso56NH7cWxzMw0y0WwZ2dqhg74EVeZaEWyLe5yzM+DE9JqQ16XSZAqE",
	"cvLuxxfk0aNHz8xGllRryByS9e6qnj3ck+0+2htlVIP/3MU1ms+FpDxLqvbvfnyB8x+5DQ5tRZWC+GXZ",
	"N1/I4UHfBnzHCAoxrmGO59DAftMjcinqn6cwExIGnoltfK2HEs7/RU8lpTpdFIJxHTkXgl+J/RylYUH3",
	"TTSsWkCjfWEgJc2gv+0mz95/fDB+sPvp337bT/7h/nzy6NPA7b+oxt0CgWjDtJQSeLpO5hIo3pYF5V14",
	"vHP4oBaizDOyoGd4+HSJpN71JaavJZ1nNC8NnrBUiv18LhShDo0ymNEy18RPTEqeGzJlRnPYTpgihRRn",
	"LINsbKjv+YKlC5JSZYfAduSc5bnBwVJB1odr8d1tuEyfQpCYdV0KHrihrxcY9b62QAJWSA2SNBcKEi22",
	"PE/+xaE8I+GDUr9V6mKPFTleAMHJzQf72CLsuMHpPF8TjeeaEaoIJf5pGhM2I2tRknM8nJydYn+3GwO1",
	"JTFAw8NpvKPm8vaBrwOMCPCmQuRAOQLP37suyPiMzUsJipwvQC/cmydBFYIrIGL6T0i1Ofb/Pvr5DRGS",
	"vAal6Bze0vSUAE9F1n/GbtLYC/5PJcyBL9W8oOlp/LnO2ZJFlvyartiyXBJeLqcgzXn590ELIkGXkvct",
	"yI64Bc+WdNWd9FiWPMXDradtMGoGlZgqcrqekMMZWdLVD7tjtxxFaJ6TAnjG+JzoFe9l0szc25eXSFHy",
	"bAAPo82BBa+mKiBlMwYZqUbZsBI3zbb1MH6x9dScVbAcP0jvcqpZtiyHwyqCM+bqmi+koHMIUGZCfnGU",
	"C79qcQq8InBkusZPhYQzJkpVdepZI069mb3mQkNSSJixCI4dOXAY6mHbOPK6dAxOKrimjENmKC8uWmiw",
	"lKh3TcGEm4WZ7hM9pQqePu57wOuvA09/JtqnvvHEB502NkrslYy8i+aru7BxtqnRf4DwF86t2DyxP3cO",
	"ks2PzVMyYzk+M/805+fBUCokAg1A+IdHsTmnupSwd8Lvm79IQo405RmVmfllaX96XeaaHbG5+Sm3P70S",
	"c5YesXkPMKu1RqUp7La0/5jx4uRYr6JCwyshTssi3FDakEqna3J40HfIdsyLIuZ+JcqGUsXxyksaF+2h",
	"V9VB9iyyF3YFNQ1PYS3BrJamM/xnNUN8ojP5h/mnKHLTWxezGGgNHrv3FnUDTmewXxQ5S6kB4jv32Xw1",
	"RACslEDrFjv4oO59DJZYSFGA1MwOSosiyUVK80RpqnGkf5cwG+2N/m2nVq7s2O5qJ5j8lel1hJ0MP2p5",
	"nIQWxQXGeGv4GrWBWBgCjZ+QTFiyhxwR4/YQDSoxQ4JzOKNcT2p5pEEPqgv8m5uphrdlZSy8W/JVL8CJ",
	"bTgFZdlb2/COIgHoCYKVIFiR25znYlr9cHe/KGoI4vf9orDwQNYQGHJdsGJKq3u4fVrfpHCew4MJ+Skc",
	"G/lswfO1eRwsq2Hehpl7tdwrVimO3B7qEe8ogscp5MQcjQeD4eGvA+NQZliI3HA9W3HFNP6raxuimfl9",
	"UOdvA8VC2PYjF0pRDnJWgMFfAsnlbgtzuojjdDkTst/uezm0MaPEEeZSuLLxPO24G+BYgfBc0sIu0H2x",
	"bynjKIHZRnatV6SmAwlddM3BHQ5wDVd16bu29T5EV4Ko0FrD81ykp3+lanENd37qx+peP5yGLIBmIMmC",
	"qsVkFOMywutVjzbkipmGKL2TaTDVpNridW1vy9YyqmmwNbfeOFtiQY/9kOiBjMguP+N/aE7MZ3O3Dem3",
	"w07IMRIwZa+zsyBkRpS3AoKdyTRAFYMgSyu9EyN1X2iVL+rJ4+c06IxeWoWBOyG3CTwhsbr2a/BcrGJr",
	"eC5WnSsgVqCuAz/MOMhGaliqAes7cCsTeP4OfFRKuu4CGcceAmSzQcO6KrwNPHzxzSy15nV/KuTlqE+L",
	"rHBS65MJNaMGxHfcAhI2LYvEoWJEJ2UbtAaqTXibiUZ7+BjEGlA40vQzQEGZUa8DCs2BrhsKYlmwHK4B",
	"9RdRoj+lCh49JEd/3X/y4OHvD588NShZSDGXdEmmaw2K3HWyGVF6ncO97s5QOipzHR/96WOvhWyOGxtH",
	"iVKmsKRFdyir3bQskG1GTLsu1Jpgxl1XCxxyOY/BUHILdmIV92ZpB0wZDms5vZbD6ANYVs+SEbeSDLYi",
	"00W3V0+zDrco17K8DlEWpBQyol/DK6ZFKvLkDKRiImIqeetaENfCs7dF+3e7WnJOFTFzo+q35MhQRDBL",
	"r/hwum+HPl7xGjYbKb/db2R3bt4h59IEvtckKlKATPSKkwym5bwhCc2kWBJKMuyIb/QrNl/ogGV5K4WY",
	"XfurHZ0ltiX8YBm+3PTpsn1vRAZG7C7VNZD3erAaegZzQpjRqSg1oYSLDFBGL1Wc8PcYetHChIYxHb4l",
	"emF5uCkYeTClpdltWRA0+3Rwse6Y0NRiUYKgUT168cqgYVvZ6awRMZdAMyMnAidi6pTPTi2Om6Ros9Ke",
	"dLpnJyI5N9ZVSJGCUka+t1Lb1qX5dhYt9QY44cJxwdUsRAkyo/KSi9VC03zLQrFNbLkVS+409t1VD5t+",
	"0wG2Jw+PkUoj4lssMPy/uXA5aOgD4UCYnIFEzfVnPT8/yWWPryx6/Eoca3XMlqgp4JQLBangmYoOllOl",
	"k23X1jRq8H9mB8FNid1UHLhHW/WKKm3tF4xnKHZZcoPzWDWWmaJ/wb1PoBn5V//6dcdODZ3kqlTVU6jK",
	"ohBSQxbbA4fVhrnewKqaS8yCsav3VgtSKtg2ch+UgvEdsOxOLICortR8zsDX3Rwqw8w7sI6CsrGIGhCb",
	"FnLkWwXQDW3rPQsxMnrVExGHqRbmVAb98UhpURTm/umk5FW/PjAd2db7+pe6bRe5qK7peibAzK79mtzK",
	"zy1krVfFghqmHUcmS3pq3iZkwa2hpbtmcxkTxXgKySbMN9fyyLQKr8CWS9oj/Ti/rWC21uVo4W8U6XqR",
	"YMsp9G24RxR7S6VmKSuQk/gbrK+dsWpPEFUQkgw0ZUY8CD5YJqsI+xNrOWuPeTlGaxDX3F1+h22ObCdn",
	"Ch+M5uJPYY2WgrfWJeM4cOS4Bk4xMqq53ZQTXKg39JoHOWwCK5rqfG2eOb2ANTkHCUSV0yXT2vrYNBlJ",
	"LYokHCCqkdgwo1O/WXcGfwJD9IFHOFSwve5RjEeWbdm8vuMW49IAh2OYCiHyAZaYDjCiKxhkqSGFMKfO",
	"nEuX9/vxmNRYpGNiUPdaEc87qgFm3AH5X1GSlHJkwEoN1YsgJJJZfH7NDOYBq+Z0NpkaQpDDEixfiV/u",
	"329v/P59d+ZMkRmcez9I07ANjvv3UUp6K5RuXK5rENHNdTuM0HZU1ZiHwvFwbZqy3SbgRh5ykm9bg1f6",
	"HXOnlHKIa7Z/ZQLQupmrIXsPcWSYPQTHHaSFCYaO7RvPHQ3Sn0eGr4eOra47cWDGqz/2WfIMf5Wvr4FO",
	"24GIhEKCwlsVyiXKfhWz0FXWXTu1VhqWXdHedv29h7F559mCDpcpeM44JEvBYR2NDmEcXuPHWG97s3s6",
	"I43t69tmmxrrby2rOc8QLLwqfPG0A1R+W5mwr+Hw2+O2tDqhkzBKpZAXhJI0ZyizCq60LFN9wilyxcFd",
	"jqj6Pa/fLye98E3igllEbnJDnXCKZp6KV46qJ2cQkYJ/BPDikirnc1C6xR/MAE64a8U4KTnTONfSnFdi",
	"D6wAifr2iW25pGsyozmKdX+AFGRa6uaLib6MShupy6qYzDREzE441SQHI4G+Zvx4hcN5l0GPMxz0uZCn",
	"FRQm0fswBw6KqSRukvjJfkVrsdv+wlmOMbDEfrZKFDN+7fC41tAIlvg/d/9r77f95B80+WM3efYfO+8/",
	"Pv50737nx4effvjh/zZ/evTph3v/9e+xk/Jrj3nauZUfHjhu8vAAWYZaudRZ+41pHJaMJ1EkO14AWTKO",
	"Dtst3CJ3DePjEeheraZyp37C9YobRDqjOcuovhw6tElc5y7a29HCmsZBtARIv9f3Mev5XCQFTU/Rojea",
	"M70op5NULHc8F70zFxVHvZNRWAqO37IdWrAdVUC6c/Zgy5N+BXpFIuSqRWQvzRB07YFx71hUWTqHV7x5",
	"s5JbpCiVU1Ki85e3y4jZuPKAtpGPewTdYxfUGxXdnw+fPB2Na7fW6ruR1O3X95E7wbJVzHk5g1WMU3NX",
	"Da/YHUUKulag43QI1x41QVm7RTjsEgyLrxasuHmaozSbxmmld6lxEt+KH3Lr62JuIqpn107rI2Y3v24t",
	"ATIo9CIWEdXgObBVfZoALZNKIcUZ8DFhE5i0Ja5sDsobw3KgM4zMQRWjGOIiWN0Di2geKwKohxsZJNbE",
	"8AfZZEf3P41Hjo1Q187Zu4Fj62rPWeli/d9akDs/vTwmO470qjvWj94OHXg+RzQZzrmvYWwz1MzGgdpA",
	"ghN+wg9gxjgz3/dOeEY13ZlSxVK1UyqQz2lOeQqTuSB73l/wgGp6wjs8W2+oduCpSYpymrOUnIa8dY2e",
	"NvyuO8LJyW+G4p+cvO9YbrqcsJsqSl/sBMk50wtR6sTFFyUSzqnMIktXVXwJjmyjAzfNOiZubEuKXfyS",
	"Gz9O82hRqLafeXf7RZGb7QdoqJwXtTkyorSQnqsxrI5dDZ7vG+EeBknPfXBaqUCRD0ta/Ma4fk+Sk3J3",
	"9xGQhuP1B8c8GJxcF9DQeV3KD76t78KNWwkJVlrSpKBzUNHta6AFnj5y3kvUruY5wW4Nh2/v0IJD1Rvw",
	"8Og/ALuOCzuv4uaObC8fKB7fAn7CI8Q2ht2ojRaXPa/ABfzSx9VyI++cUqkXibnb0V0pg+L+ZKr40blh",
	"srwlSbE5N5fAhdpOgaQLSE8hw6g/WBZ6PW5098ZKx7J60sGUjY61DpwYwoXqwSmQssioY+opX7djaRRo",
	"7QOI3sEprI9FHQF2keCZZiyH6ruoiKkBd2mQNby2boz24TvDN/qvF4UPiUDfWI8WexVe+D79F9myvNdw",
	"iWNI0Yg16AMElRFAWOTvAcElNmrGuxLqx7Zn5JWpffkiwbSe9hPXpBbDnPE63A2GUNjvS8BQe3GuyJQa",
	"vl24KHEbrxBQsVLROfRwyKGGdmBUQEOri4Nse/eiL52YtR+0znsTXbJtnJg9RzEFzBeDKijMtFwW/EzW",
	"CIA7mBBM/uIANs2RTaq8JSzRobKhKbfZLPqWFkdgkLxmOPwymhAJOZsFVT6AHeP8/V0exAN8xvibTVGX",
	"h4G1PQjmr2IqPc1t39OOdOliL33ApY+yDEXLARGThsNHB7DYcQiODFAGOcztxm1jjyh1LFB9QGYdP89m",
	"OeNAkpjhniolUmYzENTPjJsDDH98nxCrTCaDR4ihcbBsNG7hwOSNCO8mn19kkdzFMlE/NprFgr8h7nZp",
	"XbMMyyMKQ8IZ73Gq8xSAOm+P6v1q+RzhMITxMTFk7ozmhsw5ia8epBP8h2xrK9TPmVfv9bGzG3T59mG5",
	"0J7sU3SZ3YQ8k190nKHbsOKpWCXW7zrK8U5XU4PvUW819AKPXUwbZnlHkalYockenxbMX6K2rKV/HX4Z",
	"gYS/YgrxFfv1veZ2MZum3cxNxbBQIco4dV6FLn3sxJCpeziYPnS5G0ROXmoBLWVHnWPMCb9bhdQme9J9",
	"zOtXbVxnBPCOtbHr33eFoqfUA7+uFqaKdXzb5liieoqm5bkZ5hmwkDGkN2Sia+7pGpUU5IBCQdJgopLT",
	"mBHQyDaAL86R7xYoLzCYlPL1vcCdQcKcKQ21Ot48zN6+dNPqSYo5LISY9e9OF3Jm9vdOiOqZskHS2LGx",
	"zRvfwZnQkMyYVDpBW0Z0C6bRjwqF6h9N0ziv1HSYsOmcWBanDTjtKayTjOVlHF/dvH87MNO+qUiiKqdI",
	"bxknQNMFmWL6sagb1Yaprafdxg2/sht+Ra9tv8Nug2lqJpYGXZpzfCP3okV5N5GDCALGkKN7ar0g3UAg",
	"kfc5gFzHIuQCvslezsw0nGzSvnYuU+bH3uqAYlfR/0bZkaJ7CRQGG3fB0Exk2BKmg+xd3aiPnjtAi4Jl",
	"q5Yu1I7aKzHTCyk8fFqEFhTwdN1gWyAQ6D1jjsUSVDMDRs3g2zxsjQDUySDIHDfzVIQEIZyKKZ9FtAso",
	"g9rIKm6D1THQ/G+w/tW0xe2MPo1HV1OdxmDtRtwC67fV8UbhjEZ+q0prWEIuCHJaFFKc0TxxCuY+1JTi",
	"zKEmNvf66BsmdXE15vHL/Vdv3fI/jUdpDlQmFavQuytsV3wzu7LJNnouiM9SaGQ+z7NbVjI4/CpDQKiU",
	"Pl+AywgXcKOd1DW1wSG4ik5JPYv7Gm1VOTvbiN3iBhsJFJWJpFbfWQtJ0ypCzyjLvd7Mr7bHLwg3Nyz/",
	"UZQqhANc2boSGMmSayU3ndsdvx01dm2hSeFcG3LWLW1aRkUEb5vQDQuJ6jhE1SXFxDNWK9IlTrxcoiYh",
	"UTlL4zpWPlUGObi1nZnGBBv3MKNmxJL1mGJ5yYKxTDM1QNBtLTKYIwpMn8SoD3ZT4fJpl5z9qwTCMuDa",
	"fJJ4K1sXFTP9OG179zk1vEN3Ljew1dDXw1+FxwiTLrVfPFzEZgYjtNR1lntQicx+o5VGyvwQmCQuYPAP",
	"Z+w8iRuM9Q4/HDZbN8hF0+IWpr/u0j+DGDZV4vbc2154ddmfeuaI5tJmKplJ8QfE5TwUjyNRBz7NFEMv",
	"lz+ATyLBW20SU2l36pTg9ey9x93H3YRaqKaTQg/W48kHZjnMd+M11JTbo7apbRu+bnGECf1Td+z4NcK4",
	"NXd8enN6PqWxZECGyTBr2q8NwA1duhbEd/awd2p/5jJ/TUhgS67aMhuPV4CsA4K6sd+XZBjstINZhZoz",
	"QKwNeYKxtf/lSkSGKfk55TZDsulnr5LrrcAqv0yvcyExmlbF1f4ZpGxJ8zjnkKVdFW/G5szmBy4VBAlo",
	"3UA2sbrFIpfE15rYa9AczsjuOEhx7U4jY2dMsWkO2OKBbTGlCil5pYiqupjtAdcLhc0fDmi+KHkmIdML",
	"ZQGrBKmYOhRvKuPVFPQ5ACe72O7BM3IXzXaKncE9A0X3Po/2HjxDpav9Yzf2ALhE4JuoSYbk5H8cOYnj",
	"Mdot7RiGcLtRJ9HYUFu9oZ9wbbhNtuuQu4QtHa3bfpeWlNM5xD1FllvWZPviaaIirQUXntnU40pLsSZM",
	"x+cHTQ196vFjN+TPLoOkYrlkeumMO0osDT7V2WXtpH44m8fcJQbz6/If0UZaeBNRS4i8WaWpfd9iu0ZL",
	"9hu6hCZYx4TaEOqc1d4LPl0hOfSJGDBTWpUgzcLGzGW2jmwOOjPMSCEZ1yhYlHqW/IWkCyppasjfpG+5",
	"yfTp40h2uGaWIn6xhd843CUokGdx0MsetPc8hOtL7nLBk6WhKNm9Om4kuJW9xty42a7Pdrh56KFMmRkl",
	"6UW3soFuNKDUV0I8vmHAK6JitZ8L4eOFd3bjmFnKOHrQ0pzQL+9eOS5jKWQsLU993R3HIUFLBmfouxc/",
	"JDPmFc9C5oNO4Sqr/7KWB89yBmyZv8sxQeC5iEinPmNhpUl3vuoR7UDfNTUfDBpM3VBj0swOd/NGP698",
	"7hqfzBe/VvyjvdgvfKQIZL+DnkMMMldGjzOrvgf2b0qei9XQQ23dEH+wXwFooiApWZ79Wsd3thKDSsrT",
	"RdSeNTUdf69LGFSbs+9TNLvRgnIOeXQ4ywv+7nnGCFf7TzF0niXjA9u2c5Xa7bY2Vy+8uUy/KD+hAS/T",
	"uZkghGoz4K1yqM7nIiM4T51Kp6ae3Ry3QSbCf5WgdCx4CD9Ypy7UWxp51ybCI8AzlBYn5CdbgmwBpJHp",
	"A6U0tixzmzUCsjlIp1Avi1zQbEzMOMcv918RO6vtYxNx20R8cxRSmrto6auCvFvD3IN9Tu146MLwcTb7",
	"UptdK42Jd5SmyyIWZmpaHPsGGMsa6vBRfAmhMyEHVnJUXi6xkxh8mDG5NBJXNZrlXRAnzH+0pukCRbIG",
	"Se1H+eEZJD1WqqBqS5V9vUqdhffOrNslkbQ5JMdEGLn5nClbeQrOoBnZWoV5O5WAj3Rtbk+WnFtMifIe",
	"m9IQXAbsfnHWUcOr+aMrawH+ggy5TcB60YSaR9grmoumnZ2zU67FRjdWWbV9RcGUcsFZiplgYk+zq2I1",
	"xAY2IGlOW8nqr7i7oZHLFc0JWrnJOSj2Zgn1hNABrquED76aQ7XYYf/UWC5pQTWZg1aOskE29qltnR6Q",
	"cQUuFRoWNAvopJANuyJSyKipOqlMGhdEIwyL6RHsfjTf3jixH/3FTxlHBt+BzbmmW00dFtnRRipgmswF",
	"KLefZmyw+s30mWCYbAar9xNflAfHsGY5s21rg+4Ote8t0s4CbNq+MG1tUpT654YHsp10vyjcpP2Jj6P8",
	"gF7xXgBHLIuJN+0EwK3GD0fbgG4bXUnwPTWIBmdoiIYC3+EOYlRJgFsJ5g3TajEKWxDrwhXNhcB4ZBmv",
	"GIe6ZFTkgUijTwIeDN7Xnn4qlVRbFnAQTTsGmqP1OUbQlHamh6sO1TpgBAnu0c/Rf4x1/uIewlE1qBk3",
	"ytdVpSqD3QEz8QJL5DlAdrMRI1flmKgMIwpa+YljhMMQbp8BvfkAdK9Blyey3bWk9uZc5CXqCxKdltkc",
	"dEKzLJZD8jl+JfiVZCVyDrCCtKxy8BUFSTG7SjPdTBfb3ESp4KpcbpjLN7jidKmI8dFvcALlQybqwScE",
	"ya8hvQcv3757+WL/+OWBfS8UUaWNEjU8t4SlIYgTcsiVBsM6lwrIhxCMH7Dfh9aG48sM8pJHkDbMje4R",
	"EWNlpmv8N5Ynrx+BnK/Ihb0VvWMIdrwwe98cqcOcm6uXKDZPhkMCn76rg6Oe+nL3se5/rRcyF/PmQm44",
	"g8UmYhyeUYwMvzTvW5jgoZP80b6AVf4F9A0UvpoMSrdV5HCTeOKL28kGiTapqlrFZj1Jf92JMb7RPR7C",
	"Qd4OatkAa+Ts8xNOe93aqXYBdpqSjZSyN2jJOhnZ8CRbNDmq4O1zLLJ+ReZzp/cwBrYjDuDYGwHqPda6",
	"C/qbd4clBWXOgl8Tiy5kneN8v1Zz06WrD7i9CeeO3qtYjCf/70+hU6fNwWegEIrVCWtjVQEGuksdY2L/",
	"IAVQdyzvq3AGqTZMfWCDlQAXSQhkJgtqmNym0ukRPyqvMpdBZ1PanG5q4i3EphPZEkRn2bSuk+FJYvYr",
	"Txu0/2MVkTlwV0ak6bM+2HN2NoNUs7MtkUT/Y6TUOkpl7OVYWw4sCCxilSemL9N+QfG6XtCmQJ+N6wlS",
	"y115OX1xBKewvqNIAxuieWbHnuZdJgcBQgCpQ2JQRKiYJdsq3pxxkakKMxAK3nPEdoc6m1Nvgv8gLu6S",
	"c3mUJDSMldsw5ZmISe6D5jJdLxRBik6FfcFG3RTb/YzQAWY0V1VxlqoOeyDVkMNuprdzlwMB474qXbPP",
	"hgDK/+aDPO0str5/XYIANfvnVGa+RVRU9VJwsuE96kQI+fTQ7UXPqplZ7efXjQmJ5A5Cb840F4rxedLn",
	"Ett0rQtrg6IDAT4HmLsc1zUD6UqPoAo5FwoSLbxf4KZ1bAKFq2N5GSCo3nx9dnG9WTTe1WlCMAMqxawZ",
	"1DlHhBs0cis1q5NBMo/+OTcB+4X97oMgfAbMARK5w9dkazYO7+HJVAeIIdbPiHsttwdXXEbqZZzbUlQq",
	"ltmDG1CG2uNCiqxM7QMdXoxaxzA0b84GUhIVGNPuLju8f45ZpF4FoWqnsN6x/He6oLxO59W81paFsnsI",
	"QsNbp32tCoG47JPP7Qbm17LOLylUj0eFEHnSoy4+7CYoad+BU5aeQkbM2+F9o3qS/JO7qKWs7IHni7VP",
	"yFEUwCG7NyHEiOXLQq+9abCZa7c1Ob+jN82/wlmz0uYMcvL+5ITH3fowm4+8In3zw2ymagoM8bviVHaQ",
	"LekvVj3JUSQ9j5S8GFrxNmKsa5chqJHKriLGpVwyFnrQ/e7K/BHUD/Lwb5Z+wlQJtQ+WtKoj5Ja8QqfN",
	"vLyuNULDKgL4DluWFwrFQU0AT43ccr6wo9TrCijBVnoxobH9bXK2L9Rc0aXgiBR61ptt2sQ11sjePJdA",
	"iaJeVLqJOJy7KgzMiyA45orpqj4UqhIx5WyIOOZeyjOa37z6AhNm7CM8XGGr+EZD+TcEsgWlupy3wis6",
	"aO5A1r2+qflbVLf8D5gziuqA3VBOj1rVYvApJDE1Gs1JLuqaLDgkOccxrdL4wVMydZ7WhYSUKdYKQjn3",
	"2TArcQ+TQ9f1zjbLl9v2+avQV0BjJyCIgrypM+tpge9DvcL6in5hotJzc6NYHsO+DlpE4BejUWHI85bn",
	"4rShTbaZSlveHELCNWuVAzP2BbXK3WDuodvDfeCjUyro7nPwa92AbeShrvc21CTSBe6m9GtDLBnxrIqm",
	"O5pSLEAwJSnBpZIPDz4QCTOsOSDI/fs4wf37Y9f0w8PmZ3Od79+PsnE3ZkRplAZ388Yw5tc+7z/r4dbj",
	"aNo6j5Ll2TbEaLgN1/U/0DH2dxc48EUqkPxu9andq+pyt1/EfNs+BARMZK+NyYOpAofgAb7ArtskWrxd",
	"QVpKpteYz8Cr39jv0TxRP1Uae2fxqSJg3dunxSlUGTFq/X6p/Ov6k7DF3peGp0bjucZicC9XdFnk4C7K",
	"D3em/wmP/vI423304D+nf9l9spvC4yfPdnfps8f0wbNHD+DhX5483oUHs6fPpg+zh48fTh8/fPz0ybP0",
	"0eMH08dPn/3nHUOHzJLtQkc+em70dyzTk+y/PUyOzWJrmNCCVTUgDRr7CgE0xZsIS8ry0Z7/6f/3N2yS",
	"imU9vP915IJzRgutC7W3s3N+fj4Ju+zMUaGXaFGmix0/T7f23tvDysHaBnzjiVrfWYMKeKgOFfbx27uX",
	"R8dk/+3hpEaY0d5od7I7eYCVtQrgtGCjvdEj/AlvzwLPfcch22jv46fxaGcBNEf7l/ljCVqy1H9S53Q+",
	"BzlxpRLMT2cPdzwrsfPRKTM/mVHnsUwP1lU88A/uVhBwhhH0t7Gu4I2MvMoliB1XeZqdroFn6MFr9YOG",
	"tFXAOszqhISHNaHyaRlsnqq93yKlqGZsXspW1drKi8AlcWeK/PfRz2+IkMSJNG9pehp6ySJC/qsEua4R",
	"xpGyMMGSz6nrfGmXal40Hc9qNilW3zJWigFnNuccYGplV6gpkZYlhCup6aqhlbvJs/cfn/zl02jAQtDI",
	"pQDDbz/QPP9gywrDCi0FPoGFC1AeR/LHIns8rvXU2KE+pjF6zlVfwxIBVZumv/YHLjh86DsGt7DoOdA8",
	"Nw0Fh9gZvMcAUcQEvEQPd3evrbZIFaJg/e+qUTxKXGKgLoWxnyKFB32JkZ6qg4+vcaNNz50rb7c9XGfT",
	"z2mGadtBabuVB9/sVg452pkNxSf2Rfs0Hj35hs/mkBuaQ3OCLYPsC91X5Bd+ysU59y0NN1Mul1SukVcJ",
	"akuEXOmn3tdqJ8yDvfOxYYXMrvSWdUoAHB5sed7uqD6i2E1L1kqzbb5XWZTRTuVyiWNeZ3VvQn4KeyNh",
	"xihfG0NbSl4X2i2kOGOZIbHOgcMnQ6nXdkeFAdDRxzZQ7d6+u5/13d1vah0aea1ii2mg+MY1ddwUrvrw",
	"db3TW1WSLlWFKMhmfYmcoJ+1VENL6OutfT+AwN7Crgd2fexNsN6K02lmIf/8dNfKb8Ez0XgPPiNV/saZ",
	"tdc0N3gSbLcVKWeTvd0ycX8aJq7yXLPFDjG/6Sa2DosY7Hz0ufmugZVzuQkHMHGhpBv0DXLH3W1RinsT",
	"m2gvbHM5cuC80LayZ5gx8ZYx+9yMWTfVaGwZdQLJL8eM4RoWdS7Si1QYbJQOuVDO1G+U+/oTA6uX3TIr",
	"3c5oXYI2dpgoR4k/G838LpknB7RbtulPzTZZx+8NjFMjD7CLEujnnUC7wDAb4ByJKlDonGxHHxMlpPOV",
	"LSQTkun1mDBOMjB3Dy2GQmJqGC1LnlpFv50COP739f7fMU7h9f7fyQ9kd1yxYBg5H5neeoI2eaCfQHcd",
	"ntXz9X7FDmzkhb4aBuO4AlIQihCCXgufyheBtqSrH/pAtrJ2xRh7tqSr0UZOZPztcItXZZpaIZhdLMLE",
	"P5yg0d9X3mz63yoCK5rqfE0ovj9rGyiiymmdh7fJbmhRJOEAUR+3DTP6qnaxaPWLugBHEgth9bjN6ztu",
	"5SxtgMPFkGIVze2MSQcY0RVcjsu7Pd1v9nS7bCkphLnTDBNX1e+Jf6sai6xrm7nl9kQ3TMj/ihKdXWz1",
	"YogVE8AZMBLEz+kY0CAKOMfa0RV07t9vb/z+fXfmTJEZnCMFpRwbtsFx//53wLKuqhzulHDBE47Fdc+A",
	"BB5yt3zrV823Ptl99M3u5gjkGUuBHMOyEJJKlq/JL7xKDng1tryiOSUP0jVupD+dsKqaiw7Y9yvZrtu2",
	"aaZrzrARZRuoEKoa6E5WHtcVxIwsj0ndfKIcNfamE3T8s1YVex7jjmFlEmPSAwvO8/XhwRC+/BsxhA5O",
	"Lhp51+Jn87lfgKg/zbub8acZRkwf7z6+uRWEp/BGaPIjqss+M0n/rLqDOFoNJDY7U5vRfBPB4S2KgzSg",
	"zlQekB8sCBNmQ7cuwnddGd4wI/a9CfF501XFQTgaOhc0r/O3UTm3nQz5Mvsjd/yfezj+nQn5UUjDbyib",
	"Yk27EiHkDuN678HDR49dE0nPbSBBu9306eO9/R9+cM3qLPlW/Ow0V1ruLSDPhevgCHx3XPNh7+//+4/J",
	"ZHJnK6UUq+frNzYl5ddCLrumkfDg+07rGz+kmO7CpQrdCrobcTV9LlZRwi5Wtw/LF3tYDPS/iwdl2kQj",
	"Z8SprPd19NjgB8begIs8MV7XiarO6p2YkDfCpboqcyqtytlVxJqXVFKuAbKJR0Iyw5w2mNonzRlwbYR9",
	"rPEjE8UysBlC5qVE7cISi2BLOMPYS5weTV2NFWyn4aC+Zvpt5PVamzGtXmAt3Ja9vtlXGcM6OkLiTz90",
	"FPdTsUoqwFxKBX29xvAK2QbFNTYLgWwN/MKxh2iwasbGFnSkzaoDf26i/M3y2Rbd3cFuJ4oX9mOq/ZRC",
	"gd7litooylt2zJYXw3pXa1LlcjG8mWd84tTLzDBUSv+KvWK2OmNEpcE2eG/v5600fiUq0UaomiJgDhK1",
	"8xEddEJy0LmSmEPhO3LsC7ycpFh6NydBZqDThcvN0gpGj5AVXxmkn6Zsqgt73YwGHlE3MX2YYhfrlQ7M",
	"2RSkzUBXM5AR5PvZZ782n9kMM29VVV98+WN0omK+ImBVDNCVTGXKR3r6FC7mFC+0yhf15F0eCcFyHZ56",
	"twC+GIA7RO2lrzyHEHOb+B5iQb10l5A3os4Q5IqefI/Gxs/5In/uDb0RHKw3qOFYLS7eOv5V7AIqzBEo",
	"PjWcFSnwretjHXZ8ecSN/MNfbXHCjTzEkIfZTPZNvs5/jRYebzwgZm+TrSmt6tGG0F3T0Gbwb+bu/4KC",
	"xRchlV+htPEliNHNUA+8pJ6EuBefD6YnmCPR4ulOlZG9j7jEi1wMJjRaVGEO0boUU8gFn6uvk8psOvg4",
	"XCIIUJX/iNf4+PNdyxeYfpELn+ncJeRUjKdgK3titR+myJIp5YJxHu/+5eZWqNnSJzHmYS6SL0w4Pqff",
	"1k06WmEFkypBrlerRovWoNmmmbi1zpjZR98aoREf9Ypln7bTucC99oIkjvGAxIX+YLQogMrL07bt5p3j",
	"1oyHB2FgWaNmRpXNNLIUA6ILhj78x2igIggzFImZe7JKbhfqM686CuCivsRsXPmGmLdbzPbICb9P1II+",
	"efDw94dPnvo/Hz552qPKMvO4hIldZVY9kPlshxmi0fp+4ySajHQFvL2bPsqLndB4xLJVNEF+XQQrvBfO",
	"dQXpxB1FCrruratRbCniFQ5bF/S6+SzSSrPpIiryeImkqhR9yJ9XMqdNdexqX90W7+qJbgiIiEG0uopX",
	"BfXNBb02cIEttKwqJ920vFgHn9pXzANPth6UL8qg6i8lNyYoNgL3DEkTLF+OF8QiDuPAKFzV3kfnjbIo",
	"hNTV7VaTQWwa9PrDh1xaL+I6JiylOl2Uxc5H/A9mRf1U5x/NzZWUO9ZcvYkPO7ItrjX8z45Z55NvJuJ1",
	"JnQxI69ZKsU+lvdwL4ZaKw3LTiiY6/p7T5i/T23efV0EzxmHZCl4LIfvz/j1NX6MFhDBkKKezhjc1de3",
	"Rd+a628tqznPEOJ2Vfh+JVLwlRQzrd1KKKoQalR9IP7Xt6VRwbG+Jo2fdz42/nReJa6lWpQ6E+dBXxSS",
	"7L0fYnUOioAMVxtXwkWrmIYiGSiDXd+eIieAQwy1q6+RLKxBqZfeRKx/UtXOjPGshSTIvaXiDKSqhH7p",
	"HUBu9Tvfj35n+LkHlKtU24hVqa6XK3gjMrDjNhP0x7JycJGBS2reZQYqficuNvuXoW7XEmRSWs4XmpQF",
	"0SImMtUdE5pa+mnLt6pt9S5tK1/X7QwIzSXQbE2mAJyIqdl0s24woQpdrr3c5bi6eNnGel2FFCkoBVni",
	"U5VsW1qVKh6lNL0BTrhwXHA1C1GCzKi85GIte7N5oboVKl8tt/IEcRxMd9XDpt90gO3Jw2OkEoh/RVHt",
	"IpZFDk7xEgHhQJigXoB95vPzk1z2+MoiMaQ7UnjUfj1mS3yEOeVCQSp4pvrLA2+7tlgCK9iLMjsIbkrs",
	"puLAPULBK6r0O6cwDqsoBqW2zBQb6hn3lXkxI/9aFXnpjJ0aeslVqapKME5OhCy2Bw6rDXO9gVU1Fyrj",
	"/diVIKoFKRVsG7kPSsH4DlgqLFCsA1U7FsLqbg5Ti1EnRHZB2VhEDYhNCznyrQLohmrgnoUwVQO6qjra",
	"xJypEDlQbvV5oijM/dNJyat+fWA6sq339S912y5yuZRMSNczASpUEriVn1vIKvQgX1BF3DrIkp46PcLc",
	"ZUbqrtlcxgTtdskmzDfX8si0Cq/AlkvaFljD69+4Z63L0cLfKNL1IsGWU+jbcExE/iZjL9rGhc/ozNBU",
	"EQTs1aTFFe6cU6aTmZCuYj2daZAR+bZV44Qy7aM2rAZPC2ePIziCIyhuHFf5vI5qdmll7BJ8ajNz+t2Y",
	"CjPVj0IOcuJu+kVQpknJNcuD8LOKx/z6hOhb7vmWe77lnm+551vu+ZZ7vuWeb7nnz809fynn6cTTae+/",
	"EktzR26jq78rj8TqpnuWH4UEw6K7NET93tUaaI4bYjk+roVQvWHfWBJZiVKmQFIzHeOkyKnhhmClqzQY",
	"zdxJPlGbK4qM6ZiogkcPydFf97031cJ5/TTb3nWpkonS6xzuuai2qmqpD28DbiDootuol358ugyXF4Tl",
	"QJSB1UtsfQBnkBtO3jpqECOLdKWjY6D5CwebLcJRoy6lGe3DuCGTObAtaREUf8e9UkUoet61ykrOaK76",
	"60ra8Za0iGWsqOi0FZuQNDwX2bqF7ubUdvAAm4he+1QxTuU64izZQe8OamhhiI9DrK7c9+naPf+6SNtF",
	"s20YFuNcJKjopdyE5VGXt+rAOkNZt8tZC0+iRZXbfl6jaoFDXB0MPvszIe9svy8b6oMrclespsxfjeG5",
	"2bIiGtjWMFSO9HyrcTke8NHbi3d/bBA7K1MgTCviMG6VmEZz4ImjLclUZOukQZmaD0zGFFUKltPtj0xI",
	"Gl1mNfeumC+bn6Av80IcBJvbRG5DfFgljrb2EF7rzDqM7FbQwhEd5Q0g/rmpbx+FDJdAHOmJyc7tmjAX",
	"pGf1NOtbmnZL04Lb2HrsGXd+1G0iMrkcTZNrWfJ+cvZyBWlp5g0v6V11z5AshOhKNzT3GUzL+RwzxHW0",
	"0FibBMdjgn8hKme3O5TAXQw57OBVaqGrRsW3h+sSjsAd+K6QZC5FWdyzlaL4GhWcy4LytTdqGMl/WeYW",
	"hjaTx/XSUOvF3LViocEBlWv9erm3Xv0WaJ/cK9r83YKFnFNF7PlCRkqOgZyxWIcVH56dzg59vOI1Bd6Y",
	"n87uN7I7N+8Q6u9P2Xk2VoacAmSiV9xeqGZ2SBtTYW/u5DZ91p/jRXhrK7L1ENhufEBNELY/DDIgWfgy",
	"tEqY+KehSU/f0fOwIMp1MY3DpfUF4JtYSa+Rei+GjZSCZilVqNTgoM+FPP3MvKReHUa0yFVG7Uh03LC0",
	"GDjuIJayGZDqpfJyiuHcgn/p3Bh15NO+S8jUgMatYvd7Uew+95dPEYppxluX09pw8E4OIFP0XK94lErt",
	"FLbuZ5//chhablteqydGZ/imQ0ZQddMalCEvCPUZklPBlZZlqk84RYNWsLFuCazKTNfPSr3wTeI21YjJ",
	"0w11wikm0K3MXFGWagYRA/aPAJ5jU+V8Dkq3KPEM4IS7VoyTkjONcy1ZKkViI5LMc20o+sS2XNI1mdEc",
	"LbJ/gBRkaoSIsBYMmoeUZnnuvEPMNETMTjjVJAdD9F8zw9CZ4bwFofJ4snhXQSEejDwHDoqpJK6d/cl+",
	"xXhft31vBUBjhf3s4/RuOtDXr51lvSs/PHB12g4PsPRO7RfSWfuNOQssGU+iSGZefOdf1cYtctfweB6B",
	"7tUeJu7UT7hhprUgSOipvhw6tI26nbtob0cLaxoH0bL9+r2+j2UrnIvEiIx0bn6fM70op5NULHd8FsOd",
	"uagyGu5kFJaC47dshxZsRxWQ7pw92MIfXIFekQi5un25v6MgogAPzG2pDh6T9LfPvuddvoayuF93Ldyt",
	"Dqe3lWdvK8/e1ia9rTx7e7q3lWdv67Le1mX9s9ZlnWzkEF2WwK01W3RHtUmJhNTOXBHwsFmjukvXKsn0",
	"hJDjhaH/1LwBcAaS5iSlCpTPNY+JMOcLTVSZpgDZ3glPGiuxGRHNxHfr/1ox96Tc3X0EZPdeu4/VWwSU",
	"t9sXWVX8hKYm8gM5GZ2MOiNJWIozcCmlsXlWovuL7bV12P+vGvdn2Tm6JV1b5cqCFgWYZ02VsxlLmQV5",
	"LowwMBctb20u8AtIszibo40wbYvZIjzRy92XHHMJkGJMd/d9Pwxqx2wroNPOpHWjuRe/XwZ7E53qHtj1",
	"0cCNY3cI4i3JuAmS8cWJxndUYeO2mMZXtqHQkNqolnWVxDwFpGzG0pjeyfNIVp1saDOOAGkpmV7jC0cL",
	"9vspmP+/N3TcFte0j18p89HeaKF1sbezg1XkF0LpnZF5mupvqvXRvA90bkdwj0sh2RnWwnn/6f8FAAD/",
	"/yBFSh9LQwEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
