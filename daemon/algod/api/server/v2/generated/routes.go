// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"f/n/AgAA//8HEBn6mhABAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
