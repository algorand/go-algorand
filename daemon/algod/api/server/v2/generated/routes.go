// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
	// Get the state proof transaction for a given round
	// (GET /v2/transactions/state-proof/{round})
	StateProof(ctx echo.Context, round uint64) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// StateProof converts echo context to params.
func (w *ServerInterfaceWrapper) StateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StateProof(ctx, round)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)
	router.GET("/v2/transactions/state-proof/:round", wrapper.StateProof, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/196RJd/HQEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
