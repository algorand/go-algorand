// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+w9/XMTOZb/is63VQOsOw4QZodUTe0FGGZyCwxFMrt7R7hdufvZ1qRb6pHUsT0c//vV",
	"e5L6w612AoSP3PonSLda0nt63x/y21GqilJJkNaMDt+OSq55ARY0/cXTVFXSJiLDvzIwqRalFUqODsM7",
	"ZqwWcj4ajwQ+LbldjMYjyQtoxuD345GG3yqhIRsdWl3BeGTSBRQcJ7brEkfXM62SuUr8FEduiuMno3db",
	"XvAs02BMf5c/y3zNhEzzKgNmNZeGp/jKsKWwC2YXwjD/MROSKQlMzZhddAazmYA8M3sByN8q0OsWlH7x",
	"7SDxfK40l1kyU7rgdnQ4evX08f379x+yEzfo3VVH+fUSrXLoQ/xYFVMhIcAHNXj10TKrWAYzGrTgluFe",
	"Eeow0CpmgOt0wWZKXwK020QbcpBVMTp8PTIgM9B07imIC/rvTAP8Donleg529Ga8gaZ3CNzMgk6sKCKg",
	"Hftz1GCq3BpGYwnGubgAyfCrPfa8MpZNgXHJXj19zAh5DpsWMk+ug1A1q7dhqg8j4xbC6096xMZAnO2O",
	"8A07fjIEQPgwQoxCWpjTOXT4CL+IsFfzeAozpeGKZ+IGX+uhtNf/oqeSVlqDTNfJXAMnQllw2UfJK48K",
	"s1BVnrEFvyC4eUHy0n/L8Fsnfy54XiGKRKrVUT5XhnGPwQxmvMotCwuzSubIoTibP2gmDCu1uhAZZGMU",
	"YcuFSBcs5cZNQePYUuQ5or8ykA2hOQ7dFjp610YJ7uuD8EEAfb3IaOC6BBOwIkZI0lwZSKy6RDIHYctl",
	"xtqytBHT5v3kNDtdAKPF8YXTWIQ7iQSd52tm6Vwzxg3jLEjlMRMztlYVW9Lh5OKcvvfQINYKhkijw+mo",
	"ENTiQ+jrISOCvKlSOXBJyAtM10eZnIl5pcGw5QLswot7DaZU0gBT018htXjs/3ny8wumNHsOxvA5vOTp",
	"OQOZqmz4jP2iMeX1q1F44IWZlzw9j2uqXBQisuXnfCWKqmCyKqag8byCaLSKabCVlkMbcjNeQmcFX/UX",
	"PdWVTOlwm2U71g6SkjBlztd77HjGCr76fn/st2MYz3NWgsyEnDO7koOWDq59+fYSrSqZXUF9WzywlsIw",
	"JaRiJiBj9SxbduKXuWw/Qr7ffhqjorWdMMngdupVLtmOhFWEZpB18Q0r+RxaJLPHfvGSi95adQ6yFnBs",
	"uqZXpYYLoSpTfzSwR1p62Eal3SkLSalhJiI0duLRgdLDjfHitfC6PVXSciEhQ8lLm1YWnCQa3FNrwe1b",
	"u+IZztTm2W09tyudGQ1KHGNFtBu+9WwX94I631/BD2qvbcQ8cY97xyHmp6gQZiInZfErnkJAQ2WIlTuI",
	"COrDiLnkttJweCbv4F8sYSeWy4zrDJ8U7tHzKrfiRMzxUe4ePVNzkZ6I+QAy671G3QH6rHD/4HxxoWpX",
	"Uav3mVLnVdkGKO04aNM1O34ydMhuzvf1zo5qr65tFp+ugqn8vl/YVX2QA5scxF3JceA5rDXgbnk6o39W",
	"M6InPtO/x5CJlOv1JDnG3mF+5Z/hI+RYkCSQeFnmIuWIzQlpv8O3rZ38QcNsdDj690kTLZi4t2bi53Ur",
	"do/tFhSlXd9G8B/lKj3/oLVLrUrQVjgopjhPn0BoerYAnoFmGbd8r/EFnJEwcMz04U/0HZn4oCPy+Wf6",
	"D88Zvkbi4zbYHmh3CYMWiGqFGjI0V5wQdCvhADKjFCuchcLQsnivXT5uFndyqRYkrz1a3mzOFjmTH5xR",
	"xOiLAASC/kJlcGK5rcwHHVN3lWayoBYMYUNIBxMyLZ+qyjLOpMqAGRo8Gm8cd8ptuqjKAefzsXt7Kgqc",
	"mUkulYFUycw0eK2l6XiUc2OHjIFn3FgnyoXMCMduw/iN0yHMAMjheS9AG6FkfOa/upexuVPEtDSVYX4G",
	"ZqqyVNpC1nNnvQExvNYLWNVrqVlr7lIrq1KVIwFWBi6beQhLrfk9shwkDkHceougtlj6wJHzhZS0jqKy",
	"s4kGEds2chJGtbDbdhYGNoIMWX9JppQwRIrNvmoPZTwyVpUlZAm3SSXr74bQdOJGH9lfmrF94kKXjqyk",
	"DFimAFe3YU9+50uHWecmLrhhfh+s4Oeo4Uut5l7n9PeMPJMYIVNItlE+cs8JjmqzwCW8tCF9Olza4bMN",
	"5tig3yjRDRLBJacwBPBVhGJLUb10ftBpY11cgzh8ApaL3NQir3a2mlXIL9sMPC+5IU9d2nyNNDwTunCh",
	"DVIzJjxzAjXzqzgnvmFLmTENS66zMGKvJ2d9BEVmsIq7Jy50QgOYiG90Vq8mLEtDsMFHZ/ai7O7iA25z",
	"JhY5ohdIj4VIteIuIISIR4NW0TZczENDwXF3FJrweYfhNYWcJy7+FFEq7n2ITwWPon1U8XnD8QwyWn0i",
	"ywWQy4vScwOJ7UOeoZ9lYAiQUqk8Aa2VjvlFPTmzudK5SM8hY0iQlPLw4u+b7p5wEXYLD9XU/t9ysXbT",
	"LnhZgoTs9h5jR5IRE/lg7oaq21hcfmO3rb+iVbOKQlFcMgJy70zG1FYIZH0kFYVpttOOS2p85FJuku0L",
	"2ZUcICC+JA8Op4tS5FY78oS+bMm2nihvEZXbxVXE548U6eedUxYZxSob8WWqaSEo3N8aNkZZEcJQfeNQ",
	"2D3GTolbuEbMXYBGM5wbp+R90LgQ8wWqzjQFyA7PZNLZSaoKv/Ct5r+OEc+q/f37wPZvb35jLNopPo7h",
	"eGDz2+/Z/ti9InSx79nZ6GzUm0lDoS4gYzOtCtama/fVpdP+Wz3vmfy5J4pYwdcuoh54kZlqNhOpcEjP",
	"FUqyudowN6SiN6Bxe1BMQRsm7JiEN2GUzDR3Lg0DxtXjdbgLkVnRQEPloTVfh7BFl3YMgxVPEUpOQmbN",
	"lkgoNZ31tZxVZdKeIJJe27qid5dciM1CYVrBhPflu5qtaD36W1meX7K/UxwzFORtkeve5UZbDxnRHVyF",
	"/Y9YqfDUhU8zhFh0LoztbdJlViz5yjVBRpTOHvsvVbGUE/+WlYXaqFeaLGXyoHAF0qJhTW+bNBiCHAqQ",
	"tsbOnTubgN+5489cGDaDZcjN4cBNdNy545hAGftYFaXI4RpCGgtuFv2TnnID9++xk5+OHty99497D75F",
	"YMje5wWbrlGx3vIRJ2bsOofbce1oqtzGZ//2IGRIuvOOYoG5NuXQhuu5r0Ihp4BS22GMuXxgwONHS5IN",
	"Fl8dR0wvghOtkkhxB0KzdynMNO+VQG1NffwkLEhCyRhS1e/GI/RZ8/U1CE43EdPgLUVnbXkeI2cyJ1nW",
	"yqd6PjBrY6HoB1zcp/8YsGFfBVerZ7EomQsJSaEkrKN1OELCc3oZtXeI1QY+JqE39O2mK9rZ/8a2uutc",
	"5TQ/Fr902i2SeFlnd6/h8Dfn3Yi1tTPJZK1DXjLO0hxtA4qIWF2l9kxyijRsmJMbZBHiJ8Oxp8dhSDzY",
	"FYlF+anOJDeIwzr+sBeTZDOIBACfAoQQlKnmczAb5iWbAZxJP0pIVklhaS2yzhN3YCVoEnx7biRaVDOe",
	"U6jsd9CKTSvbVWGU8HIWoitmwGWYmp1JblkO3Fj2XMjTFU0X/MdAMxLsUunzGgtx+38OEowwSVw3/Oje",
	"/sTNIoCPA4Ow8R+7EC/OX9shCCaeLbcWNM70P7f+fPj6KPlvnvy+nzz84+TN24N3t+/0Ht579/33/9t9",
	"dP/d97f//IfYSYW9xxI5fufHT7x5d/yEdHiTM+ztvTf9p4riFkImUSJDt6sQkrL6G7TFbqElEgjoNguS",
	"KJz6mbQriYR0wXORcfth5LAp4nq86Lhjg2o6B7ERlAuwvom5jXOVlDw953N8Phd2UU33UlVMglk7mava",
	"xJ1kHAol6V024aWYmBLSycXdS1TjR8grFhFXlCp1+ahWqiti3vui1Y6niTO6WjWXK0ZP6wnMhBT4/vBM",
	"ZtzyyZQbkZpJZUA/4jmXKezNFTtkfson3HIKUGzE1YYKU6kcye+mrKa5SNl5W7819D4Upzo7e41YPzt7",
	"w+yGV9DXRn6pKOG7BZKlsAtV2cTHJoeDHE0giGZ2YbJtq46Zn9sds499+vnj8o9ihiYONL5CqN0YJJMm",
	"gB+CKniGL5T1YVC+DJVClQHD/lnw8rWQ9g1LfACAqh1/Ujlu7J+eR1Gwrkvo+Hpb86CtOWLunY+IJttA",
	"K7lGyFqcoGYBzhBRHQL1sIY10NU2YD8Kyhh4JddWpKLk1lsHV8gZv+x8g5NcRntRakPHqEtUjgBbSIoS",
	"mRucoC8UPQ7AN3gelXFlcwhjULJhJeedchfCp3Jzb8JNc2jFoo1PjXFNgi6A7apeh7YWpxLQsmH6sI0u",
	"RtrSZeFzCOKiyRxQ7ugqfHhpKBupKCT9RDeEJ3DdHC74YDTV5XxjMCqZI4wZ5DDnPiJH2WSPfQ/cN6YF",
	"9Zm8w36ezdDeZ0ks08aNUalwaYmgCExYA1Dw32HMeSrsyjPEaKO1bQpl0MTshWoTvJy/zyYlCIp98DA3",
	"BUFaf0PUVoqXDh238qStutK6MAgXJLA2RM24LvVyfRKhgChUDYVSodH4fct+2uZN007hNd+lGqovNxoG",
	"Gjc1Xo7a+l7feBQVR0PGQ2cUc0Om0DNhYghEsdT3g/reloEcyLJJOlI1OY95x2dnrw0Qt5yEz1oWBbsl",
	"ZozL9e1W4E3DHG3uxk5FTg2O1+f1FS6UhWQmtLEJmchR8HDQU0M6/ykOjYueDqqYKyUXWVzy0LLnsE4y",
	"kVfx0/br/uUJLvuiNq1MNT2HNSkY4OmCTblNyfHqLo9jtiztkuJbAX7mAH7Grw3eq9ESDsWFtULPprPG",
	"DaGqDXmyjZkiBBgjjv6pDaI0Kl7IZtpSUDtVvlerkuK3CpjIQFp8pX1GpiNZELshrd4THQMpfD+xz+LX",
	"08fzyuSbXckQdG5cD+VuE/VMgzgJ1nKkXiJI1QBobebjg5bl+x6OWnvFnp+2xclCbmh8KxdCWvii5gHP",
	"ZWvrVrASFm4vkWkGW7HIB4jl+0MmgMyI4Ck41UPVF3WVYrsjMJQh9Kir+ZASMFNwtR0uP8hzoyLTVHLJ",
	"pWsvwe8cmvzXBpzuw6+WCiV4yk3cYhEmmWn1O8Ql8gzPIpIH8qikDA59vRepiNq0M2rroumZC/ht72OQ",
	"el/WfBI5Zx/g6PrKA0xMhNxy/yixHexJLh3lulaYTtgjTv/tUOXEzd/Qv99zL7yb8+WUxwprz85ep7in",
	"QGC4o7blaxULH4dTMHU9h6c9djxztSHjZqxw5W4l6CZZ2yOGQXI/bZHfjSf5DFJR8DzuCGWE/dNOSjMT",
	"c+H6iSoDrYYVPxErlZDWUZFv+nHdAA1qjmdsf9xqifOnkYkLYcQ0Bxpx141AJ5hgq32v8AmCB9IuDA2/",
	"d4Xhi0pmGjK7MA6xRjF0m0/rzr/aw5iCXQJItk/j7j5kt8hzNeICbiMWC9dmNTq8+5DCme6P/ZhE9o2D",
	"2+RKRoLlb16wxOmYXHc3B+ohP+tetPTSNToPi7At3OQ+vQov0Ugv9S7npYJLPo81sJydvS4u2ZP7lk6T",
	"jN8NvMjMtSoaq9WaCRtfHyxH+TSQ0kDx57bh63UKZCCrmFEF0lPTx+IWDdO5vkdfZB/2FV6SI1uGuqtW",
	"au3zOzpOl8egpmDOC15AF61jxl2FMpWO+V4vLxD3BlL9oC/ii+iBAw5603/LbkklkwJ5J7vdJMta9BcN",
	"MijL8+iyNsiuzQD19qnbZlC/lqYS0n57gAvjLMkgYqsOYnlLJn0wiisdh5NXuNQvr555xVAoHWt1aKSh",
	"VxIarBZwEeXYzaRPbZnU6iJgPmag/KC10u0Uc6/MyVWX1Z201JSsQp8LMU/dude1FfBdpEcPOZwaWwb6",
	"91qwhIGxjf91sLXBRfO5ZUtgXEpluYVwmIyzQmWQM+Mr3XKY83Ttc0fmTCLCM6GBysVEQSX2nJkln89B",
	"U9JRk/0Qctc0Wx/2aSXy7DLPyM/xiMZGcrlfMhvbD8C4zTrfcaOkbTOOGIL9m71HBOj27GO9zKfKOKLS",
	"cDmEDvqjebeQe6UpGG2/aQtpuDZy/JrLdBHFEM3SahKN1IcvuJSQR792Ku8LUUjBf1UDey6EjL/aJAGH",
	"mA00NDB3IQxLhvkjhTjjkYG00sKuT5CrvJNein9Ew1Y/1vzrOwBr497blq5z2kvdhtubNtkflStQK9CY",
	"oQSApRrEH1a8KHPwxun330z/BPe/O8j279/90/S7/Qf7KRw8eLi/zx8e8LsP79+Fe989ONiHu7NvH07v",
	"ZfcO7k0P7h18++Bhev/g7vTg24d/+ib0qLqNNv2ff6dilOTo5XFyipttDoqX4i+wdvl0pM5QMMRTildA",
	"wUU+OgyP/iPwCTJQ614Y/3TkldhoYW1pDieT5XK51/5kMqc+kMSqKl1Mwjr9ks+Xxwxk5jwN8mWJl5BZ",
	"iHdc8FPYnAIY9O7VDyen7Ojl8V4jDkaHo/29/b27VD9WguSlGB2O7tMjovoFnfvk4t4kpNEmb70P9g7f",
	"zGNxtVCNXncK9/PsY6c4Ul5XOXdyZsZnm8Zs6iJIzDdAyIzSei50gBq4Bvg4a91J1ciQEATzV2q9jtUb",
	"x6oAYpdp1XmR4Q7yRlAg8+8nD9+8ffDdu4hx8WajOfje/v5nbgg+uMYVu9ZOZN3nPMcjgfquFbeDu59v",
	"B8eSAsfIAMwx+Lvx6MHnxMGxRNLgOaORLce4z0G/yHOpljKMRGlcFQXXa5K1tpXOailLHBbn1G5Iyufq",
	"htkXWrXdrdR+pwRvug4nOWam7uEstVCoM+junwzQZiYJr3QGetyqEve5VnBNq8+P/k4RjOdHf3ftF9F7",
	"UVrLu1akLu//CDbSxfBo3dwK8FUKgvFXe5XMzbkL6GOF6a4XZtcLc2N7YT6zHl/VEWLOpJKJpEKbC2At",
	"r2Wn2D9Ysdd0Wsm6E/kSmu11Cze6uTEKqJzbTN5SQUDbdO8pUbrq5DJt+RXfC7elVE6rIhRwKDYDmy78",
	"LSwbQYehO6S2avxtOZCP1lC7O3g+5g6ecQe7gXh2CP4Clxx9Sm11hWP+KDn/iGfsFfxWgbEsYS8oWEkM",
	"Hm6f+8Sq71PDF9WkB/sHNxagF0oCg5UwVO3raPFTWwef/pCuzdigagFCSmiKanfh1KZDDtkc9MT1Wm6z",
	"HFyv5uhanbFdf+0N6K/98vb+R/HABrQa2peSAXP03/BDqLPtF592g+N+uFlUNlNL2XpSt10MclK4jO8a",
	"OWl3I+DuRsDdjYC7GwFv3o2ANy+cFLkK+FNZcV2F3RLcjcJyf0+WXFh09hKy+RIqWw0BoclgNuhvXPhr",
	"vbk3Fq1CaQE8XNXuJI2fyF922GR0fUTVdw+Gq/BEQaW4XcWHSz1V+koBqCaqYxVDyFglrQjJZGTEWn19",
	"fdGcnWLeKeadYt4p5puvmD9jlqUTfUtCUi0ko2KpKLbLRX20YdFSOF7do7JFftoaM7LA84m/b47C68oM",
	"Foqd/nD0jBlV6RRYissJycqcU3PLyobKBrbtxjzi+f6FfeFOpq239vXtkFPgub9d0NsIYOwjla03jhG3",
	"N6Gdvqf114PYKvf7LbRm3zB5d63Zo3/d6w6/nLxitCNPVA1v7oTThwingMYoGwnJ9XqMFJZVKTDqFXb0",
	"s0pw0Bxk4lk6mapsHZp83TyNANuofAkCrCspXvFlu45mm7Boo3WVuG12UdsUnbuX4ysIkgUQD9WMFSkT",
	"QqRoxbMULWirwoVnn1jI3IxrQL+gQGgqYo98IraDjZ10+FDp8CgQO/3KIl9uMoPzFogH9i6VCpov7UpG",
	"pcKkuaYhGsbvXbZ3veH83d2ju7tHd3eP7u4e3d09erMT0BvXYNSQ0i/gbAI7oIiuoaHj6+7iuDQbsOuZ",
	"2PVM7HomrtgzcYUStd3p7jpibnBHzP+zGtxdveq1NcfsbTWhJm/tSmSXd7bf3N9ZY9f1M2vsU/3K2hf+",
	"jbWITdpXf+9zwcAGscQLUpDs3rOf+I9XaSb+V7E/d7/vuvt9193vu+5+33X3+66733e92b/v+qVSkl9H",
	"GPVTdhtuTRG/UJY9JbXycR5KfedVzAJxmwgXq5GxWF+p9voNmkR0C6i3I5t7wg4nk1ylPF8oYycjtPK6",
	"d4i1X6I44XM3g7fTSi0uqJ33zbv/CwAA///2Ojw5b5YAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
