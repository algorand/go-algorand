// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
