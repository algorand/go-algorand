// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
