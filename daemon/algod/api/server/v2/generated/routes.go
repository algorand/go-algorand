// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
