// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"include": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "include" -------------
	if paramValue := ctx.QueryParam("include"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"//8HIDZyV/IAAA==",
	"rjd824XXuDCdCwLyklCS5gwdFIIrLatUn3KKJtBOxbyOe88bdodVqRe+SdwKHzGSu6FOuVGqFqQ2jEZV",
	"qgVEXB7fAXiNTVXLJSjdkcQLgFPuWjGOtWpxLixAmNhIUHNcG4m+Z1sWdEMWNEcb/m8gBZmbW0SYxQQN",
	"ikqzPHf+RDMNEYtTTjXJwQj918wodGY4b3OqfeSW7mosDBRWtSWNkrgV4nv7FZ8xuOV7uxGat+znppb0",
	"Zyk8lsRqczvIj166DGNHLzFpTONJ7MH+ydxLBeNJlMjMie888l3aIveNjucJ6EHjk3S7fsqNMq0FQUFP",
	"9fXIoesG6PGi5Y4O1bQ2ouMt8Gt9H3vduhSJuTLSpfl9yfSqmmPpL//qdbYU9QvYWUahEBy/ZTNaspkq",
	"IZ2dP9qhH9xAXpGIuLo7uf84RvyQDgy31BuP+dm7ez9wLt9CQtffdxbXnSFKdzlT73Km3mXVvMuZere7",
	"dzlT7zKK3mUU/bNmFN3bqiG6LBw7c/zpnmmTEgmpnbkW4GGzVjbAvluS6T1CTlZG/lNzBsA5SJqTlCqr",
	"GHEbKVew5UoTVaUpQHZwypMWJKko3MT3m//aa+5ptb//BMj+g24fa7cIJG+/L6qq+AldTeRrcjo5nfRG",
	"klCIc3C5wbB5VqGv2PbaOez/qsf9Ufa2rqAba1xZ0bIEc6yparFgKbMoz4W5DCxFJ76PC/wC0gBnU08Q",
	"pm0aVsQnxkW66Bzq3p/HlO7++X6FKk6H3XwGd2lOPnoF4v6G3Z4M3Dp2TyDeiYxPITI+u9D4A2Vku0u+",
	"9jtbUOhIbWVXvYEmVdcCi9idvI5kzclGNuMIkFaS6Q2ecLRkv5yB+f97I8cVyHN/+FUynxxMVlqXB7MZ",
	"5j9fCaVnE3M0Nd9U56M5H+jSjuAOl1Kyc8yd+P7y/wcAAP//Puc58FgLAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
