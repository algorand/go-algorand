// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (POST /v2/register-participation-keys/{address})
	RegisterParticipationKeys(ctx echo.Context, address string, params RegisterParticipationKeysParams) error

	// (POST /v2/shutdown)
	ShutdownNode(ctx echo.Context, params ShutdownNodeParams) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round}/)
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// RegisterParticipationKeys converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterParticipationKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterParticipationKeysParams
	// ------------- Optional query parameter "fee" -------------
	if paramValue := ctx.QueryParam("fee"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "fee", ctx.QueryParams(), &params.Fee)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fee: %s", err))
	}

	// ------------- Optional query parameter "key-dilution" -------------
	if paramValue := ctx.QueryParam("key-dilution"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "key-dilution", ctx.QueryParams(), &params.KeyDilution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key-dilution: %s", err))
	}

	// ------------- Optional query parameter "round-last-valid" -------------
	if paramValue := ctx.QueryParam("round-last-valid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round-last-valid", ctx.QueryParams(), &params.RoundLastValid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-last-valid: %s", err))
	}

	// ------------- Optional query parameter "no-wait" -------------
	if paramValue := ctx.QueryParam("no-wait"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "no-wait", ctx.QueryParams(), &params.NoWait)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter no-wait: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterParticipationKeys(ctx, address, params)
	return err
}

// ShutdownNode converts echo context to params.
func (w *ServerInterfaceWrapper) ShutdownNode(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ShutdownNodeParams
	// ------------- Optional query parameter "timeout" -------------
	if paramValue := ctx.QueryParam("timeout"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timeout", ctx.QueryParams(), &params.Timeout)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeout: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ShutdownNode(ctx, params)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress)
	router.GET("/v2/blocks/:round", wrapper.GetBlock)
	router.GET("/v2/ledger/supply", wrapper.GetSupply)
	router.POST("/v2/register-participation-keys/:address", wrapper.RegisterParticipationKeys)
	router.POST("/v2/shutdown", wrapper.ShutdownNode)
	router.GET("/v2/status", wrapper.GetStatus)
	router.GET("/v2/status/wait-for-block-after/:round/", wrapper.WaitForBlock)
	router.POST("/v2/transactions", wrapper.RawTransaction)
	router.GET("/v2/transactions/params", wrapper.TransactionParams)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
