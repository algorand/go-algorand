// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"

	"github.com/algorand/oapi-codegen/pkg/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
