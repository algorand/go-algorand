// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
