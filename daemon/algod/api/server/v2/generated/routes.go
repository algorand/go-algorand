// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"dGFHcMKllOwCc1K+v/p/AQAA//+yKgLOjxEBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
