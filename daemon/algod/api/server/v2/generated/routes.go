// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"doklUd5f/f8AAAD//5fDYRjT/QAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
