// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/cX/BAAA//8Wh2PwdwcBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
