package auction

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	"github.com/algorand/msgp/msgp"
)

// MarshalMsg implements msgp.Marshaler
func (z *Bid) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 7 bits */
	if (*z).AuctionID == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).AuctionKey.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).BidderKey.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).BidCurrency == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).BidID == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).MaxPrice == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "aid"
			o = append(o, 0xa3, 0x61, 0x69, 0x64)
			o = msgp.AppendUint64(o, (*z).AuctionID)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "auc"
			o = append(o, 0xa3, 0x61, 0x75, 0x63)
			o = (*z).AuctionKey.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "bidder"
			o = append(o, 0xa6, 0x62, 0x69, 0x64, 0x64, 0x65, 0x72)
			o = (*z).BidderKey.MarshalMsg(o)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "cur"
			o = append(o, 0xa3, 0x63, 0x75, 0x72)
			o = msgp.AppendUint64(o, (*z).BidCurrency)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "id"
			o = append(o, 0xa2, 0x69, 0x64)
			o = msgp.AppendUint64(o, (*z).BidID)
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "price"
			o = append(o, 0xa5, 0x70, 0x72, 0x69, 0x63, 0x65)
			o = msgp.AppendUint64(o, (*z).MaxPrice)
		}
	}
	return
}

func (_ *Bid) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Bid)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Bid) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).BidderKey.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BidderKey")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).BidCurrency, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BidCurrency")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).MaxPrice, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MaxPrice")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).BidID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BidID")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).AuctionKey.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuctionKey")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).AuctionID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuctionID")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = Bid{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "bidder":
				bts, err = (*z).BidderKey.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BidderKey")
					return
				}
			case "cur":
				(*z).BidCurrency, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BidCurrency")
					return
				}
			case "price":
				(*z).MaxPrice, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MaxPrice")
					return
				}
			case "id":
				(*z).BidID, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BidID")
					return
				}
			case "auc":
				bts, err = (*z).AuctionKey.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuctionKey")
					return
				}
			case "aid":
				(*z).AuctionID, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuctionID")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *Bid) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Bid)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Bid) Msgsize() (s int) {
	s = 1 + 7 + (*z).BidderKey.Msgsize() + 4 + msgp.Uint64Size + 6 + msgp.Uint64Size + 3 + msgp.Uint64Size + 4 + (*z).AuctionKey.Msgsize() + 4 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Bid) MsgIsZero() bool {
	return ((*z).BidderKey.MsgIsZero()) && ((*z).BidCurrency == 0) && ((*z).MaxPrice == 0) && ((*z).BidID == 0) && ((*z).AuctionKey.MsgIsZero()) && ((*z).AuctionID == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *BidOutcomes) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(5)
	var zb0002Mask uint8 /* 6 bits */
	if (*z).AuctionID == 0 {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	if (*z).AuctionKey.MsgIsZero() {
		zb0002Len--
		zb0002Mask |= 0x4
	}
	if (*z).Cleared == false {
		zb0002Len--
		zb0002Mask |= 0x8
	}
	if len((*z).Outcomes) == 0 {
		zb0002Len--
		zb0002Mask |= 0x10
	}
	if (*z).Price == 0 {
		zb0002Len--
		zb0002Mask |= 0x20
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "aid"
			o = append(o, 0xa3, 0x61, 0x69, 0x64)
			o = msgp.AppendUint64(o, (*z).AuctionID)
		}
		if (zb0002Mask & 0x4) == 0 { // if not empty
			// string "auc"
			o = append(o, 0xa3, 0x61, 0x75, 0x63)
			o = (*z).AuctionKey.MarshalMsg(o)
		}
		if (zb0002Mask & 0x8) == 0 { // if not empty
			// string "cleared"
			o = append(o, 0xa7, 0x63, 0x6c, 0x65, 0x61, 0x72, 0x65, 0x64)
			o = msgp.AppendBool(o, (*z).Cleared)
		}
		if (zb0002Mask & 0x10) == 0 { // if not empty
			// string "outcomes"
			o = append(o, 0xa8, 0x6f, 0x75, 0x74, 0x63, 0x6f, 0x6d, 0x65, 0x73)
			if (*z).Outcomes == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Outcomes)))
			}
			for zb0001 := range (*z).Outcomes {
				o = (*z).Outcomes[zb0001].MarshalMsg(o)
			}
		}
		if (zb0002Mask & 0x20) == 0 { // if not empty
			// string "price"
			o = append(o, 0xa5, 0x70, 0x72, 0x69, 0x63, 0x65)
			o = msgp.AppendUint64(o, (*z).Price)
		}
	}
	return
}

func (_ *BidOutcomes) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*BidOutcomes)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BidOutcomes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).AuctionKey.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuctionKey")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).AuctionID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuctionID")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Price, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Price")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Cleared, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cleared")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Outcomes")
				return
			}
			if zb0005 {
				(*z).Outcomes = nil
			} else if (*z).Outcomes != nil && cap((*z).Outcomes) >= zb0004 {
				(*z).Outcomes = ((*z).Outcomes)[:zb0004]
			} else {
				(*z).Outcomes = make([]BidderOutcome, zb0004)
			}
			for zb0001 := range (*z).Outcomes {
				bts, err = (*z).Outcomes[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Outcomes", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = BidOutcomes{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "auc":
				bts, err = (*z).AuctionKey.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuctionKey")
					return
				}
			case "aid":
				(*z).AuctionID, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuctionID")
					return
				}
			case "price":
				(*z).Price, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Price")
					return
				}
			case "cleared":
				(*z).Cleared, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cleared")
					return
				}
			case "outcomes":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Outcomes")
					return
				}
				if zb0007 {
					(*z).Outcomes = nil
				} else if (*z).Outcomes != nil && cap((*z).Outcomes) >= zb0006 {
					(*z).Outcomes = ((*z).Outcomes)[:zb0006]
				} else {
					(*z).Outcomes = make([]BidderOutcome, zb0006)
				}
				for zb0001 := range (*z).Outcomes {
					bts, err = (*z).Outcomes[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Outcomes", zb0001)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *BidOutcomes) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*BidOutcomes)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BidOutcomes) Msgsize() (s int) {
	s = 1 + 4 + (*z).AuctionKey.Msgsize() + 4 + msgp.Uint64Size + 6 + msgp.Uint64Size + 8 + msgp.BoolSize + 9 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Outcomes {
		s += (*z).Outcomes[zb0001].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *BidOutcomes) MsgIsZero() bool {
	return ((*z).AuctionKey.MsgIsZero()) && ((*z).AuctionID == 0) && ((*z).Price == 0) && ((*z).Cleared == false) && (len((*z).Outcomes) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *BidderOutcome) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 5 bits */
	if (*z).AlgosWon == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).BidID == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).BidderKey.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).WinningsAddress.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "alg"
			o = append(o, 0xa3, 0x61, 0x6c, 0x67)
			o = msgp.AppendUint64(o, (*z).AlgosWon)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "id"
			o = append(o, 0xa2, 0x69, 0x64)
			o = msgp.AppendUint64(o, (*z).BidID)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "key"
			o = append(o, 0xa3, 0x6b, 0x65, 0x79)
			o = (*z).BidderKey.MarshalMsg(o)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "out"
			o = append(o, 0xa3, 0x6f, 0x75, 0x74)
			o = (*z).WinningsAddress.MarshalMsg(o)
		}
	}
	return
}

func (_ *BidderOutcome) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*BidderOutcome)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BidderOutcome) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).BidderKey.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BidderKey")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).AlgosWon, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AlgosWon")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).WinningsAddress.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "WinningsAddress")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).BidID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BidID")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = BidderOutcome{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "key":
				bts, err = (*z).BidderKey.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BidderKey")
					return
				}
			case "alg":
				(*z).AlgosWon, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AlgosWon")
					return
				}
			case "out":
				bts, err = (*z).WinningsAddress.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "WinningsAddress")
					return
				}
			case "id":
				(*z).BidID, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BidID")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *BidderOutcome) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*BidderOutcome)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BidderOutcome) Msgsize() (s int) {
	s = 1 + 4 + (*z).BidderKey.Msgsize() + 4 + msgp.Uint64Size + 4 + (*z).WinningsAddress.Msgsize() + 3 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *BidderOutcome) MsgIsZero() bool {
	return ((*z).BidderKey.MsgIsZero()) && ((*z).AlgosWon == 0) && ((*z).WinningsAddress.MsgIsZero()) && ((*z).BidID == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *Deposit) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 7 bits */
	if (*z).AuctionID == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).AuctionKey.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Currency == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).DepositID == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).BidderKey.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).WinningsAddress.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "aid"
			o = append(o, 0xa3, 0x61, 0x69, 0x64)
			o = msgp.AppendUint64(o, (*z).AuctionID)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "auc"
			o = append(o, 0xa3, 0x61, 0x75, 0x63)
			o = (*z).AuctionKey.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "cur"
			o = append(o, 0xa3, 0x63, 0x75, 0x72)
			o = msgp.AppendUint64(o, (*z).Currency)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "did"
			o = append(o, 0xa3, 0x64, 0x69, 0x64)
			o = msgp.AppendUint64(o, (*z).DepositID)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "key"
			o = append(o, 0xa3, 0x6b, 0x65, 0x79)
			o = (*z).BidderKey.MarshalMsg(o)
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "out"
			o = append(o, 0xa3, 0x6f, 0x75, 0x74)
			o = (*z).WinningsAddress.MarshalMsg(o)
		}
	}
	return
}

func (_ *Deposit) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Deposit)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Deposit) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).BidderKey.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BidderKey")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).WinningsAddress.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "WinningsAddress")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Currency, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Currency")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).AuctionKey.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuctionKey")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).AuctionID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuctionID")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).DepositID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "DepositID")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = Deposit{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "key":
				bts, err = (*z).BidderKey.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BidderKey")
					return
				}
			case "out":
				bts, err = (*z).WinningsAddress.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "WinningsAddress")
					return
				}
			case "cur":
				(*z).Currency, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Currency")
					return
				}
			case "auc":
				bts, err = (*z).AuctionKey.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuctionKey")
					return
				}
			case "aid":
				(*z).AuctionID, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuctionID")
					return
				}
			case "did":
				(*z).DepositID, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DepositID")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *Deposit) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Deposit)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Deposit) Msgsize() (s int) {
	s = 1 + 4 + (*z).BidderKey.Msgsize() + 4 + (*z).WinningsAddress.Msgsize() + 4 + msgp.Uint64Size + 4 + (*z).AuctionKey.Msgsize() + 4 + msgp.Uint64Size + 4 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Deposit) MsgIsZero() bool {
	return ((*z).BidderKey.MsgIsZero()) && ((*z).WinningsAddress.MsgIsZero()) && ((*z).Currency == 0) && ((*z).AuctionKey.MsgIsZero()) && ((*z).AuctionID == 0) && ((*z).DepositID == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *MasterInput) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 5 bits */
	if ((*z).SignedBid.Bid.MsgIsZero()) && ((*z).SignedBid.Sig.MsgIsZero()) {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if ((*z).SignedDeposit.Deposit.MsgIsZero()) && ((*z).SignedDeposit.Sig.MsgIsZero()) {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Round == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).Type == "" {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "b"
			o = append(o, 0xa1, 0x62)
			// omitempty: check for empty values
			zb0002Len := uint32(2)
			var zb0002Mask uint8 /* 3 bits */
			if (*z).SignedBid.Bid.MsgIsZero() {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			if (*z).SignedBid.Sig.MsgIsZero() {
				zb0002Len--
				zb0002Mask |= 0x4
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x2) == 0 { // if not empty
				// string "bid"
				o = append(o, 0xa3, 0x62, 0x69, 0x64)
				o = (*z).SignedBid.Bid.MarshalMsg(o)
			}
			if (zb0002Mask & 0x4) == 0 { // if not empty
				// string "sig"
				o = append(o, 0xa3, 0x73, 0x69, 0x67)
				o = (*z).SignedBid.Sig.MarshalMsg(o)
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "d"
			o = append(o, 0xa1, 0x64)
			// omitempty: check for empty values
			zb0003Len := uint32(2)
			var zb0003Mask uint8 /* 3 bits */
			if (*z).SignedDeposit.Deposit.MsgIsZero() {
				zb0003Len--
				zb0003Mask |= 0x2
			}
			if (*z).SignedDeposit.Sig.MsgIsZero() {
				zb0003Len--
				zb0003Mask |= 0x4
			}
			// variable map header, size zb0003Len
			o = append(o, 0x80|uint8(zb0003Len))
			if (zb0003Mask & 0x2) == 0 { // if not empty
				// string "dep"
				o = append(o, 0xa3, 0x64, 0x65, 0x70)
				o = (*z).SignedDeposit.Deposit.MarshalMsg(o)
			}
			if (zb0003Mask & 0x4) == 0 { // if not empty
				// string "sig"
				o = append(o, 0xa3, 0x73, 0x69, 0x67)
				o = (*z).SignedDeposit.Sig.MarshalMsg(o)
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "rnd"
			o = append(o, 0xa3, 0x72, 0x6e, 0x64)
			o = msgp.AppendUint64(o, (*z).Round)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			o = msgp.AppendString(o, string((*z).Type))
		}
	}
	return
}

func (_ *MasterInput) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*MasterInput)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MasterInput) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Round, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Round")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 string
				zb0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Type")
					return
				}
				(*z).Type = NoteFieldType(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedDeposit")
					return
				}
				if zb0004 > 0 {
					zb0004--
					bts, err = (*z).SignedDeposit.Deposit.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedDeposit", "struct-from-array", "Deposit")
						return
					}
				}
				if zb0004 > 0 {
					zb0004--
					bts, err = (*z).SignedDeposit.Sig.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedDeposit", "struct-from-array", "Sig")
						return
					}
				}
				if zb0004 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0004)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedDeposit", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedDeposit")
					return
				}
				if zb0005 {
					(*z).SignedDeposit = SignedDeposit{}
				}
				for zb0004 > 0 {
					zb0004--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedDeposit")
						return
					}
					switch string(field) {
					case "dep":
						bts, err = (*z).SignedDeposit.Deposit.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedDeposit", "Deposit")
							return
						}
					case "sig":
						bts, err = (*z).SignedDeposit.Sig.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedDeposit", "Sig")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedDeposit")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0006 int
			var zb0007 bool
			zb0006, zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedBid")
					return
				}
				if zb0006 > 0 {
					zb0006--
					bts, err = (*z).SignedBid.Bid.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedBid", "struct-from-array", "Bid")
						return
					}
				}
				if zb0006 > 0 {
					zb0006--
					bts, err = (*z).SignedBid.Sig.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedBid", "struct-from-array", "Sig")
						return
					}
				}
				if zb0006 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0006)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedBid", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedBid")
					return
				}
				if zb0007 {
					(*z).SignedBid = SignedBid{}
				}
				for zb0006 > 0 {
					zb0006--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedBid")
						return
					}
					switch string(field) {
					case "bid":
						bts, err = (*z).SignedBid.Bid.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedBid", "Bid")
							return
						}
					case "sig":
						bts, err = (*z).SignedBid.Sig.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedBid", "Sig")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedBid")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = MasterInput{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "rnd":
				(*z).Round, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Round")
					return
				}
			case "t":
				{
					var zb0008 string
					zb0008, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Type")
						return
					}
					(*z).Type = NoteFieldType(zb0008)
				}
			case "d":
				var zb0009 int
				var zb0010 bool
				zb0009, zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedDeposit")
						return
					}
					if zb0009 > 0 {
						zb0009--
						bts, err = (*z).SignedDeposit.Deposit.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedDeposit", "struct-from-array", "Deposit")
							return
						}
					}
					if zb0009 > 0 {
						zb0009--
						bts, err = (*z).SignedDeposit.Sig.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedDeposit", "struct-from-array", "Sig")
							return
						}
					}
					if zb0009 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0009)
						if err != nil {
							err = msgp.WrapError(err, "SignedDeposit", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "SignedDeposit")
						return
					}
					if zb0010 {
						(*z).SignedDeposit = SignedDeposit{}
					}
					for zb0009 > 0 {
						zb0009--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedDeposit")
							return
						}
						switch string(field) {
						case "dep":
							bts, err = (*z).SignedDeposit.Deposit.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SignedDeposit", "Deposit")
								return
							}
						case "sig":
							bts, err = (*z).SignedDeposit.Sig.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SignedDeposit", "Sig")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "SignedDeposit")
								return
							}
						}
					}
				}
			case "b":
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedBid")
						return
					}
					if zb0011 > 0 {
						zb0011--
						bts, err = (*z).SignedBid.Bid.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedBid", "struct-from-array", "Bid")
							return
						}
					}
					if zb0011 > 0 {
						zb0011--
						bts, err = (*z).SignedBid.Sig.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedBid", "struct-from-array", "Sig")
							return
						}
					}
					if zb0011 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0011)
						if err != nil {
							err = msgp.WrapError(err, "SignedBid", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "SignedBid")
						return
					}
					if zb0012 {
						(*z).SignedBid = SignedBid{}
					}
					for zb0011 > 0 {
						zb0011--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedBid")
							return
						}
						switch string(field) {
						case "bid":
							bts, err = (*z).SignedBid.Bid.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SignedBid", "Bid")
								return
							}
						case "sig":
							bts, err = (*z).SignedBid.Sig.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SignedBid", "Sig")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "SignedBid")
								return
							}
						}
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *MasterInput) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*MasterInput)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MasterInput) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint64Size + 2 + msgp.StringPrefixSize + len(string((*z).Type)) + 2 + 1 + 4 + (*z).SignedDeposit.Deposit.Msgsize() + 4 + (*z).SignedDeposit.Sig.Msgsize() + 2 + 1 + 4 + (*z).SignedBid.Bid.Msgsize() + 4 + (*z).SignedBid.Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *MasterInput) MsgIsZero() bool {
	return ((*z).Round == 0) && ((*z).Type == "") && (((*z).SignedDeposit.Deposit.MsgIsZero()) && ((*z).SignedDeposit.Sig.MsgIsZero())) && (((*z).SignedBid.Bid.MsgIsZero()) && ((*z).SignedBid.Sig.MsgIsZero()))
}

// MarshalMsg implements msgp.Marshaler
func (z *NoteField) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 6 bits */
	if ((*z).SignedBid.Bid.MsgIsZero()) && ((*z).SignedBid.Sig.MsgIsZero()) {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if ((*z).SignedDeposit.Deposit.MsgIsZero()) && ((*z).SignedDeposit.Sig.MsgIsZero()) {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if ((*z).SignedParams.Params.MsgIsZero()) && ((*z).SignedParams.Sig.MsgIsZero()) {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if ((*z).SignedSettlement.Settlement.MsgIsZero()) && ((*z).SignedSettlement.Sig.MsgIsZero()) {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).Type == "" {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "b"
			o = append(o, 0xa1, 0x62)
			// omitempty: check for empty values
			zb0002Len := uint32(2)
			var zb0002Mask uint8 /* 3 bits */
			if (*z).SignedBid.Bid.MsgIsZero() {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			if (*z).SignedBid.Sig.MsgIsZero() {
				zb0002Len--
				zb0002Mask |= 0x4
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x2) == 0 { // if not empty
				// string "bid"
				o = append(o, 0xa3, 0x62, 0x69, 0x64)
				o = (*z).SignedBid.Bid.MarshalMsg(o)
			}
			if (zb0002Mask & 0x4) == 0 { // if not empty
				// string "sig"
				o = append(o, 0xa3, 0x73, 0x69, 0x67)
				o = (*z).SignedBid.Sig.MarshalMsg(o)
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "d"
			o = append(o, 0xa1, 0x64)
			// omitempty: check for empty values
			zb0003Len := uint32(2)
			var zb0003Mask uint8 /* 3 bits */
			if (*z).SignedDeposit.Deposit.MsgIsZero() {
				zb0003Len--
				zb0003Mask |= 0x2
			}
			if (*z).SignedDeposit.Sig.MsgIsZero() {
				zb0003Len--
				zb0003Mask |= 0x4
			}
			// variable map header, size zb0003Len
			o = append(o, 0x80|uint8(zb0003Len))
			if (zb0003Mask & 0x2) == 0 { // if not empty
				// string "dep"
				o = append(o, 0xa3, 0x64, 0x65, 0x70)
				o = (*z).SignedDeposit.Deposit.MarshalMsg(o)
			}
			if (zb0003Mask & 0x4) == 0 { // if not empty
				// string "sig"
				o = append(o, 0xa3, 0x73, 0x69, 0x67)
				o = (*z).SignedDeposit.Sig.MarshalMsg(o)
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "p"
			o = append(o, 0xa1, 0x70)
			// omitempty: check for empty values
			zb0004Len := uint32(2)
			var zb0004Mask uint8 /* 3 bits */
			if (*z).SignedParams.Params.MsgIsZero() {
				zb0004Len--
				zb0004Mask |= 0x2
			}
			if (*z).SignedParams.Sig.MsgIsZero() {
				zb0004Len--
				zb0004Mask |= 0x4
			}
			// variable map header, size zb0004Len
			o = append(o, 0x80|uint8(zb0004Len))
			if (zb0004Mask & 0x2) == 0 { // if not empty
				// string "param"
				o = append(o, 0xa5, 0x70, 0x61, 0x72, 0x61, 0x6d)
				o = (*z).SignedParams.Params.MarshalMsg(o)
			}
			if (zb0004Mask & 0x4) == 0 { // if not empty
				// string "sig"
				o = append(o, 0xa3, 0x73, 0x69, 0x67)
				o = (*z).SignedParams.Sig.MarshalMsg(o)
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "s"
			o = append(o, 0xa1, 0x73)
			// omitempty: check for empty values
			zb0005Len := uint32(2)
			var zb0005Mask uint8 /* 3 bits */
			if (*z).SignedSettlement.Settlement.MsgIsZero() {
				zb0005Len--
				zb0005Mask |= 0x2
			}
			if (*z).SignedSettlement.Sig.MsgIsZero() {
				zb0005Len--
				zb0005Mask |= 0x4
			}
			// variable map header, size zb0005Len
			o = append(o, 0x80|uint8(zb0005Len))
			if (zb0005Mask & 0x2) == 0 { // if not empty
				// string "settle"
				o = append(o, 0xa6, 0x73, 0x65, 0x74, 0x74, 0x6c, 0x65)
				o = (*z).SignedSettlement.Settlement.MarshalMsg(o)
			}
			if (zb0005Mask & 0x4) == 0 { // if not empty
				// string "sig"
				o = append(o, 0xa3, 0x73, 0x69, 0x67)
				o = (*z).SignedSettlement.Sig.MarshalMsg(o)
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "t"
			o = append(o, 0xa1, 0x74)
			o = msgp.AppendString(o, string((*z).Type))
		}
	}
	return
}

func (_ *NoteField) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*NoteField)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *NoteField) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			{
				var zb0003 string
				zb0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Type")
					return
				}
				(*z).Type = NoteFieldType(zb0003)
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedDeposit")
					return
				}
				if zb0004 > 0 {
					zb0004--
					bts, err = (*z).SignedDeposit.Deposit.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedDeposit", "struct-from-array", "Deposit")
						return
					}
				}
				if zb0004 > 0 {
					zb0004--
					bts, err = (*z).SignedDeposit.Sig.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedDeposit", "struct-from-array", "Sig")
						return
					}
				}
				if zb0004 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0004)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedDeposit", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedDeposit")
					return
				}
				if zb0005 {
					(*z).SignedDeposit = SignedDeposit{}
				}
				for zb0004 > 0 {
					zb0004--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedDeposit")
						return
					}
					switch string(field) {
					case "dep":
						bts, err = (*z).SignedDeposit.Deposit.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedDeposit", "Deposit")
							return
						}
					case "sig":
						bts, err = (*z).SignedDeposit.Sig.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedDeposit", "Sig")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedDeposit")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0006 int
			var zb0007 bool
			zb0006, zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedBid")
					return
				}
				if zb0006 > 0 {
					zb0006--
					bts, err = (*z).SignedBid.Bid.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedBid", "struct-from-array", "Bid")
						return
					}
				}
				if zb0006 > 0 {
					zb0006--
					bts, err = (*z).SignedBid.Sig.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedBid", "struct-from-array", "Sig")
						return
					}
				}
				if zb0006 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0006)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedBid", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedBid")
					return
				}
				if zb0007 {
					(*z).SignedBid = SignedBid{}
				}
				for zb0006 > 0 {
					zb0006--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedBid")
						return
					}
					switch string(field) {
					case "bid":
						bts, err = (*z).SignedBid.Bid.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedBid", "Bid")
							return
						}
					case "sig":
						bts, err = (*z).SignedBid.Sig.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedBid", "Sig")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedBid")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0008 int
			var zb0009 bool
			zb0008, zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0008, zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedSettlement")
					return
				}
				if zb0008 > 0 {
					zb0008--
					bts, err = (*z).SignedSettlement.Settlement.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedSettlement", "struct-from-array", "Settlement")
						return
					}
				}
				if zb0008 > 0 {
					zb0008--
					bts, err = (*z).SignedSettlement.Sig.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedSettlement", "struct-from-array", "Sig")
						return
					}
				}
				if zb0008 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0008)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedSettlement", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedSettlement")
					return
				}
				if zb0009 {
					(*z).SignedSettlement = SignedSettlement{}
				}
				for zb0008 > 0 {
					zb0008--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedSettlement")
						return
					}
					switch string(field) {
					case "settle":
						bts, err = (*z).SignedSettlement.Settlement.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedSettlement", "Settlement")
							return
						}
					case "sig":
						bts, err = (*z).SignedSettlement.Sig.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedSettlement", "Sig")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedSettlement")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0010 int
			var zb0011 bool
			zb0010, zb0011, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0010, zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedParams")
					return
				}
				if zb0010 > 0 {
					zb0010--
					bts, err = (*z).SignedParams.Params.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedParams", "struct-from-array", "Params")
						return
					}
				}
				if zb0010 > 0 {
					zb0010--
					bts, err = (*z).SignedParams.Sig.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedParams", "struct-from-array", "Sig")
						return
					}
				}
				if zb0010 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0010)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedParams", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "SignedParams")
					return
				}
				if zb0011 {
					(*z).SignedParams = SignedParams{}
				}
				for zb0010 > 0 {
					zb0010--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "SignedParams")
						return
					}
					switch string(field) {
					case "param":
						bts, err = (*z).SignedParams.Params.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedParams", "Params")
							return
						}
					case "sig":
						bts, err = (*z).SignedParams.Sig.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedParams", "Sig")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "SignedParams")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = NoteField{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "t":
				{
					var zb0012 string
					zb0012, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Type")
						return
					}
					(*z).Type = NoteFieldType(zb0012)
				}
			case "d":
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedDeposit")
						return
					}
					if zb0013 > 0 {
						zb0013--
						bts, err = (*z).SignedDeposit.Deposit.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedDeposit", "struct-from-array", "Deposit")
							return
						}
					}
					if zb0013 > 0 {
						zb0013--
						bts, err = (*z).SignedDeposit.Sig.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedDeposit", "struct-from-array", "Sig")
							return
						}
					}
					if zb0013 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0013)
						if err != nil {
							err = msgp.WrapError(err, "SignedDeposit", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "SignedDeposit")
						return
					}
					if zb0014 {
						(*z).SignedDeposit = SignedDeposit{}
					}
					for zb0013 > 0 {
						zb0013--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedDeposit")
							return
						}
						switch string(field) {
						case "dep":
							bts, err = (*z).SignedDeposit.Deposit.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SignedDeposit", "Deposit")
								return
							}
						case "sig":
							bts, err = (*z).SignedDeposit.Sig.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SignedDeposit", "Sig")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "SignedDeposit")
								return
							}
						}
					}
				}
			case "b":
				var zb0015 int
				var zb0016 bool
				zb0015, zb0016, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0015, zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedBid")
						return
					}
					if zb0015 > 0 {
						zb0015--
						bts, err = (*z).SignedBid.Bid.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedBid", "struct-from-array", "Bid")
							return
						}
					}
					if zb0015 > 0 {
						zb0015--
						bts, err = (*z).SignedBid.Sig.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedBid", "struct-from-array", "Sig")
							return
						}
					}
					if zb0015 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0015)
						if err != nil {
							err = msgp.WrapError(err, "SignedBid", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "SignedBid")
						return
					}
					if zb0016 {
						(*z).SignedBid = SignedBid{}
					}
					for zb0015 > 0 {
						zb0015--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedBid")
							return
						}
						switch string(field) {
						case "bid":
							bts, err = (*z).SignedBid.Bid.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SignedBid", "Bid")
								return
							}
						case "sig":
							bts, err = (*z).SignedBid.Sig.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SignedBid", "Sig")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "SignedBid")
								return
							}
						}
					}
				}
			case "s":
				var zb0017 int
				var zb0018 bool
				zb0017, zb0018, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0017, zb0018, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedSettlement")
						return
					}
					if zb0017 > 0 {
						zb0017--
						bts, err = (*z).SignedSettlement.Settlement.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedSettlement", "struct-from-array", "Settlement")
							return
						}
					}
					if zb0017 > 0 {
						zb0017--
						bts, err = (*z).SignedSettlement.Sig.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedSettlement", "struct-from-array", "Sig")
							return
						}
					}
					if zb0017 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0017)
						if err != nil {
							err = msgp.WrapError(err, "SignedSettlement", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "SignedSettlement")
						return
					}
					if zb0018 {
						(*z).SignedSettlement = SignedSettlement{}
					}
					for zb0017 > 0 {
						zb0017--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedSettlement")
							return
						}
						switch string(field) {
						case "settle":
							bts, err = (*z).SignedSettlement.Settlement.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SignedSettlement", "Settlement")
								return
							}
						case "sig":
							bts, err = (*z).SignedSettlement.Sig.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SignedSettlement", "Sig")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "SignedSettlement")
								return
							}
						}
					}
				}
			case "p":
				var zb0019 int
				var zb0020 bool
				zb0019, zb0020, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0019, zb0020, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "SignedParams")
						return
					}
					if zb0019 > 0 {
						zb0019--
						bts, err = (*z).SignedParams.Params.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedParams", "struct-from-array", "Params")
							return
						}
					}
					if zb0019 > 0 {
						zb0019--
						bts, err = (*z).SignedParams.Sig.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedParams", "struct-from-array", "Sig")
							return
						}
					}
					if zb0019 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0019)
						if err != nil {
							err = msgp.WrapError(err, "SignedParams", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "SignedParams")
						return
					}
					if zb0020 {
						(*z).SignedParams = SignedParams{}
					}
					for zb0019 > 0 {
						zb0019--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "SignedParams")
							return
						}
						switch string(field) {
						case "param":
							bts, err = (*z).SignedParams.Params.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SignedParams", "Params")
								return
							}
						case "sig":
							bts, err = (*z).SignedParams.Sig.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "SignedParams", "Sig")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "SignedParams")
								return
							}
						}
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *NoteField) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*NoteField)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *NoteField) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(string((*z).Type)) + 2 + 1 + 4 + (*z).SignedDeposit.Deposit.Msgsize() + 4 + (*z).SignedDeposit.Sig.Msgsize() + 2 + 1 + 4 + (*z).SignedBid.Bid.Msgsize() + 4 + (*z).SignedBid.Sig.Msgsize() + 2 + 1 + 7 + (*z).SignedSettlement.Settlement.Msgsize() + 4 + (*z).SignedSettlement.Sig.Msgsize() + 2 + 1 + 6 + (*z).SignedParams.Params.Msgsize() + 4 + (*z).SignedParams.Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *NoteField) MsgIsZero() bool {
	return ((*z).Type == "") && (((*z).SignedDeposit.Deposit.MsgIsZero()) && ((*z).SignedDeposit.Sig.MsgIsZero())) && (((*z).SignedBid.Bid.MsgIsZero()) && ((*z).SignedBid.Sig.MsgIsZero())) && (((*z).SignedSettlement.Settlement.MsgIsZero()) && ((*z).SignedSettlement.Sig.MsgIsZero())) && (((*z).SignedParams.Params.MsgIsZero()) && ((*z).SignedParams.Sig.MsgIsZero()))
}

// MarshalMsg implements msgp.Marshaler
func (z NoteFieldType) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

func (_ NoteFieldType) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(NoteFieldType)
	if !ok {
		_, ok = (z).(*NoteFieldType)
	}
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *NoteFieldType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = NoteFieldType(zb0001)
	}
	o = bts
	return
}

func (_ *NoteFieldType) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*NoteFieldType)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z NoteFieldType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// MsgIsZero returns whether this is a zero value
func (z NoteFieldType) MsgIsZero() bool {
	return z == ""
}

// MarshalMsg implements msgp.Marshaler
func (z *Params) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(12)
	var zb0001Mask uint16 /* 13 bits */
	if (*z).AuctionID == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).AuctionKey.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).BankKey.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).PriceChunkRounds == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).DepositRound == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if (*z).DispensingKey.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if (*z).FirstRound == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if (*z).LastPrice == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if (*z).NumAlgos == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if (*z).MaxPriceMultiple == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if (*z).MinBidAlgos == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if (*z).NumChunks == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "aid"
			o = append(o, 0xa3, 0x61, 0x69, 0x64)
			o = msgp.AppendUint64(o, (*z).AuctionID)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "auc"
			o = append(o, 0xa3, 0x61, 0x75, 0x63)
			o = (*z).AuctionKey.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "bank"
			o = append(o, 0xa4, 0x62, 0x61, 0x6e, 0x6b)
			o = (*z).BankKey.MarshalMsg(o)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "chunkrnds"
			o = append(o, 0xa9, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x72, 0x6e, 0x64, 0x73)
			o = msgp.AppendUint64(o, (*z).PriceChunkRounds)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "depositrnd"
			o = append(o, 0xaa, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x72, 0x6e, 0x64)
			o = msgp.AppendUint64(o, (*z).DepositRound)
		}
		if (zb0001Mask & 0x40) == 0 { // if not empty
			// string "dispense"
			o = append(o, 0xa8, 0x64, 0x69, 0x73, 0x70, 0x65, 0x6e, 0x73, 0x65)
			o = (*z).DispensingKey.MarshalMsg(o)
		}
		if (zb0001Mask & 0x80) == 0 { // if not empty
			// string "firstrnd"
			o = append(o, 0xa8, 0x66, 0x69, 0x72, 0x73, 0x74, 0x72, 0x6e, 0x64)
			o = msgp.AppendUint64(o, (*z).FirstRound)
		}
		if (zb0001Mask & 0x100) == 0 { // if not empty
			// string "lastprice"
			o = append(o, 0xa9, 0x6c, 0x61, 0x73, 0x74, 0x70, 0x72, 0x69, 0x63, 0x65)
			o = msgp.AppendUint64(o, (*z).LastPrice)
		}
		if (zb0001Mask & 0x200) == 0 { // if not empty
			// string "maxalgos"
			o = append(o, 0xa8, 0x6d, 0x61, 0x78, 0x61, 0x6c, 0x67, 0x6f, 0x73)
			o = msgp.AppendUint64(o, (*z).NumAlgos)
		}
		if (zb0001Mask & 0x400) == 0 { // if not empty
			// string "maxmult"
			o = append(o, 0xa7, 0x6d, 0x61, 0x78, 0x6d, 0x75, 0x6c, 0x74)
			o = msgp.AppendUint64(o, (*z).MaxPriceMultiple)
		}
		if (zb0001Mask & 0x800) == 0 { // if not empty
			// string "minbidalgos"
			o = append(o, 0xab, 0x6d, 0x69, 0x6e, 0x62, 0x69, 0x64, 0x61, 0x6c, 0x67, 0x6f, 0x73)
			o = msgp.AppendUint64(o, (*z).MinBidAlgos)
		}
		if (zb0001Mask & 0x1000) == 0 { // if not empty
			// string "numchunks"
			o = append(o, 0xa9, 0x6e, 0x75, 0x6d, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x73)
			o = msgp.AppendUint64(o, (*z).NumChunks)
		}
	}
	return
}

func (_ *Params) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Params)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Params) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).AuctionKey.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuctionKey")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).AuctionID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuctionID")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).BankKey.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "BankKey")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).DispensingKey.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "DispensingKey")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).LastPrice, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "LastPrice")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).DepositRound, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "DepositRound")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).FirstRound, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstRound")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).PriceChunkRounds, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PriceChunkRounds")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).NumChunks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NumChunks")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).MaxPriceMultiple, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MaxPriceMultiple")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).NumAlgos, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "NumAlgos")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).MinBidAlgos, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "MinBidAlgos")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = Params{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "auc":
				bts, err = (*z).AuctionKey.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuctionKey")
					return
				}
			case "aid":
				(*z).AuctionID, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuctionID")
					return
				}
			case "bank":
				bts, err = (*z).BankKey.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BankKey")
					return
				}
			case "dispense":
				bts, err = (*z).DispensingKey.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "DispensingKey")
					return
				}
			case "lastprice":
				(*z).LastPrice, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastPrice")
					return
				}
			case "depositrnd":
				(*z).DepositRound, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DepositRound")
					return
				}
			case "firstrnd":
				(*z).FirstRound, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstRound")
					return
				}
			case "chunkrnds":
				(*z).PriceChunkRounds, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PriceChunkRounds")
					return
				}
			case "numchunks":
				(*z).NumChunks, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NumChunks")
					return
				}
			case "maxmult":
				(*z).MaxPriceMultiple, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MaxPriceMultiple")
					return
				}
			case "maxalgos":
				(*z).NumAlgos, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NumAlgos")
					return
				}
			case "minbidalgos":
				(*z).MinBidAlgos, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MinBidAlgos")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *Params) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Params)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Params) Msgsize() (s int) {
	s = 1 + 4 + (*z).AuctionKey.Msgsize() + 4 + msgp.Uint64Size + 5 + (*z).BankKey.Msgsize() + 9 + (*z).DispensingKey.Msgsize() + 10 + msgp.Uint64Size + 11 + msgp.Uint64Size + 9 + msgp.Uint64Size + 10 + msgp.Uint64Size + 10 + msgp.Uint64Size + 8 + msgp.Uint64Size + 9 + msgp.Uint64Size + 12 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Params) MsgIsZero() bool {
	return ((*z).AuctionKey.MsgIsZero()) && ((*z).AuctionID == 0) && ((*z).BankKey.MsgIsZero()) && ((*z).DispensingKey.MsgIsZero()) && ((*z).LastPrice == 0) && ((*z).DepositRound == 0) && ((*z).FirstRound == 0) && ((*z).PriceChunkRounds == 0) && ((*z).NumChunks == 0) && ((*z).MaxPriceMultiple == 0) && ((*z).NumAlgos == 0) && ((*z).MinBidAlgos == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *Settlement) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 6 bits */
	if (*z).AuctionID == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).AuctionKey.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if (*z).Canceled == false {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).Cleared == false {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if (*z).OutcomesHash.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "aid"
			o = append(o, 0xa3, 0x61, 0x69, 0x64)
			o = msgp.AppendUint64(o, (*z).AuctionID)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "auc"
			o = append(o, 0xa3, 0x61, 0x75, 0x63)
			o = (*z).AuctionKey.MarshalMsg(o)
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "canceled"
			o = append(o, 0xa8, 0x63, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x65, 0x64)
			o = msgp.AppendBool(o, (*z).Canceled)
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "cleared"
			o = append(o, 0xa7, 0x63, 0x6c, 0x65, 0x61, 0x72, 0x65, 0x64)
			o = msgp.AppendBool(o, (*z).Cleared)
		}
		if (zb0001Mask & 0x20) == 0 { // if not empty
			// string "outhash"
			o = append(o, 0xa7, 0x6f, 0x75, 0x74, 0x68, 0x61, 0x73, 0x68)
			o = (*z).OutcomesHash.MarshalMsg(o)
		}
	}
	return
}

func (_ *Settlement) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Settlement)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Settlement) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).AuctionKey.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuctionKey")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).AuctionID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "AuctionID")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Cleared, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Cleared")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).OutcomesHash.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OutcomesHash")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).Canceled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Canceled")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = Settlement{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "auc":
				bts, err = (*z).AuctionKey.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuctionKey")
					return
				}
			case "aid":
				(*z).AuctionID, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AuctionID")
					return
				}
			case "cleared":
				(*z).Cleared, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cleared")
					return
				}
			case "outhash":
				bts, err = (*z).OutcomesHash.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OutcomesHash")
					return
				}
			case "canceled":
				(*z).Canceled, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Canceled")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *Settlement) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Settlement)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Settlement) Msgsize() (s int) {
	s = 1 + 4 + (*z).AuctionKey.Msgsize() + 4 + msgp.Uint64Size + 8 + msgp.BoolSize + 8 + (*z).OutcomesHash.Msgsize() + 9 + msgp.BoolSize
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Settlement) MsgIsZero() bool {
	return ((*z).AuctionKey.MsgIsZero()) && ((*z).AuctionID == 0) && ((*z).Cleared == false) && ((*z).OutcomesHash.MsgIsZero()) && ((*z).Canceled == false)
}

// MarshalMsg implements msgp.Marshaler
func (z *SignedBid) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 3 bits */
	if (*z).Bid.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "bid"
			o = append(o, 0xa3, 0x62, 0x69, 0x64)
			o = (*z).Bid.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o = (*z).Sig.MarshalMsg(o)
		}
	}
	return
}

func (_ *SignedBid) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedBid)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SignedBid) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Bid.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Bid")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = SignedBid{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "bid":
				bts, err = (*z).Bid.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bid")
					return
				}
			case "sig":
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *SignedBid) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedBid)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedBid) Msgsize() (s int) {
	s = 1 + 4 + (*z).Bid.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *SignedBid) MsgIsZero() bool {
	return ((*z).Bid.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *SignedDeposit) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 3 bits */
	if (*z).Deposit.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "dep"
			o = append(o, 0xa3, 0x64, 0x65, 0x70)
			o = (*z).Deposit.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o = (*z).Sig.MarshalMsg(o)
		}
	}
	return
}

func (_ *SignedDeposit) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedDeposit)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SignedDeposit) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Deposit.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Deposit")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = SignedDeposit{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "dep":
				bts, err = (*z).Deposit.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Deposit")
					return
				}
			case "sig":
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *SignedDeposit) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedDeposit)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedDeposit) Msgsize() (s int) {
	s = 1 + 4 + (*z).Deposit.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *SignedDeposit) MsgIsZero() bool {
	return ((*z).Deposit.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *SignedParams) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 3 bits */
	if (*z).Params.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "param"
			o = append(o, 0xa5, 0x70, 0x61, 0x72, 0x61, 0x6d)
			o = (*z).Params.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o = (*z).Sig.MarshalMsg(o)
		}
	}
	return
}

func (_ *SignedParams) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedParams)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SignedParams) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Params.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Params")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = SignedParams{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "param":
				bts, err = (*z).Params.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Params")
					return
				}
			case "sig":
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *SignedParams) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedParams)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedParams) Msgsize() (s int) {
	s = 1 + 6 + (*z).Params.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *SignedParams) MsgIsZero() bool {
	return ((*z).Params.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}

// MarshalMsg implements msgp.Marshaler
func (z *SignedSettlement) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 3 bits */
	if (*z).Settlement.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).Sig.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "settle"
			o = append(o, 0xa6, 0x73, 0x65, 0x74, 0x74, 0x6c, 0x65)
			o = (*z).Settlement.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "sig"
			o = append(o, 0xa3, 0x73, 0x69, 0x67)
			o = (*z).Sig.MarshalMsg(o)
		}
	}
	return
}

func (_ *SignedSettlement) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedSettlement)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SignedSettlement) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Settlement.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Settlement")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Sig.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = SignedSettlement{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "settle":
				bts, err = (*z).Settlement.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Settlement")
					return
				}
			case "sig":
				bts, err = (*z).Sig.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *SignedSettlement) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignedSettlement)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedSettlement) Msgsize() (s int) {
	s = 1 + 7 + (*z).Settlement.Msgsize() + 4 + (*z).Sig.Msgsize()
	return
}

// MsgIsZero returns whether this is a zero value
func (z *SignedSettlement) MsgIsZero() bool {
	return ((*z).Settlement.MsgIsZero()) && ((*z).Sig.MsgIsZero())
}
