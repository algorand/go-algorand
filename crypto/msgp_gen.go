package crypto

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	_ "runtime/cgo"
	_ "unsafe"

	"github.com/algorand/msgp/msgp"
)

// MarshalMsg implements msgp.Marshaler
func (z *Digest) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *Digest) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Digest)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Digest) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *Digest) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Digest)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Digest) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (DigestSize * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Digest) MsgIsZero() bool {
	return (*z) == (Digest{})
}

// MarshalMsg implements msgp.Marshaler
func (z *MasterDerivationKey) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *MasterDerivationKey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*MasterDerivationKey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MasterDerivationKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *MasterDerivationKey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*MasterDerivationKey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MasterDerivationKey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (masterDerivationKeyLenBytes * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *MasterDerivationKey) MsgIsZero() bool {
	return (*z) == (MasterDerivationKey{})
}

// MarshalMsg implements msgp.Marshaler
func (z *MultisigSig) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0002Len := uint32(3)
	var zb0002Mask uint8 /* 4 bits */
	if len((*z).Subsigs) == 0 {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	if (*z).Threshold == 0 {
		zb0002Len--
		zb0002Mask |= 0x4
	}
	if (*z).Version == 0 {
		zb0002Len--
		zb0002Mask |= 0x8
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	if zb0002Len != 0 {
		if (zb0002Mask & 0x2) == 0 { // if not empty
			// string "subsig"
			o = append(o, 0xa6, 0x73, 0x75, 0x62, 0x73, 0x69, 0x67)
			if (*z).Subsigs == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Subsigs)))
			}
			for zb0001 := range (*z).Subsigs {
				o, err = (*z).Subsigs[zb0001].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Subsigs", zb0001)
					return
				}
			}
		}
		if (zb0002Mask & 0x4) == 0 { // if not empty
			// string "thr"
			o = append(o, 0xa3, 0x74, 0x68, 0x72)
			o = msgp.AppendUint8(o, (*z).Threshold)
		}
		if (zb0002Mask & 0x8) == 0 { // if not empty
			// string "v"
			o = append(o, 0xa1, 0x76)
			o = msgp.AppendUint8(o, (*z).Version)
		}
	}
	return
}

func (_ *MultisigSig) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*MultisigSig)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MultisigSig) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Version, bts, err = msgp.ReadUint8Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Version")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Threshold, bts, err = msgp.ReadUint8Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Threshold")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			var zb0004 int
			var zb0005 bool
			zb0004, zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Subsigs")
				return
			}
			if zb0004 > maxMultisig {
				err = msgp.ErrOverflow(uint64(zb0004), uint64(maxMultisig))
				err = msgp.WrapError(err, "struct-from-array", "Subsigs")
				return
			}
			if zb0005 {
				(*z).Subsigs = nil
			} else if (*z).Subsigs != nil && cap((*z).Subsigs) >= zb0004 {
				(*z).Subsigs = ((*z).Subsigs)[:zb0004]
			} else {
				(*z).Subsigs = make([]MultisigSubsig, zb0004)
			}
			for zb0001 := range (*z).Subsigs {
				bts, err = (*z).Subsigs[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Subsigs", zb0001)
					return
				}
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = MultisigSig{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "v":
				(*z).Version, bts, err = msgp.ReadUint8Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Version")
					return
				}
			case "thr":
				(*z).Threshold, bts, err = msgp.ReadUint8Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Threshold")
					return
				}
			case "subsig":
				var zb0006 int
				var zb0007 bool
				zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Subsigs")
					return
				}
				if zb0006 > maxMultisig {
					err = msgp.ErrOverflow(uint64(zb0006), uint64(maxMultisig))
					err = msgp.WrapError(err, "Subsigs")
					return
				}
				if zb0007 {
					(*z).Subsigs = nil
				} else if (*z).Subsigs != nil && cap((*z).Subsigs) >= zb0006 {
					(*z).Subsigs = ((*z).Subsigs)[:zb0006]
				} else {
					(*z).Subsigs = make([]MultisigSubsig, zb0006)
				}
				for zb0001 := range (*z).Subsigs {
					bts, err = (*z).Subsigs[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Subsigs", zb0001)
						return
					}
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *MultisigSig) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*MultisigSig)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MultisigSig) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint8Size + 4 + msgp.Uint8Size + 7 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).Subsigs {
		s += (*z).Subsigs[zb0001].Msgsize()
	}
	return
}

// MsgIsZero returns whether this is a zero value
func (z *MultisigSig) MsgIsZero() bool {
	return ((*z).Version == 0) && ((*z).Threshold == 0) && (len((*z).Subsigs) == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *MultisigSubsig) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(2)
	var zb0003Mask uint8 /* 3 bits */
	if (*z).Key == (PublicKey{}) {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).Sig == (Signature{}) {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "pk"
			o = append(o, 0xa2, 0x70, 0x6b)
			o = msgp.AppendBytes(o, ((*z).Key)[:])
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "s"
			o = append(o, 0xa1, 0x73)
			o = msgp.AppendBytes(o, ((*z).Sig)[:])
		}
	}
	return
}

func (_ *MultisigSubsig) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*MultisigSubsig)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MultisigSubsig) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = msgp.ReadExactBytes(bts, ((*z).Key)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Key")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = msgp.ReadExactBytes(bts, ((*z).Sig)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = MultisigSubsig{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "pk":
				bts, err = msgp.ReadExactBytes(bts, ((*z).Key)[:])
				if err != nil {
					err = msgp.WrapError(err, "Key")
					return
				}
			case "s":
				bts, err = msgp.ReadExactBytes(bts, ((*z).Sig)[:])
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *MultisigSubsig) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*MultisigSubsig)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MultisigSubsig) Msgsize() (s int) {
	s = 1 + 3 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 2 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *MultisigSubsig) MsgIsZero() bool {
	return ((*z).Key == (PublicKey{})) && ((*z).Sig == (Signature{}))
}

// MarshalMsg implements msgp.Marshaler
func (z *OneTimeSignature) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "p"
	o = append(o, 0x86, 0xa1, 0x70)
	o = msgp.AppendBytes(o, ((*z).PK)[:])
	// string "p1s"
	o = append(o, 0xa3, 0x70, 0x31, 0x73)
	o = msgp.AppendBytes(o, ((*z).PK1Sig)[:])
	// string "p2"
	o = append(o, 0xa2, 0x70, 0x32)
	o = msgp.AppendBytes(o, ((*z).PK2)[:])
	// string "p2s"
	o = append(o, 0xa3, 0x70, 0x32, 0x73)
	o = msgp.AppendBytes(o, ((*z).PK2Sig)[:])
	// string "ps"
	o = append(o, 0xa2, 0x70, 0x73)
	o = msgp.AppendBytes(o, ((*z).PKSigOld)[:])
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendBytes(o, ((*z).Sig)[:])
	return
}

func (_ *OneTimeSignature) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*OneTimeSignature)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OneTimeSignature) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0007 int
	var zb0008 bool
	zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0007 > 0 {
			zb0007--
			bts, err = msgp.ReadExactBytes(bts, ((*z).Sig)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Sig")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PK)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PK")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PKSigOld)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PKSigOld")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PK2)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PK2")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PK1Sig)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PK1Sig")
				return
			}
		}
		if zb0007 > 0 {
			zb0007--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PK2Sig)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PK2Sig")
				return
			}
		}
		if zb0007 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0007)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0008 {
			(*z) = OneTimeSignature{}
		}
		for zb0007 > 0 {
			zb0007--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "s":
				bts, err = msgp.ReadExactBytes(bts, ((*z).Sig)[:])
				if err != nil {
					err = msgp.WrapError(err, "Sig")
					return
				}
			case "p":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PK)[:])
				if err != nil {
					err = msgp.WrapError(err, "PK")
					return
				}
			case "ps":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PKSigOld)[:])
				if err != nil {
					err = msgp.WrapError(err, "PKSigOld")
					return
				}
			case "p2":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PK2)[:])
				if err != nil {
					err = msgp.WrapError(err, "PK2")
					return
				}
			case "p1s":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PK1Sig)[:])
				if err != nil {
					err = msgp.WrapError(err, "PK1Sig")
					return
				}
			case "p2s":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PK2Sig)[:])
				if err != nil {
					err = msgp.WrapError(err, "PK2Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *OneTimeSignature) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*OneTimeSignature)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OneTimeSignature) Msgsize() (s int) {
	s = 1 + 2 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize)) + 2 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 3 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize)) + 3 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 4 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize)) + 4 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *OneTimeSignature) MsgIsZero() bool {
	return ((*z).Sig == (ed25519Signature{})) && ((*z).PK == (ed25519PublicKey{})) && ((*z).PKSigOld == (ed25519Signature{})) && ((*z).PK2 == (ed25519PublicKey{})) && ((*z).PK1Sig == (ed25519Signature{})) && ((*z).PK2Sig == (ed25519Signature{}))
}

// MarshalMsg implements msgp.Marshaler
func (z *OneTimeSignatureSecrets) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0006Len := uint32(7)
	var zb0006Mask uint16 /* 11 bits */
	if (*z).OneTimeSignatureSecretsPersistent.FirstBatch == 0 {
		zb0006Len--
		zb0006Mask |= 0x1
	}
	if (*z).OneTimeSignatureSecretsPersistent.OneTimeSignatureVerifier == (OneTimeSignatureVerifier{}) {
		zb0006Len--
		zb0006Mask |= 0x2
	}
	if len((*z).OneTimeSignatureSecretsPersistent.Batches) == 0 {
		zb0006Len--
		zb0006Mask |= 0x4
	}
	if (*z).OneTimeSignatureSecretsPersistent.FirstOffset == 0 {
		zb0006Len--
		zb0006Mask |= 0x20
	}
	if len((*z).OneTimeSignatureSecretsPersistent.Offsets) == 0 {
		zb0006Len--
		zb0006Mask |= 0x80
	}
	if (*z).OneTimeSignatureSecretsPersistent.OffsetsPK2 == (ed25519PublicKey{}) {
		zb0006Len--
		zb0006Mask |= 0x100
	}
	if (*z).OneTimeSignatureSecretsPersistent.OffsetsPK2Sig == (ed25519Signature{}) {
		zb0006Len--
		zb0006Mask |= 0x200
	}
	// variable map header, size zb0006Len
	o = append(o, 0x80|uint8(zb0006Len))
	if zb0006Len != 0 {
		if (zb0006Mask & 0x1) == 0 { // if not empty
			// string "First"
			o = append(o, 0xa5, 0x46, 0x69, 0x72, 0x73, 0x74)
			o = msgp.AppendUint64(o, (*z).OneTimeSignatureSecretsPersistent.FirstBatch)
		}
		if (zb0006Mask & 0x2) == 0 { // if not empty
			// string "OneTimeSignatureVerifier"
			o = append(o, 0xb8, 0x4f, 0x6e, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x72)
			o = msgp.AppendBytes(o, ((*z).OneTimeSignatureSecretsPersistent.OneTimeSignatureVerifier)[:])
		}
		if (zb0006Mask & 0x4) == 0 { // if not empty
			// string "Sub"
			o = append(o, 0xa3, 0x53, 0x75, 0x62)
			if (*z).OneTimeSignatureSecretsPersistent.Batches == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).OneTimeSignatureSecretsPersistent.Batches)))
			}
			for zb0002 := range (*z).OneTimeSignatureSecretsPersistent.Batches {
				o, err = (*z).OneTimeSignatureSecretsPersistent.Batches[zb0002].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Batches", zb0002)
					return
				}
			}
		}
		if (zb0006Mask & 0x20) == 0 { // if not empty
			// string "firstoff"
			o = append(o, 0xa8, 0x66, 0x69, 0x72, 0x73, 0x74, 0x6f, 0x66, 0x66)
			o = msgp.AppendUint64(o, (*z).OneTimeSignatureSecretsPersistent.FirstOffset)
		}
		if (zb0006Mask & 0x80) == 0 { // if not empty
			// string "offkeys"
			o = append(o, 0xa7, 0x6f, 0x66, 0x66, 0x6b, 0x65, 0x79, 0x73)
			if (*z).OneTimeSignatureSecretsPersistent.Offsets == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).OneTimeSignatureSecretsPersistent.Offsets)))
			}
			for zb0003 := range (*z).OneTimeSignatureSecretsPersistent.Offsets {
				o, err = (*z).OneTimeSignatureSecretsPersistent.Offsets[zb0003].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Offsets", zb0003)
					return
				}
			}
		}
		if (zb0006Mask & 0x100) == 0 { // if not empty
			// string "offpk2"
			o = append(o, 0xa6, 0x6f, 0x66, 0x66, 0x70, 0x6b, 0x32)
			o = msgp.AppendBytes(o, ((*z).OneTimeSignatureSecretsPersistent.OffsetsPK2)[:])
		}
		if (zb0006Mask & 0x200) == 0 { // if not empty
			// string "offpk2sig"
			o = append(o, 0xa9, 0x6f, 0x66, 0x66, 0x70, 0x6b, 0x32, 0x73, 0x69, 0x67)
			o = msgp.AppendBytes(o, ((*z).OneTimeSignatureSecretsPersistent.OffsetsPK2Sig)[:])
		}
	}
	return
}

func (_ *OneTimeSignatureSecrets) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*OneTimeSignatureSecrets)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OneTimeSignatureSecrets) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0006 int
	var zb0007 bool
	zb0006, zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0006 > 0 {
			zb0006--
			bts, err = msgp.ReadExactBytes(bts, ((*z).OneTimeSignatureSecretsPersistent.OneTimeSignatureVerifier)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OneTimeSignatureVerifier")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			(*z).OneTimeSignatureSecretsPersistent.FirstBatch, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstBatch")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0008 int
			var zb0009 bool
			zb0008, zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Batches")
				return
			}
			if zb0009 {
				(*z).OneTimeSignatureSecretsPersistent.Batches = nil
			} else if (*z).OneTimeSignatureSecretsPersistent.Batches != nil && cap((*z).OneTimeSignatureSecretsPersistent.Batches) >= zb0008 {
				(*z).OneTimeSignatureSecretsPersistent.Batches = ((*z).OneTimeSignatureSecretsPersistent.Batches)[:zb0008]
			} else {
				(*z).OneTimeSignatureSecretsPersistent.Batches = make([]ephemeralSubkey, zb0008)
			}
			for zb0002 := range (*z).OneTimeSignatureSecretsPersistent.Batches {
				bts, err = (*z).OneTimeSignatureSecretsPersistent.Batches[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Batches", zb0002)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			(*z).OneTimeSignatureSecretsPersistent.FirstOffset, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstOffset")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0010 int
			var zb0011 bool
			zb0010, zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Offsets")
				return
			}
			if zb0011 {
				(*z).OneTimeSignatureSecretsPersistent.Offsets = nil
			} else if (*z).OneTimeSignatureSecretsPersistent.Offsets != nil && cap((*z).OneTimeSignatureSecretsPersistent.Offsets) >= zb0010 {
				(*z).OneTimeSignatureSecretsPersistent.Offsets = ((*z).OneTimeSignatureSecretsPersistent.Offsets)[:zb0010]
			} else {
				(*z).OneTimeSignatureSecretsPersistent.Offsets = make([]ephemeralSubkey, zb0010)
			}
			for zb0003 := range (*z).OneTimeSignatureSecretsPersistent.Offsets {
				bts, err = (*z).OneTimeSignatureSecretsPersistent.Offsets[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Offsets", zb0003)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			bts, err = msgp.ReadExactBytes(bts, ((*z).OneTimeSignatureSecretsPersistent.OffsetsPK2)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OffsetsPK2")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			bts, err = msgp.ReadExactBytes(bts, ((*z).OneTimeSignatureSecretsPersistent.OffsetsPK2Sig)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OffsetsPK2Sig")
				return
			}
		}
		if zb0006 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0006)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0007 {
			(*z) = OneTimeSignatureSecrets{}
		}
		for zb0006 > 0 {
			zb0006--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "OneTimeSignatureVerifier":
				bts, err = msgp.ReadExactBytes(bts, ((*z).OneTimeSignatureSecretsPersistent.OneTimeSignatureVerifier)[:])
				if err != nil {
					err = msgp.WrapError(err, "OneTimeSignatureVerifier")
					return
				}
			case "First":
				(*z).OneTimeSignatureSecretsPersistent.FirstBatch, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstBatch")
					return
				}
			case "Sub":
				var zb0012 int
				var zb0013 bool
				zb0012, zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Batches")
					return
				}
				if zb0013 {
					(*z).OneTimeSignatureSecretsPersistent.Batches = nil
				} else if (*z).OneTimeSignatureSecretsPersistent.Batches != nil && cap((*z).OneTimeSignatureSecretsPersistent.Batches) >= zb0012 {
					(*z).OneTimeSignatureSecretsPersistent.Batches = ((*z).OneTimeSignatureSecretsPersistent.Batches)[:zb0012]
				} else {
					(*z).OneTimeSignatureSecretsPersistent.Batches = make([]ephemeralSubkey, zb0012)
				}
				for zb0002 := range (*z).OneTimeSignatureSecretsPersistent.Batches {
					bts, err = (*z).OneTimeSignatureSecretsPersistent.Batches[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Batches", zb0002)
						return
					}
				}
			case "firstoff":
				(*z).OneTimeSignatureSecretsPersistent.FirstOffset, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstOffset")
					return
				}
			case "offkeys":
				var zb0014 int
				var zb0015 bool
				zb0014, zb0015, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Offsets")
					return
				}
				if zb0015 {
					(*z).OneTimeSignatureSecretsPersistent.Offsets = nil
				} else if (*z).OneTimeSignatureSecretsPersistent.Offsets != nil && cap((*z).OneTimeSignatureSecretsPersistent.Offsets) >= zb0014 {
					(*z).OneTimeSignatureSecretsPersistent.Offsets = ((*z).OneTimeSignatureSecretsPersistent.Offsets)[:zb0014]
				} else {
					(*z).OneTimeSignatureSecretsPersistent.Offsets = make([]ephemeralSubkey, zb0014)
				}
				for zb0003 := range (*z).OneTimeSignatureSecretsPersistent.Offsets {
					bts, err = (*z).OneTimeSignatureSecretsPersistent.Offsets[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Offsets", zb0003)
						return
					}
				}
			case "offpk2":
				bts, err = msgp.ReadExactBytes(bts, ((*z).OneTimeSignatureSecretsPersistent.OffsetsPK2)[:])
				if err != nil {
					err = msgp.WrapError(err, "OffsetsPK2")
					return
				}
			case "offpk2sig":
				bts, err = msgp.ReadExactBytes(bts, ((*z).OneTimeSignatureSecretsPersistent.OffsetsPK2Sig)[:])
				if err != nil {
					err = msgp.WrapError(err, "OffsetsPK2Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *OneTimeSignatureSecrets) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*OneTimeSignatureSecrets)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OneTimeSignatureSecrets) Msgsize() (s int) {
	s = 1 + 25 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 6 + msgp.Uint64Size + 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).OneTimeSignatureSecretsPersistent.Batches {
		s += (*z).OneTimeSignatureSecretsPersistent.Batches[zb0002].Msgsize()
	}
	s += 9 + msgp.Uint64Size + 8 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).OneTimeSignatureSecretsPersistent.Offsets {
		s += (*z).OneTimeSignatureSecretsPersistent.Offsets[zb0003].Msgsize()
	}
	s += 7 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 10 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *OneTimeSignatureSecrets) MsgIsZero() bool {
	return ((*z).OneTimeSignatureSecretsPersistent.OneTimeSignatureVerifier == (OneTimeSignatureVerifier{})) && ((*z).OneTimeSignatureSecretsPersistent.FirstBatch == 0) && (len((*z).OneTimeSignatureSecretsPersistent.Batches) == 0) && ((*z).OneTimeSignatureSecretsPersistent.FirstOffset == 0) && (len((*z).OneTimeSignatureSecretsPersistent.Offsets) == 0) && ((*z).OneTimeSignatureSecretsPersistent.OffsetsPK2 == (ed25519PublicKey{})) && ((*z).OneTimeSignatureSecretsPersistent.OffsetsPK2Sig == (ed25519Signature{}))
}

// MarshalMsg implements msgp.Marshaler
func (z *OneTimeSignatureSecretsPersistent) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0006Len := uint32(7)
	var zb0006Mask uint8 /* 8 bits */
	if (*z).FirstBatch == 0 {
		zb0006Len--
		zb0006Mask |= 0x1
	}
	if (*z).OneTimeSignatureVerifier == (OneTimeSignatureVerifier{}) {
		zb0006Len--
		zb0006Mask |= 0x2
	}
	if len((*z).Batches) == 0 {
		zb0006Len--
		zb0006Mask |= 0x4
	}
	if (*z).FirstOffset == 0 {
		zb0006Len--
		zb0006Mask |= 0x10
	}
	if len((*z).Offsets) == 0 {
		zb0006Len--
		zb0006Mask |= 0x20
	}
	if (*z).OffsetsPK2 == (ed25519PublicKey{}) {
		zb0006Len--
		zb0006Mask |= 0x40
	}
	if (*z).OffsetsPK2Sig == (ed25519Signature{}) {
		zb0006Len--
		zb0006Mask |= 0x80
	}
	// variable map header, size zb0006Len
	o = append(o, 0x80|uint8(zb0006Len))
	if zb0006Len != 0 {
		if (zb0006Mask & 0x1) == 0 { // if not empty
			// string "First"
			o = append(o, 0xa5, 0x46, 0x69, 0x72, 0x73, 0x74)
			o = msgp.AppendUint64(o, (*z).FirstBatch)
		}
		if (zb0006Mask & 0x2) == 0 { // if not empty
			// string "OneTimeSignatureVerifier"
			o = append(o, 0xb8, 0x4f, 0x6e, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x72)
			o = msgp.AppendBytes(o, ((*z).OneTimeSignatureVerifier)[:])
		}
		if (zb0006Mask & 0x4) == 0 { // if not empty
			// string "Sub"
			o = append(o, 0xa3, 0x53, 0x75, 0x62)
			if (*z).Batches == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Batches)))
			}
			for zb0002 := range (*z).Batches {
				o, err = (*z).Batches[zb0002].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Batches", zb0002)
					return
				}
			}
		}
		if (zb0006Mask & 0x10) == 0 { // if not empty
			// string "firstoff"
			o = append(o, 0xa8, 0x66, 0x69, 0x72, 0x73, 0x74, 0x6f, 0x66, 0x66)
			o = msgp.AppendUint64(o, (*z).FirstOffset)
		}
		if (zb0006Mask & 0x20) == 0 { // if not empty
			// string "offkeys"
			o = append(o, 0xa7, 0x6f, 0x66, 0x66, 0x6b, 0x65, 0x79, 0x73)
			if (*z).Offsets == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendArrayHeader(o, uint32(len((*z).Offsets)))
			}
			for zb0003 := range (*z).Offsets {
				o, err = (*z).Offsets[zb0003].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Offsets", zb0003)
					return
				}
			}
		}
		if (zb0006Mask & 0x40) == 0 { // if not empty
			// string "offpk2"
			o = append(o, 0xa6, 0x6f, 0x66, 0x66, 0x70, 0x6b, 0x32)
			o = msgp.AppendBytes(o, ((*z).OffsetsPK2)[:])
		}
		if (zb0006Mask & 0x80) == 0 { // if not empty
			// string "offpk2sig"
			o = append(o, 0xa9, 0x6f, 0x66, 0x66, 0x70, 0x6b, 0x32, 0x73, 0x69, 0x67)
			o = msgp.AppendBytes(o, ((*z).OffsetsPK2Sig)[:])
		}
	}
	return
}

func (_ *OneTimeSignatureSecretsPersistent) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*OneTimeSignatureSecretsPersistent)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OneTimeSignatureSecretsPersistent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0006 int
	var zb0007 bool
	zb0006, zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0006, zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0006 > 0 {
			zb0006--
			bts, err = msgp.ReadExactBytes(bts, ((*z).OneTimeSignatureVerifier)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OneTimeSignatureVerifier")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			(*z).FirstBatch, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstBatch")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0008 int
			var zb0009 bool
			zb0008, zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Batches")
				return
			}
			if zb0009 {
				(*z).Batches = nil
			} else if (*z).Batches != nil && cap((*z).Batches) >= zb0008 {
				(*z).Batches = ((*z).Batches)[:zb0008]
			} else {
				(*z).Batches = make([]ephemeralSubkey, zb0008)
			}
			for zb0002 := range (*z).Batches {
				bts, err = (*z).Batches[zb0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Batches", zb0002)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			(*z).FirstOffset, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "FirstOffset")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			var zb0010 int
			var zb0011 bool
			zb0010, zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Offsets")
				return
			}
			if zb0011 {
				(*z).Offsets = nil
			} else if (*z).Offsets != nil && cap((*z).Offsets) >= zb0010 {
				(*z).Offsets = ((*z).Offsets)[:zb0010]
			} else {
				(*z).Offsets = make([]ephemeralSubkey, zb0010)
			}
			for zb0003 := range (*z).Offsets {
				bts, err = (*z).Offsets[zb0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Offsets", zb0003)
					return
				}
			}
		}
		if zb0006 > 0 {
			zb0006--
			bts, err = msgp.ReadExactBytes(bts, ((*z).OffsetsPK2)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OffsetsPK2")
				return
			}
		}
		if zb0006 > 0 {
			zb0006--
			bts, err = msgp.ReadExactBytes(bts, ((*z).OffsetsPK2Sig)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "OffsetsPK2Sig")
				return
			}
		}
		if zb0006 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0006)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0007 {
			(*z) = OneTimeSignatureSecretsPersistent{}
		}
		for zb0006 > 0 {
			zb0006--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "OneTimeSignatureVerifier":
				bts, err = msgp.ReadExactBytes(bts, ((*z).OneTimeSignatureVerifier)[:])
				if err != nil {
					err = msgp.WrapError(err, "OneTimeSignatureVerifier")
					return
				}
			case "First":
				(*z).FirstBatch, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstBatch")
					return
				}
			case "Sub":
				var zb0012 int
				var zb0013 bool
				zb0012, zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Batches")
					return
				}
				if zb0013 {
					(*z).Batches = nil
				} else if (*z).Batches != nil && cap((*z).Batches) >= zb0012 {
					(*z).Batches = ((*z).Batches)[:zb0012]
				} else {
					(*z).Batches = make([]ephemeralSubkey, zb0012)
				}
				for zb0002 := range (*z).Batches {
					bts, err = (*z).Batches[zb0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Batches", zb0002)
						return
					}
				}
			case "firstoff":
				(*z).FirstOffset, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FirstOffset")
					return
				}
			case "offkeys":
				var zb0014 int
				var zb0015 bool
				zb0014, zb0015, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Offsets")
					return
				}
				if zb0015 {
					(*z).Offsets = nil
				} else if (*z).Offsets != nil && cap((*z).Offsets) >= zb0014 {
					(*z).Offsets = ((*z).Offsets)[:zb0014]
				} else {
					(*z).Offsets = make([]ephemeralSubkey, zb0014)
				}
				for zb0003 := range (*z).Offsets {
					bts, err = (*z).Offsets[zb0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Offsets", zb0003)
						return
					}
				}
			case "offpk2":
				bts, err = msgp.ReadExactBytes(bts, ((*z).OffsetsPK2)[:])
				if err != nil {
					err = msgp.WrapError(err, "OffsetsPK2")
					return
				}
			case "offpk2sig":
				bts, err = msgp.ReadExactBytes(bts, ((*z).OffsetsPK2Sig)[:])
				if err != nil {
					err = msgp.WrapError(err, "OffsetsPK2Sig")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *OneTimeSignatureSecretsPersistent) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*OneTimeSignatureSecretsPersistent)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OneTimeSignatureSecretsPersistent) Msgsize() (s int) {
	s = 1 + 25 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 6 + msgp.Uint64Size + 4 + msgp.ArrayHeaderSize
	for zb0002 := range (*z).Batches {
		s += (*z).Batches[zb0002].Msgsize()
	}
	s += 9 + msgp.Uint64Size + 8 + msgp.ArrayHeaderSize
	for zb0003 := range (*z).Offsets {
		s += (*z).Offsets[zb0003].Msgsize()
	}
	s += 7 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 10 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *OneTimeSignatureSecretsPersistent) MsgIsZero() bool {
	return ((*z).OneTimeSignatureVerifier == (OneTimeSignatureVerifier{})) && ((*z).FirstBatch == 0) && (len((*z).Batches) == 0) && ((*z).FirstOffset == 0) && (len((*z).Offsets) == 0) && ((*z).OffsetsPK2 == (ed25519PublicKey{})) && ((*z).OffsetsPK2Sig == (ed25519Signature{}))
}

// MarshalMsg implements msgp.Marshaler
func (z *OneTimeSignatureSubkeyBatchID) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "batch"
	o = append(o, 0x82, 0xa5, 0x62, 0x61, 0x74, 0x63, 0x68)
	o = msgp.AppendUint64(o, (*z).Batch)
	// string "pk"
	o = append(o, 0xa2, 0x70, 0x6b)
	o = msgp.AppendBytes(o, ((*z).SubKeyPK)[:])
	return
}

func (_ *OneTimeSignatureSubkeyBatchID) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*OneTimeSignatureSubkeyBatchID)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OneTimeSignatureSubkeyBatchID) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = msgp.ReadExactBytes(bts, ((*z).SubKeyPK)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SubKeyPK")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Batch, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Batch")
				return
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = OneTimeSignatureSubkeyBatchID{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "pk":
				bts, err = msgp.ReadExactBytes(bts, ((*z).SubKeyPK)[:])
				if err != nil {
					err = msgp.WrapError(err, "SubKeyPK")
					return
				}
			case "batch":
				(*z).Batch, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Batch")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *OneTimeSignatureSubkeyBatchID) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*OneTimeSignatureSubkeyBatchID)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OneTimeSignatureSubkeyBatchID) Msgsize() (s int) {
	s = 1 + 3 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 6 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *OneTimeSignatureSubkeyBatchID) MsgIsZero() bool {
	return ((*z).SubKeyPK == (ed25519PublicKey{})) && ((*z).Batch == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *OneTimeSignatureSubkeyOffsetID) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "batch"
	o = append(o, 0x83, 0xa5, 0x62, 0x61, 0x74, 0x63, 0x68)
	o = msgp.AppendUint64(o, (*z).Batch)
	// string "off"
	o = append(o, 0xa3, 0x6f, 0x66, 0x66)
	o = msgp.AppendUint64(o, (*z).Offset)
	// string "pk"
	o = append(o, 0xa2, 0x70, 0x6b)
	o = msgp.AppendBytes(o, ((*z).SubKeyPK)[:])
	return
}

func (_ *OneTimeSignatureSubkeyOffsetID) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*OneTimeSignatureSubkeyOffsetID)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OneTimeSignatureSubkeyOffsetID) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = msgp.ReadExactBytes(bts, ((*z).SubKeyPK)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SubKeyPK")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Batch, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Batch")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			(*z).Offset, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Offset")
				return
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = OneTimeSignatureSubkeyOffsetID{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "pk":
				bts, err = msgp.ReadExactBytes(bts, ((*z).SubKeyPK)[:])
				if err != nil {
					err = msgp.WrapError(err, "SubKeyPK")
					return
				}
			case "batch":
				(*z).Batch, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Batch")
					return
				}
			case "off":
				(*z).Offset, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Offset")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *OneTimeSignatureSubkeyOffsetID) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*OneTimeSignatureSubkeyOffsetID)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OneTimeSignatureSubkeyOffsetID) Msgsize() (s int) {
	s = 1 + 3 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 6 + msgp.Uint64Size + 4 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *OneTimeSignatureSubkeyOffsetID) MsgIsZero() bool {
	return ((*z).SubKeyPK == (ed25519PublicKey{})) && ((*z).Batch == 0) && ((*z).Offset == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *OneTimeSignatureVerifier) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *OneTimeSignatureVerifier) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*OneTimeSignatureVerifier)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OneTimeSignatureVerifier) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *OneTimeSignatureVerifier) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*OneTimeSignatureVerifier)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OneTimeSignatureVerifier) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (32 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *OneTimeSignatureVerifier) MsgIsZero() bool {
	return (*z) == (OneTimeSignatureVerifier{})
}

// MarshalMsg implements msgp.Marshaler
func (z *PrivateKey) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *PrivateKey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*PrivateKey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PrivateKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *PrivateKey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*PrivateKey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PrivateKey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *PrivateKey) MsgIsZero() bool {
	return (*z) == (PrivateKey{})
}

// MarshalMsg implements msgp.Marshaler
func (z *PublicKey) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *PublicKey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*PublicKey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PublicKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *PublicKey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*PublicKey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PublicKey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (32 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *PublicKey) MsgIsZero() bool {
	return (*z) == (PublicKey{})
}

// MarshalMsg implements msgp.Marshaler
func (z *Seed) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *Seed) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Seed)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Seed) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *Seed) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Seed)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Seed) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (32 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Seed) MsgIsZero() bool {
	return (*z) == (Seed{})
}

// MarshalMsg implements msgp.Marshaler
func (z *Signature) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *Signature) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*Signature)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Signature) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *Signature) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*Signature)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Signature) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Signature) MsgIsZero() bool {
	return (*z) == (Signature{})
}

// MarshalMsg implements msgp.Marshaler
func (z *SignatureSecrets) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "SK"
	o = append(o, 0x82, 0xa2, 0x53, 0x4b)
	o = msgp.AppendBytes(o, ((*z).SK)[:])
	// string "SignatureVerifier"
	o = append(o, 0xb1, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x72)
	o, err = (*z).SignatureVerifier.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "SignatureVerifier")
		return
	}
	return
}

func (_ *SignatureSecrets) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignatureSecrets)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SignatureSecrets) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0002 int
	var zb0003 bool
	zb0002, zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0002, zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = (*z).SignatureVerifier.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SignatureVerifier")
				return
			}
		}
		if zb0002 > 0 {
			zb0002--
			bts, err = msgp.ReadExactBytes(bts, ((*z).SK)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SK")
				return
			}
		}
		if zb0002 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0002)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 {
			(*z) = SignatureSecrets{}
		}
		for zb0002 > 0 {
			zb0002--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "SignatureVerifier":
				bts, err = (*z).SignatureVerifier.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SignatureVerifier")
					return
				}
			case "SK":
				bts, err = msgp.ReadExactBytes(bts, ((*z).SK)[:])
				if err != nil {
					err = msgp.WrapError(err, "SK")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *SignatureSecrets) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*SignatureSecrets)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignatureSecrets) Msgsize() (s int) {
	s = 1 + 18 + (*z).SignatureVerifier.Msgsize() + 3 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *SignatureSecrets) MsgIsZero() bool {
	return ((*z).SignatureVerifier.MsgIsZero()) && ((*z).SK == (ed25519PrivateKey{}))
}

// MarshalMsg implements msgp.Marshaler
func (z *VRFSecrets) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "PK"
	o = append(o, 0x82, 0xa2, 0x50, 0x4b)
	o = msgp.AppendBytes(o, ((*z).PK)[:])
	// string "SK"
	o = append(o, 0xa2, 0x53, 0x4b)
	o = msgp.AppendBytes(o, ((*z).SK)[:])
	return
}

func (_ *VRFSecrets) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*VRFSecrets)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VRFSecrets) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PK)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PK")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = msgp.ReadExactBytes(bts, ((*z).SK)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SK")
				return
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = VRFSecrets{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "PK":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PK)[:])
				if err != nil {
					err = msgp.WrapError(err, "PK")
					return
				}
			case "SK":
				bts, err = msgp.ReadExactBytes(bts, ((*z).SK)[:])
				if err != nil {
					err = msgp.WrapError(err, "SK")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *VRFSecrets) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*VRFSecrets)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VRFSecrets) Msgsize() (s int) {
	s = 1 + 3 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 3 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *VRFSecrets) MsgIsZero() bool {
	return ((*z).PK == (VrfPubkey{})) && ((*z).SK == (VrfPrivkey{}))
}

// MarshalMsg implements msgp.Marshaler
func (z *VrfOutput) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *VrfOutput) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfOutput)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VrfOutput) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *VrfOutput) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfOutput)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VrfOutput) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *VrfOutput) MsgIsZero() bool {
	return (*z) == (VrfOutput{})
}

// MarshalMsg implements msgp.Marshaler
func (z *VrfPrivkey) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *VrfPrivkey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfPrivkey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VrfPrivkey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *VrfPrivkey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfPrivkey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VrfPrivkey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *VrfPrivkey) MsgIsZero() bool {
	return (*z) == (VrfPrivkey{})
}

// MarshalMsg implements msgp.Marshaler
func (z *VrfProof) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *VrfProof) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfProof)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VrfProof) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *VrfProof) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfProof)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VrfProof) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (80 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *VrfProof) MsgIsZero() bool {
	return (*z) == (VrfProof{})
}

// MarshalMsg implements msgp.Marshaler
func (z *VrfPubkey) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *VrfPubkey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfPubkey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VrfPubkey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *VrfPubkey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfPubkey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VrfPubkey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (32 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *VrfPubkey) MsgIsZero() bool {
	return (*z) == (VrfPubkey{})
}

// MarshalMsg implements msgp.Marshaler
func (z *ed25519PrivateKey) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *ed25519PrivateKey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*ed25519PrivateKey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ed25519PrivateKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *ed25519PrivateKey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*ed25519PrivateKey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ed25519PrivateKey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *ed25519PrivateKey) MsgIsZero() bool {
	return (*z) == (ed25519PrivateKey{})
}

// MarshalMsg implements msgp.Marshaler
func (z *ed25519PublicKey) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *ed25519PublicKey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*ed25519PublicKey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ed25519PublicKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *ed25519PublicKey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*ed25519PublicKey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ed25519PublicKey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (32 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *ed25519PublicKey) MsgIsZero() bool {
	return (*z) == (ed25519PublicKey{})
}

// MarshalMsg implements msgp.Marshaler
func (z *ed25519Seed) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *ed25519Seed) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*ed25519Seed)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ed25519Seed) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *ed25519Seed) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*ed25519Seed)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ed25519Seed) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (32 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *ed25519Seed) MsgIsZero() bool {
	return (*z) == (ed25519Seed{})
}

// MarshalMsg implements msgp.Marshaler
func (z *ed25519Signature) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *ed25519Signature) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*ed25519Signature)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ed25519Signature) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *ed25519Signature) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*ed25519Signature)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ed25519Signature) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *ed25519Signature) MsgIsZero() bool {
	return (*z) == (ed25519Signature{})
}

// MarshalMsg implements msgp.Marshaler
func (z *ephemeralSubkey) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "PK"
	o = append(o, 0x84, 0xa2, 0x50, 0x4b)
	o = msgp.AppendBytes(o, ((*z).PK)[:])
	// string "PKSig"
	o = append(o, 0xa5, 0x50, 0x4b, 0x53, 0x69, 0x67)
	o = msgp.AppendBytes(o, ((*z).PKSigOld)[:])
	// string "SK"
	o = append(o, 0xa2, 0x53, 0x4b)
	o = msgp.AppendBytes(o, ((*z).SK)[:])
	// string "sig2"
	o = append(o, 0xa4, 0x73, 0x69, 0x67, 0x32)
	o = msgp.AppendBytes(o, ((*z).PKSigNew)[:])
	return
}

func (_ *ephemeralSubkey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*ephemeralSubkey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ephemeralSubkey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0005 int
	var zb0006 bool
	zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0005 > 0 {
			zb0005--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PK)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PK")
				return
			}
		}
		if zb0005 > 0 {
			zb0005--
			bts, err = msgp.ReadExactBytes(bts, ((*z).SK)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SK")
				return
			}
		}
		if zb0005 > 0 {
			zb0005--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PKSigOld)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PKSigOld")
				return
			}
		}
		if zb0005 > 0 {
			zb0005--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PKSigNew)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PKSigNew")
				return
			}
		}
		if zb0005 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0005)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0006 {
			(*z) = ephemeralSubkey{}
		}
		for zb0005 > 0 {
			zb0005--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "PK":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PK)[:])
				if err != nil {
					err = msgp.WrapError(err, "PK")
					return
				}
			case "SK":
				bts, err = msgp.ReadExactBytes(bts, ((*z).SK)[:])
				if err != nil {
					err = msgp.WrapError(err, "SK")
					return
				}
			case "PKSig":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PKSigOld)[:])
				if err != nil {
					err = msgp.WrapError(err, "PKSigOld")
					return
				}
			case "sig2":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PKSigNew)[:])
				if err != nil {
					err = msgp.WrapError(err, "PKSigNew")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *ephemeralSubkey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*ephemeralSubkey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ephemeralSubkey) Msgsize() (s int) {
	s = 1 + 3 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 3 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize)) + 6 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize)) + 5 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *ephemeralSubkey) MsgIsZero() bool {
	return ((*z).PK == (ed25519PublicKey{})) && ((*z).SK == (ed25519PrivateKey{})) && ((*z).PKSigOld == (ed25519Signature{})) && ((*z).PKSigNew == (ed25519Signature{}))
}
