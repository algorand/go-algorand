package cdilithium

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	_ "runtime/cgo"
	_ "unsafe"

	"github.com/algorand/msgp/msgp"
)

// The following msgp objects are implemented in this file:
// DilPrivateKey
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// DilPublicKey
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// DilSignature
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// DilithiumKeyPair
//         |-----> (*) MarshalMsg
//         |-----> (*) CanMarshalMsg
//         |-----> (*) UnmarshalMsg
//         |-----> (*) CanUnmarshalMsg
//         |-----> (*) Msgsize
//         |-----> (*) MsgIsZero
//

// MarshalMsg implements msgp.Marshaler
func (z *DilPrivateKey) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *DilPrivateKey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*DilPrivateKey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DilPrivateKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *DilPrivateKey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*DilPrivateKey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DilPrivateKey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (4000 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *DilPrivateKey) MsgIsZero() bool {
	return (*z) == (DilPrivateKey{})
}

// MarshalMsg implements msgp.Marshaler
func (z *DilPublicKey) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *DilPublicKey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*DilPublicKey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DilPublicKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *DilPublicKey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*DilPublicKey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DilPublicKey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (1952 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *DilPublicKey) MsgIsZero() bool {
	return (*z) == (DilPublicKey{})
}

// MarshalMsg implements msgp.Marshaler
func (z *DilSignature) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *DilSignature) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*DilSignature)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DilSignature) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *DilSignature) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*DilSignature)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DilSignature) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (3293 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *DilSignature) MsgIsZero() bool {
	return (*z) == (DilSignature{})
}

// MarshalMsg implements msgp.Marshaler
func (z *DilithiumKeyPair) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0003Len := uint32(2)
	var zb0003Mask uint8 /* 3 bits */
	if (*z).PublicKey == (DilPublicKey{}) {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	if (*z).SecretKey == (DilPrivateKey{}) {
		zb0003Len--
		zb0003Mask |= 0x4
	}
	// variable map header, size zb0003Len
	o = append(o, 0x80|uint8(zb0003Len))
	if zb0003Len != 0 {
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "pk"
			o = append(o, 0xa2, 0x70, 0x6b)
			o = msgp.AppendBytes(o, ((*z).PublicKey)[:])
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "sk"
			o = append(o, 0xa2, 0x73, 0x6b)
			o = msgp.AppendBytes(o, ((*z).SecretKey)[:])
		}
	}
	return
}

func (_ *DilithiumKeyPair) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*DilithiumKeyPair)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DilithiumKeyPair) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = msgp.ReadExactBytes(bts, ((*z).SecretKey)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SecretKey")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PublicKey)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PublicKey")
				return
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = DilithiumKeyPair{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "sk":
				bts, err = msgp.ReadExactBytes(bts, ((*z).SecretKey)[:])
				if err != nil {
					err = msgp.WrapError(err, "SecretKey")
					return
				}
			case "pk":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PublicKey)[:])
				if err != nil {
					err = msgp.WrapError(err, "PublicKey")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *DilithiumKeyPair) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*DilithiumKeyPair)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DilithiumKeyPair) Msgsize() (s int) {
	s = 1 + 3 + msgp.ArrayHeaderSize + (4000 * (msgp.ByteSize)) + 3 + msgp.ArrayHeaderSize + (1952 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *DilithiumKeyPair) MsgIsZero() bool {
	return ((*z).SecretKey == (DilPrivateKey{})) && ((*z).PublicKey == (DilPublicKey{}))
}
