package crypto

// Code generated by github.com/zeldovich/msgp DO NOT EDIT.

import (
	"github.com/zeldovich/msgp/msgp"
)

// MarshalMsg implements msgp.Marshaler
func (z *Digest) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (z)[:])
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Digest) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Digest) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (DigestSize * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *Digest) MsgIsZero() bool {
	return (z[0] == 0) && (z[1] == 0) && (z[2] == 0) && (z[3] == 0) && (z[4] == 0) && (z[5] == 0) && (z[6] == 0) && (z[7] == 0) && (z[8] == 0) && (z[9] == 0) && (z[10] == 0) && (z[11] == 0) && (z[12] == 0) && (z[13] == 0) && (z[14] == 0) && (z[15] == 0) && (z[16] == 0) && (z[17] == 0) && (z[18] == 0) && (z[19] == 0) && (z[20] == 0) && (z[21] == 0) && (z[22] == 0) && (z[23] == 0) && (z[24] == 0) && (z[25] == 0) && (z[26] == 0) && (z[27] == 0) && (z[28] == 0) && (z[29] == 0) && (z[30] == 0) && (z[31] == 0)
}
